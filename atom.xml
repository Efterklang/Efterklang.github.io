<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Efterklang</title>
  
  
  <link href="https://efterklang.github.io/atom.xml" rel="self"/>
  
  <link href="https://efterklang.github.io/"/>
  <updated>2024-04-30T11:03:12.585Z</updated>
  <id>https://efterklang.github.io/</id>
  
  <author>
    <name>Efterklang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>运输层 TransportLayer Part Ⅱ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-2TransportLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-2TransportLayer/</id>
    <published>2024-04-30T09:58:24.000Z</published>
    <updated>2024-04-30T11:03:12.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Connection-Oriented-Transport-TCP"><a href="#Connection-Oriented-Transport-TCP" class="headerlink" title="Connection-Oriented Transport: TCP"></a>Connection-Oriented Transport: TCP</h2><h3 id="TCP-Connection"><a href="#TCP-Connection" class="headerlink" title="TCP Connection"></a>TCP Connection</h3><ul><li><strong>面向连接 connection-oriented</strong>：相互发送预备报文段，以建立确保数据传输的参数；</li><li><strong>全双工服务 full-duplex service</strong>：如果一台主机上的进程 A 与另一台主机上的进程 B 存在一条 TCP 连接，那么应用层数据就可以在从进程 B 流向进程 A 的同时，也从进程 A 流向进程 B；</li><li><strong>点对点 point-to-point</strong>：即在单个发送方与单个接收方之间的连接；</li><li><strong>三次握手 three-way handshake</strong>：客户先发送一个特殊 TCP 报文段，服务器用另一个特殊的 TCP 报文段来响应，最后客户再用第三个特殊报文段作为响应。</li><li><strong>流量控制 Traffic control</strong>：TCP 通过流量控制机制来确保发送方不会淹没接收方；</li></ul><p>客户进程通过套接字，TCP 会将要发送的数据引导到该连接的发送缓存（send buffer），发送缓存是发起三次握手期间设置的缓存之一，TCP 发送缓存与接收缓存如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-23-15-09-31.png" style="zoom:100%;"></p><h3 id="TCP-Segment-Structure"><a href="#TCP-Segment-Structure" class="headerlink" title="TCP Segment Structure"></a>TCP Segment Structure</h3><ul><li><p><strong>源端口和目的端口字段</strong> Source Port Dest Port: 各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现</p></li><li><p><strong>序号字段</strong> Sequence number: 占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</p></li><li><p><strong>确认号字段</strong> Acknowledge number: 占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号</p></li><li><p><strong>数据偏移</strong>(首部长度) header length 占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）</p></li><li><p><strong>保留字段</strong> Unused: 占 8 位，保留为今后使用，但目前应置为 0</p></li><li><p><strong>标识字段</strong> flag field 占 6bit</p><ul><li>URG (Urgent Pointer field significant)：当设置为 1 时，表示紧急指针字段有意义，即 TCP 报文段中存在紧急数据，需要优先传送。</li><li>ACK (Acknowledgement field significant)：当设置为 1 时，表示确认号字段有效。TCP 使用 ACK 标志和确认号字段来实现可靠传输，确认对方发送的数据已经成功接收。</li><li>PSH (Push Function)：当设置为 1 时，表示接收方应立即将这个报文段交给应用层，而不是等待缓冲区满后再交付。</li><li>RST (Reset the connection)：当设置为 1 时，表示连接出现严重问题，需要立即重置，即终止当前连接。</li><li>SYN (Synchronize sequence numbers)：在建立连接时使用。当 SYN 标志设置为 1，而 ACK 标志为 0 时，表示这是一个连接请求报文段。如果 SYN 和 ACK 都为 1，表示对方已确认连接请求，此时连接建立。</li><li>FIN (No more data from sender)：当设置为 1 时，表示此方已经没有数据要发送，希望关闭连接。<blockquote><p>实践中，PSH，URG，Urgent data pointer 不被广泛使用<br>在 RFC 3168 中添加了两个新的标志（ECE 和 CWR），<br>CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；<br>ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</p></blockquote></li></ul></li><li><p><strong>窗口字段</strong> Receiver window: 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p></li><li><p><strong>检验和</strong> Internet checksum:占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p></li><li><p><strong>紧急指针字段</strong> Urgent data pointer 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</p></li><li><p><strong>填充字段</strong> 这是为了使整个首部长度是 4 字节的整数倍。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-23-15-50-58.png" style="zoom:50%;"><h3 id="Seq-number-and-ACK-number"><a href="#Seq-number-and-ACK-number" class="headerlink" title="Seq number and ACK number"></a>Seq number and ACK number</h3><p>报文段的序号(Sequence number)和确认号(Acknowledgement number)是 TCP 提供可靠数据传输的关键。其中序号指数据段中第一个字节在数据流中的位置编号，确认号指期望从另外一边收到的下一个字节的序号。TCP为全双工通信，因此每个方向的数据流都有自己的序号和确认号。</p><p>假设有两台主机，主机A启动了一个与主机B的Telnet会话。因为主机A启动了会话，所以它被标记为客户端，主机B被标记为服务器。<br>用户（在客户端）输入的每个字符都会被发送到远程主机；远程主机将会发送回每个字符的副本，这些字符将会显示在Telnet用户的屏幕上。这种“回显”用于确保Telnet用户看到的字符已经在远程站点被接收并处理。因此，每个字符在用户按下键盘到字符在用户的监视器上显示的时间内，都会在网络上传输两次<br>现在假设用户输入了一个单独的字母，‘C’，然后去拿咖啡。如图所示，这里我们假设客户端和服务器的起始序列号ISN分别是42和79。一个段的序列号是数据字段中第一个字节的序列号。因此，从客户端发送的第一个段的序列号将是42；从服务器发送的第一个段的序列号将是79。回忆一下，确认号是主机正在等待的下一个数据字节的序列号。在TCP连接建立但在任何数据发送之前，客户端正在等待字节79，服务器正在等待字节42</p><blockquote><p>在 TCP中，每一个新的连接都会从一个<strong>随机</strong>的起始序列号（ISN, Initial Sequence Number）开始。ISN是在 TCP 三次握手过程的第一步中由连接的发起方确定。实际的 TCP 连接中，起始序列号会是一个随机的、32位的数值。这里我们使用42和79只是为了简化讨论。<br>为什么要用随机ISN?一方面是为了防止连接失效后SOCKET被重用使得以前残留的包被错误的接受；另一方面是为了防止黑客轻易的知道序列号之后制造tcp序列号攻击，不过即使这样tcp序列号攻击也是有办法进行的，所以有很多tcp序列号的生成算法被提出和改进。</p></blockquote><p>如图所示，发送了三个段。第一个段从客户端发送到服务器，其数据字段中包含字母‘C’的1字节ASCII表示。正如我们刚才描述的，这个第一个段的序列号字段中有42。另外，因为客户端还没有从服务器接收到任何数据，所以这个第一个段的确认号字段中会有79。</p><p>第二个段从服务器发送到客户端。它有两个目的。首先，它确认了服务器接收到的数据。通过在确认字段中放入43，服务器告诉客户端它已经成功接收了直到字节42的所有内容，现在正在等待字节43及其后的数据。这个段的第二个目的是<strong>回显</strong>字母‘C’。因此，这个第二个段的数据字段中有字母‘C’的ASCII表示。这个第二个段的序列号是79，这是这个TCP连接的服务器到客户端数据流的初始序列号，因为这是服务器发送的第一个数据字节。注意，对客户端到服务器数据的确认是在携带服务器到客户端数据的段中进行的；这个确认被说成是在服务器到客户端的数据段上的捎带确认。</p><blockquote><p>回显 Echo Protocol 通常用于网络测试和故障排查。它是一种简单的协议，客户端发送给服务器的任何数据，服务器都会原封不动地发送回来。这种机制可以用于测试网络连接的质量，包括延迟、数据包丢失率等。它在 RFC 862 中有详细的描述。然而，需要注意的是，TCP Echo 并不常用，因为它可能会被利用进行拒绝服务攻击（Denial of Service attack，DoS attack）</p></blockquote><p>第三个段从客户端发送到服务器。它的唯一目的是确认它从服务器接收到的数据。（回忆一下，第二个段包含了从服务器到客户端的数据——字母‘C’。）这个段的数据字段是空的（也就是说，确认没有与任何客户端到服务器的数据捎带）。这个段的确认号字段中有80，因为客户端已经接收了直到字节序列号79的字节流，现在正在等待字节80及其后的数据。你可能会觉得奇怪，这个段也有一个序列号，虽然段中没有数据。但是，因为TCP有一个序列号字段，所以这个段需要有一些序列号。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-26-17-03-10.png" style="zoom:80%;"><p>TCP，就像我们在3.4节中的rdt协议一样，使用超时&#x2F;重传机制来从丢失的段中恢复。虽然这在概念上很简单，但是当我们在实际的协议如TCP中实现超时&#x2F;重传机制时，会出现许多微妙的问题。也许最明显的问题是超时间隔的长度。显然，超时应该大于连接的往返时间（RTT），即从发送一个段到它被确认的时间。否则，会发送不必要的重传。但是超时应该大多少？首先应该如何估计RTT？是否应该与每个未确认的段关联一个定时器？</p><h3 id="Round-Trip-Time-Estimation-and-Timeout"><a href="#Round-Trip-Time-Estimation-and-Timeout" class="headerlink" title="Round-Trip Time Estimation and Timeout"></a>Round-Trip Time Estimation and Timeout</h3><p><strong>如何估计往返时间</strong></p><p>样本RTT(SampleRTT): 测量从报文段发送到收到确认的时间<br><strong>EstimatedRTT</strong> TCP 维持的 SampleRTT 均值，其更新方式如下:$\alpha$ 推荐值为0.125<br>$$<br>EstimatedRTT&#x3D;(1-\alpha)\times EstimatedRTT+\alpha\times SampleRTT<br>$$</p><p>上述平均方法被称为<strong>指数加权移动平均（Exponential Weighted Moving Average，EWMA）</strong></p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-26-21-06-22.png" style="zoom:65%;"><p><strong>RTT偏差</strong>(RTT Deviation,DevRTT)，用于估算 SampleRTT 一般会偏离 EstimatedRTT 的程度：$\beta$ 推荐值为0.25</p><p>$$<br>DevRTT&#x3D;(1-\beta)\times DevRTT+\beta\times |SampleRTT-EstimatedRTT|<br>$$</p><hr><p><strong>Timeout时间设置</strong><br>超时间隔应该大于等于 EstimatedRTT以避免不必要的重传。同时要考虑到 RTT 的变化，因此要加上RTT偏差<br>$$<br>TimeoutInterval &#x3D; EstimatedRTT + 4\times DevRTT<br>$$</p><hr><ol><li>初始时$TimeoutInterval$设置为1s</li><li>第一个样本RTT获得后， $EstimatedRTT&#x3D;SampleRTT，DevRTT&#x3D;SampleRTT&#x2F;2$</li><li>$TimeoutInterval &#x3D;EstimatedRTT + max (G, K*DevRTT)$  （K&#x3D;4，G是用户设置的时间粒度）</li></ol><h3 id="Reliable-Data-Transfer"><a href="#Reliable-Data-Transfer" class="headerlink" title="Reliable Data Transfer"></a>Reliable Data Transfer</h3><p>TCP 在 IP 不可靠服务之上创建了一种<strong>可靠数据传输服务（reliable data transfer service,rdt）</strong>。为了减少多个定时器管理带来的相当大的开销，TCP 在即使有多个已发送但未确认的报文段的情况下，定时器的管理过程仅使用<strong>单一</strong>的定时器。简化的 TCP 发送方如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Assume sender is not constrained by TCP flow or congestion control, that data from above is less than MSS in size, and that data transfer is in one direction only. */</span></span><br><span class="line"></span><br><span class="line">NextSeqNum=InitialSeqNumber <span class="comment">// 表示下一个要发送的数据段的序列号</span></span><br><span class="line">SendBase=InitialSeqNumber <span class="comment">// 表示已发送但尚未被确认的最早的数据段的序列号</span></span><br><span class="line"></span><br><span class="line">loop (forever) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(event)</span><br><span class="line"></span><br><span class="line">        event: data received from application above</span><br><span class="line">            create TCP segment with sequence number NextSeqNum</span><br><span class="line">            <span class="keyword">if</span> (timer currently not running)</span><br><span class="line">            start timer</span><br><span class="line">            pass segment to IP</span><br><span class="line">            NextSeqNum=NextSeqNum+length(data)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        event: timer timeout</span><br><span class="line">            retransmit not-yet-acknowledged segment with smallest sequence number</span><br><span class="line">            start timer</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        event: ACK received, with ACK field value of y</span><br><span class="line">            <span class="title function_">if</span> <span class="params">(y &gt; SendBase)</span> &#123;</span><br><span class="line">                SendBase=y</span><br><span class="line">                <span class="keyword">if</span> (there are currently any not-yet-acknowledged segments)</span><br><span class="line">                start timer</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">/* end of loop forever */</span></span><br></pre></td></tr></table></figure><p><strong>简化的TCP发送方</strong></p><ul><li>data received from application above: 当从上层应用接收到数据时，创建一个 TCP Segment，其序列号为 NextSeqNum，如果没有启动定时器，则启动定时器，然后将该段传递给 IP 层以进行传输，<code>NextSeqNum += length(data)</code></li><li>timer timeout: 当定时器超时时（这通常意味着一个 TCP 段丢失了，因为我们没有在预期的时间内收到 ACK），会重新传输序列号最小的尚未确认的段，然后重新启动定时器</li><li>ACK received, with ACK field value of y: 当收到一个 ACK 时，如果 ACK 字段的值 y 大于 SendBase，则更新 SendBase 为 y。这意味着我们已经收到了序列号小于或等于 y 的所有段的确认。然后，如果还有尚未确认的段，就启动定时器<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-26-21-25-57.png" style="zoom:80%;"></li></ul><hr><p><strong>Retransmission Scenarios</strong></p><p>当发生timeout事件时，TCP 重传时都会将下一次的timeout间隔设为先前值的两倍；当发生其他两个事件计时器重启时，<code>TimeoutInterval</code>由最近的 <code>EstimatedRTT</code>值与 <code>DevRTT</code>值推算得到。这种修改提供了一个形式受限的拥塞控制,在拥塞时期，如果源继续坚持重新传输数据包，拥塞可能会变得更,通过延长超时时间，TCP 可以减少重传的次数，从而减少拥塞。如下图p2所示，Seq92超时重传，TimeoutInterval加倍，$TimeoutInterval \lt Seq100 Transport Time \lt 2 \times TimeoutInterval $, 从而Seq100不会被重传</p><p>累计确认机制避免了重传第一个段，如下图p3所示，Seq92和Seq100已经被确认，虽然ACK100丢失，但ACK120被接收，由于累计确认机制，Seq92和Seq100都被确认，因此不会被重传</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-26-22-42-12.png" style="zoom:100%;">> p1: Retransmission due to a lost acknowledgment> p2：Segment 100 not retransmitted> p3: A cumulative acknowledgment avoids retransmission of the first segmen<p><strong>Fast Retransmit</strong></p><p>当比期望序号大的失序报文段到达，接收方立即发送<strong>冗余 ACK（duplicate ACK）</strong>，指明下一个期待字节的序号<br>如果发送方收到一个确认后再收到3个对同样报文段的确认，发送方应意识到不对劲。生成三个重复ACK，是因为接收方存在缺失报文段；于是启动快速重传(fast retransmit): 在定时器超时之前重发丢失的报文段</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-30-15-08-41.png" style="zoom:80%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">event: ACK received, with ACK field value of y </span><br><span class="line"><span class="title function_">if</span> <span class="params">(y &gt; SendBase)</span> &#123; </span><br><span class="line">    SendBase = y</span><br><span class="line">    <span class="keyword">if</span> (there are currently not-yet-acknowledged segments)</span><br><span class="line">            start timer </span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">    increment count of dup ACKs received <span class="keyword">for</span> y</span><br><span class="line">    <span class="keyword">if</span> (count of dup ACKs received <span class="keyword">for</span> y == <span class="number">3</span>) &#123;</span><br><span class="line">        resend segment with sequence number y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-30-16-01-48.png" style="zoom:100%;"><p><strong>GBN or SR</strong></p><p>TCP错误恢复机制是GBN（Go-Back-N）协议还是SR（Selective Repeat）协议？</p><p>TCP的确认是累积的，正确接收但是顺序错误的段并不会被接收者单独确认。因此，TCP发送者只需要维护传输但未确认的字节的最小序列号（SendBase）和下一个要发送的字节的序列号（NextSeqNum）。从这个意义上说，TCP看起来很像一个GBN风格的协议。<br>但是TCP和GBN之间有一些显著的差异。许多TCP实现会缓存(buffer)正确接收但顺序错误的Segment [Stevens 1994]。<br>对TCP的一项提议修改，所谓的选择性确认 [RFC 2018]，允许TCP接收者选择性地确认顺序错误的段，而不是只是累积地确认最后正确接收的，顺序正确的段。当与选择性重传结合使用，TCP看起来很像我们的通用SR协议。因此，TCP的错误恢复机制可能最好被分类为GBN和SR协议的混合体。</p><h3 id="Flow-Control"><a href="#Flow-Control" class="headerlink" title="Flow Control"></a>Flow Control</h3><p>TCP 通过让发送方维护一个称为<strong>接收窗口（receive window）</strong>的变量来提供流量控制。通俗的说，接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。因为 TCP 是全双工通信，在连接两端的发送方都各自维护一个接收窗口。<br>接收窗口（<code>rwnd</code>）和接收缓存（<code>RcvBuffer</code>）如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-30-16-03-28.png" style="zoom:80%;"></p><p>通过TCP连接的主机都会为连接设置一个接收缓冲区。当TCP连接接收到正确且顺序正确的字节时，它会将数据放入接收缓冲区(TCP data in buffer)。相关的应用程序进程(Application process )将从这个缓冲区读取数据。进程从buffer中读取数据的时机是不确定的，可能在数据到达的瞬间读取，也可能在数据到达很久之后才尝试读取数据。如果应用程序读取数据的速度相对较慢，发送者很容易通过过快地发送过多的数据来溢出连接的接收缓冲区。</p><p>TCP为其应用程序提供了一种<strong>流量控制服务Flow Control</strong>，以消除发送者溢出接收者缓冲区的可能性。因此，流量控制是一种速度匹配服务(匹配发送者发送的速率与接收应用程序读取的速率)。</p><p>如前所述，由于IP网络内的拥塞，TCP发送者也可能被节流(throttled)；这种称为<strong>拥塞控制Congestion Control</strong>。尽管流量控制和拥塞控制采取的行动相似（即节流发送者），但它们显然是出于非常不同的原因。</p><p>TCP通过让发送者维护一个叫做receive window的变量来提供<strong>流量控制</strong>。接收窗口用于告诉sender关于receiver有多少可用缓冲区空间的信息。因为TCP是全双工的，连接的每一侧的发送者都维护一个独立的接收窗口。让我们在文件传输的上下文中研究接收窗口。</p><p>假设主机A正在通过TCP连接向主机B发送一个大文件。主机B为这个连接分配一个接收缓冲区；表示其大小为RcvBuffer。不时地，主机B的应用程序进程从缓冲区中读取数据。定义以下变量：</p><ul><li><code>LastByteRead</code>：这是应用程序从接收缓冲区中读取的数据流的最后一个字节的序号。换句话说，这是应用程序最后读取的数据的字节序号。例如，如果LastByteRead的值为1000，那么意味着应用程序已经读取了序号为1到1000的字节。</li><li><code>LastByteRcvd</code>：这是已经从网络到达并被放入主机B的接收缓冲区的数据流的最后一个字节的序号。换句话说，这是最后一个被接收并放入缓冲区的数据的字节序号。例如，如果LastByteRcvd的值为1500，那么意味着已经接收了序号为1到1500的字节，并且这些字节已经被放入了接收缓冲区。<blockquote><p>$LastByteRcvd - LastByteRead$即为应用程序未读取的数据量，它存放于Buffer中</p></blockquote></li></ul><p>因为TCP不允许溢出分配的缓冲区，我们必须有 $LastByteRcvd – LastByteRead \lt RcvBuffer$<br>接收窗口，表示为rwnd，设置为缓冲区的空闲空间：$rwnd &#x3D; RcvBuffer – (LastByteRcvd – LastByteRead)$，因为空闲空间随时间变化，rwnd是动态变化的。</p><p>连接如何使用变量rwnd来提供流量控制服务呢？</p><p>主机B通过在每个发送给A的Segment的<a href = "#TCP-Segment-Structure">接收窗口字段(Receieve Window)</a>中放置其rwnd的当前值，告诉主机A连接缓冲区中有多少空闲空间。最初，主机B设置$rwnd &#x3D; RcvBuffer$。注意，要实现这一点，主机B必须跟踪几个特定于连接的变量。</p><p>反过来，主机A跟踪两个变量，LastByteSent和LastByteAcked。这两个变量之间的差值 $LastByteSent – LastByteAcked$ 表示A已发送但未被确认的数据的量。通过保持未确认的数据量小于rwnd的值，主机A可以确保它没有溢出接收者的缓冲区。</p><p>这个方案有一个小的技术问题。为了看到这一点，假设主机B的接收缓冲区变满了，所以rwnd &#x3D; 0。在向主机A广告rwnd &#x3D; 0后，假设B没有任何数据要发送给A。现在考虑会发生什么。当B的应用程序进程清空缓冲区时，TCP不会向主机A发送新的段和新的rwnd值；实际上，只有当TCP有数据要发送，或者有确认要发送时，才会向主机A发送段。因此，主机A永远不会被通知主机B的接收缓冲区已经有了一些空间——主机A被阻塞了，不能再传输任何数据<br>为了解决这个问题，TCP规范要求主机A得知B的接收窗口为零时继续发送带有一个数据字节的段。这些段将被B确认。最终，缓冲区将开始清空，确认将包含一个非零的rwnd值。<br><a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/flow/">Flow Control Animations</a></p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-30-17-50-43.png" style="zoom:80%;"><blockquote><p>UDP不提供流量控制，因此，由于缓冲区溢出，接收者可能会丢失段。例如，考虑从主机A的一个进程发送一系列UDP段到主机B的一个进程。对于典型的UDP实现，UDP会将段附加在一个有限大小的缓冲区中，这个缓冲区“位于”相应的套接字之前。进程一次从缓冲区中读取一个完整的段。如果进程从缓冲区中读取段的速度不够快，缓冲区将溢出，段将被丢弃。</p></blockquote><h3 id="TCP-Connection-Management"><a href="#TCP-Connection-Management" class="headerlink" title="TCP Connection Management"></a>TCP Connection Management</h3><p><strong>How a TCP connection is established and torn down?</strong></p><p>假设一个主机（客户端）上的进程希望与另一个主机（服务器）上的进程建立连接。客户端应用程序首先通知客户端的TCP它希望与服务器中的进程建立连接。然后，客户端的TCP按照以下方式与服务器的TCP建立连接：</p><ul><li><p><strong>Step 1</strong>：客户端TCP首先向服务器TCP发送一个特殊的TCP段。这个特殊段中不包含应用层数据。但是段头部(Segment Header)中的SYN标志位，被设置为1。因此，这个特殊段被称为SYN Segment。此外，客户端随机选择一个初始序列号（client_isn），并将此号码放入初始TCP SYN段的序列号字段中。此段被封装在一个IP数据报中并发送到服务器。为了避免某些安全攻击，对客户端_isn的选择进行适当的随机化引起了极大的关注。</p></li><li><p><strong>Step 2</strong>：一旦包含TCP SYN段的IP数据报到达服务器主机（假设它确实到达了！），服务器将TCP SYN段从数据报中提取出来，为连接分配TCP缓冲区和变量，并向客户端TCP发送连接确认段。这个连接确认段也不包含应用层数据。然而，它在段头部包含三个重要的信息。首先，SYN位被设置为1。其次，TCP段头部的确认字段被设置为client_isn+1。最后，服务器选择自己的初始序列号（server_isn）并将此值放入TCP段头部的序列号字段中。这个连接确认段实际上在说，“我收到了你的SYN包，要求以你的初始序列号client_isn开始一个连接。我同意建立这个连接。我的初始序列号是server_isn。”这个连接确认段被称为SYNACK段。</p></li><li><p><strong>Step 3</strong>：收到SYNACK段后，客户端也为连接分配缓冲区和变量。然后，客户端主机向服务器发送另一个段；这个最后的段确认了服务器的连接确认段（客户端通过将值server_isn+1放入TCP段头部的确认字段中来做到这一点）。SYN位被设置为零，因为连接已经建立。这个三次握手的第三阶段可能在段负载中携带客户端到服务器的数据。</p></li></ul><h2 id="Principles-of-Congestion-Control"><a href="#Principles-of-Congestion-Control" class="headerlink" title="Principles of Congestion Control"></a>Principles of Congestion Control</h2><h2 id="TCP-Congestion-Control"><a href="#TCP-Congestion-Control" class="headerlink" title="TCP Congestion Control"></a>TCP Congestion Control</h2>]]></content>
    
    
    <summary type="html">记录运输层学习笔记, 第二部分。</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>The Database Application Programming</title>
    <link href="https://efterklang.github.io/Tech/DataBase/Ch6-DbPrograming/"/>
    <id>https://efterklang.github.io/Tech/DataBase/Ch6-DbPrograming/</id>
    <published>2024-04-28T12:07:31.000Z</published>
    <updated>2024-04-29T09:49:56.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库连接技术"><a href="#数据库连接技术" class="headerlink" title="数据库连接技术"></a>数据库连接技术</h2><h3 id="ODBC"><a href="#ODBC" class="headerlink" title="ODBC"></a>ODBC</h3><p><strong>ODBC</strong> 是由 Microsoft 在 1990 年代初开发的，用于访问各种数据库系统的标准 API。ODBC 使用 SQL 作为数据库访问语言，允许应用程序独立于任何特定 DBMS，从而使得应用程序能够与多种 DBMS 进行交互。ODBC 驱动程序是一种实现了 ODBC 接口的特定 DBMS 的库。应用程序通过 ODBC 驱动程序与 DBMS 进行通信。</p><ul><li>开放式数据库互连（Open DataBase Connectivity）实现了应用程序对多种不同DBMS的数据库的访问，实现了数据库连接方式的变革</li><li>是一套基于SQL的，公共的，与数据库无关的API</li><li>使每个应用程序利用相同的源代码就可访问不同的数据库系统</li><li>存取多个数据库中的数据，从而使得应用程序与数据库管理系统之间在逻辑上独立，使应用程序与数据库无关性</li></ul><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p><strong>JDBC</strong> 是 Java 中用于数据库连接的 API，由 Sun Microsystems（现在是 Oracle Corporation 的一部分）在 1997 年发布。JDBC 提供了一种基准，使得 Java 程序可以与多种关系数据库进行交互。JDBC 提供了一组接口和类，使得开发人员可以发送 SQL 语句并处理结果。JDBC 驱动程序是实现了 JDBC 接口的特定 DBMS 的 Java 类库。Java 程序通过 JDBC 驱动程序与 DBMS 进行通信。</p><p>JDBC程序访问数据库的步骤</p><ul><li>应用程序开始</li><li>导入java.sql包</li><li>加载并注册驱动程序</li><li>依次创建Connection对象、Statement对象</li><li>执行SQL语句</li><li>使用ResultSet对象返回结果</li><li>依次关闭ResultSet对象、Statement对象、Connection对象</li><li>应用程序结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际开发中，密码不应该明文存储，应进行一定的数据脱敏处理。这也是为什么忘记密码时，只能重置密码，而不能查看密码的原因</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessAccountData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ProcessAccountData.class.getClassLoader();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sqlURL</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;jdbc:mysql://localhost:3306/free_chat?serverTimezone=GMT&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;gjxMySQLPWD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> 对数据库,进行读取，写入到validUsers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> validUsers 要写入账号数据的HashMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readAccountFile</span><span class="params">(ConcurrentHashMap&lt;String, User&gt; validUsers)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(sqlURL, user, password);</span><br><span class="line">                <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;select * from accounts&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(rs.getString(<span class="string">&quot;account&quot;</span>), rs.getString(<span class="string">&quot;pwd&quot;</span>));</span><br><span class="line">                validUsers.put(rs.getString(<span class="string">&quot;account&quot;</span>), user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> 当进行注册时，将userId＆pwd写入到数据库中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pwd 用户密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeAccountFile</span><span class="params">(String userId, String pwd)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO accounts (account, pwd) VALUES (?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(sqlURL, user, password);) &#123;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">            pstmt.setString(<span class="number">1</span>, userId);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, pwd);</span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet 是 Java Web 技术的核心组成部分，它是在服务器端运行的 Java 程序，用于处理来自 Web 客户端（如浏览器）的请求，并生成动态的 Web 内容。Servlet 是 Java EE 规范的一部分，但在 Java EE 8 之后，Java EE 已经转交给 Eclipse 基金会，并更名为 Jakarta EE。因此，最新的 Servlet 规范是 Jakarta Servlet。</p><p>以下是关于 Servlet 的一些关键点：</p><ul><li><strong>生命周期</strong>：Servlet 的生命周期从 Web 容器加载和实例化 Servlet 开始，经过处理一系列的请求，直到最后 Web 容器卸载 Servlet。主要的方法有 init(), service(), 和 destroy()。</li><li><strong>处理请求</strong>：Servlet 可以处理来自客户端的 GET、POST 等 HTTP 请求，并根据请求生成相应的响应。请求和响应都被封装为 Java 对象，分别是 HttpServletRequest 和 HttpServletResponse。</li><li><strong>线程安全</strong>：对于每个新的请求，Servlet 容器会启动一个新的线程来处理。因此，Servlet 必须被设计为线程安全的。</li><li><strong>配置和上下文</strong>：Servlet 可以通过 ServletConfig 和 ServletContext 接口访问配置信息和应用程序级别的上下文。</li><li><strong>会话管理</strong>：Servlet 提供了 HttpSession 接口来管理与特定用户相关的会话。</li><li><strong>过滤器和监听器</strong>：Servlet API 还提供了过滤器（Filter）和监听器（Listener）等组件，可以用于拦截请求、响应，或者监听 Servlet 的生命周期事件等。</li></ul><p><strong>Servlet工作流程</strong></p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-DbPrograming-2024-04-29-17-23-01.png" style="zoom:100%;"><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>MyBatis 是一个优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码和参数的手动设置以及结果集的检索。MyBatis 可以使用简单的 XML 或注解进行配置，并将原生信息映射至 Java 对象。MyBatis 通常被视为介于全自动 ORM 框架（如 Hibernate）和手动处理所有事情的 JDBC 之间的一种解决方案。</p><p><strong>Mybatis优点</strong>：</p><ol><li>支持自定义SQL、存储过程、及高级映射</li><li>实现自动对SQL的参数设置</li><li>实现自动对结果集进行解析和封装</li><li>通过XML或者注解进行配置和映射，大大减少代码量</li><li>数据源的连接信息通过配置文件进行配置</li></ol><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>JSP全名为Java Server Pages，java服务器页面。JSP是一种基于文本的程序，其特点就是HTML和Java代码共同存在<br>jsp只是servlet的一种特殊形式，每一个jsp页面就是一个servlet实例，通俗一点的话来说：jsp就是servlet，只不过servlet把一些业务功能剥离开来交给了或者是形成了jsp。在我们的项目编译的时候就是把jsp编译成了servlet。<br>JSP比Servlet更方便更简单的一个重要原因就是：内置了9个对象！内置对象有：out、session、response、request、config、page、application、pageContext、exception</p><h3 id="SSM典型Java-web开发架构"><a href="#SSM典型Java-web开发架构" class="headerlink" title="SSM典型Java web开发架构"></a>SSM典型Java web开发架构</h3><ul><li>JSP&#x2F;HTML页面发送请求</li><li>Controller层接收用户请求，进行响应的流程处理</li><li>Service层完成具体的业务逻辑</li><li>DAO(Data Access Object)层对数据库进行操作</li><li>数据库</li></ul><h2 id="数据库存储过程"><a href="#数据库存储过程" class="headerlink" title="数据库存储过程"></a>数据库存储过程</h2><p><strong>存储过程</strong>（Stored Procedure）是一种数据库的对象。由一组能完成特定功能的SQL 语句集构成，是把经常会被重复使用的SQL语句逻辑块封装起来，经编译后，存储在数据库服务器端；当被再次调用时，不需要再次编译； 当客户端连接到数据库时，用户通过指定存储过程的名字并给出参数，数据库就可以找到相应的存储过程予以调用。</p><blockquote><p>PostgreSQL使用CREATE FUNCTION命令创建存储过程。(11版本后可以用CREATE PRECEDURE)</p></blockquote><p><strong>Pros</strong><br>(1) 减少网络通信量<br>(2) 执行速度更快<br>(3) 更强的适应性<br>(4) 降低了业务实现与应用程序的耦合<br>(5) 降低了开发的复杂性<br>(6) 保护数据库元信息<br>(7) 增强了数据库的安全性<br><strong>Cons</strong><br>(1)  SQL本身是一种结构化查询语言，而存储过程本质上是过程化的程序；面对复杂的业务逻辑，过程化处理逻辑相对比较复杂；而SQL语言的优势是面向数据查询而非业务逻辑的处理。<br>(2) 如果存储过程的参数或返回数据发生变化，一般需要修改存储过程的代码，同时还需要更新主程序调用存储过程的代码。<br>(3) 开发调试复杂，由于缺乏支持存储过程的集成开发环境，存储过程的开发调试要比一般程序困难。<br>(4) 可移植性差   </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建存储过程</span></span><br><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] <span class="keyword">FUNCTION</span><span class="operator">/</span><span class="keyword">PROCEDURE</span>  name</span><br><span class="line">([ [ argmode ] [ argname ] argtype [ &#123; <span class="keyword">DEFAULT</span> <span class="operator">|</span> <span class="operator">=</span> &#125; default_expr ] [, ...] ])</span><br><span class="line"> [ <span class="keyword">RETURNS</span> retype <span class="operator">|</span> <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span> ( column_name  column_type [, ...] ) ]</span><br><span class="line"> <span class="keyword">AS</span> $$         <span class="comment">-- $$用于声明存储过程的实际代码的开始</span></span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">    <span class="comment">-- 声明段</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">--函数体语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"> $$ <span class="keyword">LANGUAGE</span> lang_name;  <span class="comment">--$$ 表明代码的结束, LANGUAGE后面指明所用的编程语言</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">主要参数：</span></span><br><span class="line"><span class="string">（1）name：要创建的存储过程名；</span></span><br><span class="line"><span class="string">（2）OR REPLACE ：覆盖同名的存储过程；</span></span><br><span class="line"><span class="string">（3）argmode：存储过程参数的模式可以为IN、OUT或INOUT，缺省值是IN。</span></span><br><span class="line"><span class="string">（4）argname：形式参数的名字。</span></span><br><span class="line"><span class="string">（5）RETURNS：返回值；RETURNS TABLE：返回二维表</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--删除存储过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [ IF <span class="keyword">EXISTS</span> ] name ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [ </span><br><span class="line">CASCADE <span class="operator">|</span> RESTRICT ]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">主要参数：</span></span><br><span class="line"><span class="string">（1）IF EXISTS：如果指定的存储过程不存在，那么发出提示信息。</span></span><br><span class="line"><span class="string">（2）name ：现存的存储过程名称。</span></span><br><span class="line"><span class="string">（3）argmode：参数的模式：IN(缺省), OUT, INOUT, VARIADIC。请注意，实际并不注明OUT参数，因为判断</span></span><br><span class="line"><span class="string">存储过程的身份只需要输入参数。</span></span><br><span class="line"><span class="string">（4）argname：参数的名字。请注意，实际上并不注明参数的名字，因为判断函数的身份只需要输入参数的数据类</span></span><br><span class="line"><span class="string">型。</span></span><br><span class="line"><span class="string">（5）argtype：如果有的话，是存储过程参数的类型。</span></span><br><span class="line"><span class="string">（6）CASCADE：级联删除依赖于存储过程的对象(如触发器)。</span></span><br><span class="line"><span class="string">（7）RESTRICT：如果有任何依赖对象存在，则拒绝删除该函数；这个是缺省值。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 统计学生表中有多少records</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> countRecords()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INTEGER</span> <span class="keyword">AS</span> $cnt$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    COUNT <span class="type">INTEGER</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> cnt <span class="keyword">FROM</span> STUDENT; <span class="comment">-- INTO 用于将查询结果赋值给变量</span></span><br><span class="line">    <span class="keyword">RETURN</span> COUNT;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$cnt$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"><span class="comment">-- 执行存储过程</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> countRecords();</span><br></pre></td></tr></table></figure><h2 id="数据库触发器"><a href="#数据库触发器" class="headerlink" title="数据库触发器"></a>数据库触发器</h2><h2 id="数据库游标"><a href="#数据库游标" class="headerlink" title="数据库游标"></a>数据库游标</h2><h2 id="嵌入式SQL编程"><a href="#嵌入式SQL编程" class="headerlink" title="嵌入式SQL编程"></a>嵌入式SQL编程</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/whgk/p/6399262.html">Java Web Servlet详解 cnblog</a></p>]]></content>
    
    
    <summary type="html">存储过程，触发器，etc</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="DataBase" scheme="https://efterklang.github.io/categories/Tech/DataBase/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>git rebase</title>
    <link href="https://efterklang.github.io/Dev/Git/GitRebase/"/>
    <id>https://efterklang.github.io/Dev/Git/GitRebase/</id>
    <published>2024-04-27T11:10:13.000Z</published>
    <updated>2024-04-27T15:14:17.894Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在开发过程中，可能会有这样的情况：你在开发一个功能时，提交了多次commit，但是这些commit并不是一个完整的功能，或者是一个bug修复，这时候你可能会想要将这些commit合并成一个commit，以便于更好的管理提交历史。这时候，git rebase就派上用场了。通过这个命令，对git提交历史进行整理，可以使提交历史更加清晰。需要注意的是，如果你已经将这些commit推送到了远程仓库，那么你需要使用<code>git push --force</code>来推送你的更改。</p><article class="message is-danger">        <div class="message-header"><p>Warning</p></div>        <div class="message-body">            <p>⚠️️ 在多人协作的项目中使用git rebase 需要注意尽量不要对已经推送到远程仓库的commit进行rebase操作，因为这样会改变提交历史，可能会导致其他人在合并你的提交时出现问题。推荐的使用场景是在本地开发过程中使用rebase整理提交历史。</p>        </div>    </article><h2 id="如何合并多个commit"><a href="#如何合并多个commit" class="headerlink" title="如何合并多个commit"></a>如何合并多个commit</h2><p>如何确定你想要合并的commits的范围呢?</p><p>例如，如果你想要合并最近的三个 commit，你可以使用 <code>HEAD~3</code>。这将打开一个编辑器(core.editor)，列出最近的三个 commit。<br>你也可以使用<code>git rebase -i &lt;commit&gt;</code>指定commit的hash值。例如<code>git rebase -i 8c0a3c</code>,这将打开一个编辑器，列出从 <commit> 到 HEAD 的所有 commit。<br>运行<code>git rebase -i HEAD~3</code>。</p><blockquote><p>注意:git rebase只能合并连续的commit，如果你想要合并不连续的commit，你需要多次运行rebase命令<br>你可以通过设置环境变量来指定使用的编辑器，例如：<code>git config --global core.editor &quot;nvim&quot; </code>将使用nvim编辑器。<br>这里推荐<a href="https://www.lazyvim.org/installation">lazyvim</a>以及lunarvim，这两个vim配置都是基于neovim的，功能强大，配置简单，推荐使用。且对于在终端中运行支持良好。</p></blockquote><p>在编辑器中，将第二行和第三行的 pick 改为 squash 或 s;然后保存修改并退出，这将打开另一个编辑器，让你编辑新的 commit 信息。更多命令见下表Commands内容</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GitRebase-2024-04-27-19-26-02.png" style="zoom:80%;"><br><blockquote><p><strong>Commands</strong>:</p><ul><li>p, pick &#x3D; use commit</li><li>r, reword &#x3D; use commit, but edit the commit message</li><li>e, edit &#x3D; use commit, but stop for amending</li><li>s, squash &#x3D; use commit, but meld into previous commit</li><li>f, fixup &#x3D; like “squash”, but discard this commit’s log message</li><li>x, exec &#x3D; run command (the rest of the line) using shell</li><li>d, drop &#x3D; remove commit</li></ul></blockquote><p>编辑 commit 信息，然后保存并关闭编辑器。如果一切顺利，你的三个 commit 现在应该已经被合并成一个了。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GitRebase-2024-04-27-19-27-45.png" style="zoom:80%;"><p>这将改变你的 Git 历史。如果你已经将这些 commit 推送到了远程仓库，你将需要使用<code>git push --force</code> 来推送你的更改</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GitRebase-2024-04-27-19-30-26.png" style="zoom:80%;"><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://git-scm.com/docs/git-rebase">https://git-scm.com/docs/git-rebase</a></p>]]></content>
    
    
    <summary type="html">介绍git rebase的使用；通过git rebase,git squash等命令，对git提交历史进行整理，使提交历史更加清晰。</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Git" scheme="https://efterklang.github.io/categories/Dev/Git/"/>
    
    
    <category term="Git" scheme="https://efterklang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo添加Live2d模型</title>
    <link href="https://efterklang.github.io/Tech/FrontEnd/Live2d/"/>
    <id>https://efterklang.github.io/Tech/FrontEnd/Live2d/</id>
    <published>2024-04-26T10:58:52.000Z</published>
    <updated>2024-04-27T11:23:40.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Installations"><a href="#Installations" class="headerlink" title="Installations"></a>Installations</h2><ol><li>首先在网站根目录下执行<code>npm install --save hexo-helper-live2d</code>，下载Live2d插件</li><li>下载模型，在网站根目录下新建<code>live2d_models</code>文件夹，将模型文件放入其中,模型文件可在以下链接下载<br> <a href="https://github.com/xiazeyu/live2d-widget-models">https://github.com/xiazeyu/live2d-widget-models</a></li><li>修改<code>_config.yml</code>文件，添加如下配置 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">nipsilon</span> <span class="comment"># 相对于/live2d_models/的路径</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">175</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">350</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span> </span><br></pre></td></tr></table></figure> 文件的存放位置参考下图 <img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Live2d-2024-04-26-19-17-08.png" style="zoom:70%;"></li><li>效果图 <img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Live2d-2024-04-26-19-20-25.png" style="zoom:80%;"></li></ol><h2 id="Configurations"><a href="#Configurations" class="headerlink" title="Configurations"></a>Configurations</h2><h3 id="helper特有"><a href="#helper特有" class="headerlink" title="helper特有"></a>helper特有</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 相对于博客根目录的路径</span></span><br><span class="line">    <span class="comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br></pre></td></tr></table></figure><h3 id="General-Settings"><a href="#General-Settings" class="headerlink" title="General Settings"></a>General Settings</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/xiazeyu/live2d-widget.js</span></span><br><span class="line"><span class="comment">## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">superSample:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">hOffset:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">vOffset:</span> <span class="number">-20</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.npmjs.com/package/hexo-helper-live2d">hexo-helper-live2d</a><br><a href="https://blog.csdn.net/wang_123_zy/article/details/87181892">Hexo添加Live2D看板娘+模型预览</a></p>]]></content>
    
    
    <summary type="html">本文介绍如何给Hexo博客添加Live2d模型</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="FrontEnd" scheme="https://efterklang.github.io/categories/Tech/FrontEnd/"/>
    
    
    <category term="Others" scheme="https://efterklang.github.io/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Storage Management Part Ⅰ</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch4-1StorageManagement/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch4-1StorageManagement/</id>
    <published>2024-04-18T13:19:38.000Z</published>
    <updated>2024-04-27T11:23:40.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="存储器层次结构概述"><a href="#存储器层次结构概述" class="headerlink" title="存储器层次结构概述"></a>存储器层次结构概述</h3><p>为能更多的存放并更快地处理用户信息，目前许多计算机把存储器分为三级。</p><ul><li><strong>高速缓存</strong> Cache：K 字节、高速、昂贵、易变的</li><li><strong>内存</strong> RAM： M 或 G 字节、中速、中等价格、易变的</li><li><strong>磁盘</strong>：G 或 T 字节、低速、价廉、不易变的</li></ul><blockquote><p>寄存器、高速缓存、主存储器和磁盘缓存均属于操作系统存储管理的管辖范畴，掉电后它们存储的信息不再存在。<br>磁盘和可移动存储介质属于设备管理的管辖范畴，它们存储的信息将被长期保存。</p></blockquote><h4 id="主存储器与寄存器"><a href="#主存储器与寄存器" class="headerlink" title="主存储器与寄存器"></a>主存储器与寄存器</h4><ol><li><p><strong>主存储器</strong>（内存，主存，可执行存储器）<br>用于保存进程运行时的程序和数据。CPU 的控制部件只能从主存中取得指令和数据到 CPU 寄存器，同样，CPU 寄存器中的数据可存入主存。<br>CPU 与外设交换数据必须依托于主存。</p></li><li><p><strong>寄存器</strong><br>寄存器访问速度最快，与 CPU 协调工作。<br>高速缓存与磁盘缓存<br>CPU 对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。<br>根据程序执行的<strong>局部性原理</strong>，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。<br>有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。</p><blockquote><p>局部性原理（Locality Principle）指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。<br>在分页机制中，页表的作用是将虚拟地址转换为物理地址，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：<br>时间局部性：由于程序中存在一定的循环或者重复操作，因此会反复访问同一个页或一些特定的页，这就体现了时间局部性的特点。为了利用时间局部性，分页机制中通常采用缓存机制来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。<br>空间局部性：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此当访问某个页时，往往会顺带访问其相邻的一些页。为了利用空间局部性，分页机制中通常采用预取技术来预先将相邻的一些页读入内存缓存中，以便在未来访问时能够直接使用，从而提高访问速度。总之，局部性原理是计算机体系结构设计的重要原则之一，也是许多优化算法的基础。在分页机制中，利用时间局部性和空间局部性，采用缓存和预取技术，可以提高页面的命中率，从而提高内存访问效率</p></blockquote></li></ol><h4 id="高速缓存与磁盘缓存"><a href="#高速缓存与磁盘缓存" class="headerlink" title="高速缓存与磁盘缓存"></a>高速缓存与磁盘缓存</h4><ol><li><strong>高速缓存</strong><br>CPU 对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。<br>根据程序执行的局部性原理，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。<br>有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。</li><li><strong>磁盘缓存</strong><br>内存中一块存储区，对应于某固定磁盘，临时存储磁盘数据（如，数据预取）</li></ol><h3 id="存储器管理的目的和功能"><a href="#存储器管理的目的和功能" class="headerlink" title="存储器管理的目的和功能"></a>存储器管理的目的和功能</h3><p>操作系统负责协调这些存储器的使用<br>三级存储器，从缓存到内存到外存，其容量愈来愈大，而访问数据的速度则愈来愈慢，价格也愈来愈便宜。<br>用户的程序在运行时应存放在主存中，以便处理机访问。<br>为尽可能利用 CPU，要求直接存取内存的速度尽量快到与 CPU 取指速度相匹配，容量大到能装下当前运行的程序与数据<br>由于主存容量和速度有限。所以把那些不马上使用的程序、数据放在外部存储器(又称辅存)中。当用到时再把它们读入主存。</p><ol><li><strong>主存储器的分配和管理</strong>：按用户要求把适当的存储空间分配给相应的作业。一个有效的存储分配机制，应在用户请求时能作出快速的响应，分配相应的存储空间；在用户不再使用它时，应立即回收，以供其他用户使用。为此，这个存储分配机制应具有如下功能：<br>(1)记住每个存储区域的状态：哪些是已分配的，哪些是可以用作分配的。<br>(2)实施分配：在系统程序或用户提出申请时，按所需的量给予分配；修改相应的分配记录表。<br>(3)接受系统或用户释放的存储区域：并相应地修改分配记录表。</li><li><strong>提高主存储器的利用率</strong>：使多道程序能动态地共享主存，最好能共享主存中的信息</li><li><strong>“扩充”主存容量</strong>：这是借助于提供虚拟存储器或其它自动覆盖技术来达到的。即为用户提供比主存的存储空间还大的地址空间</li><li><strong>存储保护</strong>：确保各道用户作业都在所分配的存储区内操作，互不干扰。即要防止一道作业由于发生错误而损害其它作业，特别需要防止破坏其中的系统程序。这个问题不能用特权指令来加以解决，而必须由硬件提供保护功能，并由软件配合实现</li></ol><h3 id="存储分配的三种方式"><a href="#存储分配的三种方式" class="headerlink" title="存储分配的三种方式"></a>存储分配的三种方式</h3><p>存储分配，解决多道作业之间共享主存的问题。确定什么时候，以什么方式，把一个作业的全部信息或作业运行时首先需要的信息分配到主存中，并使这些问题对用户来说尽可能是<strong>透明</strong>的。</p><blockquote><p>“对用户透明”（User Transparency）是一种计算术语，它指的是用户在使用系统或服务时，不需要关心或理解其背后的复杂实现细节。换句话说，系统或服务的复杂性对用户是”透明”的。</p></blockquote><p>解决存储分配问题的三种方式：</p><blockquote><p>目前，绝大多数计算机系统都采用静态或动态存储分配方式</p></blockquote><ol><li><strong>直接指定方式</strong>：程序员在编程序时，或编译程序(汇编程序)对源程序进行编译(汇编)时，使用实际存储地址。<ul><li>在多道程序环境下，应保证各作业所用的地址互不重叠。在多道程序发展的初期，通常把存储空间划分成若干个固定的不同大小分区，并对不同的作业指定相应的分区。因此，对编程人员或对编译程序而言，存储器的可用空间是可知的</li><li>采用直接指定方式分配的前提是：存储器的可用容量(空间)已经给定或者可以指定，这对单用户计算机系统是不成问题的</li><li>这种分配方式的实质是：由编程人员在编写程序时，或由编译程序编译源程序时，对一个作业的所有信息确定在主存存储空间中的位置。因此，这种直接指定方式的存储分配方案，不仅用户感到不便，而且存储空间的利用也不那么有效</li></ul></li><li><strong>静态分配方式</strong>(Static Allocation)<br>用户在编程时，或由编译程序产生的目的程序，均可从其地址空间的零地址开始；当<strong>装配程序</strong>对其进行连接装入时才确定它们在主存中的相应位置，从而生成可执行程序。也就是说，存储分配是在装入时实现的。静态分配策略的存储管理很简单，但在多道程序系统中不能有效地共享存储器资源<br>这种静态存储分配方式的特点是：<ul><li>在一个作业装入时必须分配其要求的全部存储量；</li><li>如果没有足够的存储空间，就不能装入该作业；</li><li>一旦一个作业进入内存后，在其退出系统之前，它一直占用着分配给它的全部存储空间；</li><li>作业在整个运行过程中不能在内存中“搬家”、也不能再申请存储量。</li></ul></li><li><strong>动态分配方式</strong>(Dynamic Allocation)：<br>动态分配是一种更加有效的使用主存储器的方法。这种动态存储分配方式的特点是：<ul><li>作业在存储空间中的位置，也是在其装入时确定的；</li><li>在其执行过程中可根据需要申请附加的存储空间；</li><li>一个作业已占用的部分存储区域不再需要时，可以要求归还给系统。即：这种存储分配机制能接受不可预测的分配和释放存储区域的请求，实现个别存储区域的分配和回收；</li><li>存储区域的大小是可变的；</li><li>允许作业在内存中“搬家”。</li></ul></li></ol><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>逻辑地址</strong>（相对地址，虚地址） Logical Address<br>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为 0，其余指令中的地址都相对于首地址而编址。不能用逻辑地址在内存中读取信息<br><strong>物理地址</strong>（绝对地址，实地址）Physical Address<br>内存中存储单元的地址，可直接寻址<br><strong>名空间</strong> namespace<br>是一种封装或组织代码的方式，它可以将一组标识符（如变量、函数、类、模块等）包含在一个名为命名空间的范围内<br><strong>地址空间</strong> Address Space<br>程序用来访问信息所用地址单元的集合，是逻辑（相对）地址的集合，由编译程序生成。<br><strong>存储空间</strong> Storage Space<br>主存中物理单元的集合。这些单元的编号称物理地址或绝对地址。存储空间的大小是由主存的实际容量决定的。</p><blockquote><p>地址空间是逻辑地址的集合；存储空间是物理地址的集合。一个是“虚”的概念，一个是“实”的物体。<br>一个编译好的目标程序存在于它自己的地址空间中，当要它在计算机上运行时，才把它装入存储空间。<br>一个作业在编译、装入前后存在于不同的空间。</p></blockquote><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>将一个用户源程序变为一个可在内存中执行的程序，通常要经过下列几步：</p><ul><li><strong>预处理</strong>（Preprocessing）：这是编译过程的第一步，主要处理源代码中的预处理器指令。例如，C 和 C++语言中的<code>#include</code>和<code>#define</code>等。预处理器将处理这些指令，如扩展包含文件，替换宏定义等，生成一个预处理后的源代码文件。</li><li><strong>编译</strong>（Compilation）：在这个阶段，编译器将预处理后的源代码转换为汇编语言。编译器在这个过程中会进行词法分析、语法分析、语义分析和优化等操作。编译器还会检查源代码中的错误，并生成对应的错误和警告信息。</li><li><strong>汇编</strong>（Assembly）：汇编阶段将编译阶段生成的汇编代码转换为机器语言代码，也就是目标代码。这个过程是由汇编器完成的。每一条汇编语言指令通常会被转换为一条机器语言指令。</li><li><strong>链接</strong>（Linking）：链接阶段是将所有的目标代码和必要的库函数链接在一起，生成一个可执行文件。链接器会处理源代码中的外部符号引用，将它们与正确的地址或者符号绑定在一起。</li><li><strong>装入</strong>（Loading）：当程序运行时，加载器（Loader）的任务是将可执行文件从硬盘加载到内存中，然后开始执行。加载器还负责解析程序对动态库的依赖，并将这些库加载到内存中。</li></ul><h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><p>根据存储空间的分配方式，将一个装入模块装入内存时，可采用三种方式：</p><ol><li><strong>绝对装入方式</strong>Absolute Loading Mode：<br>在编译时，如果知道程序将驻留在内存的具体位置，那么编译程序将产生**实际存储地址(绝对地址)**的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<ul><li>装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。</li><li>通常在程序中采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址。</li></ul></li><li><strong>静态重定位装入方式</strong>Static Relocation Loading Mode：<br>地址变换是在装入内存时一次完成的，且以后不能移动。<br>一般情况下,物理地址&#x3D;相对地址+内存中的起始地址<br>适用于多道程序环境，可以将装入模块装入到内存中任何允许的位置。<ul><li>优点：不需硬件支持，可以装入有限多道程序。</li><li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动，不易实现共享。</li></ul></li><li><strong>动态重定位装入方式&#x2F;动态运行时装入方式</strong>Dynamic Run-time Loading<br>装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是<strong>把地址转换推迟到程序执行时进行</strong>。在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换，故称为<strong>动态重定位</strong><br>最简单的办法是利用一个重定位寄存器(RR)。该寄存器的值是由进程调度程序根据作业分配到的存储空间起始地址来设定的。<br>在具有这种地址变换机构的计算机系统中，当执行作业时，不是根据 CPU 给出的有效地址去访问主存，而是将有效地址与重定位寄存器中的内容相加后得到的地址作为访问主存的地址<br>采用动态重定位技术后，程序中所有指令和数据的实际地址是在运行过程中最后访问的时刻确定的。也就是说，在作业运行过程中临时申请分配附加的存储区域或释放已占用的部分存储空间是允许的。<ul><li><strong>主要优点</strong><br>① 主存的使用更加灵活有效。这里，一个用户的作业不一定要分配在一个连续的存储区，因而可以使用较小的分配单位。而且，在作业开始之前也不一定把它的地址空间全部装入主存，而可以在作业执行期间响应请求动态地进行分配。<br>② 几个作业共享一程序段的单个副本比较容易。<br>③ 有可能向用户提供一个比主存的存储空间大得多的地址空间。因而无需用户来考虑覆盖结构，而由系统来负责全部的存储管理。</li><li><strong>主要缺点</strong><br>① 需要附加硬件支持；<br>② 实现存储器管理的软件比较复杂。</li></ul></li></ol><h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>链接程序的功能，是将经过编译后所得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。</p><p>根据链接时间的不同，可把链接分成如下三种：</p><ol><li><p><strong>静态链接</strong> Static Linking<br>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开。<br>将几个目标链接装配成一个装入模块时，需解决以下两个问题：</p><ul><li>将相对地址进行修改。即将除第一个模块外的相对地址修改成装入模块中的相应的相对地址</li><li>变换外部调用符号。即将每个模块中所用的外部调用符号，都变换为相对地址。<br>这种先进行链接所形成的一个完整的装入模块，又称为可执行文件</li></ul></li><li><p><strong>装入时动态链接</strong>Load-Time Dynamic Linking<br>用户源程序经编译后所得到的目标模块，是在装入内存时，边装入边链接的。即在装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将其装入内存。<br>优点： 便于软件版本的修改和更新,只需修改各个目标模块，不必将装入模块拆开，非常方便;便于实现目标模块共享。即可以将一个目标模块链接到几个应用模块中，从而实现多个应用程序对该模块的共享。</p></li><li><p><strong>运行时动态链接</strong>(Run-Time Dynamic Linking)<br>目前最常使用的链接方式,采用装入时动态链接方式，虽然可将一个装入模块装入到内存的任何地方，但装入模块的结构是静态的，表现在：</p><ul><li>进程（程序）在整个执行期间，装入模块是不改变的；</li><li>每次运行时的装入模块是相同的。并且事先无法知道本次要运行哪些模块，只能将所有可能要运行的模块在装入时全部链接在一起，而实际上往往有些目标模块根本不会运行。<br>采用运行时动态链接可<strong>将某些目标模块的链接推迟到执行时才进行</strong>，即在执行过程中，若发现一个被调用模块尚未装入内存时，由 OS 去找到该模块，将它装入内存，并链接到调用模块上。<blockquote><p>运行时动态链接的工作原理如下：</p><ol><li><strong>加载阶段</strong>：当程序启动时，动态链接器（在 Unix-like 系统中通常是 ld.so 或 ld-linux.so，在 Windows 系统中是 kernel32.dll）会加载程序需要的动态链接库（DLL）或共享对象（SO）文件。这些库文件包含程序需要的函数和数据。</li><li><strong>链接阶段</strong>：在程序运行时，当程序第一次调用某个库函数时，动态链接器会查找这个函数在内存中的实际地址，并将这个地址写入程序的全局偏移表（GOT）或程序查找表（PLT）。这个过程被称为“解析”。</li><li><strong>运行阶段</strong>：一旦函数地址被解析，程序就可以直接调用这个函数，而不需要再次通过动态链接器。如果程序再次调用这个函数，它会直接从 GOT 或 PLT 中获取函数的地址。</li></ol><p>运行时动态链接的优点包括：</p><ul><li><strong>主要优点</strong>:凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</li><li><strong>节省内存</strong>：因为多个程序可以共享同一个库的单个副本。</li><li><strong>模块化</strong>：程序可以在运行时加载和卸载模块，这使得程序更加灵活和可扩展。</li><li><strong>版本控制</strong>：可以在不重新编译程序的情况下更新库。</li></ul><p>运行时动态链接的缺点包括：</p><ul><li><strong>性能开销</strong>：动态链接和解析需要时间，尤其是在程序第一次调用库函数时。</li><li><strong>兼容性问题</strong>：如果库的新版本和旧版本不兼容，那么使用这个库的程序可能会出错。</li></ul></blockquote></li></ul></li></ol><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>连续分配指为用户程序分配一个连续的内存空间。<br>程序空间本来就是连续的,用连续的内存装入连续的程序，减少管理工作的难度<br>连续分配有三种方式：</p><ol><li><strong>单一连续分配方式</strong><br>单用户系统在一段时间内，只有一个进程在内存，故内存分配管理十分简单，内存利用率低。内存分为两个区域，一个供操作系统使用，一个供用户使用.</li><li><strong>分区式分配方式</strong><br>系统把内存用户区划分为若干分区，分区大小可以相等，也可以不等。一个进程占据一个分区。这是早期用于多道程序的一种较简单的存储管理方式。它又可以分为：<ul><li>固定分区</li><li>动态（可变）分区</li></ul></li><li><strong>可重定位分区分配</strong>(汤子瀛)</li></ol><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>内存中仅驻留一道用户程序，整个用户区为一个用户独占。<br>内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间。<br>最简单，适用于单用户、单任务的 OS。</p><ul><li>优点：易于管理。</li><li>缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存。<br>例如：DOS 2.0 以下的 DOS 操作系统采用单一连续区域主存管理方法。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-10-51-38.png"></li></ul><blockquote><p><strong>🌟 内存碎片</strong><br>内部碎片 Internal Fragment：分配给用户但用户没有使用的空间，即多分配的空间。分配给进程的内存空间比进程所需的内存空间大，但未使用的部分不能再分配给其他进程，造成内部碎片。<br>外部碎片 External Fragment：没有分配但无法分配的空间，即太小而无法分配的空间。相邻已分配内存空间的空闲区域太小，不能分配给需要的进程，造成外部碎片。</p></blockquote><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p><strong>固定分区分配思想</strong>：将内存用户空间划分为若干个固定大小的区域，每个区域称为一个分区（region），在每个分区中只装入一道作业 ，从而支持多道程序并发设计。<br>由于这些存储区域是在系统启动时划定的，在用户作业装入及运行过程中，其区域的大小和边界是不能改变的。<br>固定式分区的划分方法有两种：<br>(1)分区大小相等<br>(2)分区大小不等<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-10-54-48.png"><br>为了实现这种固定分区的分配，系统需要建立一张<strong>分区说明表</strong>。这个分区说明表指出可用于分配的分区数以及每个区的大小、起始地址及状态(是否已被分配)<br><strong>内存分配过程</strong><br>当有作业要装入内存时，内存分配程序检索分区说明表，从中找出一个尚未使用的满足大小要求的分区分配给该作业，然后修改分区的状态；如果找不到合适的分区就拒绝为该作业分配内存。</p><blockquote><p>内存中已分配给用户但未被利用的区域称为 “内零头”（内部碎片，内碎片）;固定分区分配有内零头产生</p></blockquote><ul><li>优点：易于实现，开销小</li><li>缺点：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目；存储空间的利用率太低。现在的操作系统几乎不用它了。</li></ul><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>动态分区分配是指根据进程的实际需要，动态地为之分配连续的内存空间。即分区的边界可以移动，分区的大小是可变的。<br>动态分区又有两种不同选择，一种是分区的<strong>数目固定大小可变</strong>，而另一种则允许分区的<strong>数目和大小都可变</strong>。 为了说明它们之间的重要差异，我们考虑一个具有 256K 字节存储器的系统。</p><p><strong>第一种方案</strong>(分区数目固定)：假定系统初始化时规定把存储空间划分为 8 个分区;在下图(a)中用问号(?)来表示它们。在系统运行一段时间后，已有 192K 存储空间分配给 7 个作业，剩下 64K 还未分配，如下图(b)所示。<br>现在，又有两个作业 P 和 Q 准备调入，它们每个需要 32K 存储空间。显然，我们有足够的存储空间。却没有足够数的存储区域(目前只有一个可用)。因此，只能允许一个作业(如 P)被调入，如下图(c)所示。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-11-20-19.png"><br><strong>第二种方案</strong>(分区数目可变)：最初，没有建立任何分区，整个可用的存储空间用一个问号来表示；之后，发生上述所说在系统运行一段时间后，已有 192K 存储空间分配给 7 个作业，剩下 64K 还未分配的情况，如图(b)；<br>现在，我们在剩下的 64K 存储空间中，可以创建两个分区，分别装入作业 P 和 Q，如图(c)。显然，此方案比第一个方案更灵活，内存利用率更高。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-11-21-13.png"></p><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p>实现动态分区分配，通常有两种数据结构：空闲分区表和空闲分区链。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-11-45-01.png"></p><p><strong>算法</strong></p><p>系统运行一段时间后，在整个存储空间内将出现许多大小不等的区域，有的仍被作业进程占用，有的则因作业已退出系统而成为可用于再分配的区域。现在假设有一个新的作业需调入主存，如何为其选择一个合适的区域？</p><ul><li><strong>基于顺序搜索</strong><ul><li>最佳适应算法(Best Fit)</li><li>最坏适应算法(Worst Fit)</li><li>首次适应算法(First Fit)</li><li>循环首次适应算法(Next Fit)</li></ul></li><li><strong>基于索引搜索</strong><ul><li>快速适应算法(Quick Fit)</li><li>伙伴系统</li></ul></li></ul><hr><h5 id="最佳适应算法-Best-fit-BF"><a href="#最佳适应算法-Best-fit-BF" class="headerlink" title="最佳适应算法 Best fit: BF"></a>最佳适应算法 Best fit: BF</h5><p>就是为一作业选择分区时总是寻找其大小最接近作业所要求的存储区域。即：把作业放入这样的分区后剩下的内部碎片最小。为了加快查找速度，应将存储空间中所有的空白区按其大小递增的顺序链接起来，组成一空白区链(Free List)。<br><strong>优点</strong>：</p><ul><li>如果存储空间中具有正好是所要求大小的存储空白区，则必然被选中；</li><li>如果不存在这样的空白区，也只对比要求稍大的空白区进行划分，而绝不会去划分一个更大的空白区。因此，其后遇到大作业到来时，作业要求的存储区域就比较容易得到满足。</li></ul><p><strong>缺点</strong>：</p><ul><li>采用最佳适应算法，在每次分配时，总是产生最小的空白区。因此，经过一段时期后，存储空间中可能留许多这样的空白区，由于其太小而无法使用。为了改善这种情况，在该算法中设置一参数 G，用它来确定最小分区的大小。当选择一个分区时，如果选中的空白区与要求的大小之差小于 G，则不再对它划分，而把整个这个空白区分配给申请的作业。</li><li>在回收一个分区时，为了把它插入到空白区链中合适的位置上也颇为费时。所以，这种算法乍看起来是最佳的，其实则不然。</li></ul><hr><h5 id="最坏适应算法-Worst-fit-WF"><a href="#最坏适应算法-Worst-fit-WF" class="headerlink" title="最坏适应算法 Worst fit: WF"></a>最坏适应算法 Worst fit: WF</h5><p>与最佳适应算法相反，它在为作业选择存储区域时，总是寻找最大的空白区。在划分后剩下的空白区也是最大的，因而对以后的分配很可能仍然是有用的，这是该算法的一个优点。但是，由于最大的空白块总是首先被分配而进行划分，当有大的作业时，其存储空间的申请往往得不到满足，这是该算法的一个缺点。<br>为了支持这个算法的实现，空白块应以大小递减的顺序链接起来。</p><hr><h5 id="首次适用算法-First-fit-FF"><a href="#首次适用算法-First-fit-FF" class="headerlink" title="首次适用算法 First fit: FF"></a>首次适用算法 First fit: FF</h5><p>BF 和 WF 各有其利弊。首次适应算法是对它们进行折衷考虑后设计出来的。<br>每个空白区按其在存储空间中地址递增的顺序链在一起，即每个后继空白区的起始地址总是比前者的大。在为作业分配存储区域时，从这个空白区链的始端开始查找，选择第一个足以满足请求的空白块，而不管它究竟有多大。<br>和上述算法一样，这个选择的空白区被分成两部分。一部分与请求的大小相等，分配给作业；剩下的部分留在空白区链中。显然，这个算法倾向于优先利用存储空间中低址部分的空白区。</p><p><strong>主要优点</strong><br>算法简单，查找速度快；留在高址部分的大的空白区被划分的机会较少，因而在大作业到来时也比较容易得到满足。<br><strong>主要缺点</strong>：<br>这种算法常常利用一个大的空白区适应小作业的请求，从而留下一些较小的无法用的空白区(外部碎片)，存储空间利用率不高；而且，由于所有的请求都是从空白区链的始端开始查找，因而这些小而无用的空白区集中在这个链的前端，相应地，一些较大空白区在链的尾端才能发现，这种情况将使找到合适空白区的速度降低。</p><hr><h5 id="下次-循环首次-适应算法-Next-fit-NF"><a href="#下次-循环首次-适应算法-Next-fit-NF" class="headerlink" title="下次(循环首次)适应算法 Next fit: NF"></a>下次(循环首次)适应算法 Next fit: NF</h5><p>为了克服上述缺点，又设计了一种称为“下次”适应的算法，它实际上是首次适应算法的一种变形，故也被称为<strong>带旋转指针的首次适应算法(Next Fit with Roving Pointer)</strong><br>为此，我们把存储空间中空白区构成一个循环链。每次为存储请求查找合适的分区时，总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将它划分后分配出去。显然，采用这一策略后，存储空间的利用更加均衡，而不至于使小的空白区集中于存储器的一端。但是，在存储器的另一端也不可能保留大的空白块，因此，当需要获得相当大的空白区时，能满足的可能性减少了。</p><hr><h5 id="快速适应算法-Quik-fit-QF"><a href="#快速适应算法-Quik-fit-QF" class="headerlink" title="快速适应算法 Quik fit:QF"></a>快速适应算法 Quik fit:QF</h5><p>将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。<br>这样，系统中存在多个空闲分区链表；<br>同时，在内存中设立一张管理分区类型，并记录了该类型空闲分区链表表头的索引表，该表的每一个表项记录了对应类型空闲分区链表表头的指针。<br>分配过程：根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可<br><strong>优点</strong></p><ul><li>查找效率高。</li><li>该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。</li></ul><p><strong>缺点</strong></p><ul><li>在分区归还主存时算法复杂，系统开销较大。</li><li>该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，</li></ul><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-17-11-39-39.png" style="zoom:100%;"><hr><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-17-11-39-20.png" style="zoom:100%;"><h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><p>涉及动态分区的主要操作有<strong>分配内存</strong>和<strong>回收内存</strong>。这些操作是在程序接口中通过系统调用发出的。</p><ol><li><p><strong>分配内存</strong>：<br>向操作系统提出一特定存储量的请求。通常，它并不要求这个分配的存储区域限于特定的位置，但是，这个区域必须是连续的。OS 利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。</p><ul><li>请求的分区大小为 u.size</li><li>表中每个空闲分区的大小为 m.size</li><li>size 是事先规定的不再切割的剩余分区的大小<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-17-11-47-18.png" style="zoom:100%;"></li></ul></li><li><p><strong>回收内存</strong><br>进程用于归还一个不再需用的存储区域。</p><ul><li>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链(表)中找到相应的插入点。</li><li>在回收一个分区时，一个回收的分区与空白区邻接的情况有四种，对这四种情况分别作如下处理：<ul><li>回收区与插入点的前一个空闲分区 F1 相邻接。此时应将回收区与插入点的前一分区合并(通过修改其前一分区 F1 的大小，不必为回收区分配新表现)</li><li>回收区仅与下面的空白区邻接，合并后仍为空白区 F2，但其起始地址和大小均需改变。用回收区的首址作为新空闲区的首址，大小为两者之和</li><li>回收区与上、下面的空白区邻接此时将三个分区合并，使用 F1 的表项和 F1 的首址，取消 F2 的表项，大小为三者之和。</li><li>回收区与上、下面的空白区均不邻接，在这种情况下，应为回收区单独建立一新表项，填写回收区的首址和大小，并根据首地址插入到空闲链中的适当位置。</li></ul></li></ul></li></ol><h3 id="伙伴系统-Buddy-System"><a href="#伙伴系统-Buddy-System" class="headerlink" title="伙伴系统 Buddy System"></a>伙伴系统 Buddy System</h3><p>固定分区和动态分区都存在内部碎片和外部碎片的问题。伙伴系统是一种解决内部碎片问题的方法。</p><p>在伙伴系统中，可用内存块的大小为$2^k (1\le k\le m)$<br>其中$2^1$表示分配的最小块尺寸，$2^m$表示分配的最大块尺寸，通常是可供分配的整个内存空间大小。<br>对空闲区按照大小分类，相同大小的分区链接为一个双向空闲链表；最多可形成 k 个链表。</p><p>进程请求大小为 n 的存储空间：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-18-21-01-37.png" style="zoom:100%;"></p><ol><li>找到 i，使得$2^{i-1}\lq n &lt; 2^i$</li><li>在空闲分区大小为$2^i$的链表中查找，若找到，则分配；</li><li>如果没找到，从$2^{i+1}$的链表中查找，找到后，将其分裂为两个大小相等的伙伴，其中一个分配给进程，另一个插入到$2^i$相应的链表中。</li><li>如果仍然没找到，则继续查找更大的链表，直到找到或者查找完所有链表。</li></ol><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-18-21-02-46.png" style="zoom:100%;">> 分割及回收合并分区需要时间开销，多用于多处理机系统中。<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>利用哈希快速查找的优点，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一张哈希表，以空闲分区大小为关键字，每一个表项记录了一个对应的空闲分区链表表头指针。<br>当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p><h4 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h4><h5 id="紧凑-Compaction"><a href="#紧凑-Compaction" class="headerlink" title="紧凑 Compaction"></a>紧凑 Compaction</h5><p>可变式分区分配策略是在装入作业时根据其要求量为其划定相应的区域。这种分配策略，消除了固定式分区分配造成的“内零头”，但不可避免地在存储空间中造成“外零头”，为了进一步提高存储器的利用率，必须设法减少由于外零头造成的浪费。</p><p>一个最简单而直观的解决零头问题的办法是，定时地或者在内存紧张时，把存储空间中的空白区合并为一个大的连续区。<br>实现方法将内存中的所有作业进行移动，使它们全都相邻接，这样，可把原来分散的多个小分区合成一个大分区。这种技术称为存储器的<strong>紧凑</strong>Compaction。<br>把一个作业从一个存储区域移动到另一个存储区域，需要对作业中的某些地址部分和地址常数等进行调整。一个较实用且可行的办法是采用动态重定位技术。一个作业在主存中移动后，只要改变重定位寄存器中的内容即可。</p><hr><h5 id="动态重定位-Dynamic-Relocation"><a href="#动态重定位-Dynamic-Relocation" class="headerlink" title="动态重定位 Dynamic Relocation"></a>动态重定位 Dynamic Relocation</h5><p>在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。<br>程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-18-21-09-58.png" style="zoom:100%;"></p>]]></content>
    
    
    <summary type="html">介绍存储管理第一部分。包括存储器的层次结构、程序的装入和链接、连续分配存储管理方式三大部分。</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Storage Management Part Ⅱ</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch4-2StorageManagement/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch4-2StorageManagement/</id>
    <published>2024-04-18T13:13:40.000Z</published>
    <updated>2024-04-27T11:23:40.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><h3 id="离散方式的引入"><a href="#离散方式的引入" class="headerlink" title="离散方式的引入"></a>离散方式的引入</h3><p>连续分配方式会产生内&#x2F;外零头,为解决零头问题又要进行紧凑等高开销活动。由此引入<strong>离散分配</strong>方式(程序在内存中不一定连续存放)</p><p>根据离散时的基本单位不同，可分为三种：</p><ul><li>分页存储管理</li><li>分段存储管理</li><li>段页式存储管理</li></ul><ol><li>离散的基础<br>分页(Pages)：将程序地址空间分页<br>分块(Frames)：将内存空间分块</li><li>离散分配的体现<br>内存一块可以装入程序一页<br>连续的多个页不一定装入连续的多个块中<br>注：系统中页块的大小是不变的。</li><li>离散分配的优点<br>没有外零头。不受连续空间限制，每块都能分出去<br>仅有小于一个页面的内零头。程序大小一般不是页大小的整数倍，进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”或称为“内零头”。</li></ol><h3 id="页面与物理块"><a href="#页面与物理块" class="headerlink" title="页面与物理块"></a>页面与物理块</h3><p>页面或页(Page)：把每个进程的逻辑地址空间分成一些大小相等的片。<br>物理块或页框(Page Frame)：内存空间也分成与页相同大小的若干存储块。在为进程分配存储空间时，总是以页框为单位。<br>例如：一个作业的地址空间有 m 页。那么，只要分配给它 m 个页框，每一页分别装入一个页框内即可。这里，并不要求这些页框是连续的。<br>说明：<br>⑴ 从 0 开始编制页号，页内地址是相对于 0 编址；<br>⑵ 在进程调度时，必须把它的所有页一次装入到主存的页框内；如果当时页框数不足，则该进程必须等待，系统再调度另外的进程。（纯分页方式）</p><h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><h2 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h2><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2>]]></content>
    
    
    <summary type="html">介绍存储管理第二部分</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>运输层 TransportLayer Part Ⅰ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-1TransportLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-1TransportLayer/</id>
    <published>2024-04-17T03:34:02.000Z</published>
    <updated>2024-04-27T11:23:40.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction-and-Transport-Layer-Services"><a href="#Introduction-and-Transport-Layer-Services" class="headerlink" title="Introduction and Transport-Layer Services"></a>Introduction and Transport-Layer Services</h2><h3 id="Relationship-Between-Transport-and-Network-Layers"><a href="#Relationship-Between-Transport-and-Network-Layers" class="headerlink" title="Relationship Between Transport and Network Layers"></a>Relationship Between Transport and Network Layers</h3><p>运输层协议为运行在不同的主机上的应用进程之间提供了<strong>逻辑通信（logic communication）</strong>功能<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-14-43-16.png" style="zoom:50%;" /><br>传输层协议运行在端系统而非路由器</p><ul><li>发送方: 将从发送应用程序接收到的报文转换成传输层分组(segment)传递给网络层</li><li>接受方: 将数据段重新组装成报文传递到应用层</li></ul><p>传输层: <strong>进程之间</strong>的逻辑通信;传输层建立在网络层之上，负责端到端的通信会话和数据的可靠传输。传输层使用端口号来区分主机上的不同应用程序，并确保数据被正确地发送到接收应用程序。<br>网络层: <strong>主机之间</strong>的逻辑通信; 网络层负责处理数据包的发送和路由，包括 IP 地址处理和路由选择。网络层的主要目标是确定如何将数据从源主机传输到目标主机，即使这两台主机在物理上可能相隔很远，并且在它们之间可能存在多个中间节点（路由器）。网络层的一个关键协议是互联网协议（IP），它定义了数据包的格式和地址。</p><h3 id="Overview-of-the-Transport-Layer-in-the-Internet"><a href="#Overview-of-the-Transport-Layer-in-the-Internet" class="headerlink" title="Overview of the Transport Layer in the Internet"></a>Overview of the Transport Layer in the Internet</h3><p>Internet 的传输层协议有两个:<br><strong>传输控制协议 TCP,Transmission COntrol Protocol</strong>: 提供了一种可靠的、面向连接的服务。<br><strong>用户数据报协议 UDP,User Datagram Protocol</strong>:提供不可靠、无连接的服务</p><blockquote><p>网络层的 IP 协议(Internet Protocol)提供了一种不可靠的、无连接的服务;IP 的服务模型是尽力而为交付服务（best-effort delivery service）</p></blockquote><p>UDP 和 TCP 最基本的责任是，将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>。</p><h2 id="Multiplexing-and-Demultiplexing"><a href="#Multiplexing-and-Demultiplexing" class="headerlink" title="Multiplexing and Demultiplexing"></a>Multiplexing and Demultiplexing</h2><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-15-57-37.png" style="zoom:50%;" /><p>运输层的多路复用与多路分解，也就是将由网络层提供的主机到主机的交付服务延伸到为运行在主机上的应用程序提供进程到进程的服务。一个进程（作为网络应用的一部分）有一个或多个<strong>套接字（socket）</strong>，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。下图为进程交付过程：</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-15-48-45.png"></p><ul><li><strong>多路复用</strong>（Multiplexing）：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文传递到网络层；</li><li><strong>多路分解</strong>（Demultiplexing）：在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字，即将运输层报文段的数据交付到正确的套接字的工作；</li></ul><hr><p>主机收到 IP 数据报(IP Datagram),每个 IP 数据报中有源 IP 地址和目的 IP 地址,每个数据报搬运一个数据段,数据段中有源端口号和目的端口号,这样就可以将数据段交付给正确的 Socket。</p><ol><li>套接字由唯一标识符；</li><li>每个报文段通过<strong>源端口号字段</strong>（source port number field）和<strong>目的端口号字段</strong>（destination port number field）来指示该报文段所要交付的套接字；<blockquote><p>端口号是一个 16 比特的数，其大小在 <code>0~65535</code>之间。<code>0~1023</code>范围的端口号称为<strong>周知端口号（well-know port number）</strong>，是受限制的。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-16-00-52.png" alt="Ch5-1TransportLayer-2024-04-02-16-00-52"></p></blockquote></li></ol><ul><li><strong>UDP 的 Socket 表示</strong><br><code>(source port， dest port)</code><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-10-08-58-17.png" style="zoom:50%;" /></li><li><strong>TCP 的 Socket 表示</strong><br><code>(source IP， source port， dest IP， dest port)</code><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-10-08-58-22.png" style="zoom:50%;" /></li></ul><h2 id="Connectionless-Transport-UDP"><a href="#Connectionless-Transport-UDP" class="headerlink" title="Connectionless Transport: UDP"></a>Connectionless Transport: UDP</h2><h3 id="UDP-Segment-Structure"><a href="#UDP-Segment-Structure" class="headerlink" title="UDP Segment Structure"></a>UDP Segment Structure</h3><p>使用 UDP 时，在发送报文段之前，发送方和接收方的运送层实体之间没有握手，UDP 被称为<strong>无连接的 connectionless</strong>;UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p><ul><li>是无连接的，即发送数据之前不需要建立连接(no connection establishment)</li><li>简单: 在发送者接受者之间不需要连接状态(no connection state)</li><li>没有拥塞控制，很适合多媒体通信的要求,UDP 能够用尽可能快的速度传递(no congestion control)</li><li>UDP 的首部开销小，只有 8 个字节(small header size)</li><li>支持一对一、一对多、多对一和多对多的交互通信</li></ul><p>UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。<br>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。<br>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。<br>应用程序必须选择合适大小的报文。<br>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</p><blockquote><p>UDP 首部有 8 个字节，由 4 个字段构成，每个字段都是两个字节： 1.源端口： 源端口号，需要对方回信时选用，不需要时全部置 0. 2.目的端口：目的端口号，在终点交付报文的时候需要用到。 3.长度：UDP 的数据报的长度（包括首部和数据）其最小值为 8（只有首部） 4.校验和：检测 UDP 数据报在传输中是否有错，有错则丢弃,该字段是可选的，当源主机不想计算校验和，则直接令该字段全为 0.<br>当传输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给应用进程。<br>如果接收方 UDP 发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程），就丢弃该报文，并由 ICMP 发送“端口不可达”差错报文给对方。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-10-10-19-15.png"></p><p>伪首部中 17 是协议代号，表示 UDP<br><strong>伪首部的作用</strong><br>第一，通过伪首部的 IP 地址检验，UDP 可以确认该数据报是不是发送给本机 IP 地址的；第二，通过伪首部的协议字段检验，UDP 可以确认 IP 有没有把不应该传给 UDP 而应该传给别的高层的数据报传给了 UDP。</p><p>伪首部包括了 IPv4 头部中的一些信息，但它并不是发送 IP 数据包时使用的 IP 数据包的头部。接收主机在收到 UDP 报文以后，<strong>从 IP 首部获悉 IP 地址信息构造 UDP 伪首部</strong>。在进行校验和计算。<br>识别一个通信应用需要 5 个因素。”源 IP 地址”、”目标 IP 地址”、”源端口”、”目标端口”、”协议号”。UDP 首部只包含了（源端口和目标端口），用此来校验，如果其他三项信息被破坏，极有可能导致应收包应用收不到，不应该收包的应用收到。<br>为此，有必要在通信中，验证这 5 项的识别码是否正确，就引入了伪首部的概念。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-11-09-54-10.png"></p><h3 id="UDP-Checksum"><a href="#UDP-Checksum" class="headerlink" title="UDP Checksum"></a>UDP Checksum</h3><p><a href="https://zhuanlan.zhihu.com/p/184884139">UDP&#x2F;IP 硬件协议栈设计（三）：校验</a></p><p><strong>Sender</strong>:<br>将数据段看成 16bit 的整数序列<br>校验和: 数据段内容相加 (1 的补码和，即反码)<br>发送者将校验和值放入 UDP 的校验和域<br><strong>Receiver</strong><br>计算接收到数据段的校验和<br>检查 计算的校验和是否等于校验和域中的值:<br>NO – 检测到错误<br>YES – 没有检测到错误,但是可能是错误的</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-15-56-24.png"></p><h2 id="Principles-of-Reliable-Data-Transfer"><a href="#Principles-of-Reliable-Data-Transfer" class="headerlink" title="Principles of Reliable Data Transfer"></a>Principles of Reliable Data Transfer</h2><p>[<a href="Ch3-1DataLinkLayer.md" title="数据链路层 Datalink Layer Ⅰ">Ch3-1DataLinkLayer#可靠传输 Reliable Transmission</a>]</p><p>可靠数据传输的框架：为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-16-19-54.png"></p><blockquote><p>rdt: reliable data transfer</p></blockquote><h3 id="Building-a-Reliable-Data-Transfer-Protocol"><a href="#Building-a-Reliable-Data-Transfer-Protocol" class="headerlink" title="Building a Reliable Data Transfer Protocol"></a>Building a Reliable Data Transfer Protocol</h3><h4 id="Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt1-0"><a href="#Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt1-0" class="headerlink" title="Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0"></a>Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0</h4><p>发送方和接收方的表示使用<strong>有限状态机（Finite-State Machine，FSM）</strong>定义，如果对一个事件没有动作，我们将在横线上方或下方使用<strong>符号$\Lambda$<strong>，以表示发生这个事件后不进行处理。<br>我们考虑最简单的情况，</strong>即底层信道是完全可靠的</strong>，我们称该协议为 <code>rdt1.0</code>，发送方和接收方的 FSM 定义如下：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-16-37-28.png" alt="rdt1.0 FSM"></p><h4 id="Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt2-0"><a href="#Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt2-0" class="headerlink" title="Reliable Data Transfer over a Channel with Bit Errors: rdt2.0"></a>Reliable Data Transfer over a Channel with Bit Errors: rdt2.0</h4><blockquote><p><strong>下层信道可能让传输分组中的 bit 受损</strong></p><ul><li>校验和将检测到 bit 错误</li></ul><p><strong>问题: 如何从错误中恢复</strong></p><ul><li>确认(ACKs): 接收方明确告诉发送方 分组接收正确</li><li>否认 (NAKs):接收方明确告诉发送方 分组接收出错</li><li>发送方收到 NAK 后重发这个分组</li></ul><p><strong>在 rdt2.0 中的新机制 (在 rdt1.0 中没有的):</strong></p><ul><li>差错检测</li><li>接收方反馈: 控制信息 (ACK,NAK) rcvr-&gt;sender</li></ul></blockquote><p>实际上的底层信道是可能出现比特受损的；在分组传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中。在接收方得到比特差错的信息时，需要发送方进行重传。在计算机网络环境中，基于这种重传机制的可靠数据传输协议称为<strong>自动重传请求（Automatic Repeat reQuest，ARQ）协议</strong>。ARQ 协议中还需要另外三种协议来处理存在比特差错的情况：</p><ul><li><strong>Error Detection</strong>：发送方同时发送检测和（checksum）到接收端判断是否出现比特差错；</li><li><strong>Receiver feedback</strong>：<ul><li><strong>肯定确认（ACKnowledgement，ACK）</strong>：接收方告诉发送方包数据无差错；</li><li><strong>否定确认（Negative AcKnowledgement，NAK）</strong>：接收方告诉发送方包数据有错误；</li></ul></li><li><strong>Retransmission</strong>：接收方收到有差错的分组时，发送方将重传该分组文；</li></ul><blockquote><p>rdt2.0 中，当发送方为<code>Wait for ACK or NAK</code>状态时，它不能再接收上层传来的数据，即<code>rdt_send()</code>事件不能再出现；直到接收到 ACK 并离开该状态，才能再次接收上层传来的数据。因此，rdt2.0 也被称为<strong>停等协议（stop-and-wait protocol）</strong>。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-17-03-03.png" alt="rdt2.0 FSM" style="zoom:50%;" /></p></blockquote><p><code>rdt2.0</code>协议存在致命的缺陷，它并没有考虑 ACK 和 NAK 受损的情况,一个困难的问题是协议该如何 从错误中恢复。<br>为了解决这一问题，就是在数据分组中添加一新字段，让发送方对其数据分组编号(编号占用 1bit，为 0&#x2F;1)，即将发送数据分组的<strong>序号（sequence number）</strong>放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否一次重传。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-18-55-34.png" alt="rdt2.1 FSM"></p><p>rdt2.2: 一个不要 NAK 的协议;同 rdt2.1 一样的功能, 只用 ACKs 不用 NAK。如果上个报文接收正确接收方发送 ACK;接收方必须明确包含被确认的报文的序号；如果接受到受损的数据，那就发送一个 ACK，序号为最后一个正确的数据包的序号。发送方收到重复 ACK(duplicate ACK)等同于收到 NAK,将重发当前报文<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-17-09-18-24.png"></p><h4 id="Reliable-Data-Transfer-over-a-Lossy-Channel-with-Bit-Errors-rdt3-0"><a href="#Reliable-Data-Transfer-over-a-Lossy-Channel-with-Bit-Errors-rdt3-0" class="headerlink" title="Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0"></a>Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0</h4><p>新假设: 下层信道还要丢失报文 (数据或者 ACKs);校验和, 序号, 确认, 重发将会有帮助，但是不够<br>引入<strong>倒计数定时器（countdown timer）</strong>，实现基于时间的重传机制；只有在定时器超时时才触发重发</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-17-09-39-00.png" style="zoom:50%;"><p>因为分组序号在 0 和 1 之间交替，因此 <code>rdt3.0</code>也被称为<strong>比特交替协议（alternating-bit protocol）</strong>。运行如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-17-09-43-49.png" style="zoom:100%;"><h3 id="Pipelined-Reliable-Data-Transfer-Protocols"><a href="#Pipelined-Reliable-Data-Transfer-Protocols" class="headerlink" title="Pipelined Reliable Data Transfer Protocols"></a>Pipelined Reliable Data Transfer Protocols</h3><p>sender信道利用率$U_{sender}&#x3D;\frac{L&#x2F;R}{RTT+L&#x2F;R}$</p><p>Stop-and-Wait方式发送方信道利用率很低，解决方案是<strong>流水线化（pipelining）</strong>，即发送方可以发送多个分组，而不需要等待接收方的确认。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-17-10-03-56.png" style="zoom:100%;"><h3 id="GBN-SR"><a href="#GBN-SR" class="headerlink" title="GBN &amp; SR"></a>GBN &amp; SR</h3><p><strong>Ref</strong><br>[<a href="Ch3-1DataLinkLayer.md" title="数据链路层 Datalink Layer Ⅰ">Ch3-1DataLinkLayer#回退 N 帧协议 Go-Back-N Protocol</a>]<br>[<a href="Ch3-1DataLinkLayer.md" title="数据链路层 Datalink Layer Ⅰ">Ch3-1DataLinkLayer#选择重传协议 Selective Repeat Protocol</a>]</p>]]></content>
    
    
    <summary type="html">Transport Layer Part Ⅰ</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>数据库管理</title>
    <link href="https://efterklang.github.io/Tech/DataBase/Ch5-DbManagement/"/>
    <id>https://efterklang.github.io/Tech/DataBase/Ch5-DbManagement/</id>
    <published>2024-04-11T03:35:50.000Z</published>
    <updated>2024-04-27T11:23:40.797Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h2><p>数据库管理(Database Management)是指为保证数据库系统的正常运行和服务质量必须进行的系统管理工作。</p><p><strong>为什么需要数据库管理</strong></p><ul><li>数据库系统随规模增大,系统会变得异常复杂</li><li>多用户数据库应用带来数据库访问复杂性</li><li>数据安全和数据隐私对机构和用户都非常重要</li><li>数据库系统随数据量增加和使用时间增长其性能会降低系统遭遇意外事件，数据库损坏或数据丢失</li></ul><p><strong>数据库管理目标</strong></p><ul><li>保障数据库系统正常稳定运行</li><li>充分发挥数据库系统的软硬件处理能力</li><li>确保数据库系统安全和用户数据隐私性</li><li>有效管理数据库用户及其角色权限</li><li>解决数据库系统性能优化、系统故障与数据损坏等问题</li><li>最大程度地发挥数据库对其所属机构的作用</li></ul><p><strong>DBMS 功能</strong></p><ul><li>数据库定义<ul><li>数据库结构创建，结构修改，完整性约束定义，索引结构定义</li></ul></li><li>数据库运行管理<ul><li>系统启停控制，并发控制，事务管理，安全性控制，完整性控制，日志管理，性能监控</li></ul></li><li>数据库组织与存储<ul><li>缓冲区管理，数据组织，数据存取</li></ul></li><li>数据库维护<ul><li>数据载入，数据转换，数据库备份＆恢复，数据库重构，性能优化</li></ul></li><li>数据库通信<ul><li>数据的同步、复制、传输</li></ul></li></ul><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p><strong>为什么需要事务管理</strong></p><p>在数据库应用系统中，完成一个业务处理通常需要多个操作步骤才能完成处理。在每个操作步骤中，都可能遭遇失败，若没有一个处理机制，就可能造成操作数据混乱，从而破坏数据一致性。</p><p><strong>事务的概念</strong><br>[<a href="DataBase03.md" title="DataBase Base 多表查询&amp;事务">DataBase03#事务 Transaction</a>]<br>在数据库中，事务（Transaction）是指由构成单个业务处理单元的一组数据库访问操作，要求它们要么都成功执行，要么都不执行。</p><ul><li>最小的 DBMS 执行任务单元</li><li>最小的故障恢复任务单元</li><li>最小的并发控制任务单元</li></ul><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><ul><li><strong>原子性</strong>（Atomicity）：事务中的所有操作要么全部完成，要么全部不完成。如果事务中的某个操作失败，那么整个事务将被回滚，数据库状态不会改变。</li><li><strong>一致性</strong>（Consistency）：事务确保数据库从一个一致的状态转换到另一个一致的状态。事务开始和结束时，所有的业务规则都必须保持一致。</li><li><strong>隔离性</strong>（Isolation）：每个事务都在一个独立的工作区中执行，事务之间不会互相影响。这意味着并发事务的修改必须被隔离，直到事务提交，其他事务才能看到这些修改。</li><li><strong>持久性</strong>（Durability）：一旦事务被提交，它对数据库的更改就是永久性的。即使发生系统故障，更改也不会丢失。<blockquote><p>事务并发执行是指多个事务程序在数据库系统中同一时段运行，从而改善系统的资源利用率、减少事务运行的平均等待时间</p></blockquote></li></ul><p>事务 SQL 程序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>  或 <span class="keyword">START</span> TRANSACTION ；<span class="comment">--事务开始语句</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>； <span class="comment">--事务回滚语句</span></span><br><span class="line"><span class="keyword">COMMIT</span>；<span class="comment">--事务提交语句</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span>；<span class="comment">--事务保存点语句</span></span><br></pre></td></tr></table></figure><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p><strong>为什么需要并发控制</strong>？</p><p>当多个事务程序在 DBMS 系统中同时运行时，可能会出现对一些共享数据同时进行访问操作，如一些事务修改数据，另一些事务读取数据。这些并发的共享数据操作，如果在 DBMS 中没有一定的约束控制情况下，可能会带来数据不一致性或事务程序死锁问题。因此，在多个事务并发运行时.必须进行并发控制处理</p><p><strong>并发控制目的</strong></p><ul><li>支持并发事务处理，使更多用户并行操作，提高系统的并发访问能力。</li><li>保证一个事务工作不会对另一个事务工作产生不合理的影响。</li></ul><h3 id="并发控制需解决的问题"><a href="#并发控制需解决的问题" class="headerlink" title="并发控制需解决的问题"></a>并发控制需解决的问题</h3><ul><li><p><strong>丢失更新lost update</strong><br>两个事务同时读取同一数据，其中一个事务修改数据后，另一个事务也修改了同一数据，导致其中一个事务的修改被覆盖。</p></li><li><p><strong>脏读dirty read</strong><br>事务 T1 更新了数据，但没有 Commit,T2 读取了 T1 更新的数据，但 T1 通过 ROLLBACK 撤销事务，即 T2 读取到脏数据。</p></li><li><p><strong>不可重复读nonrepeatable read</strong><br>事务T1读取a，T2修改a并提交，T1再次读取a，发现a的值发生了变化。即一个事务的两次读取相同的资源但得到不同的值</p></li><li><p><strong>幻读phantom read</strong><br>A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</p></li><li><p><strong>serialization anomaly</strong><br>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</p></li></ul><h3 id="加锁协议"><a href="#加锁协议" class="headerlink" title="加锁协议"></a>加锁协议</h3><p><strong>一级加锁协议</strong>：任何事务在修改共享数据对象之前，必须对该数据执行排它锁定指令，直到该事务处理完成，才进行解锁指令执行。<br>特点：使用一级加锁协议，可避免出现<strong>更新丢失</strong>问题。但不能解决“不可重复读取”、“脏读”等数据不一致问题<br><strong>二级加锁协议</strong>：在一级加锁协议基础上，针对并发事务的共享数据读操作，必须对该数据执行共享锁定指令，读完数据后即刻释放共享锁定。<br>特点：该加锁协议不但可以防止<strong>丢失更新,脏读</strong>问题。但有可能会出现“不可重复读取”的数据不一致问题。<br><strong>三级加锁协议</strong>：在一级加锁协议基础上，针对并发事务对共享数据进行读操作，必须对该数据执行共享锁定指令，直到该事务处理结束才释放共享锁定。<br>特点：该加锁协议可以防止<strong>丢失更新、脏读、不可重复读取</strong></p><p>两阶段锁定协议<br>并发事务的正确调度准则：<br>一个给定的并发事务调度，当且仅当它是可串行化时，才能保证正确调度。<br>保证可串行化的一个协议是：二阶段锁定协议<br>二阶段锁定协议规定每个事务必须分两个阶段提出加锁和解锁申请:<br>增长阶段，事务只能获得锁，但不能释放锁。<br>缩减阶段，事务只能释放锁，但不能获得新锁。</p><p>结论:若并发事务执行的所有事务都遵从两阶段锁定协议，则这些事务的任何并发调度都是可串行化调度，即这些并发调度执行结果可以保证数据库一致性。</p><h2 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h2><p>数据库备份——是指将数据库当前数据和状态进行副本复制，以便当数据库受到破坏或丢失数据时可以进行修复。<br>数据库恢复——是指数据库中数据丢失或被破坏时，从备份副本将数据库从错误状态恢复到某一正确状态。</p><p>备份方法：<br>完全数据库备份<br>差异数据库备份<br>事务日志备份<br>文件备份</p><p><strong>备份方式</strong></p><ul><li><p>热备份 Hot Backup，也被称为在线备份，是在数据库仍在运行和处理事务的同时进行的备份。这种备份方式的主要优点是它不会中断数据库服务，但可能会稍微影响数据库的性能。</p></li><li><p>冷备份 Cold Backup：也被称为离线备份，是在数据库完全关闭的情况下进行的备份。这种备份方式可以确保备份的数据一致性，但在备份期间，数据库无法提供服务。</p></li></ul><p>备份时机:当系统数据库重要数据被修改、日志被清理、用户数据库创建、用户数据库加载等事件出现时。</p><p>数据库备份实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--实例操作： 备份SAMPLE数据库到一个G磁盘的根目录文件Sample.bak中。</span></span><br><span class="line">BACKUP DATABASE SAMPLE</span><br><span class="line"><span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;G:\Sample.bak&#x27;</span>; <span class="comment">--实例操作： 从存储备份文件中恢复SAMPLE数据库。</span></span><br><span class="line">RESTORE DATABASE SAMPLE</span><br><span class="line"><span class="keyword">FROM</span> DISK <span class="operator">=</span> ‘G:\Sample.bak<span class="string">&#x27;;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UESTC数据库系统原理与开发，Chapter5 - Database Management;涉及数据库管理、事务管理、数据库备份与恢复等内容</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="DataBase" scheme="https://efterklang.github.io/categories/Tech/DataBase/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>ARM伪指令</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch4-1/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch4-1/</id>
    <published>2024-04-07T11:28:39.000Z</published>
    <updated>2024-04-27T11:23:40.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="伪指令概述"><a href="#伪指令概述" class="headerlink" title="伪指令概述"></a>伪指令概述</h2><p><strong>伪指令</strong>:人们设计了一些专门用于指导汇编器进行汇编工作的指令，由于这些指令不形成机器码指令，它们只是在汇编器进行汇编工作的过程中起作用，所以被叫做伪指令<br>伪指令具有的两个特征:伪指令是一条指令；伪指令没有指令代码。</p><p><strong>伪指令的作用</strong></p><ul><li>程序定位的作用；</li><li>为非指令代码进行定义；</li><li>为程序完整性做标注；</li><li>有条件的引导程序段。</li></ul><p>在 ARM 汇编程序语言中，有如下几种伪指令：</p><ul><li>符号定义（Symbol Definition）伪指令</li><li>数据定义（Data Definition）伪指令</li><li>汇编控制（Assembly Control）伪指令</li><li>其它（Miscellaneous）伪指令</li></ul><h2 id="通用伪指令"><a href="#通用伪指令" class="headerlink" title="通用伪指令"></a>通用伪指令</h2><h2 id="与-ARM-指令相关的宏指令"><a href="#与-ARM-指令相关的宏指令" class="headerlink" title="与 ARM 指令相关的宏指令"></a>与 ARM 指令相关的宏指令</h2><h2 id="ARM-工程"><a href="#ARM-工程" class="headerlink" title="ARM 工程"></a>ARM 工程</h2><h2 id="ARM-程序框架"><a href="#ARM-程序框架" class="headerlink" title="ARM 程序框架"></a>ARM 程序框架</h2><h2 id="ARM-汇编语言程序设计"><a href="#ARM-汇编语言程序设计" class="headerlink" title="ARM 汇编语言程序设计"></a>ARM 汇编语言程序设计</h2><h2 id="C-C-语言和汇编语言的混合编程。"><a href="#C-C-语言和汇编语言的混合编程。" class="headerlink" title="C&#x2F;C++语言和汇编语言的混合编程。"></a>C&#x2F;C++语言和汇编语言的混合编程。</h2>]]></content>
    
    
    <summary type="html">temp</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM-Processor" scheme="https://efterklang.github.io/categories/UESTC/ARM-Processor/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>数据库设计与实现</title>
    <link href="https://efterklang.github.io/Tech/DataBase/Ch4-DbDesign/"/>
    <id>https://efterklang.github.io/Tech/DataBase/Ch4-DbDesign/</id>
    <published>2024-04-06T08:06:27.000Z</published>
    <updated>2024-04-27T11:23:40.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据集设计方案"><a href="#数据集设计方案" class="headerlink" title="数据集设计方案"></a>数据集设计方案</h2><p>包括:</p><ol><li><strong>数据库应用架构设计</strong><ul><li>在不同应用需求场景中，数据库的应用架构方式是不同的。数据库应用架构可分为<strong>单用户结构、集中式结构、客户／服务器结构和分布式结构</strong></li></ul></li><li><strong>数据库结构模型设计</strong><ul><li>数据库结构模型设计一般分为概念层、逻辑层、物理层设计，它们的设计模型分别为<strong>概念数据模型 CDM、逻辑数据模型 LDM 和物理数据模型 PDM</strong></li></ul></li><li><strong>数据库应用访问方式设计</strong><ul><li>数据库应用对数据库访问可以有多种方式，如<strong>直接本地接口连接访问</strong>、<strong>基于标准接口连接访问</strong>、<strong>基于数据访问层框架连接访问</strong></li></ul></li></ol><h2 id="数据库结构模型"><a href="#数据库结构模型" class="headerlink" title="数据库结构模型"></a>数据库结构模型</h2><ul><li><strong>概念数据模型</strong>（Concept Data Model，CDM）是一种面向用户的系统数据模型，它用来描述现实世界的系统概念化数据结构。使数据库设计人员在系统设计的初始阶段，摆脱计算机系统及 DBMS 的具体技术问题，集中精力分析业务数据以及数据之间的联系等，描述系统的数据对象及其组成关系。</li><li><strong>逻辑数据模型</strong> (Logic Data Model，LDM)是在概念数据模型基础上，从系统设计角度描述系统的数据对象组成及其关联结构，并考虑这些数据对象符合数据库对象的逻辑表示。</li><li><strong>物理数据模型</strong>（Physical Data Model，PDM）是在逻辑数据模型基础上，针对具体 DBMS 所设计的数据模型。它用于描述系统数据模型在具体 DBMS 中的数据对象组织、存储方式、索引方式、访问路径等实现信息。</li></ul><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-17-30-46.png" alt="数据库开发过程"></p></center><ol><li><strong>数据需求分析阶段</strong>:从现实业务中获取数据表单、报表、查询、业务规则、数据更新的说明;分析系统的数据特征、数据类型、数据取值约束;描述系统的数据关系、数据处理要求;建立系统的数据字典</li><li><strong>数据库设计阶段</strong>:数据库内部结构设计（概念数据模型、逻辑数据模型、物理数据模型）;数据库索引、视图、查询设计;数据库表约束设计;数据库触发器、存储过程设计;文件组织方式</li><li><strong>数据库实现阶段</strong>:数据库创建;数据模型的 SQL 程序创建、数据库对象物理实现</li><li><strong>数据库测试阶段</strong>:数据库数据上线;数据库系统测试<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>CDM</td><td>从用户角度所建模的系统数据对象及其关系，它帮助用户分析信息系统的数据结构关系</td></tr><tr><td>LDM</td><td>从系统分析员角度所建模的系统数据对象逻辑结构关系，它帮助开发人员分析信息系统的逻辑数据结构</td></tr><tr><td>PDM</td><td>从系统设计人员角度所建模的系统数据物理存储及结构关系，它针对设计者具体定义信息系统的数据库表结构</td></tr></tbody></table></li></ol><h2 id="E-R-模型方法"><a href="#E-R-模型方法" class="headerlink" title="E-R 模型方法"></a>E-R 模型方法</h2><h3 id="E-R-模型基本元素"><a href="#E-R-模型基本元素" class="headerlink" title="E-R 模型基本元素"></a>E-R 模型基本元素</h3><p><strong>E-R 模型</strong>是“实体-联系模型”（Entity-Relationship Model）的简称。它是一种描述现实世界概念数据模型、逻辑数据模型的有效方法。</p><p>在 E-R 模型中，基本元素包括实体、属性、标识符和联系:</p><ul><li><strong>实体</strong>Entity 是指问题域中存在的人、事、物、地点等客观事物在逻辑层面的数据抽象。它用于描述事物的数据对象，如客户、交易、产品、订单等</li><li><strong>属性</strong>Attribute 是指描述实体特征的数据项。每个实体都具有 1 个或多个属性</li><li><strong>标识符</strong>Identifier 是指标识不同实体实例的属性。标识符可以是 1 个或多个属性<br>标识符与主键的区别是标识符是一个逻辑概念，主键是物理概念</li><li><strong>联系</strong>Relationship 是指实体之间的联系，如“学生”与“成绩”的联系、“孩子”与“父亲”、“母亲”的联系等。<br>联系中关联的实体数目称为联系度数</li></ul><h3 id="实体-联系类型"><a href="#实体-联系类型" class="headerlink" title="实体-联系类型"></a>实体-联系类型</h3><h4 id="二元实体联系类型"><a href="#二元实体联系类型" class="headerlink" title="二元实体联系类型"></a>二元实体联系类型</h4><ul><li>一对一联系 1:1</li><li>一对多联系 1:N</li><li>多对多联系 M:N<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-17-42-55.png"></li></ul><p>上述实体之间的联系反映了一个给定实体有多少实例与另一实体实例存在的数量对应关系。术语<strong>基数</strong>Cardinality 表示实体联系的实例数量。在实体之间除了需要反映了数量对应关系，有时还需要反映实体参与关系的必要性，即<strong>可选</strong>optional 或<strong>强制</strong>mandatory</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-18-32-27.png"></p><h4 id="继承联系"><a href="#继承联系" class="headerlink" title="继承联系"></a>继承联系</h4><p>在 E-R 模型中，实体之间除了基本联系外，还存在继承联系。继承联系用于表示实体之间的相似性关系。在实体继承联系中，一端是具有公共属性的实体，称为父实体；另一端是与父实体具有相似属性，同时也具有特殊性的一个或多个实体，称为子实体。</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-18-33-31.png"></p></center><p>在继承联系中，还可以分为:</p><ul><li><strong>互斥性继承联系</strong>Mutual Exclusive Inheritance Relationship：在这种类型的继承中，子类只能从一个父类继承，不能同时从多个父类继承</li><li><strong>非互斥性继承联系</strong>Non-Mutual Exclusive Inheritance Relationship：这种类型的继承中，子类可以从多个父类继承，即一个子类可以属于多个父类</li></ul><hr><ul><li><strong>完整继承联系</strong> Total Inheritance Relationship：在这种继承中，父实体的每一个实例都必须是一个或多个子实体的实例。换句话说，父实体中的每个 instance 都必须在子实体中有对应。例如，如果我们有一个“人”实体，它有两个子实体：“学生”和“教师”，那么在完整继承关系中，每个“人”都必须是“学生”或“教师”。</li><li><strong>不完整继承联系</strong> Partial Inheritance Relationship：在这种类型的继承中，子类的 instance 可以不属于父类的任何子类；在上述的例子中，非完整继承允许存在一些“人”，他们既不是“学生”也不是“教师”。</li></ul><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-19-54-38.png"></p></center><h4 id="强弱实体联系"><a href="#强弱实体联系" class="headerlink" title="强弱实体联系"></a>强弱实体联系</h4><p>在 E-R 模型中，按照实体之间的语义关系，可以将实体分为<strong>弱实体 Weak Entity 和强实体 Strong Entity</strong>; 弱实体是指那些对于另外实体有依赖关系的实体，即一个实体的存在必须以另一实体的存在为前提。而被依赖的实体称为强实体; 例如在学校与学生之间的联系中，学生是弱实体，学校是强实体。</p><ul><li><strong>强实体</strong>Strong Entity</li><li><strong>弱实体</strong>Weak Entity<ul><li><strong>标识符依赖弱实体</strong> Identifier Dependent Weak Entity<br>如果弱实体的标识符中，包含了强实体的标识符，那么这种弱实体称为标识符依赖弱实体</li><li><strong>非标识符依赖弱实体</strong> Non-Identifier Dependent Weak Entity<br>如果弱实体的标识符中，不包含强实体的标识符，那么这种弱实体称为非标识符依赖弱实体</li></ul></li></ul><h2 id="数据库建模设计"><a href="#数据库建模设计" class="headerlink" title="数据库建模设计"></a>数据库建模设计</h2><p>概念数据模型设计是通过对现实世界中数据实体进行抽取、分类、聚集和概括等处理，建立反映系统业务数据组成结构的过程。<br><strong>步骤</strong></p><ul><li>业务数据分析，抽取数据实体</li><li>定义实体属性及其标识</li><li>建立实体联系，构建局部 E-R 模型图</li><li>分类、聚集和概括各个部分 E-R 模型图</li><li>完善全局 E-R 模型图，建立系统业务数据组成结构</li></ul><p><strong>数据模型 DM 元素对应关系表</strong></p><table><thead><tr><th>CDM</th><th>LDM</th><th>PDM</th></tr></thead><tbody><tr><td>Entity</td><td>Entity</td><td>Table</td></tr><tr><td>Attribute</td><td>Attribute</td><td>Column</td></tr><tr><td>Identifier</td><td>Primary Identifier&#x2F;Foreign Identifer</td><td>Primary Key&#x2F;Foreign Key</td></tr><tr><td>Relationship</td><td>Relationship</td><td>Reference(参照完整性约束)</td></tr></tbody></table><p><strong>1:1</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-20-16-28.png"><br><strong>1:N</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-20-17-38.png"><br><strong>M:N</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-20-38-36.png"></p><h2 id="规范化设计"><a href="#规范化设计" class="headerlink" title="规范化设计"></a>规范化设计</h2><p>为什么需要规范化数据库设计？</p><ul><li>减少数据库中的冗余数据，尽量使同一数据在数据库中仅保存一份，有效降低维护数据一致性的工作量。</li><li>设计合理的表间依赖关系和约束关系，便于实现数据完整性和一致性。</li><li>设计合理的数据库结构，便于系统对数据高效访问处理。</li></ul><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>定义：设有一关系模式<code>R(U)</code>，<code>U</code> 为关系 R 的属性集合，<code>X</code>和<code>Y</code>为属性<code>U</code>的子集。设 t，s 是关系 R 中的任意两个元组，如果 t<code>[X] = s[X]</code>，则<code>t[Y] = s[Y]</code>。那么称 Y 函数依赖于 X，表示为<code>X→Y</code>。<br>函数依赖的左部称为决定因子，右部称为依赖函数。决定因子和依赖函数都是属性的集合。</p><blockquote><p>假设我们有一个关系模式<code>R</code>，代表一个学生注册系统，其中<code>U</code>是关系<code>R</code>的属性集合，包括 <code>&#123;学生ID, 姓名, 课程ID, 课程名, 教师&#125;</code><br>任意给定两个元组<code>t</code>和<code>s</code>，例如<br>元组<code>t:&#123;学生ID: 001, 姓名: &quot;小明&quot;, 课程ID: C101, 课程名: &quot;数学&quot;, 教师: &quot;李老师&quot;&#125;</code><br>元组<code>s:&#123;学生ID: 001, 姓名: &quot;小明&quot;, 课程ID: C102, 课程名: &quot;英语&quot;, 教师: &quot;王老师&quot;&#125;</code><br>都有<code>t[学生ID] = s[学生ID] 则 t[姓名] = s[姓名]</code><br>可以得出学生 ID 决定姓名，即<code>学生ID→姓名</code></p></blockquote><p><strong>函数依赖的类型</strong>:</p><ul><li>完全函数依赖 Total Functional Dependency<br>若<code>X→Y</code>，对于<code>X</code>的任何一个真子集<code>X&#39;</code>，<code>X&#39;→Y</code>都不成立，则称<code>X→Y</code>是完全函数依赖</li><li>部分函数依赖 Partial Functional Dependency<br>若<code>X→Y</code>，<code>X</code>存在一个真子集<code>X&#39;</code>，使得<code>X&#39;→Y</code>，则称<code>X→Y</code>是部分函数依赖</li><li>属性传递依赖 Transitive Dependency<br>若满足<code>X→Y</code>，<code>Y→Z</code>，则有<code>X→Z</code>是，则称为属性传递依赖</li><li>多值函数依赖 Multivalued Dependency<br>设 U 是关系模式 R 的属性集，X 和 Y 是 U 的子集，<code>Z=U-X-Y</code>，<code>xyz</code>表示属性集 XYZ 的值。对于 R 的关系 r，在 r 中存在元组<code>（x, y1, z1）</code>和<code>（x, y2, z2）</code>时，也存在元组<code>（x, y1, z2）</code>和<code>（x, y2, z1）</code>，那么在模式 R 上存在多值函数依赖。<blockquote><p>(数据结构，李老师，《数据结构与算法-初级》)<br>(数据结构，王老师，《数据结构与算法-高级》)</p><hr><p>(数据结构，李老师，《数据结构与算法-高级》)<br>(数据结构，王老师，《数据结构与算法-初级》)</p></blockquote></li></ul><h2 id="关系规范化范式"><a href="#关系规范化范式" class="headerlink" title="关系规范化范式"></a>关系规范化范式</h2><p>关系规范化是把一个有访问异常的关系分解成结构良好的关系的过程，使得这些关系有最小的冗余或没有冗余。<br><strong>规范化范式</strong>（Normal Form，NF）是指关系表符合特定规范化程度的模式。</p><ol><li>第 1 范式（1NF）<br>如果关系表中的属性不可再细分，该关系满足第 1 范式。反之，该表就不是关系表。<blockquote><p>如果联系方式是一个关系表的属性，那么联系方式还可细分为电话号码、邮箱等属性；消除联系方式这类属性，将联系方式细分为电话号码、邮箱等属性，就满足了第 1 范式。</p></blockquote></li><li>第 2 范式（2NF）<br>如果关系满足第 1 范式，并消除了关系中的属性部分函数依赖，该关系满足第 2 范式。有一个关系<code>(A,B,N, 0,P)</code>其复合主键为<code>(A,B)</code>那么 <code>N,O,P</code> 这三个非键属性都不存在只依赖 A 或只依赖 B 情况，则该关系满足第 2 范式，反之，不满足第 2 范式。<blockquote><p>我们有一个关系模式 R，它的属性集 U 包括 {学生 ID, 课程 ID, 学生姓名, 课程名, 教师}，复合主键为(学生 ID,课程 ID)，然而学生姓名只依赖于学生 ID，课程名和教师只依赖于课程 ID，那么学生姓名和课程名、教师之间存在部分函数依赖，不满足第 2 范式。</p></blockquote></li><li>第 3 范式（3NF）<br>如果关系满足第 2 范式，并切断了关系中的属性传递函数依赖，该关系满足第 3 范式。<blockquote><p>{学号，姓名，系名，住址(宿舍地址)，电话，电子邮件}，其中学号决定系名，系名决定宿舍地址，故学号决定宿舍地址，存在传递依赖，不满足第 3 范式;可以对学生关系表再次分解为学生和系信息关系表<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-21-44-39.png"></p></blockquote></li><li>Boyce-Codd 范式（BCNF）<br>在关系中，所有函数依赖的决定因子都是候选键，该关系满足 BCNF 范式</li><li>第 4 范式（4NF）<br>如果关系满足 BCNF 范式，并消除了多值函数依赖，该关系满足第 4 范式。</li></ol>]]></content>
    
    
    <summary type="html">Database design and implementation</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="DataBase" scheme="https://efterklang.github.io/categories/Tech/DataBase/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>The Dead Lock</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch3-2TheDeadLock/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch3-2TheDeadLock/</id>
    <published>2024-04-05T13:52:59.000Z</published>
    <updated>2024-04-27T11:23:40.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生死锁的原因和必要条件"><a href="#产生死锁的原因和必要条件" class="headerlink" title="产生死锁的原因和必要条件"></a>产生死锁的原因和必要条件</h2><h3 id="死锁相关定义"><a href="#死锁相关定义" class="headerlink" title="死锁相关定义"></a>死锁相关定义</h3><p><strong>永久（可重用）性资源</strong></p><ul><li>可抢占性资源: 是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺</li><li>不可抢占性资源: 当系统把这类资源分配给某进程后，就不能强行收回，只能在进程用完后自行释放。<strong>临时性（消耗性）资源</strong></li><li>只可使用一次的资源</li></ul><p><strong>死锁 Dead Lock</strong>：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。</p><ul><li>死锁会造成进程无法执行</li><li>死锁会造成系统资源的极大浪费(资源没法释放)</li></ul><p><strong>产生死锁的原因</strong></p><ul><li>竞争资源</li><li>进程间推进顺序不当</li></ul><p><strong>产生死锁的必要条件</strong></p><ol><li><strong>互斥条件</strong>:进程对分配到的资源进行排它性使用</li><li><strong>请求和保持条件</strong>:进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又被其他进程占有，请求进程阻塞，但对已经获得的资源不释放</li><li><strong>不剥夺条件</strong>:进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完时自己释放</li><li><strong>环路等待条件</strong>:发生死锁时，必然存在进程—资源的环形链</li></ol><h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>资源分配图 Resource Allocation Graph(RAG)：用来描述进程和资源之间的关系，以及资源之间的竞争关系。它是有向图，说明了系统资源、进程状态，其中每个资源、进程用节点表示，圆点表示资源的一个示例，一个资源可拥有多个实例</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-07-11-53-28.png" style="zoom:50%;" /></center><p><strong>1.竞争不可抢占性资源引起死锁</strong></p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-07-11-54-14.png" style="zoom:50%;" /></center><p><strong>2.竞争临时性资源引起进行死锁</strong><br>临时性资源，可以创造（生产）和撤消（消耗）的资源，也称之为消耗性资源，如信号量、消息、buffer 中的数据等资源<br>例如：S1、S2 和 S3 是临时性资源，是由进程 P1、P2 和 P3 产生的消息。如果消息通信处理顺序不当也会发生死锁。</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-07-15-15-18.png" style="zoom:50%;" /></center><p><strong>3. 进程推进顺序不当引起死锁</strong><br>联合进程图(Joint Progress Diagram)记录共享资源的多个进程的执行进展</p><blockquote><p>竞争资源，未必产生死锁。是否产生死锁，还取决于动态执行和应用程序细节</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P: 申请A，申请B，释放A，释放B</span><br><span class="line">Q: 申请B，申请A，释放B，释放A</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-07-16-00-03.png"></p><h2 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h2><ol><li><strong>预防死锁 Deadlock Prevention</strong>：设置某些限制条件，破坏四个必要条件中的一个或几个。<br>优点：容易实现<br>缺点:系统资源利用率和吞吐量降低</li><li><strong>避免死锁 Deadlock Avoidance</strong>：在资源的动态分配过程用某种方法防止系统进入不安全状态。<br>优点：较弱限制条件可获得较高系统资源利用率和吞吐量。<br>缺点：有一定实现难度。<br>死锁避免的两种方法：<ul><li>若一个进程的请求会导致死锁，则不启动进程</li><li>若一个进程增加的资源请求会导致死锁，则不允许这一资源分配</li></ul></li><li><strong>检测死锁 Deadlock Detection</strong>：预先不采取任何限制，也不检查系统是否已进入不安全区，通过设置检测机构，检测出死锁后解除。</li><li><strong>解除死锁 Unlocking deadlock</strong>：常用撤消或挂起一些进程，回收一些资源。</li></ol><blockquote><p>预防死锁和避免死锁是两种不同的概念，两者都是事先防范死锁的发生，但是方法不同。<br>预防死锁是在系统设计时就考虑到死锁的可能性，采取措施避免死锁的发生，而避免死锁是在系统运行时，根据系统的状态，采取措施避免死锁的发生。</p><p>预防死锁：破坏死锁的必要条件，施加的条件比较严格，可能会影响到进程的并发执行。<br>避免死锁：资源动态分配，施加的限制条件较弱一些，有利于进程的并发执行。</p></blockquote><h3 id="摒弃请求和保持条件"><a href="#摒弃请求和保持条件" class="headerlink" title="摒弃请求和保持条件"></a>摒弃请求和保持条件</h3><p><strong>第一种协议</strong>：系统要求所有进程一次性申请所需的全部资源，只要有一种资源要求不能满足，即使是已有的其它各资源，也全部不分配给该进程，而让其等待</p><ul><li>优点：简单、易于实现且很安全。</li><li>缺点：资源严重浪费；进程延迟运行。</li></ul><p><strong>第二种协议</strong>：允许一个进程只获得运行初期所需的资源后便开始运行。进程运行过程中再逐步释放已分配给自己的、且已使用完毕的全部资源，然后再请求新的所需资源<br>优点：使进程更快地完成任务，提高设备的利用率，减少进程发生饥饿的概率</p><h3 id="摒弃不剥夺条件"><a href="#摒弃不剥夺条件" class="headerlink" title="摒弃不剥夺条件"></a>摒弃不剥夺条件</h3><p>进程在需要资源时才提出请求，一个已经保持了某些资源的进程，再提出新的资源要求而不能立即得到满足时，必须释放已经保持的所有资源，待以后需要时再重新申请。<br>Cons:实现复杂，代价大；延长了进程的周转时间，增加系统开销，降低系统吞吐量。</p><h3 id="摒弃环路等待条件"><a href="#摒弃环路等待条件" class="headerlink" title="摒弃环路等待条件"></a>摒弃环路等待条件</h3><p>系统将所有资源按类型进行线性排队（常用-不常用），并赋予不同的序号。所有进程对资源的请求必须严格按资源序号递增的次序提出，按序号递减的次序释放</p><blockquote><p>假设我们的系统有三种资源：A、B、C，我们将它们按照使用频率进行排序，得到的序列是 A（最常用）-&gt; B -&gt; C（最不常用）。然后，我们给每种资源分配一个序号：A&#x3D;1，B&#x3D;2，C&#x3D;3。<br>在这种策略下，所有的进程必须按照资源序号递增的顺序请求资源,按照资源序号递减的顺序释放资源。</p></blockquote><h2 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h2><p><strong>安全状态</strong>:是指系统能按某种进程顺序 <code>〈P1, P2, …, Pn〉</code>，来为每个进程 Pi 分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成,则称这是一个安全序列。安全序列的实质是:序列中的每一个进程 Pi 到运行完成尚需的资源量不超过系统当前剩余的资源量与所有在它之前的进程 P1, P2, …, Pi-1 所占用的资源量之和。<br>如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><ul><li>并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能有进入死锁状态。</li><li>系统处于安全状态时，不会进入死锁状态。</li></ul><p>死锁避免策略并不能确切的预测死锁，仅仅是预料死锁的可能性并确保永远不会出现这种可能性。<br>死锁避免比死锁预防限制少，但使用中也有许多限制：</p><ul><li>必须事先声明每个进程请求的最大资源。</li><li>考虑的进程必须是无关的，执行的顺序必须没有任何同步的要求。</li><li>分配的资源数目必须是固定的。</li><li>在占有资源时，进程不能退出。</li></ul><h3 id="🌟-银行家算法思想-死锁避免策略"><a href="#🌟-银行家算法思想-死锁避免策略" class="headerlink" title="🌟 银行家算法思想 死锁避免策略"></a>🌟 银行家算法思想 死锁避免策略</h3><p><a href="https://www.cnblogs.com/wkfvawl/p/11929508.html">Banker’s Alogorithm</a></p><h4 id="银行家算法的基本思想"><a href="#银行家算法的基本思想" class="headerlink" title="银行家算法的基本思想"></a>银行家算法的基本思想</h4><p>避免死锁的关键在于如何准确的预测是否会出现死锁，从而避免死锁。最有代表性的避免死锁的算法是 Dijkstra 在 1965 年提出的银行家算法。该算法可用于银行发放一笔贷款前，预测该笔贷款是否会引起银行资金周转问题。<br>银行的资金就类似于计算机系统的资源，贷款业务类似于计算机的资源分配。银行家算法能预测一笔贷款业务对银行是否是安全的，该算法也能预测一次资源分配对计算机系统是否是安全的。</p><ol><li>当前状态下，某进程申请资源；</li><li>系统假设将资源分给该进程，满足它的需求；</li><li>检查分配后的系统状态是否是安全的，如果是安全，就确认本次分配；如果系统是不安全的，就取消本次分配并阻塞该进程(这一步也被称为安全性算法)</li></ol><h4 id="银行家算法的数据结构"><a href="#银行家算法的数据结构" class="headerlink" title="银行家算法的数据结构"></a>银行家算法的数据结构</h4><p>为实现银行家算法，系统中必须设置若干数据结构</p><ol><li><p><strong>可利用资源向量 Available</strong>这是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 <code>Available[j]= K</code>，则表示系统中现有 Rj 类资源 K 个。</p></li><li><p><strong>最大需求矩阵 Max</strong>这是一个 n×m 的矩阵，它定义了系统中 n 个进程中的每一个进程对 m 类资源的最大需求。如果 <code>Max[i,j]=K</code>，则表示进程 i 需要 Rj 类资源的最大数目为 K。</p></li><li><p><strong>分配矩阵 Allocation</strong>这也是一个 n×m 的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果 <code>Allocation[i,j]</code>&#x3D;K，则表示进程 i 当前已分得 Rj 类资源的数目为 K。</p></li><li><p><strong>需求矩阵 Need</strong>这也是一个 n×m 的矩阵，用以表示每一个进程尚需的各类资源数。如果 <code>Need[i,j]=K</code>，则表示进程 i 还需要 Rj 类资源 K 个，方能完成其任务。</p><p>设 $Request_i$ 是进程 $P_i$ 的请求向量，如果 $Request_i[j] &#x3D; K$，表示进程 $P_i$ 需要 K 个 $R_j$ 类型的资源。当 Pi 发出资源请求后，系统按下述步骤进行检查：<br>(1) 如果 $Request_i[j] \leq Need[i,j]$，便转向步骤 2；否则认为出错，因为它所申请的资源数已超过它所宣布的需要的资源数。<br>(2) 如果 $Request_i[j] \leq Available[j]$，便转向步骤(3)；否则， 表示尚无足够资源，Pi 须等待。<br>(3) 系统试探着把资源分配给进程 Pi，并修改下面数据结构中的数值：<br>$Available[j]&#x3D;Available[j]-Requesti[j];$<br>$Allocation[i,j]&#x3D;Allocation[i,j]+Requesti[j];$<br>$Need[i,j]&#x3D;Need[i,j]-Requesti[j];$<br>(4) 系统执行<a href = #安全性算法>安全性算法</a>，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程 Pi，以完成本次分配；否则， 将本次的试探分配作废，恢复原来的资源分配状态，让进程 Pi 等待。</p><center> <p> <img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-08-15-42-12.png"></p></li></ol>  </center><h4 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h4><p>(1) 设置两个向量：<br><strong>工作向量 Work</strong>: 它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m 个元素，在执行安全算法开始时，Work 初始化为 Available;<br><strong>Finish</strong>: 它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先初始化 Finish[i]&#x3D;false; 当有足够资源分配给进程时， 再令 Finish[i]&#x3D;true。<br>(2) 从进程集合中找到一个能满足下述条件的进程：<br>$Finish[i] &#x3D; false$<br>$Need[i,j] \leq Work[j]$<br>若找到， 执行步骤(3)，否则，执行步骤(4)。<br>(3) 当进程 Pi 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<br>$Work[j]&#x3D;Work[j]+Allocation[i,j];$<br>$Finish[i]&#x3D;true;$<br>go to step 2;<br>(4) 如果所有进程的$Finish[i]&#x3D;true$都满足， 则表示系统处于安全状态；否则，系统处于不安全状态。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-08-15-52-12.png"></p><h2 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h2><p>如果系统不愿意附加太多约束条件预防死锁，也不希望系统额外开销预测并避免死锁，那么，只能允许死锁出现，然后，再解除它。因此，系统需要利用某种方法来检测死锁。</p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><h4 id="化简资源分配图—检测死锁"><a href="#化简资源分配图—检测死锁" class="headerlink" title="化简资源分配图—检测死锁"></a>化简资源分配图—检测死锁</h4><p><strong>资源分配图(Resource Allocation Graph)</strong><br>该图是由一组结点 N 和一组边 E 所组成的一个对偶<code>G＝（N,E）</code>，其中：</p><ol><li>把 N 分为两个互斥的子集，即一组进程结点<code>P=&#123;P1,P2，…，Pn&#125;</code>和一组资源结点<code>R=&#123;R1, R2 ，…， Rn&#125;</code>，<code>N＝PUR</code></li><li>凡属于 E 中的一个边 e∈E 都连接着 P 中的一个结点和 R 中的一个结点<br><code>e=&#123;Pi,Rj&#125;</code>表示进程 Pi 请求一个单位的 Rj 资源<br><code>e=&#123;Rj,Pi&#125;</code>表示把一个单位的资源 Rj 分配给进程 Pi</li></ol><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-08-15-58-04.png"></p></center><p>Steps:<br>第一步:先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞的（即系统有足够的空闲资源分配给它）<br>第二步:把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来<br>第三步:重复一二步<br>第四步:最后，若所有的资源和进程都可以变成孤立的点。这样的图就叫做“可完全简化”</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-08-18-40-23.png"></p></center>**死锁定理**：S 为死锁状态当且仅当 S 状态的资源分配图是不可完全简化的。<p><strong>死锁检测中的数据结构</strong><br>(1) 可利用资源向量 Available，它表示了 m 类资源中每一类资源的可用数目。<br>(2) 把不再占用资源的进程(即向量 Allocation 和 Request 为 0 的进程)记入 L 表中， 即<code>L = Li∪L</code><br>(3) 从进程集合中找到一个 <code>Requesti≤Work</code> 的进程，做如下处理：① 将其资源分配图简化，释放出资源，增加工作向量 $Work&#x3D;Work+Allocation_i$。 ② 将它记入 L 表中。<br>(4) 若不能把所有进程都记入 L 表中， 便表明系统状态 S 的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Work = Available;</span><br><span class="line">L = &#123;Li| Allocation_i = <span class="number">0</span> ∩ Request_i = <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; Pi not in L; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span> Requesti≤Work&#123;</span><br><span class="line">      Work=Work+Allocation_i;</span><br><span class="line">      Li=Pi；</span><br><span class="line">      L=Li∪L;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">deadlock= !(L=&#123;p1, p2, …, pn&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>例题<br>p 个进程共享 m 个同类资源，每一资源在任一时刻只能供一个进程使用，每一进程对任一资源都只能使用一有限时间，使用完便立即释放，并且每个进程对该类资源的最大需求量小于该类资源的数目。设所有进程对资源的最大需要之和小于 p+m。试证：在系统中不会发生死锁。<br>证明：假设系统发生死锁。<br>设 Max(i)为进程 i 的最大资源需求量，Need(i)为进程 i 尚需资源量，Allocation(i)为已分配资源量，则系统在任意时刻有：<br>$\sum_{i&#x3D;1}^{p}Max(i) &#x3D; \sum_{i&#x3D;1}^{p} Need(i) + \sum_{i&#x3D;1}^{p}Allocation(i) \lt p+ m①$<br>系统发生死锁，则一方面说明所有 m 个资源都应该已经分配出去：$\sum_{i&#x3D;1}^{p} Allocation(i)&#x3D;m②$<br>另一方面，进程将处于无限等待状态之中。<br>由 ① ② 可以得到：$\sum_{i&#x3D;1}^{p} Need(i) \lt p③$<br>即死锁后 p 个进程还需要的资源量之和少于 p，这就意味着此刻至少有一个进程譬如 j，已经获得了所需要的全部资源数，即$Need（j）&#x3D;0$。但是系统发生死锁时，每个进程至少还需要一个资源单位，即$\sum_{i&#x3D;1}^{p} Need(i) \geq p$，与等式 ③ 矛盾。此外，既然该进程已经获得了所需要的全部资源数，那么就能完成其任务并释放占有的资源，以保证系统能进一步前进，这与前面的假定死锁矛盾。</p></blockquote><h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p>当发现有进程死锁时，常采用的两种方法是解除死锁：</p><ol><li><strong>剥夺资源</strong>。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。</li><li><strong>撤消进程</strong>。最简单的撤消进程的方法，是使全部死锁进程都夭折掉；或者按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。</li></ol><p>按照解除死锁复杂度递增的顺序列出解除死锁的方法：</p><ol><li>撤消死锁进程 -该方法是目前操作系统中解除死锁的常用方法。</li><li>把死锁进程恢复到前一个检查点，重新执行每个进程。</li><li>按照某种原则逐个选择死锁进程进行撤消，直到解除系统死锁。</li><li>按照某种原则逐个剥夺进程资源，直到解除死锁。</li></ol><p>第三种和第四种方法需要选择系统付出代价最小的进程，最小代价原则：</p><ul><li>到目前为止，花费处理机的时间最少的进程；</li><li>到目前为止，产生输出最少的进程；</li><li>估计未执行部分最多的进程；</li><li>到目前为止，已获得资源量最少的进程；</li><li>优先级最低的进程。<br>为把系统从死锁状态中解脱出来，所花费的代价(最小)可表示为：<div>$R(S)_{min} = \sum_{1\lt i\lt j\lt n} min{C_{ij}}$</div></li><li>$R(S)_{min}$ 表示从死锁状态中解脱出来的最小代价。</li><li>$C_{ui}$, $C_{uj}$, $C_{uk}$, … 表示各个死锁参与者（例如线程、进程或事务）需要付出的代价。这些代价可能是不同的，因为每个参与者可能在不同的状态，需要执行的操作也可能不同。</li><li>$min{C_{ui}}$, $min{C_{uj}}$, $min{C_{uk}}$, … 表示选择每个死锁参与者需要付出的最小代价。这是因为在解决死锁时，通常会选择使得总代价最小的策略。</li></ul>]]></content>
    
    
    <summary type="html">死锁的产生原因、必要条件、预防、避免、检测与解除</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>The Processor Scheduling</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch3-1TheProcessorScheduling/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch3-1TheProcessorScheduling/</id>
    <published>2024-03-29T02:56:11.000Z</published>
    <updated>2024-04-27T11:23:40.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理机调度的层次-Process-Scheduling-Levels"><a href="#处理机调度的层次-Process-Scheduling-Levels" class="headerlink" title="处理机调度的层次 Process Scheduling Levels"></a>处理机调度的层次 Process Scheduling Levels</h2><h3 id="概述-Overview"><a href="#概述-Overview" class="headerlink" title="概述 Overview"></a>概述 Overview</h3><p>处理机是计算机系统中的重要资源,在<strong>多道程序环境</strong>下[<a href="Ch1-1OSIntroduction.md" title="操作系统概论">Ch1-1OSIntroduction#操作系统的发展过程</a>]，进程数目通常多于处理机的数目,系统必须按一定方法动态地把处理机分配给就绪队列中的一个进程;处理机利用率和系统性能（吞吐量、响应时间）在很大程度上取决于处理机调度</p><ul><li>WHAT：按什么原则分配 CPU 调度算法</li><li>WHEN：何时分配 CPU 调度的时机</li><li>HOW：如何分配 CPU 调度过程及进程的上下文切换</li></ul><h3 id="作业-JOB"><a href="#作业-JOB" class="headerlink" title="作业 JOB"></a>作业 JOB</h3><p>作业是用户在一次算题过程中或一次事务处理中，要求计算机系统所做的工作的集合<br>作业是一个比程序更广泛的概念，可以包含多个程序和数据，还配有一份作业说明书，系统根据作业说明书来对作业中的程序进行控制。在批处理系统中，以作业为单位从外存调入内存<br>用户为了让计算机完成某个特定任务，首先编写成源程序，然后提交给计算机通过编译或汇编、连接、装配、运行等步骤，最终由计算机输出用户所需要的运行结果。从计算机管理的角度看，上述一系列的由计算机执行的任务的集合就是作业。</p><blockquote><p>Job and task are today vague, ambiguous terms, especially task. A “job” often means a set of processes, while a “task” may mean a process, a thread, a process or thread, or, distinctly, a unit of work done by a process or thread.<br><a href="https://stackoverflow.com/questions/3073948/job-task-and-process-whats-the-difference">job, task and process, what’s the difference</a></p></blockquote><h4 id="作业步-Job-Step"><a href="#作业步-Job-Step" class="headerlink" title="作业步 Job Step"></a>作业步 Job Step</h4><p>计算机完成作业是通过执行一系列有序的工作步骤进行的，每个步骤完成作业的一部分特定工作;把计算机系统完成一个作业所需的一系列有序的相对独立的工作步骤称为<strong>作业步</strong><br>作业的各个作业步虽然功能相对独立，但它们之间相互关联，往往是一个作业步的执行需要使用上一个作业步的执行结果。</p><blockquote><p>从用户把源程序提交给计算机系统到得出运算结果要经过若干个工作步骤，首先计算机系统要对用户的源程序进行编辑工作来进行语法检查，再由编译或汇编工作生成目标代码。由连接工作形成装入模块，然后通过装入工作将装入模块装入内存。最后由运行工作得出运行结果。5 个步骤，每步都完成一项相对独立的工作</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-29-15-12-12.png"></p></blockquote><h4 id="作业状态转换-Job-State-Transition"><a href="#作业状态转换-Job-State-Transition" class="headerlink" title="作业状态转换 Job State Transition"></a>作业状态转换 Job State Transition</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-29-15-26-26.png" alt="Ch3-1TheProcessorScheduling-2024-03-29-15-26-26"></p><h4 id="JCB"><a href="#JCB" class="headerlink" title="JCB"></a>JCB</h4><p>作业提交给系统进入后备状态后，系统将为每个作业建立一个作业控制块 JCB。<br>JCB 在作业的整个运行过程中始终存在，并且其内容与作业的状态同步地动态变化。只有当作业完成并退出系统时，JCB 才被撤消。可以说，<strong>JCB 是一个作业在系统中存在的唯一标志</strong>，系统根据 JCB 才感知到作业的存在<br>作业控制块 JCB 中包含了对作业进行管理的必要信息，JCB 中的信息一部分是从用户提供的作业控制卡或作业说明书中得到，另一部分是记录作业运行过程中的动态信息<br>JCB 的具体内容因系统不同而异</p><table><thead><tr><th><strong>作业名</strong></th><th></th></tr></thead><tbody><tr><td>资源要求</td><td>预估的运行时间 最迟完成时间 要求的内存量 要求外设类型、台数 要求的文件量和输出量</td></tr><tr><td>资源使用情况</td><td>进入系统时间 开始运行时间 已运行时间 内存地址 外设台号</td></tr><tr><td>类型级别</td><td>控制方式 作业类型 优先级</td></tr><tr><td>状态</td><td></td></tr><tr><td>用户账户……</td><td></td></tr></tbody></table><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ul><li>在多道程序系统中，一个作业从提交到执行，通常都要经历多级调度,如高级调度、低级调度、中级调度以及 I&#x2F;O 调度等</li><li>系统的运行性能在很大程度上取决于调度,如吞吐量的大小、周转时间的长短、响应的及时性等</li><li>调度是多道系统的关键</li></ul><table><thead><tr><th align="center">类型</th><th align="center">运行频率</th><th align="center">运行时间</th><th align="center">算法复杂性</th><th>存储</th><th>OS</th></tr></thead><tbody><tr><td align="center">进程调度</td><td align="center">高</td><td align="center">短</td><td align="center">低</td><td>内存中</td><td>批处理,实时,分时</td></tr><tr><td align="center">中程调度</td><td align="center">中</td><td align="center">较短</td><td align="center">中</td><td>内外存互换</td><td>批处理,实时,分时</td></tr><tr><td align="center">作业调度</td><td align="center">低</td><td align="center">长</td><td align="center">高</td><td>外存到内存</td><td>批处理</td></tr></tbody></table><p>引起进程调度的事件：</p><ol><li>正在执行的进程正常终止或异常终止</li><li>正在执行的进程因某事件而阻塞(如提出 IO 请求后阻塞,调用<code>wait()</code>后阻塞,在进程通信或同步过程中执行了某种原语操作，如 P、V 操作原语，Block 原语， Wakeup 原语等后阻塞)</li><li>在引入时间片的系统中，时间片用完，进程被抢占</li><li>在抢占式系统中，就绪队列中的某进程优先级高于当前进程,或有更高优先级的进程进入就绪队列</li></ol><h4 id="高级调度-High-Scheduling"><a href="#高级调度-High-Scheduling" class="headerlink" title="高级调度 High Scheduling"></a>高级调度 High Scheduling</h4><p><strong>高级调度 High Scheduling</strong>：又称<strong>作业调度、准入调度、长程调度或接纳调度</strong>，其主要功能是根据某种算法，把外存上处于后备队列中的那些作业调入内存;它发生在一批作业完成，重新调入一批作业到内存的时候，执行频率低。批处理系统需要有作业调度，<strong>分时和实时系统无需此调度</strong>。主要用于批处理系统。其设计目标是最大限度地发挥各种资源的利用率和保持系统内各种活动的充分并行;</p><blockquote><p>例：对资源需求不同的作业进行合理搭配<br>科学计算往往需要占用大量的 CPU 时间，属于 CPU 繁忙型作业，对于 I&#x2F;O 设备的使用少；<br>数据处理要求占用较少的 CPU 时间，但要求大量 I&#x2F;O 时间，属于 I&#x2F;O 繁忙型作业；<br>有些递归计算，产生大量中间结果，需要很多内存单元存放它们，这属于内存繁忙型作业。<br>如果能把它们搭配在一起，程序 A 在使用处理机，程序 B 在利用通道 l，而程序 C 恰好利用通道 2 等，这样一来，A、B 和 C 从来不在同一时间使用同一资源，每个程序就好像单独在一个机器上运行</p></blockquote><p>在每次执行作业调度时，都须做出以下两个决定：</p><ol><li>接纳多少个作业（取决于多道程序度）<ul><li>作业太多 服务质量下降</li><li>作业太少 资源利用率低</li></ul></li><li>接纳哪些作业 （取决于采用的调度算法）</li></ol><h5 id="调度评价指标"><a href="#调度评价指标" class="headerlink" title="调度评价指标"></a>调度评价指标</h5><blockquote><p>多道程序度 Degree Of Multiprogramming：即允许多少个作业同时在内存中运行。<br>周转时间 Turnaround Time：指从作业被提交给系统开始，到作业完成为止的这段时间间隔,也称为作业周转时间<br>带权周转时间 Weighted Turnaround Time：作业的周转时间 T 与系统为它提供服务的时间 TS 之比,称为带权周转世界,$WTT&#x3D;\frac{T_{周转时间}}{T_{预计运行时间}}$<br>吞吐量 Throughput：是指在单位时间内系统所完成的作业数<br>服务时间 Service Time：作业的预计运行时间<br>响应比 Response Ratio：$RR&#x3D;\frac{T_{等待时间} + T_{预计运行时间}}{T_{预计运行时间}}&#x3D;\frac{T_{响应时间}}{T_{预计运行时间}}$,注意 <code>RR&gt;=1</code></p></blockquote><h4 id="低级调度-Low-Scheduling"><a href="#低级调度-Low-Scheduling" class="headerlink" title="低级调度 Low Scheduling"></a>低级调度 Low Scheduling</h4><p><strong>低级调度又称为进程调度或短程调度</strong>，它所调度的对象是进程。三种类型 OS 都必须配置这级调度(最基本调度);低级调度用于决定就绪队列中的哪个进程应获得处理机，然后由<strong>分派进程Dispatcher</strong>执行把分配处理机给相应进程的具体操作。其时间尺度通常是毫秒级的,且是系统中最频繁的调度,要求在实现时做到高效</p><p><strong>低级调度基本机制</strong></p><ol><li><strong>排队器</strong>为了提高进程调度的效率，应事先将系统中所有的就绪进程按照一定的方式排成一个或多个队列。</li><li><strong>分派器(调度程序)</strong> 分派器把由进程调度程序所选定的进程从就绪队列中取出，然后进行上下文切换，将处理机分配给它。</li><li><strong>上下文切换机制</strong>当对处理机进行切换时，会发生两对上下文切换操作。</li></ol><p><strong>低级调度功能</strong></p><ol><li>按某种算法选取进程（调度）。</li><li>保存处理机的现场信息（上下文切换第一步骤）</li><li>恢复新进程的 CPU 现场,从而把处理器分配给新进程（上下文切换第二步骤）。</li></ol><p><strong>进程调度方式</strong></p><p><strong>非抢占方式 Non-preemptive Mode</strong>：进程占用处理机直至自愿放弃或发生某事件被阻塞时，在把处理机分配给其他进程。</p><p>进程正在处理机上执行时，新就绪的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻塞状态时，才转让处理机。</p><p>优点：算法简单，系统开销小<br>缺点：紧急任务不能及时响应；短进程到达要等待长进程运行结束</p><p><strong>抢占方式 Preemptive Mode</strong>：允许暂停某个正在执行的进程，将处理机重新分配给另一个进程。</p><p>进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程</p><p>优点：可以防止一个长进程长时间占用处理机，能为大多数进程提供更公平的服务，特别是能满足对响应时间有着较严格要求的实时任务的需求。<br>缺点：抢占方式比非抢占方式调度所需付出的开销较大，且调度算法复杂。</p><p>抢占方式 Preemptive Mode</p><ul><li>时间片原则:适用于分时、大多数实时以及要求较高的批处理系统</li><li>优先权原则:重要紧急作业优先权高</li><li>短作业(进程)优先原则。</li></ul><h4 id="中级调度-Intermediate-Level-Scheduling"><a href="#中级调度-Intermediate-Level-Scheduling" class="headerlink" title="中级调度 Intermediate-Level Scheduling"></a>中级调度 Intermediate-Level Scheduling</h4><p>中级调度 Intermediate-Level Scheduling,又称中程调度(Medium-Term Scheduling);<br>主要目的：为了提高内存利用率和系统吞吐量。<br>具体实现：</p><ul><li>使那些暂时不能运行的进程不再占用宝贵的内存资源，而将其调至外存的交换区(swap space)去等待，把此时的进程状态称为就绪驻外存状态或挂起状态。</li><li>当这些进程重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把外存上的那些又具备运行条件的就绪进程，重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。</li></ul><h2 id="调度队列模型和调度准则"><a href="#调度队列模型和调度准则" class="headerlink" title="调度队列模型和调度准则"></a>调度队列模型和调度准则</h2><h3 id="调度模型-Scheduling-Model"><a href="#调度模型-Scheduling-Model" class="headerlink" title="调度模型 Scheduling Model"></a>调度模型 Scheduling Model</h3><p>三级调度都涉及进程的队列。可以形成以下三种调度队列模型</p><ul><li>仅有进程调度(低级调度)</li><li>具有高级和低级调度</li><li>具有三级调度</li></ul><h4 id="仅有进程调度"><a href="#仅有进程调度" class="headerlink" title="仅有进程调度"></a>仅有进程调度</h4><p>在分时系统中，通常仅设有进程调度,系统把这些进程组织成一个就绪队列,每个进程在执行时，可能有以下几种情况</p><ul><li>进程获得 CPU 正在执行；</li><li>任务在给定时间片内已完成，释放处理机后为完成状态；</li><li>任务在时间片内未完成，进入就绪队列末尾；</li><li>在执行期间因某事件而阻塞。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-31-18-02-37.png" alt="仅有进程调度的调度队列模型(分时系统)"><blockquote><p>就绪队列时间片轮转，常采用 FCFS(FIFO)算法， FCFS(FIFO)队列。<br>进程执行时三种情况：完成、时间片到、阻塞</p></blockquote></li></ul><h4 id="具有高级和低级调度"><a href="#具有高级和低级调度" class="headerlink" title="具有高级和低级调度"></a>具有高级和低级调度</h4><p>在批处理系统中，不仅需要进程调度，而且还要有作业调度<br>就绪队列的形式:在批处理系统中，常用高优先权队列。进程进入就绪队列时，按优先权高低插入相应位置，调度程序总是把处理机分配给就绪队列首进程<br>设置多个阻塞队列:根据事件的不同设置多个队列提高效率<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-31-18-04-45.png" alt="具有高级和低级调度的调度队列模型"></p><blockquote><p>常采用高优先权优先调度算法<br>可采用优先队列，进程来时按优先权插队，从队首调度 （效率高）<br>可采用无序列表，每次调度时，先比较优先权<br>多个阻塞队列</p></blockquote><h4 id="同时具有三级调度的调度队列模型"><a href="#同时具有三级调度的调度队列模型" class="headerlink" title="同时具有三级调度的调度队列模型"></a>同时具有三级调度的调度队列模型</h4><p>在 OS 中引入中级调度后，进程的就绪状态分为内存就绪(表示进程在内存中就绪)和外存就绪(进程在外存中就绪)。同样，阻塞状态进一步分成内存阻塞和外存阻塞两种状态。<br>在调出操作的作用下，可使进程状态由内存就绪转为外存就绪，由内存阻塞转为外存阻塞；<br>在中级调度的作用下，又可使外存就绪转为内存就绪。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-31-18-11-01.png" alt="同时具有三级调度的调度队列模型"></p><h3 id="选择调度方式和调度算法的若干准则"><a href="#选择调度方式和调度算法的若干准则" class="headerlink" title="选择调度方式和调度算法的若干准则"></a>选择调度方式和调度算法的若干准则</h3><p>在不同的系统中通常采用不同的调度方式和算法。</p><p><strong>调度的目标</strong></p><ul><li>提高处理机的利用率</li><li>提高系统吞吐量</li><li>尽量减少进程的响应时间</li><li>防止进程长期得不到运行</li></ul><h4 id="系统选择调度方式和算法的准则"><a href="#系统选择调度方式和算法的准则" class="headerlink" title="系统选择调度方式和算法的准则"></a>系统选择调度方式和算法的准则</h4><p><a href="#调度评价指标">调度评价指标术语</a></p><ol><li>面向用户的准则<ul><li><strong>周转时间短</strong>:用来评价批处理系统的性能、选择作业调度方式与算法的重要准则之一<ul><li>作业在外存后备队列上等待调度的时间。</li><li>进程在就绪队列等待调度的时间。</li><li>进程在 CPU 上的执行时间。</li><li>等待 I&#x2F;O 操作完成的时间。</li></ul></li><li><strong>响应时间快</strong>:用来评价分时系统的性能、选择进程调度算法的重要准则之一<br>这里的响应时间，是指从用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间。<ul><li>从键盘输入的请求信息传送到处理机的时间。</li><li>处理机对请求信息进行处理的时间。</li><li>将所形成的响应回送到终端显示器的时间。</li></ul></li><li><strong>截止时间的保证</strong>:用来评价实时系统的性能、选择实时调度算法的重要准则之一<br>截止时间，是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。（也叫做时限，即 deadline）<ul><li>开始截止时间。</li><li>终止&#x2F;完成截止时间。</li></ul></li><li><strong>优先权准则</strong>:适合批处理、分时和实时系统<ul><li>让某些紧急的作业能得到及时处理。</li><li>往往还需选择抢占式调度方式，才能保证紧急作业得到及时处理。</li></ul></li></ul></li><li>面向系统的准则<ul><li><strong>系统吞吐量高</strong>:评价批处理系统<ul><li>吞吐量是指在单位时间内，系统所完成的作业数</li><li>与批处理作业的平均长度有关</li></ul></li><li><strong>处理机利用率高</strong>。主要对大、中型多用户系统，对单用户或实时系统不重要。<br>$CPU利用率 &#x3D; \frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$</li><li><strong>各类资源的平衡利用</strong>:如内存、外存、I&#x2F;O 设备等;主要对大、中型系统，对微型机或实时系统不重要。</li></ul></li></ol><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p><strong>进程切换</strong>:当一个进程占用处理机执行完(或不能继续执行)，则切换另一个进程占用处理机执行，称为进程切换。<br><strong>进程调度</strong>:把处理机分配给不同的进程占用执行，称为进程调度。实现分配处理机的程序称为<strong>调度程序</strong><br>在进程切换时，要保护执行现场。执行现场称为进程的<strong>上下文 context</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-01-14-10-26.png" alt="Process Switch"></p><p><strong>进程切换基本步骤</strong></p><ol><li>保存当前进程的上下文</li><li>更新当前运行进程的 PCB，将其状态改为就绪 Ready 或阻塞 Blocked</li><li>将 PCB 插入就绪队列或阻塞队列</li><li>改变需要投入运行的进程的 PCB，将其状态改为运行 Running</li><li>恢复新进程的上下文</li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-01-20-52-59.png"></p><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><p><strong>先到先服务调度算法</strong>(FCFS，First Come First Served) 按照作业&#x2F;进程进入系统的<strong>先后次序</strong>进行调度，先进入系统者先调度；适合于作业调度和进程调度;用于批处理系统，不适于分时系统</p><ul><li>优点：<ul><li>有利于长作业（进程）</li><li>有利于 CPU 繁忙型作业（进程）</li></ul></li><li>缺点：<ul><li>不利用短作业（进程），特别是来的较晚的短作业（进程）。</li><li>不利于 I&#x2F;O 繁忙型作业（进程）</li></ul></li></ul><h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p><strong>短作业优先的调度算法</strong>(SJF，Shortest Job First) 以要求运行时间长短进行调度，即启动要求运行时间最短的作业;可以分别用于作业调度和进程调度</p><ul><li>短作业优先(SJF)的调度算法，是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行；</li><li>短进程优先(SPF)调度算法，则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。</li><li>优点<ul><li>能有效降低作业&#x2F;进程的平均等待时间</li><li>提高系统的吞吐量。</li></ul></li><li>缺点<ul><li>该算法对长作业不利，更严重的是可能将导致长作业(进程)长期不被调度</li><li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li><li>由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度</li><li>无法实现人机交互</li></ul></li></ul><h3 id="SRT"><a href="#SRT" class="headerlink" title="SRT"></a>SRT</h3><p><strong>最短剩余时间优先调度算法</strong>(SRT,Shortest Remaining Time) 调度时选择预期剩余时间最短的进程。当一个新进程加入到就绪队列时，它可能比当前运行的进程具有更短的剩余时间。因此，只要新进程就绪，调度器可能抢占当前正在运行的进程。可能存在长进程被饿死的危险。</p><h3 id="PSA"><a href="#PSA" class="headerlink" title="PSA"></a>PSA</h3><p><strong>优先权调度算法</strong>(PSA,Priority) 适合于作业调度和进程调度</p><ul><li><strong>优先权类型</strong><ul><li><strong>静态优先权</strong>:静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。优点是简单易行、系统开销小。缺点：不够精确，可能出现优先权低的作业或进程长期得不到调度的情况。</li><li><strong>动态优先权</strong>:动态优先权随进程的推进或随其等待时间的增加而改变，以获得更好的调度性能</li></ul></li><li><strong>确定进程优先权的依据有</strong><ul><li>进程类型: 系统进程高，一般用户进程低。</li><li>进程对资源的需求:进程的估计执行时间、内存需求量等。要求少的进程赋予较高的优先权。</li><li>用户要求:紧迫程度、所付费用。</li></ul></li><li><strong>非抢占式优先权算法</strong>（用于批处理、要求不严的实时 OS）系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。</li><li><strong>抢占式优先权调度算法</strong>（用于要求严格的实时、性能要求较高的批处理和分时 OS）系统把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。这种抢占式的优先权调度算法，能更好地满足<strong>紧迫作业</strong>的要求<br><strong>Note: 只要新的进程到达并加入到就绪队列中，就进行优先权比较</strong><ul><li><strong>高响应比优先调度算法</strong>(HRRN,High Response Ratio Next),优先权的变化规律可描述为：$优先权 &#x3D; \frac{等待时间+预计运行时间}{预计运行时间}$ 由于等待时间与预计运行时间之和，就是系统对该作业的响应时间，故该优先权又相当于响应比 RP。据此，又可表示为$R_p &#x3D; \frac{等待时间+预计运行时间}{预计运行时间} &#x3D; \frac{响应时间}{预计运行时间}$<blockquote><p>HRRN 是介于 FCFS 和 SJ(P)F 之间的一种折中算法,HRRN 调度算法的优点是能够较好地平衡服务时间短和等待时间长的进程，避免了“饥饿”现象。由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于 SJ(P)F 算法，从而采用 HRRN 方式时其吞吐量将小于采用 SJF 算法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。</p></blockquote></li></ul></li></ul><h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round-Robin"></a>Round-Robin</h3><p><strong>时间片轮转调度算法</strong>(RR，Round-Robin):时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法,适合于进程调度。</p><ul><li><strong>基本原理</strong><br>系统将所有就绪进程按 FCFS 原则，排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个<strong>时间片</strong>(Time Slice)。当时间片用完时，由一个计时器发出时钟中断请求，调度程序便根据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-02-21-04-08.png"></li><li><strong>Time Slice 大小确定</strong><br>需考虑系统对响应时间的要求,就绪队列中进程的数量,系统的处理能力(保证用户键入的命令能在一个时间片内处理完毕)<ul><li>时间片太短，会增加进程切换的开销，降低系统吞吐量</li><li>时间片太长，退化成 FCFS</li></ul></li><li><strong>优缺点</strong><br>时间片的大小对计算机性能的影响。<br>存在的问题：未有效利用系统资源。<br>对于短的、计算密集型任务(CPU-bound)比较有利，因为该进程充分利用时间片，而 I&#x2F;O 密集型(I&#x2F;O-bound)任务却不利(虽然进程大部分时间都在等待 I&#x2F;O，它仍然会被分配到 CPU 时间片。这可能导致 CPU 资源的浪费)<br>常用于分时系统及事务处理系统。</li></ul><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p><strong>多级队列调度算法</strong> (MQ,Multilevel Queue):就绪队列被分解为多个独立的队列，每个队列具有自己的调度算法。前台的就绪队列是交互性作业(Interactive Job)的进程，采用时间片轮转。后台的就绪队列是批处理作业(Batch Job)的进程，采用优先权或短作业优先算法。<br>调度方式有两种：① 优先调度前台，若前台无可运行进程，才调度后台 ② 分配占用 CPU 的时间比例，如：前台 80%，后台 20%</p><blockquote><p>什么是交互性作业(Interactive Job)和批处理作业(Batch Job)？<br>Interact Job: 与用户交互的作业,在执行这类作业时，用户可以输入命令，系统立即响应并返回结果;例如 UNIX shell 的<code>ls</code><br>Batch Job:批处理作业是在没有用户交互的情况下自动执行的一组命令或程序;些作业通常被组织成批次，一次性提交给系统，然后按照预定的顺序或优先级执行</p></blockquote><h3 id="MFQ"><a href="#MFQ" class="headerlink" title="MFQ"></a>MFQ</h3><p><strong>多级反馈队列调度算法</strong>(MFQ，Multilevel Feedback Queue):最通用的调度算法，多数 OS 都使用该方法或其变形，如 UNIX、Windows 等。它可以看作是更成熟的多级队列调度,其任务可以在队列之间移动,从而更细致的区分任务</p><blockquote><p>Note:MFQ 均为为抢占式;高优先级队列中有进程进入时，会抢占低优先级队列中进程的 CPU。被抢占的进程不降级，回到原级队列中，下次仍然执行该级队列的时间片。</p></blockquote><p><strong>MFQ 调度算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-02-21-45-44.png"></p><ul><li>设置多个就绪队列,记作 RQ0，RQ1 … RQn，并为各个队列赋予不同的优先级队列。 第一个队列的优先级最高，第二个次之，其余各队列的优先级逐个降低。规定高优先级队列时间片小</li><li>一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统；进程一次时间片没执行完，就降至下一级队列，以此类推，降至最低优先级队列后，一直在此队列中不再下降。</li><li>系统优先调度高优先级队列中的进程，仅当 RQ0 空闲时才调度 RQ1 队列进程，以此类推</li></ul><p><strong>MFQ 性能</strong></p><ul><li>对于终端型作业用户，其所提交的作业大都属于较小的交互型作业，系统只要使这些作业在箫 1 队列规定的时间片内完成，终端型作业用户就会感到满足。</li><li>对于短批处理作业用户，如果其作业在第 1 队列中执行一个时间片即可完成，便可获得与终端作业一样的响应时间。对于稍长批处理作业用户，其作业通常只须在第 2 队列和第 3 队列各执行 1 个时间片即可完成，周转时间仍然较短。</li><li>对于长批处理作业用户，其将依次在第 1,2…n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。因此，多级反馈队列调度算法能满足多用户需求。</li></ul><h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><ol><li><p>保证调度算法<br>保证的是绝对运行时间，即启动后在某个时间段内必须获得多少运行时间。<br>例如 N 个进程平均分配时间。</p></li><li><p>公平分享调度算法<br>按照用户数量平均分配时间，而不是进程间平均分配。</p></li></ol><blockquote><p>例：公平分享调度算法<br>用户 1 有 4 个进程 ABCD<br>用户 2 有 1 个进程 E</p><ol><li>时间片轮转法:<code>ABCDEABCDEABCDEABCDE……</code></li><li>所有用户获得相同的处理机时间:<code>AEBECEDEAEBECEDEAEBECEDE……</code></li><li>用户 1 获得的处理机时间是用户 2 的两倍:<code>ABECDEABECDEABECDEABECDE……</code></li></ol></blockquote><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>实时任务</strong>：任务的结束时间有严格约束(Deadline),即任务执行必须在 Deadline 之前完成;具有紧迫性。<br>前述算法不能很好地满足实时系统对调度的特殊要求，所以引入实时调度。<br><strong>实时操作系统 RTOS Real-Time Operating System</strong> 对外部输入的信息，实时操作系统能够在规定的时间内处理完毕并做出反应正确性:不仅要求计算逻辑的正确，而且要求在规定的时间内得到该结果通常给定一个开始时间或者结束时间的最后期限;多用于工业、军事等控制领域或实时信息处理方面<br><strong>硬实时系统</strong>有一个刚性的、不可改变的时间限制，它不允许任何超出时限的错误。超时错误会带来损害甚至导致系统失败、或者导致系统不能实现它的预期目标<br><strong>软实时系统</strong>的时限是柔性灵活的，它可以容忍偶然的超时错误。失败后造成的后果并不严重，例如在网络中仅仅轻微地降低了系统的吞吐量<br><strong>硬实时 HRT 与软实时 SRT</strong>之间最关键的差别在于：软实时只能提供统计意义上的实时。例如，有的应用要求系统在 95%的情况下都会确保在规定的时间内完成某个动作，而不一定要求 100%<br><strong>优先级倒置</strong>: 即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。</p><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ol><li>提供必要的调度信息</li></ol><ul><li>任务的到达时间,开始截止时间,执行时间,完成截止时间</li><li>资源要求</li><li>优先级(若错过开始截止时间则赋予“绝对”优先级)</li></ul><ol start="2"><li>系统处理能力强<br>若处理机的处理能力不够强，则有可能因处理机忙不过来而使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。<br>假定系统中有 m 个周期性的硬实时任务，它们的处理时间可表示为 Ci ，周期时间表示为 Pi，则在单处理机情况下，必须满足$\sum_{i&#x3D;1}^{m} \frac{C_i}{P_i} \leq 1$;若为多处理机系统,假设有 n 个处理机，则需满足$\sum_{i&#x3D;1}^{m} \frac{C_i}{P_i} \leq n$</li><li>采用抢占式调度机制:调度程序先调度开始截止时间即将到达的任务。</li><li>具有快速切换机制</li></ol><ul><li>具有快速响应外部中断的能力:及时响应紧迫的外部事件的中断请求</li><li>快速的任务分派能力:使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。</li></ul><h3 id="实时调度算法分类"><a href="#实时调度算法分类" class="headerlink" title="实时调度算法分类"></a>实时调度算法分类</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-05-20-46-52.png"></p><p><strong>非抢占式调度算法</strong></p><ol><li>非抢占式轮转调度算法（如工业生产群控系统）<br>调度程序每次选择队列中的第一个任务投入运行。该任务完成后，便把它挂在轮转队列的末尾，等待下次调度运行，而调度程序再选择下一个(队首)任务运行。<br>常用于要求不太严格的实时控制系统。</li><li>非抢占优先权调度算法<br>如果在实时系统中存在着要求较为严格(响应时间为数百毫秒)的任务，则可采用非抢占式优先调度算法为这些任务赋予较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后才能被调度执行。常用于有一定要求的实时控制系统。</li></ol><p><strong>抢占式调度算法</strong></p><ol><li>基于时钟中断的抢占式优先权调度算法</li><li>立即抢占(Immediate Preemption)的优先权调度算法</li></ol><h3 id="常见的实时调度算法"><a href="#常见的实时调度算法" class="headerlink" title="常见的实时调度算法"></a>常见的实时调度算法</h3><h4 id="最早截止时间优先即-EDF-Earliest-Deadline-First-算法"><a href="#最早截止时间优先即-EDF-Earliest-Deadline-First-算法" class="headerlink" title="最早截止时间优先即 EDF(Earliest Deadline First) 算法"></a>最早截止时间优先即 EDF(Earliest Deadline First) 算法</h4><p>优先级确定：根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。<br>实时任务就绪队列：按各任务截止时间的早晚排序；具有最早截止时间的任务排在队列的最前面。<br>调度顺序：总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。<br>适用范围：既可用于抢占式调度，也可用于非抢占式调度方式中。</p><h4 id="最低松弛度优先即-LLF-Least-Laxity-First-算法"><a href="#最低松弛度优先即-LLF-Least-Laxity-First-算法" class="headerlink" title="最低松弛度优先即 LLF(Least Laxity First)算法"></a>最低松弛度优先即 LLF(Least Laxity First)算法</h4><p>$Laxity &#x3D; Deadline - RemainingServiceTime - CurrentTime$<br>松弛度&#x3D;完成截止时间–剩余运行时间–当前时间 (假设从现在执行任务, 完成的时间为 t1, 则松弛度为截止时间-t1)</p><p>该算法按松弛度排序实时任务的就绪队列，松弛度值最小的任务排在队列最前面，调度程序总是选择就绪队列中的队首任务执行。<br>该算法主要用于可抢占调度方式中。</p><p><strong>抢占方式和时机</strong></p><ul><li>当等待任务的松弛度值为 0 时才进行抢占</li><li>当有任务执行时，只有等待任务的松弛度值为 0 才会发生任务的调度，其他情况不发生调度。</li><li>任务执行结束后或无任务执行时，再比较等待任务的松弛度值，较小的先执行。</li></ul>]]></content>
    
    
    <summary type="html">介绍处理机调度的层次 调度队列模型和调度准则调度算法 实时调度</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>应用层 ApplicationLayer Part Ⅱ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-2ApplicationLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-2ApplicationLayer/</id>
    <published>2024-03-28T12:41:49.000Z</published>
    <updated>2024-04-26T11:40:57.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS——The-Internet’s-Directory-Service"><a href="#DNS——The-Internet’s-Directory-Service" class="headerlink" title="DNS——The Internet’s Directory Service"></a>DNS——The Internet’s Directory Service</h2><h3 id="Services-Provided-by-DNS"><a href="#Services-Provided-by-DNS" class="headerlink" title="Services Provided by DNS"></a>Services Provided by DNS</h3><p>识别主机的两种方式：通过<strong>hostname</strong>或者<strong>IP address</strong>。人们喜欢记忆主机名标识方式，而路由器喜欢定长的、有着层次结构的 IP 地址。DNS 提供了一种将主机名转换为 IP 地址的服务。</p><p><strong>DNS(Domain Name System),域名系统</strong></p><ul><li>分布式数据库：一个由分层 DNS 服务器实现的分布式数据库</li><li>应用层协议：DNS 服务器实现域名转换,域名&#x2F;地址转换;DNS 协议运行在 <code>UDP</code>之下，使用 <code>53</code>号端口；<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-16-31.png"></li></ul><p><strong>DNS 服务器提供的功能</strong></p><ul><li>主机名到 IP 地址的转换（hostname to IP address translation）；</li><li>主机别名（host aliasing）：一个主机可以有一个规范主机名和多个主机别名,应用程序调用 DNS 获取主机别名对应的规范主机名（canonical hostname）以及主机的 IP 地址；</li><li>邮件服务器别名（mail server aliasing）；</li><li>负载分配（load distribution）：繁忙的站点被<strong>冗余分布在多台服务器</strong>上，每台服务器运行在不同的端系统上，每个都有着不同的 IP 地址。由于这些冗余的 Web 服务器，一个 IP 地址集合对应<strong>一个规范主机名</strong>。当客户对映射到某处到某地址集合的名字发出一个 DNS 请求时，该服务器用 IP 地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常<strong>总是向 IP 地址排在最前面的服务器发送 HTTP 请求报文</strong>，所以 DNS 就在所有这些冗余的 Web 服务器之间循环分配了负载；</li></ul><h3 id="Overview-of-How-DNS-Works"><a href="#Overview-of-How-DNS-Works" class="headerlink" title="Overview of How DNS Works"></a>Overview of How DNS Works</h3><h4 id="集中式设计的问题"><a href="#集中式设计的问题" class="headerlink" title="集中式设计的问题"></a>集中式设计的问题</h4><ul><li>单点故障（a single point of failure）；</li><li>通信容量（traffic volume）；</li><li>远距离的集中式数据库（distant centralized database）；</li><li>维护（maintenance）；</li></ul><h4 id="分布式-DNS-服务器的层次结构"><a href="#分布式-DNS-服务器的层次结构" class="headerlink" title="分布式 DNS 服务器的层次结构"></a>分布式 DNS 服务器的层次结构</h4><ul><li>Root DNS servers:负责记录顶级域名服务器的信息</li><li>Top-Level Domain DNS servers:负责顶级域名 com, org, net, edu, etc, 和所有国家的顶级域名 uk, fr, ca, jp.</li><li>Authoritative DNS servers:在因特网上具有公共可访问主机（如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。组织机构的权威 DNS 服务器负责保存这些 DNS 记录。</li><li>Local DNS servers:严格来说不属于该服务器的层次结构,每个 ISP（如居民区 ISP、公司、大学）都有一个本地 DNS,也叫默认服务器,当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器,它起着代理的作用，转发请求到层次结构中。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-18-29.png"></p><blockquote><p>PS:你可以通过<code>ipconfig /all</code>命令查看本地 DNS 服务器的地址。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Wireless LAN adapter WLAN:</span><br><span class="line">Connection<span class="literal">-specific</span> DNS Suffix . :</span><br><span class="line">Description . . . . . . . . . . . : Intel(<span class="built_in">R</span>) Wi<span class="literal">-Fi</span> <span class="number">6</span> AX200 <span class="number">160</span>MHz</span><br><span class="line">Physical Address. . . . . . . . . : <span class="number">48</span><span class="literal">-51-C5-27-0C-9F</span></span><br><span class="line">DHCP Enabled. . . . . . . . . . . : Yes</span><br><span class="line">Autoconfiguration Enabled . . . . : Yes</span><br><span class="line">IPv4 Address. . . . . . . . . . . : <span class="number">113.54</span>.<span class="number">231.1</span>(Preferred)</span><br><span class="line">Subnet Mask . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">224.0</span></span><br><span class="line">Lease Obtained. . . . . . . . . . : Thursday, March <span class="number">28</span>, <span class="number">2024</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">52</span> PM</span><br><span class="line">Lease Expires . . . . . . . . . . : Thursday, March <span class="number">28</span>, <span class="number">2024</span> <span class="number">3</span>:<span class="number">16</span>:<span class="number">27</span> PM</span><br><span class="line">Default Gateway . . . . . . . . . : <span class="number">113.54</span>.<span class="number">224.1</span></span><br><span class="line">DHCP Server . . . . . . . . . . . : <span class="number">113.54</span>.<span class="number">224.1</span></span><br><span class="line">DNS Servers . . . . . . . . . . . : <span class="number">202.112</span>.<span class="number">14.21</span></span><br><span class="line"><span class="number">202.112</span>.<span class="number">14.11</span></span><br><span class="line">NetBIOS over Tcpip. . . . . . . . : Enabled</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-41-23.png"></p></blockquote><h4 id="DNS-查询方法"><a href="#DNS-查询方法" class="headerlink" title="DNS 查询方法"></a>DNS 查询方法</h4><p><strong>递归 Recursive Query</strong>：客户端只发一次请求，要求对方给出最终结果。<br><strong>迭代 Iterated Quert</strong>：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-57-53.png"></p><h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><ul><li>一旦名字服务器获得 DNS 映射, 它将缓存该映射到局部内存<ul><li>服务器在一定时间后将丢弃缓存的信息</li><li>本地 DNS 服务器可以缓存 TLD 服务器的 IP 地址</li><li>因此根 DNS 服务器不会被经常访问</li></ul></li><li>权威 DNS 服务器记录更新：IETF 动态更新&#x2F;通报机制</li></ul><h3 id="DNS-Records-and-Messages"><a href="#DNS-Records-and-Messages" class="headerlink" title="DNS Records and Messages"></a>DNS Records and Messages</h3><h4 id="DNS-Resource-Records"><a href="#DNS-Resource-Records" class="headerlink" title="DNS Resource Records"></a>DNS Resource Records</h4><p>DNS 服务器中存储了大量的资源记录——Resource Record(RR),RR 是一个包含了下列字段的 4 元组<code>(name, value, type, ttl)</code><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-15-31-40.png"></p><h4 id="DNS-Messages"><a href="#DNS-Messages" class="headerlink" title="DNS Messages"></a>DNS Messages</h4><ul><li>Identification 标识符: 16 位，查询和应答报文使用相同的标识符</li><li>Flags 标志:有若干个标志构成，分别标识不同的功能<ul><li>查询&#x2F;应答－0&#x2F; 1</li><li>查询希望是&#x2F;非递归查询－1&#x2F;0</li><li>应答可&#x2F;否获得(支持)递归查询－1&#x2F;0</li><li>应答是&#x2F;否来自权威名字服务器－1&#x2F; 0</li></ul></li><li>Questions 问题部分:查询的 Name, type</li><li>Answers 回答部分:对于查询,应答的资源记录可以多个资源记录，由于可以有多个 IP 地址</li><li>Authority 权威部分:域对应的权威名字服务器的信息</li><li>Additional information 附加信息部分:权威名字服务器的 IP 地址等其他有帮助的记录.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-15-32-48.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dns.message</span><br><span class="line"><span class="keyword">import</span> dns.query</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 DNS 查询报文对象</span></span><br><span class="line">query = dns.message.make_query(<span class="string">&quot;baidu.com&quot;</span>, dns.rdatatype.ANY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 DNS 查询并接收响应报文,设置DNS服务器的IP地址为202.112.14.21</span></span><br><span class="line">response = dns.query.tcp(query, <span class="string">&quot;202.112.14.21&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印输出报文的信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Identification: <span class="subst">&#123;response.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Flags: <span class="subst">&#123;response.flags&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Questions: <span class="subst">&#123;response.question&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Answers: <span class="subst">&#123;response.answer&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Authority: <span class="subst">&#123;response.authority&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Additional information: <span class="subst">&#123;response.additional&#125;</span>&quot;</span>)</span><br><span class="line">[OUTPUT]</span><br><span class="line">Identification: <span class="number">41532</span></span><br><span class="line">Flags: <span class="number">33152</span></span><br><span class="line">Questions: [&lt;DNS baidu.com. IN ANY RRset: []&gt;]</span><br><span class="line">Answers: [&lt;DNS baidu.com. IN A RRset: [&lt;<span class="number">110.242</span><span class="number">.68</span><span class="number">.66</span>&gt;, &lt;<span class="number">39.156</span><span class="number">.66</span><span class="number">.10</span>&gt;]&gt;, &lt;DNS baidu.com. IN NS RRset: [&lt;ns7.baidu.com.&gt;, &lt;ns2.baidu.com.&gt;, &lt;dns.baidu.com.&gt;, &lt;ns3.baidu.com.&gt;, &lt;ns4.baidu.com.&gt;]&gt;]</span><br><span class="line">Authority: []</span><br><span class="line">Additional information: [&lt;DNS dns.baidu.com. IN A RRset: [&lt;<span class="number">110.242</span><span class="number">.68</span><span class="number">.134</span>&gt;]&gt;, &lt;DNS ns2.baidu.com. IN A RRset: [&lt;<span class="number">220.181</span><span class="number">.33</span><span class="number">.31</span>&gt;]&gt;, &lt;DNS ns3.baidu.com. IN A RRset: [&lt;<span class="number">153.3</span><span class="number">.238</span><span class="number">.93</span>&gt;, &lt;<span class="number">36.155</span><span class="number">.132</span><span class="number">.78</span>&gt;]&gt;, &lt;DNS ns4.baidu.com. IN A RRset: [&lt;<span class="number">111.45</span><span class="number">.3</span><span class="number">.226</span>&gt;, &lt;<span class="number">14.215</span><span class="number">.178</span><span class="number">.80</span>&gt;]&gt;, &lt;DNS ns7.baidu.com. IN A RRset: [&lt;<span class="number">180.76</span><span class="number">.76</span><span class="number">.92</span>&gt;]&gt;, &lt;DNS ns7.baidu.com. IN AAAA RRset: [&lt;240e:bf:b801:<span class="number">1002</span>:<span class="number">0</span>:ff:b024:26de&gt;, &lt;240e:<span class="number">940</span>:<span class="number">603</span>:<span class="number">4</span>:<span class="number">0</span>:ff:b01b:589a&gt;]&gt;]</span><br></pre></td></tr></table></figure><h2 id="Peer-to-Peer-File-Distribution"><a href="#Peer-to-Peer-File-Distribution" class="headerlink" title="Peer-to-Peer File Distribution"></a>Peer-to-Peer File Distribution</h2><ul><li>没有总是在线的服务器</li><li>任意端系统之间直接通信</li><li>对等方之间可以间断连接并可以改变 IP 地址</li></ul><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>BitTorrent 是一种用于高效分发文件的协议和技术。它是一种点对点（P2P）文件共享协议，允许用户在互联网上分享和下载文件。</p><p>相比于传统的文件下载方式，BitTorrent 采用了一种分布式的下载模式，使得文件可以同时从多个来源下载，从而提高了下载速度和可靠性。BitTorrent 协议的核心思想是让下载者同时充当上传者，即将下载好的文件块分享给其他下载者，从而实现文件的高效传输。</p><p>以下是 BitTorrent 的工作原理：</p><p>种子文件（Torrent File）的创建和分享：对于要被共享的文件，首先需要创建一个种子文件，该文件包含了文件的元数据和跟踪器（Tracker）的信息。跟踪器是协调下载者之间连接的服务器，帮助下载者找到其他参与文件共享的人。这个种子文件被分享给其他用户。</p><p>Peers 的连接和数据交换：下载者（也称为 Peer）通过 BitTorrent 客户端连接到跟踪器，并获取参与共享文件的其他 Peer 的信息。然后，下载者与这些 Peer 建立连接，开始交换文件块。下载者不仅从上传者下载文件块，也同时将自己已经下载好的文件块分享给其他下载者。</p><p>分块下载和校验：文件被分成小块（通常为 256KB 或 512KB），下载者通过与其他 Peer 交换文件块来逐步下载文件。每个文件块都有一个唯一的标识符，以便下载者之间进行正确的数据交换。下载者还会进行校验，确保下载的文件块的完整性和准确性。</p><p>做种（Seeding）：当下载者完全获得整个文件后，他们可以选择继续将文件保持在 BitTorrent 网络中作为种子继续分享给其他下载者，这称为做种。通过做种，更多的用户可以从他们那里下载文件，从而促进整个网络的稳定性和可扩展性。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-15-52-44.png"></p><h2 id="Video-Streaming-and-Content-Distribution-Networks"><a href="#Video-Streaming-and-Content-Distribution-Networks" class="headerlink" title="Video Streaming and Content Distribution Networks"></a>Video Streaming and Content Distribution Networks</h2><h3 id="HTTP-Streaming-And-DASH"><a href="#HTTP-Streaming-And-DASH" class="headerlink" title="HTTP Streaming And DASH"></a>HTTP Streaming And DASH</h3><p>HTTP 流所有客户接受到相同编码的视频，但对不同用户或者不同时间，客户可用的带宽大小有很大不同。<strong>HTTP 的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）</strong>：视频编码成几个不同的版本，其中每个版本具有不同的比特率，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒的视频段数据块。</p><p>每个视频版本存储在 HTTP 服务器中，每个版本都有一个不同的 URL。HTTP 服务器也有一个<strong>告示文件（manifest file）</strong>，为每个版本提供了一个 URL 及其比特率。</p><h3 id="Content-Distribution-Networks"><a href="#Content-Distribution-Networks" class="headerlink" title="Content Distribution Networks"></a>Content Distribution Networks</h3><p>如何从海量的视频中，挑选出某些内容，采用流的方式发送给成千上万的用户?<br>CDN 使用多台分布在全球各地的服务器（这些服务器被称为边缘节点），这些服务器存储了网站中内容的副本。当用户请求访问网站时，CDN 会根据用户的地理位置，选择距离用户最近的边缘节点来响应请求。</p><ul><li><strong>Private CDN</strong> 私有 CDN 是由单个组织或企业自己建立和管理的内容分发网络。它通常由该组织或企业在自己的数据中心或云环境中架设服务器节点，用于存储和分发自己的内容。私有 CDN 的优势在于对内容的控制权和安全性更高。</li><li><strong>Third-party CDN</strong> 第三方 CDN 是由专业的 CDN 提供商运营和管理的网络基础设施。这些提供商拥有全球分布的服务器节点，并为各种网站和应用提供内容分发服务。第三方 CDN 通过在全球各地部署服务器节点，将站点或应用的静态和动态内容缓存到离用户近的节点，并通过智能路由和负载均衡，将用户的请求引导到最近的节点。</li></ul><p><strong>CDN Operation:</strong></p><p>When a browser in a user’s host is instructed to retrieve a specific video (identified by a URL), the CDN must intercept(截获) the request so that it can</p><ol><li>Determine a suitable CDN server cluster(集群) for that<br>client at that time</li><li>Redirect the client’s request to a server in that cluster.<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-20-11-15.png"><blockquote><p>许多 CDN 利用 DNS 截获用户请求并将用户重定向到最近的 CDN 服务器。</p></blockquote></li></ol><p>如下是一个用户访问 NetCinema 网页中视频的过程：</p><ul><li>用户访问 NetCinema 的网页。</li><li>当用户点击链接<code>http://video.netcinema.com/6Y7B23V</code>时，用户的主机会发送一个寻找<code>video.netcinema.com</code>的 DNS 查询。</li><li>用户的本地 DNS 服务器（LDNS）将 DNS 查询转发到 NetCinema 的权威 DNS 服务器，该服务器注意到主机名<code>video.netcinema.com</code>中的字符串 video。为了将 DNS 查询交给 KingCDN，NetCinema 的权威 DNS 服务器不返回 IP 地址，而是返回 KingCDN 域中的主机名，例如<code>a1105.kingcdn.com</code></li><li>DNS 查询进入 KingCDN 的私有 DNS 基础设施;用户的 LDNS 然后发送查询<code>a1105.kingcdn.com</code>的请求;KingCDN 的 DNS 系统指定合适的 KingCDN 内容服务器,将其 IP 地址返回给 LDNS。</li><li>LDNS 将提供内容的 CDN 节点的 IP 地址转发给用户的主机。</li><li>一旦客户端收到 KingCDN 内容服务器的 IP 地址，它就会与该 IP 地址的服务器建立 TCP 连接，并发出一个 HTTP GET 请求获取视频。如果使用 DASH，服务器会首先向客户端发送一个清单文件，其中包含一个 URL 列表，每个版本的视频对应一个 URL，客户端会动态地从不同的版本中选择块。</li></ul><h2 id="Socket-Programming-Creating-Network-Applications"><a href="#Socket-Programming-Creating-Network-Applications" class="headerlink" title="Socket Programming: Creating Network Applications"></a>Socket Programming: Creating Network Applications</h2><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-20-40-38.png"></p>]]></content>
    
    
    <summary type="html">Application Layer Part Ⅱ,DNS,P2P,Video Streaming,CDN,Socket Programming</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>应用层 ApplicationLayer Part Ⅰ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-1ApplicationLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-1ApplicationLayer/</id>
    <published>2024-03-28T05:33:20.000Z</published>
    <updated>2024-04-02T09:09:10.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Principles-of-Network-Applications"><a href="#Principles-of-Network-Applications" class="headerlink" title="Principles of Network Applications"></a>Principles of Network Applications</h2><h3 id="Network-application-architecture"><a href="#Network-application-architecture" class="headerlink" title="Network application architecture"></a>Network application architecture</h3><p><strong>应用程序体系结构（application architecture）</strong>由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。现代网络应用程序中所使用的两种主流体系结构：<strong>the client-server architecture 和 the peer-to-peer (P2P) architecture.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-18-49-55.png"></p><h4 id="Client-Server-Architecture"><a href="#Client-Server-Architecture" class="headerlink" title="Client-Server Architecture"></a>Client-Server Architecture</h4><ul><li><p>Server</p><ul><li>总是在线（always on host）；</li><li>永久的 IP 地址（permanent IP address）；</li><li>配置在数据中心（often in data centers）；</li></ul></li><li><p>Client</p><ul><li>与服务器沟通联系；</li><li>被间歇性（intermittently）的连接；</li><li>拥有动态地址；</li><li>客户之间不直接联系；</li></ul></li></ul><h4 id="P2P-Architecture"><a href="#P2P-Architecture" class="headerlink" title="P2P Architecture"></a>P2P Architecture</h4><ul><li>没有总是打开的服务器</li><li>任意一对主机(peer)直接相互通信</li><li>对等方间歇连接并且可以改变 IP 地址</li><li>自我可扩展性 self-scalability</li></ul><blockquote><p>P2P (Peer-to-Peer) 网络的自我可扩展性（self-scalability）是指网络的能力，随着参与节点数量的增加，其性能和效率不会显著下降，甚至可能会提高。这种特性是由 P2P 网络的分散性和去中心化特性赋予的。<br>在许多传统的客户端-服务器模型中，所有的请求都会集中到一台或几台服务器上，随着用户数量的增加，服务器可能会遭受过载，导致性能下降。然而，在 P2P 网络中，每个节点都可以成为数据的提供者和消费者，因此负载可以在所有的节点上进行分布，使得网络能够更好地扩展。<br>然而，这并不意味着 P2P 网络没有扩展性问题。例如，当网络规模变得非常大时，查找和路由可能会变得复杂和昂贵。因此，需要使用高效的查找和路由算法，例如分布式哈希表（DHT），来确保网络的可扩展性。</p></blockquote><h4 id="C-S-与-P2P-混合的体系结构"><a href="#C-S-与-P2P-混合的体系结构" class="headerlink" title="C&#x2F;S 与 P2P 混合的体系结构"></a>C&#x2F;S 与 P2P 混合的体系结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-19-44-10.png"></p><h3 id="Processes-Communicating"><a href="#Processes-Communicating" class="headerlink" title="Processes Communicating"></a>Processes Communicating</h3><h4 id="Client-And-Server-Process"><a href="#Client-And-Server-Process" class="headerlink" title="Client And Server Process"></a>Client And Server Process</h4><ul><li>进程：运行在端系统中的程序[<a href="../../UESTC/OS/ProcessvsThread.md" title="Process &amp; Thread">ProcessVsThread#Definition</a>]</li><li>同一主机上的两个进程通过内部进程通信机制进行通信</li><li>不同主机上的进程通过交换报文(message)相互通信</li></ul><blockquote><p><strong>客户进程</strong>：发起通信的进程；<br><strong>服务进程</strong>：在会话开始时等待联系的进程；</p></blockquote><h4 id="The-Interface-Between-the-Process-and-the-Computer-Network"><a href="#The-Interface-Between-the-Process-and-the-Computer-Network" class="headerlink" title="The Interface Between the Process and the Computer Network"></a>The Interface Between the Process and the Computer Network</h4><p>大多数应用程序由许多<strong>互相通信的进程对</strong>(pairs of communicating processes)组成,任何两个进程之间发送的报文都需要经由底层的网络;<strong>套接字 Socket</strong>作为软件接口,向进程提供发送和接受报文功能</p><p>由于该套接字是建立网络应用的可编程接口，因此套接字被称为应用程序和网络之间的<strong>应用程序编程接口（Application Programming Interface，API）</strong>。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-20-09-22.png"></p><h4 id="Addressing-Processes"><a href="#Addressing-Processes" class="headerlink" title="Addressing Processes"></a>Addressing Processes</h4><ul><li><strong>IP Address</strong> 用于唯一标识 Internet 上的主机</li><li><strong>Port</strong> 用于标识目的主机的接受进程</li></ul><blockquote><p>发送进程还必须识别在主机中运行的接收进程（更具体地说，是接收信息的 Socket）。这个信息是必要的，因为通常一个主机可能运行着许多网络应用。目标端口号就是为了这个目的而设立的。一些流行的应用已经被分配了特定的端口号。例如，Web 服务器被标识为 80 号端口。邮件服务器进程（使用 SMTP 协议）被标识为 25 号端口。</p></blockquote><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-20-15-36.png" style="zoom:50%;" /></center><h3 id="Transport-Services-Available-to-Applications"><a href="#Transport-Services-Available-to-Applications" class="headerlink" title="Transport Services Available to Applications"></a>Transport Services Available to Applications</h3><ol><li><p><strong>Reliable Data Transfer</strong></p><ul><li>一些应用需要 100%可靠数据传输,如金融应用</li><li>loss-tolerant applications 允许丢包(loss),常见的有多媒体应用,如视频通话等</li></ul></li><li><p><strong>Throughout</strong></p><ul><li>具有吞吐量要求是应用程序被称为带宽敏感的应用（bandwidth-sensitive application）；</li><li>弹性应用（elastic application）能够根据当时可用的带宽或多或少地利用可供使用的吞吐量；</li></ul></li><li><p><strong>Timing</strong></p><ul><li>低延时（low delay）要求；</li></ul></li><li><p><strong>Security</strong></p><ul><li>传输数据的 Cryption&amp;Decryption</li><li>Confidentiality(保密性)<ul><li>数据完整性 Data Integrity</li><li>终端验证 end-point authentication</li></ul></li></ul><table><thead><tr><th>Application</th><th>Data Loss</th><th>Throughtput</th><th>Time-Senstive</th></tr></thead><tbody><tr><td>文件传输</td><td>No loss</td><td>elastic</td><td>no</td></tr><tr><td>电子邮件</td><td>No loss</td><td>elastic</td><td>no</td></tr><tr><td>Web</td><td>No loss</td><td>elastic</td><td>no</td></tr><tr><td>实时音频&#x2F;视频</td><td>Loss-tolernet</td><td>音频: 几 kbps-1Mbps</td><td>yes,100 msec</td></tr><tr><td>存储音频&#x2F;视频</td><td>Loss-tolernet</td><td>视频:10kbps-5Mbps</td><td>yes, 几秒</td></tr><tr><td>交互式游戏</td><td>Loss-tolernet</td><td>视频:10kbps-5Mbps</td><td>yesy, 100 msec</td></tr><tr><td>即时讯息</td><td>No loss</td><td>几 kbps 以上 elastic</td><td>yes and no</td></tr></tbody></table></li></ol><h3 id="Transport-Services-Provided-by-the-Internet"><a href="#Transport-Services-Provided-by-the-Internet" class="headerlink" title="Transport Services Provided by the Internet"></a>Transport Services Provided by the Internet</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-23-27-14.png"></p><ol><li><p><strong>TCP 服务</strong></p><ul><li><p>面向连接的服务（connection-oriented）：报文开始流动之前，TCP 让客户和服务器互相交换运输层控制信息（握手阶段），握手阶段后，一条 TCP 连接（TCP connection）就在两条进程的套接字之间建立；</p></li><li><p>可靠的数据传送服务（reliable transport）：无差别、按适当顺序交付所有发送的数据；</p></li><li><p>拥塞控制机制（congestion control）</p></li><li><p>安全套接字层（Secure Sockets Layer，SSL）提供了关键的进程到进程的安全性服务<br>🚥<code>http + SSL = https</code></p> <center> <img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-23-01-46.png" style="zoom:50%;" /> </center></li></ul></li><li><p><strong>UDP 服务</strong></p><ul><li>无连接</li><li>尽最大努力交付</li><li>面向报文</li><li>无拥塞控制</li><li>支持一对一，一对多，多对一和多对多的交互通信</li><li>首部开销小</li></ul></li></ol><h3 id="Application-Layer-Protocols"><a href="#Application-Layer-Protocols" class="headerlink" title="Application Layer Protocols"></a>Application Layer Protocols</h3><p>**应用层协议(Application Layer Protocols)**定义了在不同端系统上运行的应用程序进程如何相互传递消息。具体来说，应用层协议定义了：</p><ul><li>交换的消息类型，例如，请求消息和响应消息</li><li>报文类型的语法：报文中的各个字段及其详细描述</li><li>字段的语义，即包含在字段中的信息的含义</li><li>进程何时、如何发送报文及对报文进行响应</li></ul><p>应用层协议根据其是否公开可供所有人使用，可以分为两种类型：公共领域协议和专用协议:</p><ul><li><strong>公共领域协议</strong>:由 RFC 文档定义,可供所有人使用,例如 HTTP,SMTP,POP3</li><li><strong>专用协议</strong>:由公司或组织定义,例如 Skype, KaZaA</li></ul><blockquote><p>RFC，全称是 Request for Comments（征求意见书），是由互联网工程任务组（IETF）出版的一系列备忘录，用于描述、规定或者建议互联网标准、协议、程序、或者概念。RFC 文档是互联网技术和协议的主要来源，包括了诸如 TCP&#x2F;IP、HTTP、SMTP 等核心互联网协议的规范。<br>RFC 文档的内容可以是互联网社区的共识、工作小组的产品、个人的观点，或者只是为了获取公众的反馈。RFC 文档一旦发布，编号就不再改变，如果需要对 RFC 进行修改或者更新，会以新的 RFC 编号发布。<br>值得注意的是，尽管 RFC 是”征求意见书”的缩写，但是大部分 RFC 文档实际上是互联网标准的官方规范，而不仅仅是征求意见的提案。</p></blockquote><h3 id="Network-Applications"><a href="#Network-Applications" class="headerlink" title="Network Applications"></a>Network Applications</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-18-20-57.png"></p><h2 id="The-Web-and-HTTP"><a href="#The-Web-and-HTTP" class="headerlink" title="The Web and HTTP"></a>The Web and HTTP</h2><h3 id="Overview-of-HTTP"><a href="#Overview-of-HTTP" class="headerlink" title="Overview of HTTP"></a>Overview of HTTP</h3><ul><li><strong>网页 WebPage，或称 Document</strong>由许多<strong>对象 Object</strong>组成。</li><li>对象就是文件，可以是 HTML 文件, JPEG 图像, Java applet, 音频文件…</li><li>多数网页由单个<strong>基本 HTML 文件 base HTML</strong>和若干个所引用的对象构成</li><li>每个对象被一个 <strong>统一资源定位符 URL Uniform Resource Locator</strong>寻址</li><li><strong>Web 浏览器（Web browser）</strong>实现了 HTTP 的客户端；<strong>Web 服务器（Web server）</strong>实现了 HTTP 的服务器端；</li><li>HTTP 使用 TCP 作为运输协议；</li><li>HTTP 超文本传输协议（HyperText Transfer Protocol）</li><li>因为 HTTP 服务器不维护客户先前的状态信息， 是无状态协议（stateless protocol）；</li></ul><blockquote><p>维护状态的协议非常复杂</p><ul><li><p>必须维护过去历史 (状态信息)</p></li><li><p>如果 server&#x2F;client 崩溃, 它们各自的状态视图可能不一致, 因此必须保持协调一致。</p></li></ul></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.someschool.edu/someDept/pic.gif</span><br><span class="line">👆🏻协议      👆🏻主机名         👆🏻路径名</span><br></pre></td></tr></table></figure><h3 id="Non-Persistent-and-Persistent-Connections"><a href="#Non-Persistent-and-Persistent-Connections" class="headerlink" title="Non-Persistent and Persistent Connections"></a>Non-Persistent and Persistent Connections</h3><p><strong>非持久 HTTP 连接</strong></p><ul><li>每个 TCP 连接上只传送一个对象，下载多个对象需要建立多个 TCP 连接</li><li>HTTP&#x2F;1.0 使用非持久 HTTP 连接</li></ul><p><strong>持久 HTTP 连接</strong></p><ul><li>一个 TCP 连接上可以传送多个对象</li><li>HTTP&#x2F;1.1 默认使用持久 HTTP 连接</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-01-03.png"></p><blockquote><p><strong>往返时间（Round-Trip Time，RTT）</strong>定义：该时间是指一个短分组从客户到服务器然后在返回客户所需要的时间；[<a href="Ch1-NetworkOverview.md" title="Computer Networks Overview">Ch1-NetworkOverview#往返时间 Round Trip Time</a>]</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-02-41.png" style="zoom:50%;" /></center></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-35-15.png"></p><h3 id="HTTP-Message-Format"><a href="#HTTP-Message-Format" class="headerlink" title="HTTP Message Format"></a>HTTP Message Format</h3><p>终端输入<code>curl -v &quot;https://baidu.com&quot;</code>或使用 wireshark 等抓包工具可以</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> curl -v &quot;https://baidu.com&quot;</span><br><span class="line">* Host baidu.com:443 was resolved.</span><br><span class="line">* IPv6: (none)</span><br><span class="line">* IPv4: 110.242.68.66, 39.156.66.10</span><br><span class="line">*   Trying 110.242.68.66:443...</span><br><span class="line">* Connected to baidu.com (110.242.68.66) port 443</span><br><span class="line">* schannel: disabled automatic use of client certificate</span><br><span class="line">* ALPN: curl offers http/1.1</span><br><span class="line">* ALPN: server accepted http/1.1</span><br><span class="line">* using HTTP/1.x</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl/8.6.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 302 Moved Temporarily</span><br><span class="line">&lt; Server: bfe/1.0.8.18</span><br><span class="line">&lt; Date: Wed, 27 Mar 2024 07:08:02 GMT</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Content-Length: 161</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Location: http://www.baidu.com/</span><br><span class="line">&lt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;bfe/1.0.8.18&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Connection #0 to host baidu.com left intact</span><br></pre></td></tr></table></figure><h4 id="HTTP-Request-Message"><a href="#HTTP-Request-Message" class="headerlink" title="HTTP Request Message"></a>HTTP Request Message</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/somedir/page.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.someschool.edu</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">User-agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept-language</span><span class="punctuation">: </span>fr</span><br></pre></td></tr></table></figure><ul><li><strong>请求行 request line</strong>请求报文的第一行,其有 3 个字段：方法字段、URL 字段和 HTTP 版本字段；<ul><li>方法包含<code>GET,POST,HEAD,PUT,DELETE</code>；</li></ul></li><li><strong>首部行 header line</strong> 请求行后继的行叫作</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-57-34.png" alt="Request"></p><h4 id="HTTP-Response-Message"><a href="#HTTP-Response-Message" class="headerlink" title="HTTP Response Message"></a>HTTP Response Message</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">Connection：close</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sat, 06 Aug 2011 12:00:15 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/1.3.0 (Unix)</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Thu, 22 Jun 2011 …...</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>6821</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-haskell"><span class="class"><span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> ...</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong>状态行 status line</strong>响应报文的第一行,其有 3 个字段：HTTP 版本字段、状态码字段和状态码短语字段；</p></li><li><p><strong>首部行 header line</strong> 响应行后继的行叫作</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-17-21-22.png"></p></li></ul><blockquote><p><strong>HTTP 状态码</strong><br>1xx （信息性状态码）：表示服务器已经接收到请求，正在处理。</p><ul><li>100 Continue: 服务器已收到请求的初始部分，客户端应继续发送其余部分。</li><li>101 Switching Protocols: 服务器已经理解客户端的请求，并将切换到更适合的协议进行通信。</li></ul><hr><p>2xx （成功状态码）：表示请求已成功处理。</p><ul><li>200 OK: 请求成功，返回所请求的内容。</li><li>201 Created: 请求成功，并在服务器上创建了一个新的资源。</li><li>202 Accepted: 请求已被接受，但尚未处理完成。</li><li>204 No Content: 请求成功，但服务器没有返回任何内容。</li></ul><hr><p>3xx （重定向状态码）：表示需要进一步操作以完成请求。</p><ul><li>301 Moved Permanently: 被请求的资源已永久移动到新位置，并且将来的请求应使用新的 URL。</li><li>302 Found: 被请求的资源暂时移动到了新位置。</li><li>304 Not Modified: 资源未被修改，可以直接使用缓存的版本。</li></ul><hr><p>4xx （客户端错误状态码）：表示客户端发送了错误的请求。</p><ul><li>400 Bad Request: 客户端发送的请求语法错误。</li><li>401 Unauthorized: 请求需要身份验证。</li><li>403 Forbidden: 服务器拒绝了请求，客户端没有权限访问请求的资源。</li><li>404 Not Found: 请求的资源在服务器上未找到。</li></ul><hr><p>5xx （服务器错误状态码）：表示服务器在处理请求时发生了错误。</p><ul><li>500 Internal Server Error: 服务器在执行请求时遇到了未知的错误。</li><li>502 Bad Gateway: 作为代理或网关的服务器收到无效的响应。</li><li>503 Service Unavailable: 服务器暂时无法处理请求，通常是由于过载或维护。</li></ul></blockquote><h3 id="User-Server-Interaction-Cookies"><a href="#User-Server-Interaction-Cookies" class="headerlink" title="User-Server Interaction: Cookies"></a>User-Server Interaction: Cookies</h3><p>前面提到 HTTP 服务器为无状态的，而一个 Web 站点通常希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来。为此，HTTP 使用了 cookie(最初被称作 magic cookie)🍪<br><a href="https://en.wikipedia.org/wiki/Magic_cookie">Magic_cookie</a></p><p>cookie technology has four components:</p><ol><li>a cookie header line in the HTTP response message;</li><li>a cookie header line in the HTTP request message;</li><li>a cookie file kept on the user’s end system and managed by the user’s browser</li><li>a back-end database at the Web site.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-17-30-02.png"></p><p><strong>Cookies 跟踪用户</strong><br>cookies 允许网站更加了解你<br>你可以提供名字和 e-mail 给网站<br>广告公司通过网站获得信息<br>Cookies 不适合游动用户<br><strong>Cookie 可用于：</strong><br>跟踪用户在给定网站上的行为（第一方 cookie）<br>在多个网站上跟踪用户行为（第三方 cookie），而无需用户选择访问跟踪器网站！<br>跟踪可能对用户不可见：可能是一个不可见的链接<br>通过 Cookie 进行的第三方跟踪：在 Firefox、Safari 浏览器中默认禁用，将于 2023 年在 Chrome 浏览器中禁用</p><h3 id="Web-Caching-proxy-server"><a href="#Web-Caching-proxy-server" class="headerlink" title="Web Caching(proxy server)"></a>Web Caching(proxy server)</h3><p><strong>Web 缓存器 Web cache,也称代理服务器 proxy server</strong>，设计它的目标是代表<strong>初始 Web 服务器（origin server）</strong>满足 HTTP 请求;一般的，Web 缓存器既是服务器又是客户机,典型的缓存器由 ISP 提供（大学、公司或居民 ISP）;引入 Weh 缓存器减少了对客户机请求的响应时间,内部网络与接入链路上的通信量,并从整体上大大降低因特网上的 Web 流量</p><blockquote><p>如图,加入 cache 后,客户端请求的对象可能在缓存器中(称作缓存命中),缓存器直接返回给客户端;图中接入链路(access link)的速率为 15Mbps,远低于局域网的网络速率,$total delay &#x3D; LAN delay + access dalay + Internet delay$,可见接入时延为该例中提升传播速率的瓶颈;可选择更快的接入链路,但这需要更多的费用;而缓存器可以减少接入链路上的流量,从而减少接入时延,同时费用相对较低</p><p>LAN delay: 在局域网中传输一个报文所需的时间<br>Access delay: 在两个路由器之间传输一个报文所需的时间<br>Internet delay: 在因特网中传输一个报文所需的时间<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-18-50-25.png" style="zoom:50%;" /></p></blockquote><p><strong>Request Steps:</strong></p><ol><li>浏览器创建一个到 Web 缓存器的 TCP 连接，并向 Web 缓存器中的对象发送一个 HTTP 请求；</li><li>Web 缓存器进行检查，看看本地是否存储该对象副本。如果有，Web 缓存器向客户返回该对象；</li><li>如果缓存器中没有该对象，它就打开一个与该对象的初始服务器的 TCP 连接。Web 缓存器向初始服务器发送请求，并得到初始服务器的响应；</li><li>当 Web 缓存器接受对象后，在本地创建给对象的副本，并向客户发送响应报文返回该对象；<br>通过使用<strong>内容分发网络（Content Distribution Network，CDN）</strong>，Web 缓存器正在因特网中发挥着越来越重要的作用。[<a href="Ch6-2ApplicationLayer.md" title="应用层 ApplicationLayer Part Ⅱ">Ch6-2ApplicationLayer#Content Distribution Networks</a>]<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-17-35-49.png"></li></ol><p>尽管高速缓存器能减少用户感受到的响应时间，但引入了一个新的问题，即存放在缓存器中的副本可能陈旧的。为验证缓存器中的副本是否仍然有效，你可以使用<strong>条件 GET 请求</strong>,参照如下 python 代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义报文内容和首部</span></span><br><span class="line">request = <span class="string">&quot;GET /index.html HTTP/1.1\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;Host: www.baidu.com\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;If-Modified-Since: Sat, 01 Jan 2022 00:00:00 GMT\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;Connection: close\r\n\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建套接字并连接目标服务器</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送报文</span></span><br><span class="line">s.send(request.encode())</span><br><span class="line"></span><br><span class="line">response = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = s.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    response += data</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.decode())</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line">[OUTPUT]</span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Accept-Ranges: <span class="built_in">bytes</span></span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Length: <span class="number">9508</span></span><br><span class="line">Content-<span class="type">Type</span>: text/html</span><br><span class="line">Date: Fri, <span class="number">29</span> Mar <span class="number">2024</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">29</span> GMT</span><br><span class="line">P3p: CP=<span class="string">&quot; OTI DSP COR IVA OUR IND COM &quot;</span></span><br><span class="line">P3p: CP=<span class="string">&quot; OTI DSP COR IVA OUR IND COM &quot;</span></span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: BWS/<span class="number">1.1</span></span><br><span class="line"><span class="type">Set</span>-Cookie: BAIDUID=E79C6BEF6A7F8AA35FBC1FD6742520D8:FG=<span class="number">1</span>; expires=Thu, <span class="number">31</span>-Dec-<span class="number">37</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">55</span> GMT; <span class="built_in">max</span>-age=<span class="number">2147483647</span>; path=/; domain=.baidu.com</span><br><span class="line"><span class="type">Set</span>-Cookie: BIDUPSID=E79C6BEF6A7F8AA35FBC1FD6742520D8; expires=Thu, <span class="number">31</span>-Dec-<span class="number">37</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">55</span> GMT; <span class="built_in">max</span>-age=<span class="number">2147483647</span>; path=/; domain=.baidu.com</span><br><span class="line"><span class="type">Set</span>-Cookie: PSTM=<span class="number">1711717229</span>; expires=Thu, <span class="number">31</span>-Dec-<span class="number">37</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">55</span> GMT; <span class="built_in">max</span>-age=<span class="number">2147483647</span>; path=/; domain=.baidu.com</span><br><span class="line"><span class="type">Set</span>-Cookie: BAIDUID=E79C6BEF6A7F8AA30F2B2E6688EB66DE:FG=<span class="number">1</span>; <span class="built_in">max</span>-age=<span class="number">31536000</span>; expires=Sat, <span class="number">29</span>-Mar-<span class="number">25</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">29</span> GMT; domain=.baidu.com; path=/; version=<span class="number">1</span>; comment=bd</span><br><span class="line">Traceid: <span class="number">1711717229235279668210477533425964763324</span></span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=<span class="number">1</span></span><br><span class="line">X-Xss-Protection: <span class="number">1</span>;mode=block</span><br><span class="line">Connection: close</span><br><span class="line"><span class="comment"># html file</span></span><br><span class="line">data data ... data</span><br></pre></td></tr></table></figure><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>HTTP1.1：</p><ul><li>在单个 TCP 连接上引入了多个流水线 GET</li><li>服务器按顺序响应 GET 请求（FCFS: first-come-first-served scheduling）</li><li>对于 FCFS，小对象可能必须在大对象后面等待传输 head-of-line(HOL)blocking, 线头阻塞 HOL</li><li>丢失恢复（重新传输丢失的 TCP 段）对对象传输时间的影响</li></ul><p>HTTP&#x2F;2:[RFC 7540，2015]</p><ul><li>增加了服务器向客户端发送对象的灵活性</li><li>方法、状态代码、大多数头字段与 HTTP1.1 相比没有变化</li><li>基于客户端指定的对象优先级的请求对象的传输顺序（不一定是 FCFS）</li><li>将未请求的对象推送到客户端</li><li>将对象划分为帧 frames 以减少 HOL 阻塞<blockquote><p><a href="https://www.jianshu.com/p/63fe1bf5d445">详细分析 http2 和 http1.1 区别</a></p></blockquote></li></ul><p>HTTP&#x2F;3：通过 UDP 增加了安全性、每个对象的错误和拥塞控制（更多的流水线操作）</p><h2 id="Electronic-Mail-in-the-Internet"><a href="#Electronic-Mail-in-the-Internet" class="headerlink" title="Electronic Mail in the Internet"></a>Electronic Mail in the Internet</h2><p>邮箱系统的 3 个主要组成部分:</p><ul><li><strong>用户代理 user agents</strong><ul><li>允许用户阅读,回复,转发,保存,编辑邮件；</li><li>服务器上存储的传入和传出的消息；</li><li>例如：Outlook, foxmail 等</li></ul></li><li><strong>邮件服务器 mail servers</strong><ul><li>邮箱（mailbox）包括用户传入的消息；</li><li>报文队列（message queue）中为待发送的邮件报文；</li></ul></li><li><strong>简单邮件传送协议 SMTP</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-28-09-35-41.png"></li></ul><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><h4 id="SMTP-服务概述"><a href="#SMTP-服务概述" class="headerlink" title="SMTP 服务概述"></a>SMTP 服务概述</h4><p>SMTP（Simple Mail Transfer Protocol）是一种用于电子邮件传输的标准协议。它定义了电子邮件客户端（如邮件程序）和邮件服务器之间的通信规则，以便可靠地将邮件从发送方传递到接收方。</p><ul><li>SMTP 使用持久连接</li><li>SMTP 要求邮件消息(header &amp; body)必须是 7-bit ASCII</li><li>SMTP 服务器使用 CRLF.CRLF 来判断邮件消息的结束</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-28-09-59-42.png"></p><ul><li><strong>用户代理与发送服务器的连接</strong>：用户代理（例如电子邮件客户端）使用 SMTP 协议与发送服务器建立连接。连接过程包括身份验证和协议握手等步骤。<br>用户代理提交邮件：<br>用户代理将邮件发送到发送服务器。邮件的内容、收件人、发件人等信息被打包成一个 SMTP 消息。</li><li><strong>发送服务器的邮件传递</strong>：发送服务器接收到用户代理提交的邮件后，开始根据收件人的电子邮件地址确定邮件的路由。它可能会通过 DNS 查找 MX 记录来找到目标邮件服务器，并将邮件转发给目标邮件服务器。</li><li><strong>目标邮件服务器的接收与存储</strong>：目标邮件服务器接收到邮件后将其存储，并等待用户代理或接收器以后续协议（如 POP3 或 IMAP）请求获取邮件。</li><li><strong>用户代理收取邮件</strong>：用户代理使用 POP3 或 IMAP 协议从接收服务器上下载邮件，并将邮件显示在用户界面上供用户查看和管理。</li></ul><h4 id="SMAP-与-HTTP-的区别"><a href="#SMAP-与-HTTP-的区别" class="headerlink" title="SMAP 与 HTTP 的区别"></a>SMAP 与 HTTP 的区别</h4><table><thead><tr><th>特性</th><th>SMTP</th><th>HTTP</th></tr></thead><tbody><tr><td>协议类型</td><td>推协议 push protocol</td><td>拉协议 pull protocol</td></tr><tr><td>数据编码</td><td>要求采用 7 比特 ASCII 码格式</td><td>不受 7 比特 ASCII 码限制</td></tr><tr><td>消息传递</td><td>发送文件的机器发起 TCP 连接</td><td>接收文件的机器发起 TCP 连接</td></tr><tr><td>报文封装</td><td>所有报文对象放在一个报文中</td><td>每个对象封装在不同的 HTTP 响应报文中</td></tr></tbody></table><h3 id="Mail-Message-Format"><a href="#Mail-Message-Format" class="headerlink" title="Mail Message Format"></a>Mail Message Format</h3><p>一般格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To:发件人地址</span><br><span class="line">From:收件人地址</span><br><span class="line">Subject:邮件主题</span><br><span class="line"></span><br><span class="line">...邮件正文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>MIME</strong>: Multipurpose Internet mail Extensions 多用途因特网邮件扩展, RFC 2045, 2046;增添额外的信头头部声明 MIME content-type,实现多媒体邮件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">From: alice@crepes.fr</span><br><span class="line">To: bob@hamburger.edu</span><br><span class="line">Subject: Picture of yummy crepe.</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">base64 encoded data .....</span><br><span class="line">.........................</span><br><span class="line">......base64 encoded data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Mail-Access-Protocols"><a href="#Mail-Access-Protocols" class="headerlink" title="Mail Access Protocols"></a>Mail Access Protocols</h3><p>收件人的用户代理不能使用 SMTP 得到报文，因为取得报文是一个 pull 操作，而 SMTP 协议是一个 push 协议。通过引用一个特殊的邮件访问协议来解决这个问题，该协议将收件人邮件服务器上的报文传送给他的本地<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-28-13-22-24.png"></p><ul><li>SMTP: 递送&#x2F;存储邮件消息到接收者邮件服务器</li><li>邮件访问协议: 从服务器获取邮件消息<ul><li>POP3: Post Office Protocol-Version3 邮局协议[RFC 1939]110 端口号<br>身份认证 (代理 &lt;–&gt;服务器) 并 下载邮件消息</li><li>IMAP: Internet Message Access Protocol [RFC 3501] 143 端口<br>更多功能特征,允许用户像对待本地邮箱那样操纵远程邮箱的邮件</li><li>HTTP: Hotmail , Yahoo! Mail, etc.</li></ul></li></ul><p><strong>POP3 VS IMAP</strong></p><table><thead><tr><th>特性</th><th>POP3</th><th>IMAP</th></tr></thead><tbody><tr><td>邮件存储</td><td>下载邮件至本地客户端</td><td>在服务器上保留邮件副本</td></tr><tr><td>邮件同步</td><td>单设备上的邮件删除操作不会同步更新</td><td>多设备上的邮件操作同步更新</td></tr><tr><td>邮件管理</td><td>仅支持简单的邮件收发操作</td><td>支持复杂的邮件管理功能</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">ApplicationLayer Part Ⅰ,Principles of Network Applications,Web&amp;HTTP,Electronic Mail</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>Java Reflection</title>
    <link href="https://efterklang.github.io/Tech/Java/Java%20Reflection/"/>
    <id>https://efterklang.github.io/Tech/Java/Java%20Reflection/</id>
    <published>2024-03-25T04:31:26.000Z</published>
    <updated>2024-03-26T09:58:42.922Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Class&lt;?&gt; clazz = user.getClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java Reflection</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="Java" scheme="https://efterklang.github.io/categories/Tech/Java/"/>
    
    
    <category term="Java" scheme="https://efterklang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ARM指令分类</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch3-2ARM%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch3-2ARM%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB/</id>
    <published>2024-03-24T08:29:50.000Z</published>
    <updated>2024-04-27T11:23:40.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARM-指令集"><a href="#ARM-指令集" class="headerlink" title="ARM 指令集"></a>ARM 指令集</h2><h3 id="分支指令"><a href="#分支指令" class="headerlink" title="分支指令"></a>分支指令</h3><p>在 ARM 中有两种方式可以实现程序的跳转：<br>一种是使用分支转移指令直接跳转;<br>另一种则是直接向 PC 寄存器赋值来实现跳转。<br>ARM 的分支转移指令，可以从当前指令向前或向后的 32MB($2^{23}\times4&#x3D;2^{10} \times 2^{10} \times 32 $) 的地址空间跳转，根据完成的功能它可以分为 4 种:<code>B</code>、<code>BL</code>、<code>BX</code>、<code>BLX</code>。</p><blockquote><p>signed_immed_24 间接提供目标地址，真正的目标地址是由处理器根据这个有符号数和当前的 PC 值计算出来的。<br>具体计算为：先将 signed_immed_24 左移两位（即具有 26 位的偏移量），并扩展为 32 位有符号数，然后再将这 32 位有符号数与 PC 的当前值相加，得到实际的跳转地址。<br>因此 B 和 BL 指令转移的偏移量为 26 位，即转移的跨度为前后 32MB 地址空间。</p></blockquote><h4 id="跳转指令-B-及带连接的跳转指令-BL"><a href="#跳转指令-B-及带连接的跳转指令-BL" class="headerlink" title="跳转指令 B 及带连接的跳转指令 BL"></a>跳转指令 B 及带连接的跳转指令 BL</h4><p><code>B</code>指令与<code>BL</code>指令的编码格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-19-20-02-46.png"></p><p>从编码中看到 L 控制了 PC 与 LR 寄存器之间的开关。当 L&#x3D;0 时，该开关断开，指令为 B 指令;当 L&#x3D;1 时，该开关接通，指令为 BL 指令。<br>Signed_immed_24 表示 24 位有符号的立即数（偏移量）</p><p>B 和 BL 指令的助记符格式为：<br><code>B &#123;&lt;cond&gt;&#125; &lt;target&gt;和BL&#123;&lt;cond&gt;&#125;  &lt;target&gt;</code><br>cond 表示指令执行条件<br>target 表示跳转地址<br>功能：跳转到指定地址执行，地址范围限制在当前 PC 寄存器所指向的指令地址的 ±32MB 范围</p><p>跳转指令也叫程序转移指令。<br>写汇编程序时，可以跳转到一个绝对地址，如:<br><code>B 0x1234</code> （注： <code>B #0x1234</code> 是错误的 ）<br>编译器会把该绝对地址转换为相对地址放入指令中。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：现已知寄存器 R0 中存放了数据 a ，寄存器 R1 中存放了数据 b ，编写一个程序段，求取 a 和 b 的最大公约数并将其存入寄存器 R0 。</span><br><span class="line">gcb CMP R0,R1      ; 比较a和b的大小</span><br><span class="line">      SUBGT  R0,R0,R1; 如果a&gt;b,则a=a-b</span><br><span class="line">      SUBLT  R1,R1,R0; 如果a&lt;b,则b=b-a</span><br><span class="line">      BNE gcb        ; 如果a!=b,则返回gcb</span><br><span class="line">      MOV  PC,LR     ; 如果a=b,则返回主程序</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>B(Branch)和 BL(Branch with Link) 的区别在于</strong>：BL 在跳转之前会把 BL 指令的下一条指令地址（断点地址）保存到连接寄存器 LR（R14），因此程序在必要的时候可以通过将 LR 的内容加载到 PC 中，使程序返回到跳转点。<br>BL 这也是一个跳转指令，但它在跳转之前会将下一条指令的地址存储到链接寄存器（LR）中。这是为了在子程序或函数执行完毕后，能够返回到调用它的代码处继续执行。换句话说，BL 指令用于函数或子程序的调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    MOV R0, #5     ; 将5放入寄存器R0</span><br><span class="line">    BL  multiply    ; 调用multiply函数</span><br><span class="line">    B   end         ; 跳转到end标签</span><br><span class="line"></span><br><span class="line">multiply:</span><br><span class="line">    LSL R0, R0, #1 ; 将R0的值乘以2(逻辑左移)</span><br><span class="line">    MOV PC, LR     ; 返回到调用multiply的地方</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    ; 这里是程序结束的地方</span><br></pre></td></tr></table></figure><h4 id="带状态切换的跳转指令-BX"><a href="#带状态切换的跳转指令-BX" class="headerlink" title="带状态切换的跳转指令 BX"></a>带状态切换的跳转指令 BX</h4><p>BX 指令的格式为<code>BX&#123;&lt;cond&gt;&#125; Rm</code><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-19-20-42-39.png"><br>cond 表示指令执行条件<br>Rm 寄存器，值是绝对地址值，不是偏移量，在指令执行后，Rm 中的地址值与#0XFFFF FFFE 进行 AND 运算，再被复制到程序计数器 PC。<br>带状态切换的跳转。最低位(<code>Rm[0]</code>)为 1 时，切换到 Thumb 指令执行，为 0 时，解释为 ARM 指令执行</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">        <span class="meta">CODE32</span>         <span class="comment">;32位编码</span></span><br><span class="line"><span class="symbol">ARM1</span>   <span class="keyword">LDR</span> <span class="built_in">R0</span>，<span class="symbol">=Thumb1</span> <span class="comment">;把Thumb地址赋给R0，末位自动置1</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">LR</span>,<span class="built_in">PC</span>       <span class="comment">;设置返回地址</span></span><br><span class="line">        <span class="keyword">BX</span> <span class="built_in">R0</span>           <span class="comment">;跳转，切换状态</span></span><br><span class="line">        <span class="keyword">ADD</span> <span class="built_in">R1</span>,<span class="built_in">R2</span>,<span class="number">#2</span></span><br><span class="line">          …</span><br><span class="line">        <span class="meta">CODE16</span>          <span class="comment">;16位编码</span></span><br><span class="line"><span class="symbol">Thumb1</span>  <span class="keyword">ADD</span> <span class="built_in">R1</span>，<span class="built_in">R3</span>,<span class="number">#1</span>   <span class="comment">;Thumb程序</span></span><br><span class="line">         …</span><br><span class="line">        <span class="keyword">BX</span> <span class="built_in">LR</span>           <span class="comment">;跳转到返回地址，状态切换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="带连接和状态切换的连接跳转指令-BLX"><a href="#带连接和状态切换的连接跳转指令-BLX" class="headerlink" title="带连接和状态切换的连接跳转指令 BLX"></a>带连接和状态切换的连接跳转指令 BLX</h4><pre><code> BLX 指令的格式有两种：</code></pre><p><code>BLX &lt;target&gt; 和 BLX&#123;&lt;cond&gt;&#125;  Rm</code><br>以 target 方式提供目标地址的 BLX 指令的功能是：把程序跳转到指令中所指定的目标地址继续执行，并同时将处理器的工作状态从 ARM 状态切换到 Thumb 状态，并将下一条的地址保存到寄存器 LR 中。<br>而以 Rm 方式提供目标地址的 BLX 指令，除了跳转和下一条的地址保存到 LR 之外，也可进行状态切换，但其切换的依据是 Rm 最低位的值。如果值为 0 ，则目标地址处应为 ARM 指令，如果值为 1 ，则目标地址处应为 Thumb 指令</p><h4 id="修改-PC"><a href="#修改-PC" class="headerlink" title="修改 PC"></a>修改 PC</h4><p>另一种实现指令跳转的方式是通过直接向 PC 寄存器中写入目标地址值，实现在 4GB 地址空间中任意跳转，这种跳转又称为长跳转。<br>如果在长跳转指令之前使用“MOV LR，PC” 等指令，可以保存将来返回的地址值，也就实现了在 4GB 的地址空间中的子程序调用。</p><h3 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h3><h4 id="数据处理指令概述"><a href="#数据处理指令概述" class="headerlink" title="数据处理指令概述"></a>数据处理指令概述</h4><p><strong>1. ARM 数据处理指令的功能</strong><br>主要完成寄存器中数据的算术和逻辑运算操作。<br><strong>2. ARM 数据处理指令的特点</strong><br><strong>操作数来源</strong>:所有的操作数要么来自寄存器，要么来自立即数，不会来自存储器。<br><strong>操作结果</strong>:如果有结果，则结果一定是为 32 位宽、或 64 位宽（长乘法指令），并且放在一个或两个寄存器中，不会写入存储器。<br><strong>有第二个操作数 Operand2</strong> :切记其三种形式：立即数、寄存器、寄存器移位。特别地,乘法指令的操作数:全部是寄存器。</p><p><strong>3. ARM 数据处理指令分类</strong><br>算术运算指令：<code>ADD ADC SUB SBC RSB RSC MUL MLA UMULL UMLAL SMULL SMLAL</code><br>逻辑运算指令： <code>AND ORR EOR BIC</code><br>数据传送指令： <code>MOV MVN</code><br>比较指令： <code>CMP CMN</code><br>测试指令： <code>TST TEQ</code><br>上述指令只能对寄存器操作，不能针对存储器。</p><p><strong>4. 数据处理指令对程序状态寄存器 CPSR 的影响</strong><br>指令中可以添加 S 后缀，以影响 CPSR 状态标志。但是比较指令（CMP 和 CMN）和测试指令(TST 和 TEQ)不需要后缀 S，它们总会直接影响 CPSR 中的状态标志。</p><p><strong>关于恢复 CPSR 原值问题：</strong></p><blockquote><p>如果指令带有 S 后缀（除了比较指令以外），同时又以 PC 为目标寄存器进行操作:<br><strong>1. 在异常模式下</strong>：则操作的同时从 SPSR(Saved Program Status Register) 恢复 CPSR(Current Program Status Register)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movs pc, #0xff/* cpsr = spsr; pc = 0xff */</span><br><span class="line">adds pc, r1, #0xff00</span><br><span class="line">      /* cpsr = spsr; pc = r1 + 0xff00 */</span><br><span class="line">ands pc, r1, r2/* cpsr = spsr; pc = r1 &amp; r2; */</span><br></pre></td></tr></table></figure><p><strong>2. 在 user 或者 system 模式</strong>：会产生不可预料的结果，因为在这两种模式下没有 SPSR<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-20-13-47-39.png"></p></blockquote><h4 id="数据处理指令格式"><a href="#数据处理指令格式" class="headerlink" title="数据处理指令格式"></a>数据处理指令格式</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-15-08-00.png"></p><p>I 用于区别立即数(I&#x3D;1)或寄存器移位(I&#x3D;0)<br>opcode 为数据处理指令操作码<br>operand2 为第二个操作数，若指令不需要全部的可用操作数时(如 MOV 指令的 Rn)，不用的寄存器域应设置为 0(由编译器自动完成)。对于比较指令,b20 位固定为 1。</p><h4 id="Data-Processing-Instructions"><a href="#Data-Processing-Instructions" class="headerlink" title="Data Processing Instructions"></a>Data Processing Instructions</h4><h5 id="加减乘"><a href="#加减乘" class="headerlink" title="加减乘"></a>加减乘</h5><p><strong>ADD——加法运算指令</strong><br><code>ADD&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2; Rd&lt;-Rn+operand2</code></p><table><thead><tr><th><strong>受影响的 CPSR 标志位</strong></th><th><strong>取值</strong></th></tr></thead><tbody><tr><td><strong>N</strong></td><td>寄存器 Rd[31]被复制到 N</td></tr><tr><td><strong>Z</strong></td><td><strong>如果 Rd 为 0，则 Z&#x3D;1，否则 Z&#x3D;0</strong></td></tr><tr><td><strong>C</strong></td><td><strong>运算结果有进位 C&#x3D;1，否则 C&#x3D;0</strong></td></tr><tr><td><strong>V</strong></td><td><strong>运算结果有溢出 V&#x3D;1，否则 V&#x3D;0</strong></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD R0，R1，R2    ;R0←（R1）+（R2）</span><br><span class="line">ADD R0，R1，#255  ;R0 ←（R1）+ 255</span><br><span class="line">ADD R0，R2，R3，LSL#1  ;R0 ←（R2） +（R3&lt;&lt;1）</span><br></pre></td></tr></table></figure><p><strong>ADC——带进位加法指令</strong><br>指令格式：<code>ADC&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2</code><br>ADC 指令将 operand2 的数据与 Rn 的值相加，再加上 CPSR 中的 C 条件标志位，结果保存到 Rd 寄存器。<br>ADC 通常用来实现字长大于 32 位的加法运算。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-15-35-45.png"></p><p><strong>SUB——减法运算指令</strong><br>指令格式：<code>SUB&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2</code><br>SUB 指令用寄存器 Rn 减去 operand2，结果保存到 Rd 中</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUB R0，R1，R2 ;R0←（R1）-（R2）</span><br><span class="line">SUB R0，R1，#256;R0←（R1）- 256</span><br><span class="line">SUB R0，R2，R3，LSL#1;R0←（R2）-（R3&lt;&lt;1）</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>受影响的 CPSR 标志位</strong></th><th><strong>取值</strong></th></tr></thead><tbody><tr><td><strong>N</strong></td><td>寄存器 Rd[31]被复制到 N</td></tr><tr><td><strong>Z</strong></td><td><strong>如果 Rd 为 0，则 Z&#x3D;1，否则 Z&#x3D;0</strong></td></tr><tr><td><strong>C</strong></td><td><strong>运算结果有借位 C&#x3D;0，否则 C&#x3D;1</strong></td></tr><tr><td><strong>V</strong></td><td><strong>运算结果有溢出 V&#x3D;1，否则 V&#x3D;0</strong></td></tr></tbody></table><p><strong>SBC——带进位减法指令</strong><br>指令格式：<code>SBC&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2</code><br>SBC 指令用寄存器 Rn 减去 operand2，再减去 CPSR 中的 C 条件标志位的反码，结果保存到 Rd 中。<br>标志位的修改同 SUB。该指令主要用于字长大于 32 位的数据的减法运算。</p><p><strong>RSC——带进位反向减法指令</strong><br>指令格式：<code>RSC&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2</code><br>RSC 指令用寄存器 operand2 减去 Rn，再减去 CPSR 中的 C 条件标志位的反码，结果保存到 Rd 中。</p><p><strong>乘法指令格式</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-15-52-42.png"><br>其中，opcode 为乘法指令操作码。S 为设置条件码。Rm 为被乘数寄存器，Rs 为乘数的寄存器。Rn&#x2F;RdLo 用于 MLA 指令相加的寄存器或 64 位乘法指令的目标寄存器(低 32 位)。Rd&#x2F;RdHi 用于目标寄存器或 64 位乘法指令的目标寄存器(高 32 位)。若指令不需要全部的可用操作数时(如 MUL 指令的 Rn)，不用的寄存器域应设置为 0(由编译器自动完成)</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-15-42-19.png"><br><strong>MUL——32 位乘法指令</strong><br>指令格式：<code>MUL&#123;cond&#125;&#123;S&#125; Rd，Rm，Rs</code><br>MUL 指令将 Rm 和 Rs 中的值相乘，结果的低 32 位保存到 Rd 中</p><table><thead><tr><th>受影响的 CPSR 标志位</th><th>取值</th></tr></thead><tbody><tr><td>N</td><td>寄存器 Rd[31]被复制到 N</td></tr><tr><td>Z</td><td>如果 Rd 为 0 则 Z&#x3D;1，否则 Z&#x3D;0</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MUL    R1，R2，R3    ;R1=R2×R3</span><br><span class="line">MULS  R0，R3，R7    ;R0=R3×R7，</span><br><span class="line">                     ;设置CPSR的N位和Z位</span><br></pre></td></tr></table></figure><p><strong>MLA——32 位乘加指令</strong><br>格式 <code>MLA&#123;cond&#125;&#123;S&#125; Rd，Rm，Rs，Rn</code><br>指令将 Rm 和 Rs 中的值相乘，再将乘积加上第 3 个操作数，结果的低 32 位保存到 Rd 中。注： Rd ≠ Rm<br>标志位的修改同 MUL。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MLA R0,R1,R2,R3   ;R0←(R1)X(R2)+(R3)</span><br><span class="line">MLAS R0,R1,R2,R3   ;  R0←(R1)X(R2)+(R3),</span><br><span class="line">                               ;并更新CPSR标志位</span><br></pre></td></tr></table></figure><p><strong>UMULL—64 位无符号乘法指令</strong><br>指令格式：<code>UMULL&#123;cond&#125;&#123;S&#125; RdLo，RdHi，Rm，Rs;RdHi, RdLo← Rm*Rs</code><br>UMULL 指令将 Rm 和 Rs 中的值作无符号数相乘，结果的低 32 位保存到 RdLo 中，高 32 位保存到 RdHi 中<br>例：<code>UMULL R0，R1，R5，R8;(R1,R0)←R5×R8</code></p><table><thead><tr><th>受影响的 CPSR 标志位</th><th>取值</th></tr></thead><tbody><tr><td>N</td><td>寄存器 RdHi[31]被复制到 N</td></tr><tr><td>Z</td><td>如果 RdHi 且 Rdlo 为 0，则 Z&#x3D;1，否则 Z&#x3D;0</td></tr></tbody></table><p><strong>UMLAL—64 位无符号乘加指令</strong><br>指令格式：<code>UMLAL&#123;cond&#125;&#123;S&#125; RdLo，RdHi，Rm，Rs;RdHi, RdLo← Rm*Rs+ RdHi, RdLo</code><br>UMLAL 指令将 Rm 和 Rs 中的值作无符号数相乘，64 位乘积与 RdHi、RdLo 相加，结果的低 32 位保存到 RdLo 中，而高 32 位保存到 RdHi 中。<br>标志的修改同 UMULL。<br>指令举例如下：<br><code>UMLAL R0，R1，R5，R8;(R1,R0)←R5×R8+(R1,R0)</code></p><p><strong>SMULL—64 位有符号乘法指令</strong><br>指令格式：<code>SMULL&#123;cond&#125;&#123;S&#125; RdLo，RdHi，Rm，Rs; RdHi, RdLo← Rm*Rs</code><br>SMULL 指令将 Rm 和 Rs 中的值作有符号数相乘，结果的低 32 位保存到 RdLo 中，而高 32 位保存到 RdHi 中。<br>例如：<code>SMULL R2，R3，R7，R6;(R3,R2)←R7×R6</code></p><table><thead><tr><th>受影响的 CPSR 标志位</th><th>取值</th></tr></thead><tbody><tr><td>N</td><td>寄存器 RdHi[31]被复制到 N</td></tr><tr><td>Z</td><td>如果 RdHi 且 Rdlo 为 0，则 Z&#x3D;1，否则 Z&#x3D;0</td></tr></tbody></table><p><strong>SMLAL—64 位有符号乘加指令</strong><br>指令格式：<code>SMLAL&#123;cond&#125;&#123;S&#125; RdLo，RdHi，Rm，Rs; RdHi, RdLo← Rm*Rs+ RdHi, RdLo</code><br>SMLAL 指令将 Rm 和 Rs 中的值作有符号数相乘，64 位乘积与 RdHi、RdLo 相加，结果的低 32 位保存到 RdLo 中，高 32 位保存到 RdHi 中。<br>标志的修改同 SMULL。</p><blockquote><p>乘法指令的特点</p><ul><li>结果寄存器不能与第一源寄存器相同。</li><li>不支持第 2 操作数为立即数。</li><li>Rd、RdHi、RdLo 不能与 Rm 为同一寄存器。</li><li>RdHi 和 RdLo 不能为同一寄存器。</li><li>避免将 R15 定义为任一操作数或结果寄存器。</li><li>早期的 ARM 处理器仅支持 32 位乘法指令。ARM7 版本和后续的在名字中有 M 的处理器才支持 64 位乘法指令。</li><li>对标志位的影响<ul><li>对 N 标志位：若结果是 32 位指令形式，Rd 的第 31 位是标志位 N;对于产生长结果的指令形式，RdHi 的第 31 位是标志位。</li><li>对 Z 标志位：如果 Rd 或 RdHi、RdLo 为 0，则标志位 Z 置位。</li><li>对 V 标志位：乘法指令不影响 V 标志位。</li><li>对 C 标志位： ARM v5 及以上的版本不影响 C 标志位; ARM v5 以前的版本，C 标志位数值不确定。</li></ul></li></ul></blockquote><h5 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h5><ol><li><p>按位与指令（AND）<br>按位与指令用于将两个寄存器中的值进行按位与运算，并将结果存储在目标寄存器中。基本语法如下：<br><code>AND Rd, Rn, Operand2</code><br>其中，Rd 是目标寄存器，Rn 是第一个操作数所在寄存器，Operand2 是第二个操作数。<br>示例：<code>AND R0, R1, R2</code><br>这个指令将 R1 和 R2 中的值进行按位与运算，并将结果存储在 R0 中。</p></li><li><p>按位或指令（ORR）<br>按位或指令用于将两个寄存器中的值进行按位或运算，并将结果存储在目标寄存器中。基本语法如下：<br><code>ORR Rd, Rn, Operand2</code><br>其中，Rd 是目标寄存器，Rn 是第一个操作数所在寄存器，Operand2 是第二个操作数。<br>示例：<br><code>ORR R0, R1, R2</code><br>这个指令将 R1 和 R2 中的值进行按位或运算，并将结果存储在 R0 中。</p></li><li><p>按位异或指令（EOR）<br>按位异或指令用于将两个寄存器中的值进行按位异或运算，并将结果存储在目标寄存器中。基本语法如下：<br><code>EOR Rd, Rn, Operand2</code><br>其中，Rd 是目标寄存器，Rn 是第一个操作数所在寄存器，Operand2 是第二个操作数。<br>示例：<br><code>EOR R0, R1, R2</code><br>这个指令将 R1 和 R2 中的值进行按位异或运算，并将结果存储在 R0 中。</p></li><li><p>位清楚指令（BIC）<br>按位非指令用于对一个寄存器中的值进行按位取反，并将结果存储在目标寄存器中。基本语法如下：<br><code>BIC Rd, Rn, Operand2</code><br>BIC 指令将寄存器 Rn 的值与 Operand2 的值的反码按位逻辑与操作，结果保存到 Rd 中。<br>指令举例如下：<br><code>BIC R1，R1，#0x0F; 将R1的低4位清0,其它位不变 </code></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例：请把寄存器R2中的高8位数据传送到寄存器R3的低8位，原R3低24置换为高24位。</span><br><span class="line">MOV R0，R2，LSR #24;将R2右移24位，即将其高8位移至低8位送R0。</span><br><span class="line">ORR R3，R0，R3，LSL #8;将R3左移8位后将R0低8位送至R3。</span><br></pre></td></tr></table></figure><h5 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h5><p><code>MOV&#123;cond&#125;&#123;S&#125; Rd，operand2</code><br>MOV 指令将 operand2 传送到目标寄存器 Rd 中<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-16-10-41.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV R2，#0x7E; 将立即数 0x7E 传送到寄存器 R2 中</span><br><span class="line">MOVS R1，R0，LSL#3; 将寄存器 R0 * 8 传送到寄存器 R1，并影响标志位</span><br><span class="line">MOV PC，LR; PC←LR，子程序返回</span><br><span class="line">MOVS PC，LR; PC←LR，异常模式下返回 CPSR←SPSR</span><br></pre></td></tr></table></figure><blockquote><p>MOV 指令的功能总结</p><ul><li>寄存器之间传送。</li><li>立即数传送到寄存器中。（8 位立即数位图）</li><li>实现单纯的移位操作。MOV Rd，Rd，LSL，#3</li><li>实现子程序调用、从子程序中返回。当 PC 寄存器作为目标寄存器时可以实现程序跳转。</li><li>实现异常模式的返回，并把当前处理器模式的 SPSR 寄存器内容复制到 CPSR 中。</li></ul></blockquote><p><code>MVN&#123;cond&#125;&#123;S&#125; Rd，operand2</code><br>MVN 指令将 operand2 按位取反后传送到目标寄存器 Rd</p><h5 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h5><p><code>CMP&#123;cond&#125; Rn，operand2</code><br>CMP 指令将寄存器 Rn 的值减去 operand2 的值，但不存储运算结果，只根据操作的结果更新 CPSR 中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。</p><table><thead><tr><th>受影响的 CPSR 标志位</th><th>取值</th></tr></thead><tbody><tr><td>N</td><td>运算结果的第 31 位被复制到 N</td></tr><tr><td>Z</td><td>运算结果为 0 则 Z&#x3D;1，否则 Z&#x3D;0</td></tr><tr><td>C</td><td>运算结果有借位则 C&#x3D;0，否则 C&#x3D;1</td></tr><tr><td>V</td><td>运算结果有溢出则 V&#x3D;1，否则 V&#x3D;0</td></tr></tbody></table><p><code>CMN&#123;cond&#125; Rn，operand2</code><br>CMN 指令将寄存器 Rn 的值减去 operand2 的相反数（即加上 operand2 的值），但不存储运算结果，只根据操作的结果更新 CPSR 中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMN R0，#1;R0+1，判断R0是否为-1。</span><br></pre></td></tr></table></figure><h5 id="测试指令"><a href="#测试指令" class="headerlink" title="测试指令"></a>测试指令</h5><p><code>TST&#123;cond&#125; Rn，operand2</code><br>TST 指令将寄存器 Rn 的值与 operand2 的值按位逻辑“与”操作，但不存储运算结果，只根据操作的结果更新 CPSR 中的相应条件标志位。该指令一般用来检测是否设置了特定的位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TST R0，#0x01;判断 R0 的最低位是否为 0</span><br><span class="line">TST Rl，#0x0F;判断 R1 的低 4 位是否为 0</span><br></pre></td></tr></table></figure><p><code>TEQ&#123;cond&#125; Rn，operand2</code><br>TEQ 指令将寄存器 Rn 的值与 operand2 的值按位逻辑“异或”操作，但不存储运算结果，只根据操作的结果更新 CPSR 中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。<br>指令举例如下：<br><code>TEQ R0，R1;比较 R0 与 R1 是否相等；(不影响 V 位和 C 位)</code></p><h3 id="存储器访问指令"><a href="#存储器访问指令" class="headerlink" title="存储器访问指令"></a>存储器访问指令</h3><p>ARM 微处理器用加载&#x2F;存储指令访问存储器，实现在寄存器和存储器之间传送数据。<br>由于 ARM 处理器对外设寄存器、I&#x2F;O 映射空间与存储器统一编址，因此，对外围设备的 I&#x2F;O 操作也用此类指令。<br>基本的加载&#x2F;存储指令仅有 5 条，分为 3 种：</p><ul><li>LDR 和 STR，单寄存器加载&#x2F;存储指令</li><li>LDM 和 STM，多寄存器加载&#x2F;存储指令</li><li>SWP，寄存器和存储器数据交换指令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2ARM%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB-2024-03-24-21-49-34.png"><br>其中，I、P、U、W 用于区别不同的地址模式(偏移量)</p><ul><li>I 为 0 时，偏移量为 12 位立即数；I 为 1 时，偏移量为寄存器移位；</li><li>P 表示前&#x2F;后变址，U 表示加&#x2F;减，W 表示回写(！后缀)</li><li>L 用于区别加载(L 为 1 时)或存储(L 为 0 时)</li><li>B 用于区别字节访问(B 为 1 时)或字访问(B 为 0 时)</li><li>Rn 为基址寄存器，Rd 为源&#x2F;目标寄存器。</li></ul><h4 id="单寄存器加载-存储指令"><a href="#单寄存器加载-存储指令" class="headerlink" title="单寄存器加载&#x2F;存储指令"></a>单寄存器加载&#x2F;存储指令</h4><p>单寄存器加载&#x2F;存储指令是 ARM 在<strong>寄存器</strong>和<strong>存储器</strong>间传送单个字节和字的最灵活方式。</p><blockquote><p>LDR（Load Register）：这是一个加载指令，用于从内存中读取数据并将其加载到寄存器中。其基本格式为 LDR Rd, [Rn]，其中 Rd 是目标寄存器，Rn 是包含要读取的内存地址的寄存器;例如，LDR R1, [R2] 会将存储在 R2 寄存器所指向的内存地址中的数据加载到 R1 寄存器中。<br>STR（Store Register）：这是一个存储指令，用于将寄存器中的数据写入到内存中。其基本格式为 STR Rd, [Rn]，其中 Rd 是源寄存器，Rn 是包含要写入的内存地址的寄存器。例如，STR R1, [R2] 会将 R1 寄存器中的数据存储到 R2 寄存器所指向的内存地址中。</p></blockquote><p>根据传送数据的类型不同，单个寄存器存取指令又可以分为以下两类：<br>单字和无符号字节的加载&#x2F;存储指令<br>半字和有符号字节的加载&#x2F;存储指令</p><h5 id="单字和无符号字节的加载／存储指令"><a href="#单字和无符号字节的加载／存储指令" class="headerlink" title="单字和无符号字节的加载／存储指令"></a>单字和无符号字节的加载／存储指令</h5><p>LDR：指令从内存中取 32 位字或 8 位无符号字节数据放入寄存器；<br>STR：指令将寄存器中的 32 位字或 8 位无符号字节数据保存到存储器中。</p><p>注意：无符号字节加载时，用 0 将 8 位的操作数扩展到 32 位。</p><p><strong>Instruction Format</strong><br>LDR{cond}{T} Rd，&lt;地址&gt;;加载指定地址上的字数据，放入 Rd 中。<br>STR{cond}{T} Rd，&lt;地址&gt;;存储 Rd 中字数据，到指定地址的存储单元。<br>LDR{cond}B{T} Rd，&lt;地址&gt;;加载字节数据到 Rd 低 8 位数据位中，高 24 位为 0。<br>STR{cond}B{T} Rd，&lt;地址&gt;;存储 Rd 中字节数据， Rd 中最低字节为传送数据</p><p><strong>Postfix</strong><br>T 为可选后缀，若指令有 T，存储系统将访问看成是处理器是在用户模式下。<br>用于存储器保护。<br>不能与后变址模式、自动变址模式一起使用（即不能改变基址寄存器值）。<br>T 在用户模式下无效</p><p><strong>Addressing</strong><br>LDR&#x2F;STR 指令为基址变址寻址[<a href="Ch3-1ARM%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0.md" title="ARM指令集概述">Ch3-1ARM指令概述.md#基址变址寻址 Base-index Addressing</a>]（或寄存器间接寻址），由两部分组成：</p><ul><li><strong>基地址部分</strong>：为一个基址寄存器，可以为任一个通用寄存器；</li><li><strong>偏移地址部分</strong>：这一部分非常灵活，实际就类似第二个操作数，可以有以下 3 种格式：<ul><li><strong>立即数</strong>:12 位立即数是一个无符号的数值。这个数据可以加到基址寄存器，也可以从基址寄存器中减去这个数值</li><li><strong>寄存器</strong>:寄存器中的数值(无符号数)可以加到基址寄存器，也可以从基址寄存器中减去这个数值</li><li><strong>寄存器及移位常数</strong>:寄存器移位后的值(无符号数)可以加到基址寄存器，也可以从基址寄存器中减去这个数值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LDR R1，[R0，#0x10];</span><br><span class="line">LDR R1，[R0，# -0x10];</span><br><span class="line">LDR R1，[R0，R2]</span><br><span class="line">LDR R1，[R0，-R2]</span><br><span class="line">LDR R1，[R0，R2，LSL #2] 将R0+R2×4地址处的数据读出,保存到R1中(R0、R2的值不变)</span><br><span class="line">LDR R1，[R0，-R2，LSL #2] 将R0-R2×4地址处的数据读出,保存到R1中(R0、R2的值不变)</span><br></pre></td></tr></table></figure><blockquote><p>PC（即 R15）使用的几个问题<br>使用 PC 作为基址时，使用的数值是当前执行指令的地址加 8 个字节（取指与执行相差 8 个字节）。<br>PC 不能用做偏移寄存器，也不能用于任何变址寻址模式。<br>把一个字加载到 PC，将使程序转移到所加载的地址，这是一个公认的实现跳转的方法。但是应当避免将一个字节加载到 PC。<br>把 PC 存到存储器的操作在不同体系结构的处理器中产生不同的结果，应尽可能避免。</p></blockquote></li></ul></li></ul><h4 id="多寄存器的存取指令"><a href="#多寄存器的存取指令" class="headerlink" title="多寄存器的存取指令"></a>多寄存器的存取指令</h4><p>LDM 和 STM 指令可以实现在一组寄存器和一块连续的内存单元之间存&#x2F;取数据。<br>LDM 为加载多个寄存器；STM 为存储多个寄存器。<br>这两条指令，允许传送 16 个寄存器 R0—R15 的任何子集或所有寄存器。</p><p><code>LDM&#123;cond&#125;&lt;模式&gt; Rn&#123;!&#125;，&lt;reglist&gt;&#123;^&#125;</code><br><code>STM&#123;cond&#125; &lt;模式&gt; Rn&#123;!&#125;，&lt;reglist&gt;&#123;^&#125;</code><br>（1）Rn：表示基址寄存器，装有传送数据的初始地址，Rn 不允许为 R15（即 PC）。<br>（2）Rn 后缀“!”：表示最后的地址写回到 Rn 中。<br>（3）Reglist：表示寄存器列表，其中包含一个或多个寄存器。当寄存器不连续时，中间使用“，”隔开。例如：{R1，R2，R6-R9}<br>列表寄存器和存储器地址的关系规则：编号低的寄存器对应于存储器中低地址单元，编号高的寄存器对应于存储器中高地址单元。<br>(4)后缀“^”说明<br>寄存器列表不包含 PC：使用后缀“^”进行数据传送时，加载／存储的是用户模式的寄存器，而不是当前模式的寄存器。<br>寄存器列表包含有 PC：除了正常的多寄存器传送外，还要将 SPSR 拷贝到 CPSR 中。该用法可用于异常处理返回。<br>禁用情况：后缀“^”不允许在用户模式或系统模式下使用。 ，因为它们没有 SPSR<br>（5）当 Rn 在寄存器列表中且使用后缀“!”<br>对于 STM 指令，若 Rn 为寄存器列表中的最低序号的寄存器，则会将 Rn 的初值保存；<br>其它情况下 Rn 的编译无法通过。<br>（6）地址字对齐<br>这些指令寻址是字对齐的，即忽略地址位[1:0]。</p><h3 id="协处理器指令"><a href="#协处理器指令" class="headerlink" title="协处理器指令"></a>协处理器指令</h3><p>略</p><h3 id="杂项指令"><a href="#杂项指令" class="headerlink" title="杂项指令"></a>杂项指令</h3><p>主要由两种类型指令组成，程序状态寄存器操作指令、中断操作指令，一共有 5 条指令。</p><p>状态寄存器操作指令：<br>MRS：读程序状态寄存器指令<br>MSR：写程序状态寄存器指令<br>异常中断操作指令：<br>SWI： 软件中断指令<br>BKPT：断点指令（v5T 体系）<br>CLZ： 前导 0 计数（v5T 体系）</p>]]></content>
    
    
    <summary type="html">ARM指令分类</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM-Processor" scheme="https://efterklang.github.io/categories/UESTC/ARM-Processor/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>ARM指令集概述</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch3-1ARM%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch3-1ARM%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0/</id>
    <published>2024-03-24T08:27:30.000Z</published>
    <updated>2024-04-27T11:23:40.578Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARM-指令集简介"><a href="#ARM-指令集简介" class="headerlink" title="ARM 指令集简介"></a>ARM 指令集简介</h2><p>ARM 微处理器的 ARM 指令集 ，所有的指令长度都是 32 位 ，并且大多数指令都在一个单独指令周期内执行。<br><strong>主要特点包括</strong>：</p><ul><li>指令是条件执行的;</li><li>ARM 微处理器的指令集是加载&#x2F;存储型的;</li><li>在多寄存器操作指令中一次最多可以完成 16 个寄存器的数据传送。</li></ul><h3 id="ARM-Instruction-Format"><a href="#ARM-Instruction-Format" class="headerlink" title="ARM Instruction Format"></a>ARM Instruction Format</h3><h4 id="助记符表示"><a href="#助记符表示" class="headerlink" title="助记符表示"></a>助记符表示</h4><p>用助记符表示的 ARM 指令格式如下：<br><code>&lt;opcode&gt; &#123;&lt;cond&gt;&#125; &#123;S&#125; &#123;&lt;Rd&gt;&#125; &#123; ，&lt;Rn&gt;&#125; &#123;，&lt;OP2&gt;&#125;</code><br>格式中 <code>&lt; &gt;</code>的内容必不可少，<code>&#123; &#125;</code>中的内容可省略。</p><p><code>&lt;opcode&gt;</code>表示操作码，如 ADD 表示算术加法。<br><code>&#123;&lt;cond&gt;&#125;</code>表示指令执行的条件域，如 EQ、NE 等。<br><code>&#123;S&#125;</code>决定指令的执行结果是否影响 CPSR 的值，使用该后缀则指令执行的结将果影响 CPSR 的值，否则不影响。<br><code>&lt;Rd&gt;</code>表示目标或源寄存器。<br><code>&lt;Rn&gt;</code>表示第一个操作数，为寄存器。<br><code>&lt;op2&gt;</code>表示第二个操作数，可以是立即数、寄存器和寄存器移位操作数。<br>除了 <code>&lt;opcode&gt;</code>其余域都可以选择使用</p><blockquote><p><strong>例如</strong>： 指令 <code>ADDEQS R0,R1,#8;</code></p><ul><li>操作码为 ADD，</li><li>条件域 cond 为 EQ，</li><li>S 表示该指令的执行影响 CPSR 寄存器的值，</li><li>目的寄存器 Rd 为 R0，</li><li>第一个操作数寄存器 Rn 为 R1，</li><li>第二个操作数 OP2 为立即数＃8。<br>执行结果：R0 &#x3D; R1+ 8</li></ul></blockquote><h4 id="机器码表示"><a href="#机器码表示" class="headerlink" title="机器码表示"></a>机器码表示</h4><p>ARM 指令代码一般可以分为 5 个域：<br>第 1 个域是 4 位[31:28]的条件码域，4 位条件码共有 16 种组合;<br>第 2 个域是指令代码域[27:20],除了指令编码外，还包含几个很重要的指令特征和可选后缀的编码;<br>第 3 个域是第 1 个操作数寄存器 Rn，是 4 位[19:16],为 R0 ～ R15 共 16 个寄存器编码;<br>第 4 个域是目标或源寄存器 Rd，是 4 位[15:12],为 R0 ～ R15 共 16 个寄存器编码;<br>第 5 个域是第二个操作数[11:0]。</p><h4 id="可选后缀"><a href="#可选后缀" class="headerlink" title="可选后缀"></a>可选后缀</h4><ol><li><strong>S 后缀</strong></li></ol><p>指令中使用 S 后缀时，指令执行后程序状态寄存器的条件标志位将被刷新，不使用 S 后缀时，指令执行后程序状态寄存器 CPSR 的条件标志将不会发生变化。</p><blockquote><p>假设 R0&#x3D;0x1,R3&#x3D;0x3,指令执行之前 CPSR 部分标志位为 nZcv,分别执行如下指令 CPSR 的值有何变化？<br><code>SUB R1,R0,R3; R0的值减去R3的值，结果存入R1</code> &gt; <code>SUBS R1,R0,R3; R0的值减去R3的值，结果存入R1影响标志位。</code><br>分析：执行第 1 条指令对于标志寄存器的值没有任何影响，因此 CPSR 的值不变。执行第 2 条指令后 CPSR&#x3D;Nzcv。</p></blockquote><ol start="2"><li><strong>!后缀</strong></li></ol><p>如果指令地址表达式中不含！后缀，则基址寄存器中的地址值不会发生变化。<br>指令中的地址表达式中含有!后缀时，指令执行后，基址寄存器中的地址值将发生变化，变化的结果如下：<br>基址寄存器中的值（指令执行后）＝指令执行前的值＋地址偏移量<br>使用!后缀需要注意如下事项：</p><pre><code>- ！后缀必须紧跟在地址表达式后面，而地址表达式要有明确的地址偏移量;- ! 后缀不能用于 R15(PC)的后面;- 当用在单个地址寄存器后面时，必须确信这个寄存器有隐性的偏移量，例如“STMIA R7!, &#123;R0 – R3&#125;”此时地址基址寄存器 R7 的隐性偏移量是 16 字节。如果 R7 的初始值为 0X40000000，则该语句结束后为 0X40000010</code></pre><blockquote><p>例 分别执行下面两条指令有何区别？<br><code>LDR R3,[R0,#4]</code> &gt; <code>LDR R3,[R0,#4]！</code><br>分析：在上述指令中，第 1 条指令没有后缀！，指令的结果是把 R0 加 4 作为地址指针，把这个指针所指向的地址单元所存储的数据读入 R3，R0 的值不变。第 2 条指令除了实现以上操作外，还把 R0 ＋ 4 的结果送到 R0 中。</p></blockquote><ol start="3"><li><strong>B 后缀</strong><br>B 后缀的含义是：指令所涉及的数据是一个字节，不是一个字或半字。<br><code>LDR R4，[R0]</code><br>R4&#x3D;[R0]，指令传送一个字<br><code>LDRB R4，[R0]</code><br>R4&#x3D;[R0]，指令传送一个字节<br><code>LDREQB R4，[R0]</code><br>如果相等则执行，R4&#x3D;[R0]，指令传送一个字节</li></ol><h3 id="ARM-指令的条件码"><a href="#ARM-指令的条件码" class="headerlink" title="ARM 指令的条件码"></a>ARM 指令的条件码</h3><table><thead><tr><th><strong>条件码</strong></th><th><strong>条件码助记符</strong></th><th><strong>CPSR 中条件标志位值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>0000</strong></td><td><strong>EQ</strong></td><td><strong>Z&#x3D;1</strong></td><td><strong>相等</strong></td></tr><tr><td><strong>0001</strong></td><td><strong>NE</strong></td><td><strong>Z&#x3D;0</strong></td><td><strong>不相等</strong></td></tr><tr><td><strong>0010</strong></td><td><strong>CS&#x2F;HS</strong></td><td><strong>C&#x3D;1</strong></td><td><strong>无符号数大于或等于</strong></td></tr><tr><td><strong>0011</strong></td><td><strong>CC&#x2F;LO</strong></td><td><strong>C&#x3D;0</strong></td><td><strong>无符号数小于</strong></td></tr><tr><td><strong>0100</strong></td><td><strong>MI</strong></td><td><strong>N&#x3D;1</strong></td><td><strong>负数</strong></td></tr><tr><td><strong>0101</strong></td><td><strong>PL</strong></td><td><strong>N&#x3D;0</strong></td><td><strong>正数或零</strong></td></tr><tr><td><strong>0110</strong></td><td><strong>VS</strong></td><td><strong>V&#x3D;1</strong></td><td><strong>溢出</strong></td></tr><tr><td><strong>0111</strong></td><td><strong>VC</strong></td><td><strong>V&#x3D;0</strong></td><td><strong>未溢出</strong></td></tr><tr><td><strong>1000</strong></td><td><strong>HI</strong></td><td><strong>C&#x3D;1 且 Z&#x3D;0</strong></td><td><strong>无符号数大于</strong></td></tr><tr><td><strong>1001</strong></td><td><strong>LS</strong></td><td><strong>C&#x3D;0 或 Z&#x3D;1</strong></td><td><strong>无符号数小于或等于</strong></td></tr><tr><td><strong>1010</strong></td><td><strong>GE</strong></td><td><strong>N&#x3D;V</strong></td><td><strong>带符号数大于或等于</strong></td></tr><tr><td><strong>1011</strong></td><td><strong>LT</strong></td><td><strong>N!&#x3D;V</strong></td><td><strong>带符号数小于</strong></td></tr><tr><td><strong>1100</strong></td><td><strong>GT</strong></td><td><strong>Z&#x3D;0 且 N&#x3D;V</strong></td><td><strong>带符号数大于</strong></td></tr><tr><td><strong>1101</strong></td><td><strong>LE</strong></td><td><strong>Z&#x3D;1 或 N!&#x3D;V</strong></td><td><strong>带符号数小于或等于</strong></td></tr><tr><td><strong>1110</strong></td><td><strong>AL</strong></td><td></td><td><strong>无条件执行</strong></td></tr><tr><td><strong>1111</strong></td><td><strong>NV</strong></td><td><strong>ARMV3 之前</strong></td><td><strong>从不执行不要使用</strong></td></tr></tbody></table><h3 id="ARM-指令分类"><a href="#ARM-指令分类" class="headerlink" title="ARM 指令分类"></a>ARM 指令分类</h3><p>ARM 指令可以分为：分支指令、数据处理指令、存储访问指令、协处理器指令和杂项指令五类。<br><strong>1. 分支指令</strong><br>分支指令用于控制程序的执行流程、实现 ARM 代码与 Thumb 代码之间进行切换。<br><strong>2. 数据处理指令</strong><br>数据处理指令在通用寄存器上执行计算，主要分为 3 种：算术&#x2F;逻辑指令、比较指令和乘法指令。<br><strong>3. 存储访问指令</strong><br>用于加载&#x2F;存储存放于 MCU 片外存储系统中的数据。加载指令用于从内存中读取数据放入寄存器中，存储指令用于将寄存器中的数据保存到内存中。<br><strong>4. ARM 协处理器指令</strong><br>ARM 协处理器指令用于控制外部的协处理器。包括</p><ul><li><strong>数据处理指令</strong>：启动一个协处理器专用的内部操作。</li><li><strong>数据转移指令</strong>：使数据在协处理器和存储器之间进行转移。</li><li><strong>寄存器转移指令</strong>：协处理器值转移到 ARM 寄存器或 ARM 寄存器的值转移到协处理器。</li></ul><p><strong>5. 杂项指令</strong><br>包括<strong>状态寄存器转移指令</strong>和<strong>异常中断产生指令</strong>。<br>状态寄存器转移指令将 CPSR 或 SPSR 的内容转移到一个通用寄存器，或者反过来将通用寄存器的内容写入 CPSR 或 SPSR 寄存器<br>ARM 有 两条 异常中断产生指令，分别为 软中断指令 SWI 和 断点中断指令 BKPT。</p><h2 id="ARM-指令的寻址方式"><a href="#ARM-指令的寻址方式" class="headerlink" title="ARM 指令的寻址方式"></a>ARM 指令的寻址方式</h2><h3 id="立即数寻址-Immediate-Addressing"><a href="#立即数寻址-Immediate-Addressing" class="headerlink" title="立即数寻址 Immediate Addressing"></a>立即数寻址 Immediate Addressing</h3><p>立即数寻址也叫立即寻址，操作数本身就在指令中给出，取出指令也就取到了操作数。这个操作数被称为立即数，对应的寻址方式也就叫做立即数寻址。</p><p>立即数要求以“＃”为前缀，<br>对于以十六进制表示的立即数，还要求在“＃”后加上“0x”或“&amp;”;<br>对于以二进制表示的立即数，要求在“#”后加上“0b”;<br>对于以十进制表示的立即数，要求在“#”后加上“0d”或缺省。</p><p>在指令格式中，第二个操作数有 12 位：</p><p>因此有效立即数 immediate 可以表示成： <code>&lt;immediate&gt; =  immed_8 循环右移（2×rot）</code><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-14-09-35-20.png"><br><code>[8,11]这4 bit</code>移位因子 (十进制表示范围 0-15)乘 2(内存对齐,ARM 内存地址为 4 的倍数)，得到一个范围在 0-30，步长为 2 的移位值。<br>因此，将 ARM 中的立即数称为 8 位位图。“最后 8 位移动偶数位”得到立即数</p><blockquote><p>如何判断一个数是合法立即数还是非法立即数<br>判断一个数是否符合 8 位位图的原则, 首先看这个数的二进制表示中<strong>1 的个数是否不超过 8 个</strong>. 如果不超过 8 个, 再看这 n 个 1(n&lt;&#x3D;8)是否能同时放到 8 个二进制位中, 如果可以放进去, 再看这八个二进制位是否可以<strong>循环右移</strong>偶数位得到<br>我们欲使用的数. 如果可以, 则此数符合 8 位位图原理, 是合法的立即数. 否则, 不符合.</p></blockquote><h3 id="寄存器寻址-Register-Addressing"><a href="#寄存器寻址-Register-Addressing" class="headerlink" title="寄存器寻址 Register Addressing"></a>寄存器寻址 Register Addressing</h3><p>寄存器寻址就是利用寄存器中的数值作为操作数，这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的寻址方式。</p><h3 id="寄存器移位寻址-Register-Shift-Addressing"><a href="#寄存器移位寻址-Register-Shift-Addressing" class="headerlink" title="寄存器移位寻址 Register Shift Addressing"></a>寄存器移位寻址 Register Shift Addressing</h3><p>当第二操作数为寄存器型时，在执行寄存器寻址操作时，也可以对第二操作数寄存器进行移位，此时第二操作数形式为：<code>ADD  Rd, Rn, Rm，&#123;&lt;shift&gt;&#125;</code></p><p><code>Rm</code>: 第二操作数寄存器<br><code>&lt;shift&gt;</code>:用来指定移位类型和移位位数，有两种形式:5 位立即数,寄存器(用 Rs 表示)<br>在指令执行时，将寄存器移位后的内容，作为第二操作数参与运算。<br>例如指令：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R3←R2+(R1右移2位):</span><br><span class="line">ADD R3，R2，R1，LSR #2;</span><br><span class="line">R3←R2+(R1右移R0位)</span><br><span class="line">ADD R3，R2，R1，LSR R0;</span><br></pre></td></tr></table></figure><p><strong>第二操作数的移位方式:</strong></p><p>移位位数可以用立即数方式或者寄存器方式给出，其值均小于 32，应为[0,31]</p><ul><li><code>LSL,LSR</code> 逻辑左&#x2F;右移: 空出的最低&#x2F;高有效位用 0 填充</li><li><code>ASL,ASR</code> 算术左&#x2F;右移: 算术移位的对象为<strong>带符号数</strong>;故 ASL 空出的最低有效位用 0 填充,而 ASR 移位时,如果为负数,最高有效位用 1 填充;若为正数,则用 0 填充</li><li><code>ROR</code> Rotate Right;循环右移 移出的字的最低有效位依次填入空出的最高有效位。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-16-23-02-45.png" alt="ROR"></li><li><code>RRX</code> Rotate Right Extended 带扩展的循环右移;将寄存器的内容循环右移 1 位，空位用原来 C 标志位填充<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-16-23-03-12.png" alt="RRX"></li></ul><h3 id="寄存器间接寻址-Register-Indirect-Addressing"><a href="#寄存器间接寻址-Register-Indirect-Addressing" class="headerlink" title="寄存器间接寻址 Register Indirect Addressing"></a>寄存器间接寻址 Register Indirect Addressing</h3><p>寄存器间接寻址就是以寄存器中的值作为操作数的地址，而操作数本身存放在存储器中。<br><code>LDR R0，[R4];AR0←[R4]</code><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-16-23-16-48.png" alt="Indirect-Addressing"></p><h3 id="基址变址寻址-Base-index-Addressing"><a href="#基址变址寻址-Base-index-Addressing" class="headerlink" title="基址变址寻址 Base-index Addressing"></a>基址变址寻址 Base-index Addressing</h3><p>变址寻址,也叫基址变址寻址,是指将基址寄存器的内容与指令中给出的地址偏移量相加，得到操作数所在的存储器的有效地址<br>变址寻址方式常用于访问某基地址附近的地址单元(4K 范围的偏移)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-17-12-22-21.png" alt="Base-Index Addressing"><br><code>LDR R0，[R1，＃4]; R0←mem32[R1＋4]</code></p><p><strong>偏移地址方式</strong></p><p>有三种加偏址的方式：前变址、自动变址和后变址寻址方式</p><p><strong>前变址模式</strong>(不修改基址寄存器):先基址+偏址，生成操作数地址，再做指令指定的操作。也叫前索引偏移。例如 <code>STR r0,[r1,#12]</code>(将 r0 的内容存入 r1+12 的地址单元中)<br><strong>自动变址模式</strong>(修改基址寄存器)： 先基址+偏移，生成操作数地址，做指令指定的操作。然后自动修改基址寄存器。例如 <code>LDR R0，[R1，＃4]!;</code>(从 R1 指向的地址加上 4 的位置加载数据到 R0，并将计算得出的地址写回到 R1 中”。)<br><strong>后变址模式</strong>(修改基址寄存器)： 基址寄存器不加偏移作为操作数地址。完成指令操作后，用(基址+偏移)的值修改基址寄存器。例如 <code>STR r0,[r1],#12</code>将 r0 中的值存储到 r1 指向的地址，然后将 r1 的值加上 12 并把结果写回 r1”。</p><p><strong>偏移地址形式</strong>:可以是一个立即数，也可以是另一个寄存器，并且还可以是寄存器移位操作;常用的是立即数偏移的形式</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDR R2，[R3，#0X0C]; R2&lt;-mem32[R3＋0X0C]</span><br><span class="line">STR R1，[R0，#-0x4]!; R1-&gt;mem32[R0-0x4],R0&lt;-R0-0x4</span><br><span class="line">LDR r0，[r1，r2]; r0&lt;-mem32[r1+r2]</span><br><span class="line">LDR r0，[r1，r2，LSL #2]; r0&lt;-mem32[r1+r2*4](r2逻辑左移4位)</span><br></pre></td></tr></table></figure><h3 id="多寄存器寻址-Multiple-Register-Addressing"><a href="#多寄存器寻址-Multiple-Register-Addressing" class="headerlink" title="多寄存器寻址 Multiple Register Addressing"></a>多寄存器寻址 Multiple Register Addressing</h3><p>采用多寄存器寻址方式，一条指令可以完成多个寄存器值的传送。<br>这种寻址方式是多寄存器传送指令 LDM&#x2F;STM 的寻址方式，这种寻址方式中用一条指令最多可传送 16 个通用寄存器的值。连续的寄存器间用 <code>-</code>连接，否则用 <code>,</code>分隔</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDMIA R0！，&#123;R1-R4&#125;;</span><br><span class="line">R1←[R0]、R2←[R0＋4]、R3←[R0＋8]、R4←[R0＋12]</span><br></pre></td></tr></table></figure><p>LDMIA “Load Multiple Increment After”<br>从 R0 指向的地址开始，连续加载寄存器 R1, R2, R3, R4 的值，并将最后的地址写回到 R0 中”<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-17-15-24-28.png"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4种寻址操作</span><br><span class="line">LDMIA/STMIAIncrement After(先传送，后地址加4)</span><br><span class="line">LDMIB/STMIBIncrement Before(先地址加4 ,后传送)</span><br><span class="line">LDMDA/STMDADecrement After(先传送，后地址减4)</span><br><span class="line">LDMDB/STMDBDecrement Before (先地址减4,后传送)</span><br><span class="line">⚠️注意:对于所有LDM/STM指令而言，寄存器序号低的，在低地址单元，序号大的在高地址单元！与书写顺序无关！</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-17-15-38-02.png" alt="LDM/STM"></p><h3 id="堆栈寻址-Stack-Addressing"><a href="#堆栈寻址-Stack-Addressing" class="headerlink" title="堆栈寻址 Stack Addressing"></a>堆栈寻址 Stack Addressing</h3><p>堆栈是一种数据结构，按后进先出（Last In First Out， LIFO）的方式工作，使用一个称作堆栈指针的专用寄存器指示当前的操作位置，堆栈指针总是指向栈顶。</p><p>堆栈可分为两种增长方式：</p><ul><li><strong>向上生长</strong>：向高地址方向生长，称为递增堆栈。</li><li><strong>向下生长</strong>：向低地址方向生长，称为递减堆栈。</li></ul><p>根据堆栈指针指向的数据位置的不同，可分为：</p><ul><li><strong>满堆栈</strong>：堆栈指针指向最后压入堆栈的有效数据项，称为满堆栈;</li><li><strong>空堆栈</strong>：堆栈指针指向下一个待压入数据的空位置，称为空堆栈。</li></ul><p>四种类型的堆栈工作方式</p><ul><li><strong>满递增堆栈 FA</strong>(Full Ascending)：堆栈指针指向最后压入的数据，且由低地址向高地址生长。</li><li><strong>空递增堆栈 EA</strong>(Empty Ascending)：堆栈指针指向下一个将要放入数据的空位置，且由低地址向高地址生长。</li><li><strong>满递减堆栈 FD</strong>(Full Descending) ：堆栈指针指向最后压入的数据，且由高地址向低地址生长。</li><li><strong>空递减堆栈 ED</strong>(Empty Descending)：堆栈指针指向下一个将要放入数据的空位置，且由高地址向低地址生长。</li></ul><p>STMXX 是存入到主存，是入栈操作;LDMXX 是从主存读出到寄存器，是出栈操作</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">STMFD</span>  <span class="built_in">SP</span>!,&#123;<span class="built_in">R1</span>-<span class="built_in">R7</span>,<span class="built_in">LR</span>&#125;<span class="comment">;将R1-R7，LR入栈</span></span><br><span class="line"><span class="keyword">LDMFD</span>  <span class="built_in">SP</span>!,&#123;<span class="built_in">R1</span>-<span class="built_in">R7</span>,<span class="built_in">LR</span>&#125;<span class="comment">;数据出栈，放入R1-R7,LR</span></span><br></pre></td></tr></table></figure><h3 id="相对寻址-Relative-Addressing"><a href="#相对寻址-Relative-Addressing" class="headerlink" title="相对寻址 Relative Addressing"></a>相对寻址 Relative Addressing</h3><p>与基址变址寻址方式相类似，相对寻址以程序计数器 PC 的当前值为基地址，指令中的地址标号作为偏移量，将<br>两者相加之后得到操作数的有效地址</p>]]></content>
    
    
    <summary type="html">ARM指令集简介,包括ARM指令格式、ARM指令的条件码、ARM指令分类、ARM指令的寻址方式等</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM-Processor" scheme="https://efterklang.github.io/categories/UESTC/ARM-Processor/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层 Datalink Layer Ⅱ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch3-2DataLinkLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch3-2DataLinkLayer/</id>
    <published>2024-03-19T06:48:55.000Z</published>
    <updated>2024-04-27T11:23:40.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="点对点协议-Point-to-Point-Protocol"><a href="#点对点协议-Point-to-Point-Protocol" class="headerlink" title="点对点协议 Point to Point Protocol"></a>点对点协议 Point to Point Protocol</h2><p>一般的用户接入互联网的方式: 连接到某个因特网服务提供者 ISP(中国电信,中国移动.etc),用户计算机获取到 ISP 所分配的合法 IP 地址后,才能成为因特网的一员;PPPoE(PPP over Ethernet)协议在家庭和小型企业中被广泛用于连接到互联网服务提供商</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-12-15-55-21.png"></p><p>PPP（Point-to-Point Protocol）是一种网络协议,通常用于在两点之间建立直接连接,例如计算机和互联网服务提供商（ISP）的连接。PPP 可以在各种类型的物理网络上运行,包括串行线、电话线、同轴电缆、全双工光纤传输线路或无线连接等。</p><h3 id="Components-of-PPP"><a href="#Components-of-PPP" class="headerlink" title="Components of PPP"></a>Components of PPP</h3><p><strong>The Link Control Protocol (LCP)</strong>: responsible for establishing, configuring, and testing the link between the two devices. It negotiates link parameters like the maximum frame size and compression type while monitoring the link for errors and drops<br><strong>The Authentication Protocol (AP)</strong>: responsible for verifying the identities of the two devices using a range of authentication methods, including passwords, digital certificates, and biometrics<br><strong>The Network Control Protocol (NCP)</strong>: responsible for negotiating the network layer protocol used to transmit data over the connection, supporting a variety of network layer protocols such as IP, IPX, and AppleTalk!<br><a href="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-18-55-25.png"></a></p><h3 id="PPP-的主要特性和功能"><a href="#PPP-的主要特性和功能" class="headerlink" title="PPP 的主要特性和功能"></a>PPP 的主要特性和功能</h3><ul><li><strong>封装数据</strong>：PPP 可以封装 IP,IPX 等网络层协议的数据包,使它们可以在点对点链接上传输。</li><li><strong>身份验证</strong>：PPP 支持 PAP（Password Authentication Protocol）和 CHAP（Challenge Handshake Authentication Protocol）等身份验证协议,这些协议可以在建立连接时验证用户的身份。</li><li><strong>链接控制</strong>：PPP 使用 LCP（Link Control Protocol）来建立、配置和测试数据链路连接。</li><li><strong>网络控制</strong>：PPP 使用 NCP（Network Control Protocol）来建立和配置不同的网络层协议。</li><li><strong>错误检测</strong>：PPP 帧包含一个校验和字段,用于错误检测。</li><li><strong>多协议支持</strong>：PPP 支持多种网络层协议,这使得它可以在各种不同的网络环境中使用。</li></ul><p>PPP 是一种灵活且广泛使用的协议,特别适用于拨号和 DSL 连接。它是许多互联网用户连接到 ISP 的基础。它的特点是：简单；只检测差错,而不是纠正差错；不使用序号,也不进行流量控制；可同时支持多种网络层协议,是目前使用最广泛的点对点数据链路层协议</p><h3 id="PPP-帧格式"><a href="#PPP-帧格式" class="headerlink" title="PPP 帧格式"></a>PPP 帧格式</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-12-16-44-00.png" alt="Frame Format"></p><h3 id="PPP-透明传输"><a href="#PPP-透明传输" class="headerlink" title="PPP 透明传输"></a>PPP 透明传输</h3><p>面向字节的异步链路：字节填充法(插入转义字符)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-15-34-56.png"><br>面向比特的同步链路：比特填充法(插入比特 0)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-15-37-14.png"></p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>能够对接收端收到的帧进行检测,并立即丢弃有差错的帧。因此 PPP 向上层提供的是不可靠传输服务</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-15-51-31.png"></p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-18-43-26.png"></p></center><blockquote><ul><li>Bob initiates a connection by dialing his ISP’s phone number</li><li>Bob’s modem establishes a physical connection with the ISP’s modem over a phone line</li><li>The two modems exchange LCP packets for negotiating the connection parameters. Parameters are, for instance, the maximum frame size and compression type</li><li>They agree to a maximum frame size of 1500 bytes with no compression</li><li>After the LCP negotiation, Bob’s modem and the ISP’s modem authenticate each other’s identities</li><li>The ISP uses the Challenge-Handshake Authentication Protocol (CHAP) to verify Bob’s identity. Bob, however, employs the Password Authentication Protocol (PAP) to verify the ISP’s identity</li><li>Once authentication is complete, the two modems exchange NCP packets. So, they determine which network layer protocol will be used to transmit data over the connection</li><li>They agree to use the TCP&#x2F;IP protocol suite</li><li>With the NCP negotiation complete, we can transmit the data between Bob’s computer and the internet using the TCP&#x2F;IP protocol suite through encapsulated frames transmitted over the PPP connection</li><li>Finally, when Bob finishes using the internet, he can terminate the PPP connection by disconnecting the modem or logging off the ISP’s **server<br>*PPP 协议已不是纯粹的数据链路层的协议,它还包含了物理层和网络层的内容*</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-19-10-51-14.png"></p><h2 id="媒体接入控制-Media-Access-Control"><a href="#媒体接入控制-Media-Access-Control" class="headerlink" title="媒体接入控制 Media Access Control"></a>媒体接入控制 Media Access Control</h2><h3 id="MAC-引入"><a href="#MAC-引入" class="headerlink" title="MAC 引入"></a>MAC 引入</h3><p><strong>局域网的数据链路层</strong></p><ul><li>局域网最主要的<strong>特点</strong>是：<ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。</li></ul></li><li>局域网具有如下<strong>主要优点</strong>：<ul><li>具有广播功能,从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变,各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li></ul><p><strong>数据链路层的两个子层</strong><br>为了使数据链路层能更好地适应多种局域网标准,IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ul><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ul><p>与接入到传输媒体有关的内容都放在 MAC 子层,而 LLC 子层则与传输媒体无关。<strong>不管采用何种协议的局域网,对 LLC 子层来说都是透明的。</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-19-15-39-34.png"></p><p>为什么要媒体接入控制（介质访问控制）？<br><strong>共享信道带来的问题</strong><br>若多个设备在共享信道上同时发送数据,则会造成彼此干扰,导致发送失败。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-22-22-20-50.png" alt="DataLinkLayerPart2-2024-03-22-22-20-50"></p><p><strong>媒体接入控制(MAC)可分为</strong></p><p><strong>1. 静态信道划分 Static Channel Allocation</strong><br>静态信道划分（Static Channel Allocation）是一种通信网络中的资源分配策略,它将可用的频谱资源事先固定地分配给各个用户或者信道。这种方式下,即使某个用户或信道当前没有数据需要传输,其分配的资源也不能被其他用户或信道使用,因此可能导致资源的浪费。谨常在无线网络的物理层中使用</p><p>SCA 有三种主要的技术,在这些技术中,每个用户或信道都被分配到一个特定的频率带宽、时间槽或编码。</p><ul><li>频分多址 FDMA,Frequency Division Multiple Access</li><li>时分多址 TDMA,Time Division Multiple Access</li><li>码分多址 CDMA,Code Division Multiple Access</li></ul><p><strong>2. 动态接入控制 Dynamic Access Control</strong></p><p>动态接入控制（Dynamic Access Control）是一种网络通信中的资源分配策略,它根据网络的实时需求动态地分配资源。与静态信道划分（如 FDMA、TDMA、CDMA）相比,动态接入控制可以更有效地利用可用资源。在动态接入控制中,如果一个用户没有数据需要传输,其分配的资源可以被其他用户使用,从而避免了资源的浪费。这种方式需要一个接入控制协议来确定哪些用户可以在哪个时刻使用网络资源。</p><ul><li>受控接入 Controlled Access(已经被淘汰)<ul><li>集中控制 Centralized Control</li><li>分散控制 Distributed Control</li></ul></li><li>随机接入 Random Access<ul><li>ALOHA</li><li>CSMA&#x2F;CD</li><li>CSMA&#x2F;CA</li></ul></li></ul><h3 id="MAC-定义"><a href="#MAC-定义" class="headerlink" title="MAC 定义"></a>MAC 定义</h3><p><strong>Media access control</strong>, medium access control or simply MAC, is a specific network data transfer policy. It determines how data transmits through a regular network cable. The protocol exists to ease data packets’ transfer between two computers and ensure no collision or simultaneous data transit occurs.</p><p>The medium access control – commonly referred to as the MAC protocol – is, effectively, a sublayer or MAC sublayer that controls hardware responsible for the communication with a wired, wireless or optical transmission medium.</p><p>The MAC sublayer is part of the two sublayers scheme: data link layer. The other part of the data link layer is the logical link control (LLC) sublayer. The LLC sublayer offers multiplexing and flow control for the logical link, and the MAC sublayer acts as the interface between the LLC sublayer and the physical layer within a transmission medium.<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-19-15-02-02.png"></p><p><strong>媒体访问控制（MAC）</strong>是数据通信协议中一种子层,它是数据链路层的一部分。MAC 子层的主要职责是控制设备如何访问网络介质（例如以太网,Wi-Fi）,以便进行有效的信息传输。<br>MAC 地址是一个设备网络接口的唯一标识符。它通常由六组两位十六进制数字组成,例如：<code>00:0A:95:9D:68:16</code>。每个网络设备的 MAC 地址都是全球唯一的,由设备制造商在生产时分配。<br>MAC 地址在网络通信中起着关键作用。当一个设备需要发送数据包到另一个设备时,它会使用目标设备的 MAC 地址来定位它。这是在同一局域网（LAN）内进行通信的基础。</p><h3 id="静态划分信道-Static-Channel-Allocation"><a href="#静态划分信道-Static-Channel-Allocation" class="headerlink" title="静态划分信道 Static Channel Allocation"></a>静态划分信道 Static Channel Allocation</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-25-18-53-09.png"></p><p><strong>复用 (Multiplexing)</strong> 是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时,可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</p><h5 id="频分复用-FDM-Frequency-Division-Multiplexing"><a href="#频分复用-FDM-Frequency-Division-Multiplexing" class="headerlink" title="频分复用 FDM (Frequency Division Multiplexing)"></a>频分复用 FDM (Frequency Division Multiplexing)</h5><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-09-41-34.png"></p><p>将传输线路的频带资源划分成多个子频带,形成多个子信道,各子信道间需要留出隔离频带,以免造成子信道间的十扰。当多路信号输入一个多路复用器时,这个复用器将每一路信号调制到不同频率的载波上。接收端由相应的分用器通过滤波将各路信号分开,将合成的复用信号恢复成原始的多路信号。</p><h5 id="时分复用-TDM-Time-Division-Multiplexing"><a href="#时分复用-TDM-Time-Division-Multiplexing" class="headerlink" title="时分复用 TDM (Time Division Multiplexing)"></a>时分复用 TDM (Time Division Multiplexing)</h5><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是 TDM 帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li>时分复用的所有用户在不同的时间占用同样的频带宽度。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-09-42-39.png"></p><h5 id="波分复用-WDM-Wavelength-Division-Multiplexing"><a href="#波分复用-WDM-Wavelength-Division-Multiplexing" class="headerlink" title="波分复用 WDM (Wavelength Division Multiplexing)"></a>波分复用 WDM (Wavelength Division Multiplexing)</h5><p>波分复用就是光的频分复用,使用一根光纤来同时传输多个光载波信号;光信号传输一段距离后会衰减,所以要用<strong>掺铒光纤放大器 EDFA(Erbium-Doped Fiber Amplifier)</strong> 放大光信号<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-10-07-39.png"></p><h5 id="码分复用-CDM-Code-Division-Multiplexing"><a href="#码分复用-CDM-Code-Division-Multiplexing" class="headerlink" title="码分复用 CDM (Code Division Multiplexing)"></a>码分复用 CDM (Code Division Multiplexing)</h5><p><strong>码分复用 CDM</strong> 是另一种共享信道的方法。实际上,由于该技术主要用于多址接入,人们更常用的名词是<strong>码分多址 CDMA(Code Division MuItipIe Access)</strong> 同理,频分复用 FDM 和时分复用 TDM 同样可用于多址接入,相应的名词是频分多址 FDMA(Frequency Division Multiple Access) 和时分多址 TDMA(Time Division Multiple Access);与 FDM 和 TDM 不同,CDM 的每一个用户可以在同样的时间使用同样的频带进行通信。由于各用户使用经过特殊挑选的不同码型,因此各用户之间不会造成干扰。CDM 最初是用于军事通信的,因为这种系统所发送的信号有很强的抗干扰能力,其频谱类似于白噪声,不易被敌人发现。随着技术的进步,CDMA 设备的价格和体积都大幅度下降,因而现在已广泛用于民用的移动通信中</p><blockquote><p>复用与多址的概念。可简单理解如下：</p><ul><li>复用(Multiplexing)是将单一媒体的频带资源划分成很多子信道,这些子信道之间相互独立,互不干扰。从媒体的整体频带资源上看,每个子信道只占用该媒体频带资的一部分。</li><li>多址(Multiple Access),更确切地应该称为多点接入,处理的是动态分配信道给用户;这在用户暂时性占用信道(如移动通信)的应用中是必须的。在信道永久性地分配给用户(如无线广播等)的应用中,多址是不需要的</li><li>某种程度上,FDMA,TDMAS CDMA 可以分别看成是 FDM,TDM,CDM 的应用</li></ul></blockquote><ul><li><p>在 CDMA 中,每一个比特时间再划分为 m 个短的间隔,称为<strong>码片 (Chip)</strong>;通常 m 的值是 64 或 128 为了简单起见,在后续的举例中,我们假设 m 为 8;</p></li><li><p>使用 CDMA 的每一个站被指派一个唯一的 m bit <strong>码片序列 (Chip Sequence);</strong></p><ul><li>一个站如果要发送比特 1 ,则发送它自己的 m bit 码片序列；</li><li>一个站如果要发送比特 0 ,则发送它自己的 m bit 码片序列的二进制反码；<br>指派给（ DMA 系统中某个站点的码片序列为 <code>00011011</code><br>发送比特 1:发送自己的码片序列 <code>00011011</code><br>发送比特 0:发送自己的码片序列的二进制反码 <code>11100100</code><br>为了方便，我们按惯例将码片序列中的 0 写为-1, 将 1 写为+ 1 。则该站点的码片序列是<code>(-1 -1 -1 + 1 + 1 -1 + 1 + 1)</code></li></ul></li><li><p>码片序列需要满足的条件</p><ul><li>每个站的 Chip Sequence 不能相同,实际上常采用伪随机码片序列,这样可以使得码片序列之间的相关性很小,从而减小干扰；</li><li>每个站的 Chip Sequence 必须相互正交,令向量 S 表示站 S 的码片序列，令向量 T 表示其他任何站的码片序列。两个不同站 S 和 T 的码片序列正交，就是向量 S 和 T 的规格化内积为 0 ：</li><li>满足的 4 个条件如公式所示<div>$$  \begin{array}{ll}  S \cdot T \equiv \frac{1}{m} \sum_{i=1}^{m} S_{i} T_{i}=0 &  S \cdot \bar{T} \equiv 0 \\  S \cdot S \equiv \frac{1}{m} \sum_{i=1}^{m} S_{i} S_{i}=\frac{1}{m} \sum_{i=1}^{m} S_{i}^{2}=\frac{1}{m} \sum_{i=1}^{m}( \pm 1)^{2}=1 &   S \cdot \bar{S} \equiv-1   \end{array}$$</div></li></ul></li></ul><p><strong>Examples</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-15-29-46.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-15-44-04.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-15-47-32.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-15-48-11.png"></p><h3 id="动态接入控制-Dynamic-Access-Control"><a href="#动态接入控制-Dynamic-Access-Control" class="headerlink" title="动态接入控制 Dynamic Access Control"></a>动态接入控制 Dynamic Access Control</h3>]]></content>
    
    
    <summary type="html">介绍数据链路层的 PPP 协议和 MAC 协议</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>Thread</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch2-4Thread/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch2-4Thread/</id>
    <published>2024-03-14T11:36:01.000Z</published>
    <updated>2024-03-29T06:55:04.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>为使程序能并发执行，系统必须进行以下的一系列操作:<strong>创建进程</strong> <strong>撤消进程</strong> <strong>进程切换</strong><br>由于进程是一个资源的拥有者，因此在创建、撤销和切换中，系统必须为此付出较大的时间和空间的开销。<br>如何使多个程序更好的并发执行，同时又能减少系统开销？</p><p><strong>进程的概念体现出两个特点</strong>：</p><ul><li><strong>资源所有权</strong>：一个进程包括一个保存进程映像的虚地址空间，并且随时分配对资源的控制或所有权，包括内存、I&#x2F;O 通道、I&#x2F;O 设备、文件等。</li><li><strong>调度／执行</strong>：进程是被操作系统调度的实体。</li></ul><p>调度和分派的部分通常称为<strong>线程或轻型进程</strong>（lightweight process），而资源所有权的部分通常称为<strong>进程</strong></p><p><strong>线程</strong>具有许多传统进程所具有的特征，所以又称为<strong>轻型进程</strong>(Light-Weight Process) ，相应地把传统<strong>进程</strong>称为<strong>重型进程</strong>(Heavy-Weight Process)，传统进程相当于只有一个线程的任务。<br>在引入了线程的操作系统中，通常一个进程都拥有若干个线程，至少也有一个线程。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-4Thread-2024-03-13-09-23-33.png" alt="Create Thread vs Create Process"></p><p><strong>History</strong></p><ul><li><strong>60 年代</strong>：提出进程(Process)概念，在 OS 中一直都是以进程作为能拥有资源和独立运行的基本单位的。</li><li><strong>80 年代中期</strong>：提出线程（Thread）概念，线程是比进程更小的能独立运行的基本单位，目的是提高系统内程序并发执行的程度，进一步提高系统的吞吐量。</li><li><strong>90 年代</strong>：多处理机系统得到迅速发展，线程能比进程更好地提高程序的并行执行程度，充分发挥多处理机的优越性。</li></ul><h3 id="线程的共享问题"><a href="#线程的共享问题" class="headerlink" title="线程的共享问题"></a>线程的共享问题</h3><p>进程内的所有线程共享进程的很多资源,而这种共享又带来了同步问题</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程间共享                 线程私有</span><br><span class="line">进程指令       线程ID</span><br><span class="line">全局变量        寄存器集合（包括PC和栈指针）</span><br><span class="line">打开的文件           栈（用于存放局部变量）</span><br><span class="line">信号处理程序                信号掩码</span><br><span class="line">当前工作目录                优先级</span><br><span class="line">用户ID</span><br></pre></td></tr></table></figure><h3 id="线程的互斥问题"><a href="#线程的互斥问题" class="headerlink" title="线程的互斥问题"></a>线程的互斥问题</h3><p><strong>对全局变量进行访问的基本步骤</strong></p><ul><li>将内存单元中的数据读入寄存器</li><li>对寄存器中的值进行运算</li><li>将寄存器中的值写回内存单元<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-4Thread-2024-03-13-09-33-01.png"></li></ul><h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><ul><li><strong>轻型实体</strong> 线程自己基本不拥有系统资源，只拥有少量必不可少的资源：TCB，程序计数器、一组寄存器、栈。</li><li><strong>独立调度和分派的基本单位</strong> 在多线程 OS 中,线程是独立运行的基本单位,因而也是独立调度和分派的基本单位。</li><li><strong>可并发执行</strong> 同一进程中的多个线程之间可以并发执行，一个线程可以创建和撤消另一个线程。</li><li><strong>共享进程资源</strong> 它可与同属一个进程的其它线程共享进程所拥有的全部资源。</li></ul><h2 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h2><p><strong>Ref</strong><br>[<a href="Ch2-1ProcessContorl" title="进程的描述及控制">Ch2-1ProcessContorl#进程的描述 Process</a>]<br>[<a href="ProcessvsThread" title="Process &amp; Thread">ProcessvsThread#Comparison</a>]</p><h2 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a>线程的控制</h2><h3 id="Create-Terminate-Thread"><a href="#Create-Terminate-Thread" class="headerlink" title="Create&#x2F;Terminate Thread"></a>Create&#x2F;Terminate Thread</h3><p><strong>线程的创建</strong>：</p><ul><li>在多线程 OS 环境下，应用程序在启动时，通常仅有一个“初始化线程”线程在执行。</li><li>在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数。</li><li>如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。</li><li>在线程创建函数执行完后，将返回一个线程标识符供以后使用。</li></ul><p><strong>线程的终止</strong>：</p><ul><li>线程完成了自己的工作后自愿退出；</li><li>或线程在运行中出现错误或由于某种原因而被其它线程强行终止。</li></ul><p><strong>线程的三种终止方式</strong></p><ul><li>线程从启动例程函数中返回，函数返回值作为线程的退出码</li><li>线程被同一进程中的其他线程取消</li><li>线程在任意函数中调用 <code>pthread_exit</code> 函数终止执行</li></ul><h2 id="线程间的同步与通信"><a href="#线程间的同步与通信" class="headerlink" title="线程间的同步与通信"></a>线程间的同步与通信</h2><h3 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h3><p>互斥锁是一种比较简单的、用于实现进程间对资源互斥访问的机制。<br>由于操作互斥锁的时间和空间开销都较低，因而较适合于高频度使用的关键共享数据和程序段。<br>互斥锁可以有两种状态， 即开锁(unlock)和关锁(lock)状态。</p><p><strong>上锁的两种方式</strong></p><ul><li>阻塞方式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//用来锁住互斥体变量。如果参数 mutex 所指的互斥体已经被锁住了，那么发出调用的线程将被阻塞直到其他线程对 mutex 解锁。</span></span><br><span class="line">lock(mutex)</span><br><span class="line">访问</span><br><span class="line">unlock(mutex)</span><br></pre></td></tr></table></figure><ul><li>非阻塞方式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（trylock） then</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//如果互斥体已经被上锁，该调用不会阻塞等待，而会返回一个错误代码。</span></span><br></pre></td></tr></table></figure><h3 id="条件变量-Condition-Variable"><a href="#条件变量-Condition-Variable" class="headerlink" title="条件变量 Condition Variable"></a>条件变量 Condition Variable</h3><p>在多线程编程中，条件变量是一种同步机制，用于在某个特定条件变为真时唤醒一个或多个线程。条件变量通常与互斥锁（mutex）一起使用，以确保线程在检查条件和对条件进行等待时不会发生竞争条件。</p><p>以下是条件变量在控制线程同步中的一般用法：</p><ul><li><strong>等待条件</strong>：当线程需要等待某个条件变为真时，它会首先获取与条件变量相关联的互斥锁。然后，它会检查条件是否已经满足。如果条件未满足，线程会调用条件变量的等待方法（例如在 Java 中的 <code>Condition.await()</code>）。这将释放互斥锁，并使线程进入睡眠状态，等待条件变为真。</li><li><strong>改变条件</strong>：当线程改变可能会影响条件的状态的数据时，它会首先获取互斥锁，然后修改数据。修改完成后，它会调用条件变量的唤醒方法（例如在 Java 中的 <code>Condition.signal()</code>或 <code>Condition.signalAll()</code>），以唤醒正在等待该条件的所有线程。然后，它会释放互斥锁。</li><li><strong>响应唤醒</strong>：当线程被唤醒时（即，它从等待方法返回时），它会重新获取互斥锁，并再次检查条件。这是必要的，因为在多线程环境中，条件可能在线程被唤醒和线程实际运行之间的时间内发生变化。</li></ul><p>使用条件变量可以使线程在等待某个条件时不必进行忙等待（即，不断地检查条件是否已经满足）。这可以大大提高系统的效率，因为线程在等待时不会消耗 CPU 资源。</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ul><li><strong>私用信号量</strong>(private semaphore)。<br>当某线程需利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一私用信号量，其数据结构存放在应用程序的地址空间中。<br>私用信号量属于特定的进程所有，OS 并不知道私用信号量的存在，因此，一旦发生私用信号量的占用者异常结束或正常结束，但并未释放该信号量所占有空间的情况时，系统将无法使它恢复为 0(空)，也不能将它传送给下一个请求它的线程。</li><li><strong>公用信号量</strong>(public semaphore)。<br>公用信号量是为实现不同进程间或不同进程中各线程之间的同步而设置的。<br>有着一个公开的名字供所有的进程使用，故称为公用信号量。<br>其数据结构是存放在受保护的系统存储区中，由 OS 为它分配空间并进行管理，故也称为<strong>系统信号量</strong><br>如果信号量的占有者在结束时未释放该公用信号量，则 OS 会自动将该信号量空间回收，并通知下一进程。因此公用信号量是一种比较安全的同步机制</li></ul><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><p>各类线程的实现细节，其中上下文切换是核心</p><h3 id="用户级线程-User-Level-Threads"><a href="#用户级线程-User-Level-Threads" class="headerlink" title="用户级线程 User-Level Threads"></a>用户级线程 User-Level Threads</h3><ul><li><strong>用户级线程</strong>仅存在于<strong>用户空间</strong>中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都<strong>无须内核</strong>来实现。</li><li>对于用户级线程的切换，通常是发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。由于切换的规则远比进程调度和管理的规则简单，因而使线程的切换速度特别快。可见，这种线程是与内核无关的</li><li>由应用程序完成所有线程的管理<br><strong>线程库</strong>(用户空间)：通过一组管理线程的函数库来提供一个线程运行管理系统（运行系统）</li><li>内核不知道线程的存在</li><li>线程切换不需要核心态特权</li><li>调度算法可以是进程专用的</li></ul><p><strong>Pros And Cons:</strong></p><ul><li>线程切换不调用内核</li><li>调度是应用程序特定的：可以选择最好的算法</li><li>可运行在任何操作系统上（只需要线程库），可以在一个不支持线程的 OS 上实现</li></ul><hr><ul><li>当线程执行一个系统调用时，该线程及其所属进程内的所有线程都会被阻塞。</li><li>多线程应用不能利用多处理机进行多重处理。</li></ul><p><strong>用户级线程实现</strong></p><p>用户级线程是在<strong>用户空间</strong>实现的。所有用户级线程都具有相同的数据结构，它们都运行在一个中间系统上。</p><p>当前有两种方式实现的中间系统：</p><ul><li><strong>运行时系统</strong>（又称为线程库）<br>用于管理和控制线程的函数的集合，包括创建、撤消线程函数、线程同步和通信函数、线程调度函数等。<br>用户级线程不能直接利用系统调用，必须通过<strong>运行时系统</strong>间接利用系统调用。</li><li><strong>内核控制线程</strong><br>这种线程又称为轻型进程 LWP（Light Weight Process）<br>每个进程都可拥有多个 LWP，每个 LWP 都有自己的 TCB，其中包括线程标识符、优先级、状态、栈和局部存储区等<br>LWP 可通过系统调用来获得内核提供的服务，当一个用户级线程运行时，只要将它连接到一个 LWP 上，它便具有了内核支持线程的所有属性</li></ul><h3 id="内核支持线程-Kernel-Supported-Threads"><a href="#内核支持线程-Kernel-Supported-Threads" class="headerlink" title="内核支持线程 Kernel Supported Threads"></a>内核支持线程 Kernel Supported Threads</h3><ul><li>内核支持线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，是<strong>依靠内核</strong>实现的。</li><li>在内核空间中为每一个内核支持线程设置了一个线程控制块 TCB， 内核是根据该控制块而感知某线程的存在的，并对其加以控制。</li></ul><p><strong>Pros and Cons</strong></p><ul><li>在多处理器系统中，内核能够同时调度同一进程中多个线程并行执行；</li><li>如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程；</li><li>内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；</li><li>内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。</li></ul><hr><p>对于线程切换而言，其模式切换的开销较大<br>在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态再转到用户态进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。</p><blockquote><p>和用户级相比，内核支持线程有什么不同?<br>由内核完成线程的创建、调度等<br>主要工作仍是保存现场,但保存位置为内核栈<br>每个执行序列需有两个栈: 用户栈+内核栈<br>用户栈：普通的函数调用<br>内核栈：系统调用、中断处理</p></blockquote><p><strong>内核支持线程的实现</strong></p><p>在仅设置了内核支持线程的 OS 中，一种可能的线程控制方法是，系统在创建一个新进程时，便为它分配一个任务数据区 PTDA(Per Task Data Area),其中包括若干个线程控制块 TCB 空间。TCB 包含了线程的各种信息，如线程的状态（运行、就绪、阻塞等）、寄存器的值、栈指针、优先级、线程 ID 等。每个线程都有一个与之对应的 TCB。</p><p>在创建新进程时，系统会为该进程的 PTDA 预分配若干个 TCB 空间,用来存放该进程将要创建的线程的 TCB。当进程创建新线程时，一个空闲的 TCB 会被取出并填充该线程的信息。当线程结束时，其 TCB 会被回收并放回到空闲的 TCB 池中。</p><p>通过这种方式，系统可以有效地管理和调度线程。每次线程切换时，系统只需要保存当前线程的状态到其 TCB 中，然后从下一个线程的 TCB 中恢复其状态，就可以实现线程的切换。</p><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><blockquote><p><strong>EX1</strong><br>进程 A 包含了 1 个用户级线程$t_{1}$，进程 B 包含了 100 个用户级线程$t_{i},i \in (1,100)$，$t_1$运行的时间和$t_i$的运行时间是否一样？<br>不一样，$t_1$运行的时间是$t_{i}$的 100 倍,进程 B 获得 CPU 的时间与进程 A 的相等<br><strong>EX2</strong><br>若进程 A 和进程 B 中的线程都是内核支持线程，两者的运行时间是否一样？<br>$t_1&#x3D;t_i$,进程 B 获得 CPU 的时间是进程 A 的 100 倍<br><strong>Explanation</strong><br>当一个系统设置了<strong>用户级线程</strong>时，虽然每个进程可能有多个线程，但对于操作系统内核来说，它只看到进程，而看不到进程内部的线程。因此，内核的调度仍然是<strong>以进程为单位</strong>进行的。在采用时间片轮转调度算法时，操作系统会<strong>公平地将处理器时间分配给每个进程</strong>。也就是说，每个进程都会轮流获得一定的处理器时间（时间片）来执行。这确保了各个进程之间的公平性。<br>而运行<strong>内核支持线程</strong>时,操作系统内核是可以看到进程内部的线程的。因此，内核的调度是<strong>以线程为单位</strong>进行的。也就是说，每个线程都会轮流获得一定的处理器时间（时间片）来执行。这确保了各个线程之间的公平性。</p></blockquote>]]></content>
    
    
    <summary type="html">Thread</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Interprocess Communication</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch2-3InterprocessCommunication/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch2-3InterprocessCommunication/</id>
    <published>2024-03-11T06:54:48.000Z</published>
    <updated>2024-03-21T09:54:37.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程通信的类型-Types-Of-IPC"><a href="#进程通信的类型-Types-Of-IPC" class="headerlink" title="进程通信的类型 Types Of IPC"></a>进程通信的类型 Types Of IPC</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><strong>低级通信</strong>：进程之间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。<br>信号量机制作为同步工具是卓有成效的，但作为通信工具，则不够理想，<br>主要表现在下述两方面：</p><ol><li>效率低，生产者每次只能向缓冲池投放一个产品(消息)，消费者每次只能从缓冲区中取得一个消息；</li><li>通信对用户不透明。</li></ol><hr><p><strong>高级通信</strong>：是指用户可直接利用操作系统所提供的一组通信命令高效地传送大量数据的一种通信方式。常用的高级通信方式有 :</p><ul><li><strong>共享存储器系统</strong>：在内存中分配一片空间作为共享存储区</li><li><strong>管道通信</strong>：写者向管道文件中写入数据；读者从该文件中读出数据</li><li><strong>消息传递系统</strong>：以消息（Message）为单位在进程间进行数据交换<ul><li>直接通信方式</li><li>间接通信方式</li></ul></li><li><strong>客户机-服务器系统</strong></li></ul><h3 id="共享存储器系统-Shared-Memory-System"><a href="#共享存储器系统-Shared-Memory-System" class="headerlink" title="共享存储器系统 Shared-Memory System"></a>共享存储器系统 Shared-Memory System</h3><ol><li><p><strong>基于共享数据结构的通信方式</strong><br>诸进程共用某些数据结构，借以实现诸进程间的信息交换。<br>如在生产者—消费者问题中，就是用有界缓冲区这种数据结构来实现通信的。这种通信方式是低效的，只适于传递相对少量的数据。</p></li><li><p><strong>基于共享存储区的通信方式</strong><br>由操作系统在内存中划分出一块区域作为共享存储区。<br>进程在通信前向操作系统申请共享存储区中的一个分区。<br>然后，申请进程把获得的共享存储分区连接到本进程上，此后便可象读&#x2F;写普通存储器一样地读&#x2F;写共享存储分区。<br>该方式下，通信进程之间的同步与互斥访问共享存储区由进程负责。</p></li></ol><h3 id="管道通信-Pipe-Communication"><a href="#管道通信-Pipe-Communication" class="headerlink" title="管道通信 Pipe Communication"></a>管道通信 Pipe Communication</h3><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名 pipe 文件。<br>向管道(共享文件)提供输入的发送进程 Writer， 以<strong>字符流 Character Stream</strong>形式将大量的数据写入管道；<br>接受管道输出的接收进程 Reader，则从管道中读数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。<br>这种方式首创于 UNIX 系统，由于它能有效地传送大量数据，因而又被引入到许多其它操作系统中。</p><p>为了协调双方的通信，管道机制必须提供以下<strong>三方面</strong>的协调能力：</p><ul><li><strong>互斥</strong>，即当一个进程正在对 pipe 执行读&#x2F;写操作时，其它(另一)进程必须等待。</li><li><strong>同步</strong>，指当写(输入)进程把一定数量(如 4KB)的数据写入 pipe，便去睡眠等待， 直到读(输出)进程取走数据后，再把他唤醒。当读进程读空 pipe 时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒。</li><li><strong>确定对方是否存在</strong>，只有确定了对方已存在时，才能进行通信。</li></ul><p>Linux 命名管道非常适合同一机器上两个进程之间传递数据，其形式也是一个文件，但是读取与写入时遵循 FIFO 的原则。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;/tmp/my_fifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE PIPE_BUF</span></span><br><span class="line">mkfifo(FIFO_NAME,<span class="number">0777</span>);</span><br></pre></td></tr></table></figure><h3 id="消息传递系统-Message-Passing-System"><a href="#消息传递系统-Message-Passing-System" class="headerlink" title="消息传递系统 Message-Passing System"></a>消息传递系统 Message-Passing System</h3><p>应用最广泛的进程通信机制,进程间数据交换以格式化的信息 Message 为单位<br>程序员使用通信原语完成通信，其实现细节被隐藏，简化了通信程序的编写复杂性<br>微内核与服务器程序的通信采用本机制，可满足多处理机 OS、分布式 OS、计算机网络的通信要求</p><p><strong>消息传递通信的实现方法</strong></p><ul><li><strong>直接通信方式</strong> <code>send(),receive()</code></li><li><strong>间接通信方式</strong> 信箱</li></ul><h4 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h4><p>指发送进程利用 OS 提供的发送命令,直接把消息发送给目标进程。通常，系统提供下述两种类型的通信命令(原语)：</p><ul><li><strong>对称寻址方式 Symmetric Addressing</strong><br><code>Send(Receiver, Message);</code><br><code>Receive(Sender, Message);</code><br>例如，原语<code>Send(P2, m1)</code>表示将消息 m1 发送给接收进程 P2; 而原语<code>Receive(P1，m1)</code>则表示接收由 P1 发来的消息 m1</li><li><strong>非对称寻址方式 Asymmetric Addressing</strong><br><code>Send(P, Message);</code>发送一个消息给接收进程 P；<br><code>Receive(id,Message);</code>接收来自任何进程的消息，进程 id 不固定</li></ul><p>利用直接通信原语，来解决生产者-消费者问题：<br>当生产者生产出一个产品(消息)后，便用 Send 原语将消息发送给消费者进程；而消费者进程则利用 Receive 原语来得到一个消息。如果消息尚未生产出来，消费者必须等待，直至生产者进程将消息发送过来</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">     …</span><br><span class="line">    produce an item <span class="keyword">in</span> nextp;</span><br><span class="line">      …</span><br><span class="line">    send(consumer, nextp);</span><br><span class="line">   <span class="keyword">until</span> false;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    receive(producer, nextc);</span><br><span class="line">      …</span><br><span class="line">    consume the item <span class="keyword">in</span> nextc;</span><br><span class="line">  <span class="keyword">until</span> false;</span><br></pre></td></tr></table></figure><p><strong>消息缓冲队列通信机制</strong></p><p>发送进程利用 <code>send</code> 原语将消息直接发送给接收进程的消息缓冲队列；<br>接收进程利用 <code>receive</code> 原语接收消息；<br>用于本地进程通信。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-13-21-04.png"></p><p><strong>Send</strong></p><ul><li><strong>发送进程</strong>在利用发送原语发送消息之前，应先在自己的内存空间，设置一发送区<code>a</code>，把待发送的消息正文、发送进程标识符、消息长度等信息填入其中，然后调用发送原语，把消息发送给目标(接收)进程。</li><li>发送原语首先根据发送区<code>a</code>中所设置的消息长度<code>a.size</code>来申请一缓冲区<code>i</code>，接着，把发送区<code>a</code>中的信息复制到缓冲区<code>i</code>中。为了能将<code>i</code>挂在<strong>接收进程的消息队列</strong><code>mq</code>上，应先获得<strong>接收进程</strong>的内部标识符<code>j</code>，然后将<code>i</code>挂在<code>j.mq</code>上。</li><li>由于该队列属于临界资源, 故在执行<code>insert</code>操作的前后，需要执行<code>wait</code>和<code>signal</code>操作</li></ul><p><strong>Receive</strong></p><ul><li><strong>接收进程</strong>调用接收原语<code>receive(b)</code>，从自己的消息队列<code>mq</code>中,摘下第一个消息缓冲区 i,并将其中的数据复制到以 b 为首址的指定消息接收区内</li><li>完成消息的接收后接收进程返回到用户态继续进行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-13-24-54.png"></p><h4 id="消息传递系统实现中的若干问题"><a href="#消息传递系统实现中的若干问题" class="headerlink" title="消息传递系统实现中的若干问题"></a>消息传递系统实现中的若干问题</h4><ul><li><p><strong>通信链路(communication link)</strong><br>为使在发送进程和接收进程之间能进行通信，必须在两者之间建立一条通信链路。有两种方式建立通信链路。</p><ul><li>第一种方式：由发送进程在通信之前，用显式的“建立连接”命令(原语)请求系统为之建立一条通信链路；在链路使用完后，也用显式方式拆除链路。这种方式主要用于计算机网络中</li><li>第二种方式: 发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令(原语)，系统会自动地为之建立一条链路。这种方式主要用于单机系统中。</li></ul><p>根据通信链路的<strong>连接方法</strong>，又可把通信链路分为两类：</p><ul><li><strong>点对点连接通信链路</strong>，这时的一条链路只连接两个结点(进程)；</li><li><strong>多点连接链路</strong>，指用一条链路连接多个(n ＞ 2)结点(进程)。<br>而根据<strong>通信方式</strong>的不同，则又可把链路分成两种：</li><li><strong>单向通信链路</strong>，只允许发送进程向接收进程发送消息；</li><li><strong>双向链路</strong>，既允许由进程 A 向进程 B 发送消息，也允许进程 B 同时向进程 A 发送消息。</li></ul></li><li><p><strong>消息的格式</strong></p><ul><li><strong>定长消息</strong><br>在某些 OS 中，消息是采用比较短的定长消息格式，这减少了对消息的处理和存储开销。</li><li><strong>变长消息</strong><br>在有的 OS 中，采用另一种变长的消息格式，即进程所发送消息的长度是可变的。系统在处理和存储变长消息时，须付出更多的开销，但方便了用户。<br>注意：这两种消息格式各有其优缺点，故在很多系统(包括计算机网络)中，是同时都用的。</li></ul></li><li><p><strong>进程同步方式</strong><br>进程间通过消息队列通信，则进程之间需同步，其同步方式有三种：</p><ul><li><strong>发送进程阻塞,接收进程阻塞</strong>：进程间汇合同步，有消息时传递，无消息时同时阻塞。</li><li><strong>发送进程不阻塞,接收进程阻塞</strong>：发送者尽快发送消息，接收者平时阻塞收到消息才唤醒，例如多个用户共享一个打印服务。</li><li><strong>发送进程和接收进程均不阻塞</strong>：发送者和接收者均忙于自身事务，直到无法继续才阻塞。例如发送进程和接收进程间关联一个长度为 n 的消息队列。</li></ul></li></ul><h4 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h4><p>信箱是间接通信方式的一种实现，是一种特殊的消息队列，用于进程间通信。</p><p><strong>信箱的创建和撤消</strong>:进程可利用信箱创建原语来建立一个新信箱。创建者进程应给出信箱名字、信箱属性(公用、私用或共享)；对于共享信箱，还应给出共享者的名字。当进程不再需要读信箱时，可用信箱撤消原语将之撤消。<br><strong>消息的发送和接收</strong>:当进程之间要利用信箱进行通信时，必须使用共享信箱，并利用系统提供的下述通信原语进行通信。<br><code>Send(mailbox, message);</code> 将一个消息发送到指定信箱；<br><code>Receive(mailbox, message);</code> 从指定信箱中接收一个消息；</p><p>信箱定义为一种数据结构。在逻辑上，可以将其分为信箱头 MailboxHeader 和信箱体 MailboxBody 两部分</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-00-40.png"></p><p>信箱可由操作系统创建，也可由用户进程创建，创建者是信箱的拥有者。据此，可把信箱分为以下三类：</p><ul><li><strong>私用信箱</strong> 用户<strong>进程</strong>可为自己建立一个新信箱，并作为该进程的一部分。信箱的拥有者有权从信箱中读取消息，其他用户则只能将自己构成的消息发送到该信箱中。这种私用信箱可采用单向通信链路的信箱来实现。当拥有该信箱的进程结束时，信箱也随之消失。</li><li><strong>公用信箱</strong> 由<strong>操作系统</strong>创建，并提供给系统中的所有核准进程使用。进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息。显然，公用信箱应采用双向通信链路的信箱来实现。通常，公用信箱在系统运行期间始终存在。</li><li><strong>共享信箱</strong> 由某<strong>进程</strong>创建，在创建时或创建后，指明它是可共享的，同时须指出共享进程(用户)的名字。信箱的拥有者和共享者，都有权从信箱中取走发送给自己的消息。</li></ul><p>在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：</p><ul><li><strong>一对一关系</strong> 这时可为发送进程和接收进程建立一条两者专用的通信链路，使两者之间的交互不受其他进程的干扰</li><li><strong>多对一关系</strong> 允许提供服务的进程与多个用户进程之间进行交互，也称为客户&#x2F;服务器交互(client&#x2F;server interaction)</li><li><strong>一对多关系</strong> 允许一个发送进程与多个接收进程进行交互，使发送进程可用广播方式，向接收者(多个)发送消息</li><li><strong>多对多关系</strong>。允许建立一个公用信箱，让多个进程都能向信箱中投递消息；也可从信箱中取走属于自己的消息</li></ul><h3 id="客户机-服务器系统-Client-Server-System"><a href="#客户机-服务器系统-Client-Server-System" class="headerlink" title="客户机-服务器系统 Client-Server System"></a>客户机-服务器系统 Client-Server System</h3><h4 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 Socket"></a>套接字 Socket</h4><p><strong>Socket 定义</strong><br>Windows Sockets 是<strong>为上层应用程序提供的一种标准网络接口</strong>，主要用于网络中的数据通信。上层应用程序不用关心 Winsock 的实现细节，它为上层应用程序提供透明的服务。<br>Windows Sockets 规范以 U.C. Berkeley 大学 BSD UNIX 中流行的 Socket 接口为范例定义了一套 microsoft Windows 下网络编程接口。<br>它不仅包含了人们所熟悉的 Berkeley Socket 风格的库函数；也包含了一组针对 Windows 的扩展库函数，以使程序员能充分地利用 Windows 消息驱动机制进行编程。</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-18-48.png" style="zoom:50%;" /></center><p><strong>TCP&#x2F;IP</strong></p><p>TCP&#x2F;IP 协议的核心部分是传输层协议(TCP、UDP)，网络层协议(IP)和物理接口层，这三层通常是在操作系统内核中实现。因此用户一般不涉及。<br>编程时，编程界面有两种形式：由内核直接提供的系统调用；使用以库函数方式提供的各种函数。前者为核内实现，后者为核外实现。用户服务要通过核外的应用程序才能实现，所以要使用套接字(socket)来实现。</p><p><strong>TCP&#x2F;IP 协议与 WinSock 的关系</strong></p><p>WinSock 不是一种网络协议，它只是一个网络编程接口，可以把它当作一些协议的封装。<br>WinSock 就是 TCP&#x2F;IP 协议的一种封装，可以通过调用 WinSock 的接口函数来调用 TCP&#x2F;IP 的各种功能.<br>例如想用 TCP&#x2F;IP 协议发送数据，就可以使用 WinSock 的接口函数 Send()来调用 TCP&#x2F;IP 的发送数据功能，至于具体怎么发送数据，WinSock 已经帮用户封装好了这种功能。</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-20-43.png" alt="TCP" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-28-31.png" alt="UDP" style="zoom:50%;" /></center><h4 id="远程过程调用-RPC"><a href="#远程过程调用-RPC" class="headerlink" title="远程过程调用 RPC"></a>远程过程调用 RPC</h4><p><strong>远程过程调用 RPC</strong>(Remote Procedure Call)，是一个通信协议，用于通过网络连接的系统。该协议允许运行于一台主机(本地)系统上的进程调用另一台主机(远程)系统上的进程，而对程序员表现为常规的过程调用，无需额外地为此编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称做远程方法调用。<br>RPC 主要是为了解决的两个问题：</p><ul><li>解决分布式系统中，服务之间的调用问题。</li><li>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑</li></ul><p><strong>Steps</strong></p><ol><li>调用客户端存根；执行传送参数</li><li>调用本地系统内核发送网络消息</li><li>消息传送到远程主机</li><li>服务器存根得到消息并取出参数</li><li>执行远程过程</li><li>执行的过程将结果返回服务器存根</li><li>服务器存根封装结果，调用远程系统内核</li><li>消息传回本地主机</li><li>客户存根从内核接收消息</li><li>客户接收存根返回的数据</li></ol><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-51-43.png" alt="Ch2-3InterprocessCommunication-2024-03-11-14-51-43"></p></center>]]></content>
    
    
    <summary type="html">IPC, Interprocess Communication</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Concurrency vs Parallelism</title>
    <link href="https://efterklang.github.io/UESTC/OS/ConcurrencyvsParallelism/"/>
    <id>https://efterklang.github.io/UESTC/OS/ConcurrencyvsParallelism/</id>
    <published>2024-03-10T13:30:40.000Z</published>
    <updated>2024-04-27T11:23:40.580Z</updated>
    
    <content type="html"><![CDATA[<p>当我们谈论计算机科学和互联网技术时，经常会遇到并发(concurrency)和并行(parallelism)这两个词。它们听起来相似，但实际上又有一些重要的区别。</p><h2 id="并发-Concurrency"><a href="#并发-Concurrency" class="headerlink" title="并发 Concurrency"></a>并发 Concurrency</h2><p>是指两个或多个事件在<strong>同一时间间隔内</strong>发生<br>CPU 交替执行多个程序,由于切换速度很快,以人类的感觉来看是同时执行的;但在微观层面,在同一时刻只能有一条指令执行处理器分时复用,多线程交织执行;在特定某个时刻，某一个线程以排他方式独占 CPU 资源，而在不同时刻，不同的线程占用 CPU 运行，从而实现在一段时间内同时执行多个线程的表象。</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ConcurrencyvsParallelism-2024-03-10-19-00-41.png"></p></center><h2 id="并行-Parallelism"><a href="#并行-Parallelism" class="headerlink" title="并行 Parallelism"></a>并行 Parallelism</h2><p>是指两个或多个事件在<strong>同一时刻</strong>发生</p><p>同一时刻内,无论从微观还是宏观层面来看，有多条指令在多个处理器上是同时执行的</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ConcurrencyvsParallelism-2024-03-10-19-00-49.png"></p></center><h2 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结 Conclusion"></a>总结 Conclusion</h2><p>多 CPU 指的是在一套系统中拥有多颗 CPU，常见于服务器、工作站或计算中心，可以提供庞大的算力。</p><p>多核是指在一枚处理器（processor）中集成两个或多个完整的计算引擎。</p><table><thead><tr><th></th><th align="center"><strong>Thread Concurrency</strong></th><th align="center"><strong>Thread Parallelism</strong></th><th align="center"><strong>Process Concurrency</strong></th><th align="center"><strong>Process Parallelism</strong></th></tr></thead><tbody><tr><td>多 CPU</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td>多核</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">❌</td></tr><tr><td>单核 CPU</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td><td align="center">❌</td></tr></tbody></table><p>操作系统会拆分 CPU 为一段段时间的运行片，轮流分配给不同的程序。对于多 cpu，多个进程可以并行在多个 cpu 中计算，当然也会存在进程切换；对于单 cpu，多个进程在这个单 cpu 中是并发运行，根据时间片读取上下文+执行程序+保存上下文。同一个进程同一时间段只能在一个 cpu 中运行，如果进程数小于 cpu 数，那么未使用的 cpu 将会空闲。</p><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p><p>对于多核 cpu，进程中的多线程并行执行，执行过程中存在线程切换，线程切换开销较小。对于单核 cpu，多个线程在 cpu 中并发执行，根据时间片切换线程。同一个线程同一时间段只能在一个 cpu 内核中运行，如果线程数小于 cpu 内核数，那么将有多余的内核空闲。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.jianshu.com/p/cbf9588b2afb">https://www.jianshu.com/p/cbf9588b2afb</a><br><a href="https://zhuanlan.zhihu.com/p/383279972">https://zhuanlan.zhihu.com/p/383279972</a><br><a href="https://blog.csdn.net/weixin_45163798/article/details/104596138">https://blog.csdn.net/weixin_45163798&#x2F;article&#x2F;details&#x2F;104596138</a></p>]]></content>
    
    
    <summary type="html">并发Concurrency和并行Parallelism</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Linux Terminal Commands</title>
    <link href="https://efterklang.github.io/Dev/Linux/LinuxCmds/"/>
    <id>https://efterklang.github.io/Dev/Linux/LinuxCmds/</id>
    <published>2024-03-10T07:20:17.000Z</published>
    <updated>2024-04-28T11:47:51.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>查询指定文件夹下的文件个数<code>ls -A &lt;folder_path&gt;  wc -l</code><br>重命名&#x2F;移动文件 <code>mv &lt;old_name&gt; &lt;new_name&gt;</code> <code>mv &lt;old_path&gt; &lt;new_path&gt;</code><br>将指定文件夹下的所有文件移动到另一个指定的目录<code>mv &lt;source_folder&gt;/* &lt;target_folder&gt;</code></p><p>nohup命令可以在退出shell后继续运行进程，<code>nohup &lt;command&gt; &amp;</code><br>例如 <code>nohup python ./train.py &gt;&gt; train.log 2&gt;&amp;1 &amp;</code></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + L clear</span><br><span class="line">Ctrl + K 删除从光标位置到行尾的内容</span><br><span class="line">Ctrl + U 删除从光标位置到行首的内容</span><br><span class="line">Ctrl + A：移动光标到行首。</span><br><span class="line">Ctrl + E：移动光标到行尾</span><br></pre></td></tr></table></figure><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><ul><li><a href="https://github.com/ajeetdsouza/zoxide">zoxide</a><br> A smarter cd command. Supports all major shells.</li><li><a href="https://github.com/sharkdp/bat">bat</a><br> A cat clone with syntax highlighting and Git integration.</li><li><a href="https://github.com/sharkdp/fd">fd</a><br> A simple, fast and user-friendly alternative to find.</li><li><a href="https://github.com/BurntSushi/ripgrep">ripgrep</a><br> ripgrep recursively searches directories for a regex pattern while respecting your gitignore</li><li><a href="https://github.com/junegunn/fzf">fzf</a><br> 🌸 A command-line fuzzy finder</li><li><a href="https://github.com/ClementTsang/bottom">bottom</a><br> Yet another cross-platform graphical process&#x2F;system monitor.</li><li><a href="https://github.com/orf/gping">gping</a><br> Ping, but with a graph</li><li><a href="https://github.com/rs/curlie">curlie</a><br> The power of curl, the ease of use of httpie.</li></ul><h2 id="Terminal-Shell"><a href="#Terminal-Shell" class="headerlink" title="Terminal &amp; Shell"></a>Terminal &amp; Shell</h2><p>Terminal推荐使用Wezterm，Alacritty，Kitty，iTerm2 etc.<br>Shell推荐使用Nushell,Fish,Powershell zshell etc.</p>]]></content>
    
    
    <summary type="html">记录个人常用的Linux命令,快捷键和插件,以及推荐的terminal&amp;shell;</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Linux" scheme="https://efterklang.github.io/categories/Dev/Linux/"/>
    
    
    <category term="Linux" scheme="https://efterklang.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ARM中断及异常</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD/</id>
    <published>2024-03-09T08:33:02.000Z</published>
    <updated>2024-03-24T08:33:50.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>中断是主机与外设进行数据通信的重要机制，它负责处理处理器外部的事件;<strong>异常实质上也是一种中断，只不过它主要负责处理处理器内部事件</strong>。计算机通常是用中断来处理外中断和内部异常，因此在ARM技术中，将二者统称为异常。<br><strong>中断</strong>当处理器遇有外部设备发生 “紧急事件” 需要它来处理时，它就必须停下 “手头上的工作” 先去处理这个 “紧急事件”。处理器的这种工作过程，或者这种工作状态就叫做中断。<br><strong>中断请求</strong>当外部设备有紧急事件需要处理器进行处理时，外部设备必须向处理器发送一个 电信号（脉冲或电平） 来表示有事件需要处理器来处理。这个信号叫做 中断请求信号 ，或称 中断请求。<br><strong>中断源</strong>发出中断请求信号的外部设备或事件就叫做中断源。<br><strong>异常</strong>由内部事件引起的中断叫做异常。</p><p><strong>中断向量和中断向量表</strong><br>为了与普通子程序的首地址进行区分，<strong>中断服务程序的首地址（入口地址）通常被叫做中断向量</strong>，或中断矢量。以后还会看到，凡是能直接或间接指向中断服务程序的都叫中断向量。<br><strong>在处理器收到中断请求之后，它们都需要获得中断服务程序首地址——中断向量。</strong><br>所有的中断向量都按一定规律存放在一个固定的存储区域，这个集中存放了中断向量或与中断向量相关信息的存储区域就叫做<strong>中断向量表</strong>。</p><h3 id="中断请求信号的屏蔽"><a href="#中断请求信号的屏蔽" class="headerlink" title="中断请求信号的屏蔽"></a>中断请求信号的屏蔽</h3><p><strong>可屏蔽中断</strong> 人们把带有开关，能阻止中断请求的中断输入端叫做可屏蔽中断信号输入端。这类中断叫可屏蔽中断。<br><strong>非屏蔽中断</strong> 人们把不带开关，不能阻止中断请求的中断输入端叫做非屏蔽中断信号输入端。这类中断叫非屏蔽中断。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD-2024-03-09-14-22-06.png"></p><p>为了对处理器可以接收中断源的数目进行扩充及对中断进行必要的管理，在中断源和处理器之间还配有如下图所示的<strong>中断控制器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD-2024-03-09-14-22-54.png"></p><h3 id="中断优先级及中断嵌套"><a href="#中断优先级及中断嵌套" class="headerlink" title="中断优先级及中断嵌套"></a>中断优先级及中断嵌套</h3><p>处理器通常只有一个可屏蔽中断请求输入端。对于具有 多个中断源的系统来说，当有两个或两个以上中断源同时发生中断请求时就会出现所谓的竞争。<br>竞争可以通过优先级的方法来处理，具体实现方法有两种：硬件实现方法和软件实现方法。</p><h3 id="ARM异常响应"><a href="#ARM异常响应" class="headerlink" title="ARM异常响应"></a>ARM异常响应</h3><p><strong>处理器响应中断的条件</strong></p><ul><li>处理器程序状态寄存器的中断屏蔽标志处于<strong>非屏蔽状态</strong></li><li>没有更高级的中断请求正在响应或正在发出、正挂起；</li><li>处理器在<strong>现行指令执行结束后</strong></li></ul><p><strong>中断的处理过程</strong></p><ul><li>当有中断请求发生且满足上述条件时，计算机系统就会响应中断请求，并自动将被中断程序的下一条指令地址（断点地址）保存和关闭中断；接下来便将自中断向量表查询得到的与该中断源对应的中断向量送入PC，并转去执行中断服务程序。</li><li>当执行到中断服务程序末尾时，执行中断返回指令或跳转指令，把保存的断点地址送回 PC，以在断点处接续执行被中断的程序。</li></ul><p><strong>ARM的中断(异常)向量表</strong></p><p>ARM的中断向量表内存放的是响应异常和中断的转移指令而不是中断向量地址。<br>在ARM处理器中，当异常发生时，完成当前指令后跳转到相应的异常中断处理程序入口执行异常中断处理。异常处理完毕后返回原来的程序断点继续执行原来的程序。</p><p><strong>进入异常</strong></p><p>在异常发生后，ARM内核会作以下工作：</p><ul><li>在适当的LR中保存断点的地址</li><li>把当前程序状态寄存器（CPSR）中的内容保存到模式私有寄存器SPSR中</li><li>将寄存器CPSR中的MODE域设置为中断（异常）应进入的运行模式；</li><li>对CPSR的I位和F位进行相应的设置，以防止再次响应同一个中断请求。</li><li>强制PC从相关的异常向量处取指，即到中断向量表中获取中断向量，转向用户所编写的中断（异常）服务程序。<br>注：异常总是在ARM状态中进行处理。当处理器处于Thumb状态时发生了异常，在异常向量地址装入PC时，会自动切换到ARM状态</li></ul><p><strong>异常返回</strong></p><p>当异常结束时，异常处理程序必须做如下处理：</p><ul><li>将SPSR的值复制回CPSR</li><li>将LR中的值减去偏移量后存入PC，偏移量根据异常的类型而有所不同。</li></ul><h3 id="ARM的中断-异常"><a href="#ARM的中断-异常" class="headerlink" title="ARM的中断(异常)"></a>ARM的中断(异常)</h3><p>ARM按事件的紧急程度为每个中断（异常）都定义了一个固定的优先级别。当多个异常同时发生时，一个固定的优先级系统决定它们被处理的顺序：</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD-2024-03-09-16-31-02.png"></p></center><h4 id="快速中断请求异常FIQ"><a href="#快速中断请求异常FIQ" class="headerlink" title="快速中断请求异常FIQ"></a>快速中断请求异常FIQ</h4><p>有些嵌入式系统的应用对实时性要求比较高，需要足够快的中断响应速度，比如数据转移或通道处理。ARM在设计上充分地考虑了嵌入式系统的这一特点，在IRQ异常之外还设计了一种快速中断请求（FIQ）异常，并在硬件结构和资源分配上给予了足够的支持。<br>为减少延时，ARM在快中断中采取了 两个措施：<br>专门为快中断配置了较多的私有寄存器，从而可使中断服务程序有足够的寄存器来使用，而不必与被中断服务程序使用同一组寄存器，这样就免去了因寄存器冲突而必需的保护及恢复现场工作。<br>ARM把FIQ的中断向量放在了中断（异常）向量表末尾 0X0000001C处，因此它后面没有其它中断向量，允许用户将中断服务程序直接放在这里。</p><h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h4><p>自行查阅资料</p>]]></content>
    
    
    <summary type="html">ARM处理器异常及中断</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM-Processor" scheme="https://efterklang.github.io/categories/UESTC/ARM-Processor/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>ARM处理器及系统结构</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch2-1ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch2-1ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-09T06:12:26.000Z</published>
    <updated>2024-03-24T08:33:59.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARM-介绍"><a href="#ARM-介绍" class="headerlink" title="ARM 介绍"></a>ARM 介绍</h2><p>ARM（Advanced RISC Machines）有 3 种含义：</p><ul><li>是一个公司的名称;</li><li>是一种技术的名称</li><li>是一类微处理器的通称;</li></ul><p>基于 ARM 技术 的微处理器应用约占据了 32 位 RISC 微处理器 80% 以上的市场份额，其中，在手机市场，ARM 占有绝对的垄断地位。</p><p><strong>处理器 Processor</strong>（也称为中央处理单元或 CPU）是计算机的核心组件，它负责执行大部分的计算和逻辑操作。处理器不仅包括处理芯片，还有其他几个关键的部分:</p><ul><li><strong>内核</strong>（Cores）：现代处理器通常包含多个内核，每个内核都可以独立执行指令。多核处理器可以同时执行多个任务，提高了性能。</li><li><strong>缓存</strong>（Cache）：缓存是一种快速存储器，用于存储处理器可能需要的数据和指令。通过使用缓存，处理器可以减少从主内存获取数据的时间，提高性能。</li><li><strong>控制单元</strong>（Control Unit）：控制单元是处理器的一个部分，负责管理和协调处理器的操作。它解释和执行存储在内存中的指令。</li><li><strong>算术逻辑单元</strong>（Arithmetic Logic Unit, ALU）：ALU 负责执行所有的算术和逻辑操作，包括加法、减法、乘法、除法以及比较操作。</li><li><strong>寄存器</strong>（Registers）：寄存器是一种非常快速的存储器，用于临时存储和访问正在被处理器处理的数据和指令。</li><li><strong>总线</strong>（Buses）：总线是连接处理器和其他系统组件（如内存、硬盘、输入&#x2F;输出设备等）的通道，用于数据传输。</li></ul><p><strong>ARM 公司</strong>是一家总部位于英国 Cambridge 的设计和许可证公司，专注于处理器核心的设计。ARM 并不直接生产和销售芯片，而是设计和开发处理器架构，然后向各种芯片制造商授权这些设计。这些芯片制造商，如高通（Qualcomm）、三星（Samsung）、苹果（Apple）等，会基于 ARM 的设计，制造出各自的处理器产品。</p><p>ARM 的业务模式使得它可以专注于设计和优化处理器架构，而无需投入大量资金来建立和维护自己的制造设施。同时，芯片制造商可以利用 ARM 的设计来生产高效、低功耗的芯片，而无需自行从头开始设计处理器架构。</p><p>采用 RISC 架构的 ARM 微处理器一般有如下<strong>特点</strong>：</p><ul><li>体积小、功耗低、低成本、高性能；</li><li>支持 Thumb（16 位）&#x2F;ARM（32 位）双指令集，能很好地兼容 8 位&#x2F;16 位 器件；</li><li>大量使用 寄存器，指令执行速度更快；</li><li>大多数数据操作都在寄存器中完成；</li><li>寻址方式灵活简单，执行效率高；</li><li>指令长度固定。</li></ul><h2 id="ARM-Processor-系列介绍"><a href="#ARM-Processor-系列介绍" class="headerlink" title="ARM Processor 系列介绍"></a>ARM Processor 系列介绍</h2><p><strong>ARM 处理器指令集的特点</strong></p><p>ARM 内核不是一个纯粹的 RISC 体系结构，ARM 指令集与纯粹的 RISC 的定义有以下几个不同。</p><ul><li>一些特定指令的周期数可变，并不是每条 ARM 指令都是单周期的。</li><li>内嵌的桶形移位器(可以单个时钟周期内对二进制数进行多位的移位操作)产生了更为复杂的指令，扩展了指令的功能，因此改善了内核的性能。</li><li>支持 16 位的 Thumb 指令集，提高了代码密度。</li><li>支持条件执行：每条指令都可以设置一个执行条件，只有条件满足时才执行。</li><li>增强指令：一些功能强大的数字信号处理指令被加入到 ARM 指令集中。</li></ul><p><strong>ARM 指令集体系结构的演变</strong>（了解）</p><blockquote><p>ARM 公司定义了不同版本的 ARM 指令集体系结构版本，用 vn 来标识（n 是版本号，目前是 1-8）。<br>ARM v1 ～ v3 版本的处理器未得到大量应用，ARM 处理器的大量广泛应用是从其 v4 版本开始的。<br>v7 系列 CPU 被称作 CoreTex 系列<br>到目前 v8 是最新的版本， 可以选择 64 或 32 执行状态。64 执行状态针对 64 位处理技术，引入了一个全新指令集 A64，可以存取大虚拟地址空间。</p></blockquote><p><code>ARMv4</code><br>ARMv4 是目前支持的最老的架构,是基于 32-bit 地址空间的 32-bit 指令集。ARMv4 除了支持 ARMv3 的指令外还扩展了：<br>支持 halfword 的存取<br>支持 byte 和 halfword 的符号扩展读<br>进一步的明确了会引起 Undefined 异常的指令<br>对以前的 26bits 体系结构的 CPU 不再兼容</p><p><code>ARMv4T</code><br>ARMv4T 增加了 16-bit Thumb  指令集，这样使得编译器能产生紧凑代码(相对于 32-bit 代码，内存能节省到 35%以上)并保持 32-bit 系统的好处。<br>Thumb 在处理器中仍然要扩展为标准的 32 位 ARM 指令来运行。用户采用 16 位 Thumb 指令集最大的好处就是可以获得更高的代码密度和降低功耗。</p><p><code>ARMv8</code><br>2011 年 11 月，ARM 公司发布了新一代处理器架构 ARM V8，<strong>ARM 的首个 64 位架构</strong>;ARM 2012 年十月发布了 Cortex-A53 and Cortex-A57 核心。2013 年苹果基于 V8 架构的 Apple 7 使用在了 iPhone 5S 上。</p><p><code>Cortex</code><br>ARM 推出的Cortex 系列包括：Cortex-A、Cortex-R 和Cortex-M三个系列。</p><ul><li><code>Cortex-A(Application)</code>系列主要应用于复杂的应用中，支持：ARM、Thumb和 Thumb2指令集。</li><li><code>Cortex-R(Real-time)</code>系列是为实时操作系统设计的嵌入式处理器，能带来更小的芯片面积和低功耗。</li><li><code>Cortex-M(Microcontroller)</code>系列处理器结合了多种突破性技术，集成了许多紧耦合系统外设，以便能满足下一代产品的控制要求，适用于高性能、低成本需求的嵌入式应用。 Cortex-M主要针对单片机领域。</li></ul><p><strong>ARM9的5 级流水线</strong>(流水线的级数，代表的是指令周期被划分成的阶段数量)<br>5级流水线 是 ARM9TDMI 的主要特征之一，其设计减少了在每个时钟内必须完成的最大工作量，进而允许使用较高的时钟频率。</p><ul><li><strong>取指</strong>：指令从存储器中取出，放入指令流水线</li><li><strong>译码</strong>：指令译码，从寄存器堆中读取寄存器操作数</li><li><strong>执行</strong>：把一个操作数移位，产生ALU的结果。如果指令是Load或Store，在ALU中计算存储器的地址</li><li><strong>缓存</strong>&#x2F;数据：如果需要，则访问数据存储器；否则，ALU的结果只是简单地缓冲一个时钟周期，以便使所有指令具有同样的流水线流程</li><li><strong>回写</strong>：将指令产生的结果写回到寄存器堆，包括任何从寄存器读出的数据</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-19-42.png" alt="classic name"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ARM 处理器命名</span><br><span class="line">规则：ARM&#123;x&#125;&#123;y&#125;&#123;z&#125;&#123;T&#125;&#123;D&#125;&#123;M&#125;&#123;I&#125;&#123;E&#125;&#123;J&#125;&#123;F&#125;&#123;-S&#125;</span><br><span class="line">x -- 处理器系列</span><br><span class="line">y -- 存储管理/保护单元</span><br><span class="line">z -- cache</span><br><span class="line">T -- 支持 Thumb 指令集</span><br><span class="line">D -- 支持片上调试</span><br><span class="line">M -- 支持快速乘法器</span><br><span class="line">I -- 支持 Embedded ICE，支持嵌入式跟踪调试</span><br><span class="line">E -- 支持增强型 DSP(Digital Signal Processor) 指令</span><br><span class="line">J -- 支持 Jazelle</span><br><span class="line">F -- 具备向量浮点单元 VFP</span><br><span class="line">-S -- 可综合版本</span><br></pre></td></tr></table></figure><h2 id="ARM-Processor-工作状态"><a href="#ARM-Processor-工作状态" class="headerlink" title="ARM Processor 工作状态"></a>ARM Processor 工作状态</h2><h3 id="ARM-状态和-Thumb-状态"><a href="#ARM-状态和-Thumb-状态" class="headerlink" title="ARM 状态和 Thumb 状态"></a>ARM 状态和 Thumb 状态</h3><blockquote><p><strong>Thumb 指令集</strong><br>嵌入式系统在某些应用场合对存储成本或空间要求比较苛刻，为了让用户更好地控制代码量，于是设计了 2 套指令系统，分别为 ARM 指令集和 Thumb 指令集。其中 ARM 指令集为 32 位（字）长度，具有最完整的功能；Thumb 指令集为 16 位（半字）长度，能实现 ARM 指令集的大部分功能<br>在功能上可以认为 Thumb 是 ARM 指令集的子集</p></blockquote><p>既然 ARM 处理器共存 2 种指令集，那么到底何时执行 ARM 指令集，何时执行 Thumb 指令集呢?<br>ARM 处理器有 2 个处理器状态与这 2 套指令集分别对应;ARM 处理器的两种状态可以通过相应的指令进行切换;</p><p>ARM9TDMI 核是具有 T 变种的 ARM 处理器核，其<strong>工作状态一般有以下两种</strong>，并可在两种状态之间切换。</p><ul><li>ARM 状态:执行 32 位的字对齐的 ARM 指令。是系统上电默认的状态。</li><li>Thumb 状态:执行 16 位的、半字对齐的 Thumb 指令。</li></ul><p><strong>Note</strong></p><ul><li>ARM 指令集与 Thumb 指令集不能同时混合使用</li><li>ARM 和 Thumb 状态间的切换并不影响处理器模式或寄存器内容。</li><li>从一个 ARM 例程调用另一个 Thumb 例程时，内核必须切换状态，反之亦然</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-34-34.png" alt="Work state"></p><h3 id="指令长度和数据格式"><a href="#指令长度和数据格式" class="headerlink" title="指令长度和数据格式"></a>指令长度和数据格式</h3><p>ARM 微处理器的指令长度可以是 32 位（在 ARM 状态下），也可以为 16 位（在 Thumb 状态下）。<br>ARM 微处理器中支持字节<strong>Byte（8 位）、半字 Half-Word（16 位）、字 Word（32 位）</strong>三种数据类型。</p><ul><li>如果一个数据是以字方式存储的，那么它就是字对齐的；</li><li>如果一个数据是以半字方式存储的，那么它就是半字对齐的。</li></ul><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-39-05.png" alt="alignment"></p></center><p><em><code>0x4002</code> 和 <code>0x4004</code> 相差 2 个 Byte,即 16bit,所以为半字对齐 Half-Word Aligned</em></p><h2 id="ARM-Processor-运行模式"><a href="#ARM-Processor-运行模式" class="headerlink" title="ARM Processor 运行模式"></a>ARM Processor 运行模式</h2><p>ARM 体系结构支持<strong>7 种</strong>运行模式：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-49-18.png" alt="ARM Processor Mode"></p><ul><li><strong>用户模式</strong>（USR）正常程序执行模式，大部分任务执行在这种模式下。用户模式是用户程序的工作模式。该没有权限去操作其它硬件资源，也不能切换到其它模式下。</li><li><strong>系统模式</strong>（SYS）系统模式是特权模式，不受用户模式的限制。用户模式和系统模式共用一套寄存器，但比用户模式有更高的权限，可以访问所有系统资源及进行模式切换。</li><li><strong>一般中断模式</strong>（IRQ）一般中断模式也叫通用中断模式，用于处理一般的中断请求，通常在硬件产生中断信号之后自动进入该模式，该模式为特权模式，可以自由访问系统硬件资源。</li><li><strong>快速中断模式</strong>（FIQ）快速中断模式是相对一般中断模式而言的，它是用来处理对时间要求比较紧急的中断请求，主要用于高速数据传输及通道处理中，其中断优先级相对普通中断更高</li><li><strong>管理模式</strong>（Supervisor，SVC） 管理模式是 CPU 上电后默认模式，因此在该模式下主要用来做系统的初始化，软中断处理也在该模式下。系统复位或开机、软中断时进入到 SVC 模式下。</li><li><strong>中止模式</strong>（ABT）中止模式用于支持虚拟内存或存储器保护，当用户程序访问非法地址，没有权限读取的内存地址时，会进入该模式。</li><li><strong>未定义模式</strong>（UND）CPU 在指令的译码阶段不能识别该指令操作时，会进入未定义模式，进行未定义陷阱处理。</li></ul><blockquote><p><strong>特权模式</strong>: 除用户模式外的其它 6 种处理器模式称为特权模式（Privileged Modes）。在特权模式下，程序可以访问所有的系统资源，也可以任意的进行处理器模式切换。只有在特权模式下才允许对当前程序状态寄存器（CPSR）的所有控制位直接进行读&#x2F;写访问，而在非特权模式下只允许对 CPSR 的控制位进行间接访问（SWI 方式）。<br>特权模式中除系统模式之外的其他 5 种模式又统称为<strong>异常模式</strong>。它们除了可以通过在特权下的程序切换进入外，也可以由特定的异常进入。其中管理模式也称为超级用户模式，是为操作系统提供软中断的特有模式。大多数的用户程序运行在用户模式下。当处理器工作在用户模式时，需要进行处理器模式切换时，应用程序可以产生异常处理，在异常处理过程中进行处理器模式切换。这种体系结构可以使操作系统控制整个系统资源的使用。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-53-32.png" alt="fix:快速中断为FIQ"></p><h2 id="ARM-Register"><a href="#ARM-Register" class="headerlink" title="ARM Register"></a>ARM Register</h2><p>ARM 处理器有如下 37 个用户可见寄存器。<br>31 个通用寄存器：</p><ul><li><code>R0~R15</code></li><li><code>R13_svc,R14_svc,</code></li><li><code>R13_abt,R14_abt,</code></li><li><code>R13_und、R14_und、</code></li><li><code>R13_irq、 R14_irq </code></li><li><code>R8_fiq~R14_fiq。</code></li></ul><p>6 个状态寄存器：</p><ul><li>1 个 CPSR</li><li>5 个 SPSR（ SPSR_svr、 SPSR_abt 、 SPSR_und 、 SPSR_irq 、 SPSR_frq ）；</li></ul><p>ARM 处理器共有 7 种运行模式，在每一种处理器模式中都有一组相应的寄存器。</p><p>在 ARM 状态下，任一时刻都可以访问到 16 个 通用寄存器和 1~2 个状态寄存器。各种模式下能访问的寄存器如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-16-06-15.png"></p><h3 id="堆栈指针-SP-R13"><a href="#堆栈指针-SP-R13" class="headerlink" title="堆栈指针 SP R13"></a>堆栈指针 SP R13</h3><p>寄存器R13通常用作堆栈指针，称作SP。每种异常模式都有自己的分组R13。通常R13应当被初始化成指向给异常模式所分配的堆栈。<br>其中用户模式和系统模式共用一个，每种异常模式都有专用的R13寄存器。它们通常指向各模式所对应的专用堆栈，也就是说ARM处理器允许用户程序有6个不同的堆栈空间。</p><h3 id="链接寄存器-LR-R14"><a href="#链接寄存器-LR-R14" class="headerlink" title="链接寄存器 LR R14"></a>链接寄存器 LR R14</h3><p>寄存器R14(链接寄存器或LR)在体系结构中有两种特殊用途：<br><strong>用途1</strong><br>在各种模式下，R14用来保存子程序的返回地址。当一条BL或者BLX指令执行子程序调用时，R14设为子程序的返回地址。返回时，通过复制R14中的地址值到PC中来实现子程序的返回。通常有以下<strong>2种方式</strong><br><strong>Method1:执行下列指令之一</strong></p><ul><li><code>MOV  PC, LR</code> 把LR中的值写入到PC寄存器中</li><li><code>BX LR</code>跳转(带状态切换)到LR地址所指向的指令执行。用于从实现从一个状态返回另外一个状态并继续执行。<br> <strong>Method2</strong><br>在子程序入口，执行R14的入栈操作<code>STMFP SP!, &#123;&lt;registers&gt;, LR&#125;</code> 该条指令用于把，<registers>和LR（R14）等多个寄存器压入堆栈，SP（R13）指向堆栈顶部。<br>并使用匹配的指令返回<code>LDMFP SP!, &#123;&lt;registers&gt;, PC&#125;</code>该条指令用于把堆栈顶部多个单元，执行出栈操作，出栈的数据保存到<registers>和PC等多个寄存器中。<br>注：执行该操作后，原R14入栈的值，出栈后就保存到PC中了，相当于执行了把R14的值写入到PC的操作。<br><strong>用途2</strong><br>当发生异常时，相关异常模式下的R14就设为异常返回地址。异常的返回地址与子程序的返回类似。区别在于有些异常有一个小常量的偏移</li></ul><h3 id="程序计数器-PC-R15"><a href="#程序计数器-PC-R15" class="headerlink" title="程序计数器 PC R15"></a>程序计数器 PC R15</h3><p>无论处理器处于何种状态，程序计数器 R15（即 PC）总是指向“正在取指”的指令，而不是指向“正在执行”的指令或正在“译码”的指令。<br>一般来说，人们习惯性约定将“正在执行的指令作为参考点”，称之为当前第 1 条指令。<br>因此，PC 总是指向第 3 条指令，或者说 PC 总是指向当前正在执行的指令地址再加 2 条指令的地址。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-16-13-50.png"></p><blockquote><p>MOV 执行时,LDR 在取值,相差 2 条指令的地址,如果为 ARM 指令,设三条指令地址分别为 <code>0x4000,0x4004,0x4008</code>,PC 值等于当前指令的地址+8Bytes,<code>0x4000 + 8 = 0x4008</code><br>当处理器处于 Thumb 状态时，每条指令长为 2 字节，所以 PC 的值为正在执行的指令地址加 4 字节，即：<code>PC值=当前程序执行位置+4字节</code></p></blockquote><h3 id="程序状态寄存器-PSR"><a href="#程序状态寄存器-PSR" class="headerlink" title="程序状态寄存器 PSR"></a>程序状态寄存器 PSR</h3><p><strong>当前程序状态寄存器</strong>（CPSR,Curren Program Status Register）可以在任何处理器模式下被访问，它包含下列内容：</p><ul><li>ALU 状态标志（条件码标志位）；</li><li>当前的处理器模式；</li><li>中断使能标志；</li><li>设置处理器的状态。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-21-20-39.png"></p><p>每一种异常器模式下，都有一个专用的物理寄存器做<strong>备份程序状态寄存器</strong>（SPSR,Saved Program Status Register ）。当特定的异常中断发生时，这个物理寄存器负责存放当前程序状态寄存器的内容。当异常处理程序返回时，再将其内容恢复到当前程序状态寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-21-28-07.png"></p><p>这些<strong>条件标志位</strong>会根据程序中的算数指令或逻辑指令的执行结果进行改变，而且这些条件标志位可由大多数指令检测以决定指令是否执行。</p><ul><li><code>N</code> 本位设置成当前指令执行结果的第 31 位。当两个由补码表示的有符号整数运算时，N&#x3D;1 表示结果为负数；否则结果为正数或零。</li><li><code>Z</code> Z&#x3D;1 表示运算的结果为零，否则结果不为零。</li><li><code>C</code> 分 4 种情况设置 C 的方法：<ul><li>在加法指令中（包括比较指令 CMN），当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢出，其它情况下 C&#x3D;0;</li><li>在减法指令中（包括比较指令 CMP），当运算中发生了借位，则 C&#x3D;0，其它情况下 C&#x3D;1;</li><li>对于在操作数中包含移位操作的运算指令（非加&#x2F;减指令），C 被设置成被移位寄存器最后移出去的位;</li><li>对于其它非加&#x2F;减法运算指令，C 的值通常不受影响。</li></ul></li><li><code>V</code> 下面分两种情况讨论 V 的设置方法：<ul><li>对于加&#x2F;减运算指令，当操作数和运算结果都是以二进制的补码表示的带符号的数时，且运算结果超出了有符号运算的范围时溢出。V&#x3D;1 表示符号位溢出；</li><li>对于非加&#x2F;减法指令，通常不改变标志位 V 的值。</li></ul></li><li><code>Q</code>（了解）在带 DSP 指令扩展的 ARMV5 及更高版本中，Q 标志位被指定用于指示增强 DSP 指令是否发生了溢出。在 ARMV5 以前的版本及 ARMV5 的非 E 系列处理器中，Q 标志位没有被定义，属于待扩展的位。</li></ul><p><strong>控制位</strong>:CPSR 的低 8 位属于控制位。</p><ul><li><code>I,F</code>中断禁止位（第 7、6 位） I&#x3D;1：IRQ 被禁止；F&#x3D;1：FIQ 被禁止。</li><li><code>T</code>状态控制位（第 5 位）T 是处理器的状态控制位。T&#x3D;0：处理器处于 ARM 状态；T&#x3D;1：处理器处于 Thumb 状态。<br>注意：绝对不要强制改变 CPSR 寄存器中的控制位 T。如果这样做，处理器会进入一个无法预知的状态。</li><li><code>MMMMM</code>模式控制位<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-21-37-07.png"></li></ul><p><strong>注意</strong><br>通过程序修改 CPSR 可以进入<strong>异常</strong>(除 SYS 以外的特权模式)。除此之外，也可以在内核对异常或者中断响应时由硬件切换到异常模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 例：从系统模式切换到管理模式 --&gt;</span><br><span class="line">&lt;!-- MSR CPSR_c, #D3 是一条ARM汇编语言指令，用于修改当前程序状态寄存器（Current Program Status Register，CPSR）的特定字段。这条指令的具体含义如下：</span><br><span class="line">MSR：这是一个Move to Status Register的指令，用于将一个值移动到一个状态寄存器中。</span><br><span class="line">CPSR_c：这表示目标是CPSR的控制字段（control field）</span><br><span class="line">#D3：这是一个立即数，表示要将CPSR的控制字段设置为十六进制的D3。在二进制中，D3等于1101 0011。 --&gt;</span><br><span class="line"></span><br><span class="line">MSR CPSR_c,#D3;</span><br></pre></td></tr></table></figure><p>用户模式与系统模式不能由异常进入，也就是说要想进入系统模式，必须通过修改 CPSR 才能实现。<br><code>MSR CPSR_c,#DF;</code></p><h2 id="ARM-Storage"><a href="#ARM-Storage" class="headerlink" title="ARM Storage"></a>ARM Storage</h2><h3 id="ARM存储方法"><a href="#ARM存储方法" class="headerlink" title="ARM存储方法"></a>ARM存储方法</h3><p>ARM处理器外部采用冯·诺依曼（von Neumann）结构，指令和数据共用一条32位数据总线，只有装载、存储和交换指令可访问存储器中的数据。<br>ARM处理器将存储器看作是一个从0开始的线性递增的字节集合，其中每个数组元素（字节）都是可以寻址的。<br>ARM支持<strong>大端模式（big-endian）</strong>和<strong>小端模式（little-endian）</strong>两种内存模式。<br>在大端模式下，一个字的高地址单元放的是数据的低位；而在小端模式下，数据的低位放在内存中低地址单元中。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-1ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-09-13-14-43.png"><br>一个基于ARM的实际芯片可能只支持小端存储器格式，也可能只支持大端存储器格式，还可能两者都支持。<br>ARM指令集不包含任何直接选择大小端存储器格式的指令，但是一个同时支持大小端存储器格式基于ARM的芯片可以通过硬件配置（一般使用芯片的引脚来配置）来匹配存储器系统所使用的规则。如果芯片有一个标准系统控制的协处理器（例如ARM920T的CP15协处理器），系统控制协处理器寄存器1的bit7可用于改变配置。<br>注意：对于 <code>S3C2440</code>是通过<strong>软件</strong>来指定存储器格式的（通过设置CP15协处理器协处理器寄存器1的bit7来实现），<strong>缺省为小端格式</strong>。</p><h3 id="ARM体系的存储空间"><a href="#ARM体系的存储空间" class="headerlink" title="ARM体系的存储空间"></a>ARM体系的存储空间</h3><p>ARM9使用 $2^{32}$ 个8位字节地址空间，字节地址的排列从 $0～2^{32}-1$<br>地址空间也可以看作是包含$2^{30}$个32位字，地址以字为单位进行分配。也就是将地址除以4，地址为A的字包含4个字节，地址分别为 <code>A、A+1、A+2和A+3</code>。<br>与此同时，地址空间还可被看作包含$2^{31}$个16位半字，地址按照半字进行分配。地址为A的半字包含2个字节，地址分别为 <code>A和A+1</code>。</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-1ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-09-13-35-31.png"></p></center><h3 id="ARM存储器结构"><a href="#ARM存储器结构" class="headerlink" title="ARM存储器结构"></a>ARM存储器结构</h3><p>ARM处理器有的带有指令cache和数据cache，但不带有片内RAM和片内ROM。<br>系统所需的RAM和ROM（包括Flash）都通过总线外接。<br>有的ARM片内还带有存储器管理单元MMU（Memory Management Unit）</p><h3 id="存储器映射I-O"><a href="#存储器映射I-O" class="headerlink" title="存储器映射I&#x2F;O"></a>存储器映射I&#x2F;O</h3><p>基于ARM内核的芯片具有许多的外设，这些外设访问的标准方法是使用存储器映射的I&#x2F;O（存储器统一编址），为外设的每个寄存器都分配一个地址。通常，从这些地址装载数据用于读入，向这些地址保存数据用于输出。有些地址的装载和保存用于外设的控制功能，而不是输入或输出功能。<br>注意：存储器映射的I&#x2F;O位置的操作不同于正常的存储器位置的操作。通常，把存储器映射的I&#x2F;O位置标记为无高速缓存和无缓冲区，以避免处理器把这部分地址当普通内存，调入到cache中，进行缓存操作。</p><h3 id="Flash组织形式"><a href="#Flash组织形式" class="headerlink" title="Flash组织形式"></a>Flash组织形式</h3><p>目前几乎所有MCU的程序都存储在Flash中。Flash分为片内和片外两种。片外Flash又有以下种类。<br>NOR Flash:NOR Flash读取速度快，但是擦除和写入速度慢。<br>NAND Flash:NAND Flash读取速度比NOR Flash慢，但擦除和写入速度很快</p><h3 id="RAM的组织形式"><a href="#RAM的组织形式" class="headerlink" title="RAM的组织形式"></a>RAM的组织形式</h3><p>芯片自带的RAM不够用时需要外加，外加的RAM一般是SDRAM和DDR RAM，极少数使用SRAM，因为SRAM的价格相对较贵，但SRAM速度要比动态RAM快。<br>SRAM:只需要在IDE中设置好地址。<br>SDRAM&#x2F;DDR RAM:不仅要在IDE中设置好起始地址，还要在程序中做初始化操作后才能使用。如果使用仿真器，那么在仿真运行程序前，要执行一个初始化脚本文件，或者执行一系列命令对SDRAM和DDR RAM进行初始化，否则会运行出错。</p>]]></content>
    
    
    <summary type="html">ARM处理器及系统结构;ARM介绍,ARM Processor 系列介绍,ARM处理器工作状态＆运行模式,ARM Register以及ARM存储</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM-Processor" scheme="https://efterklang.github.io/categories/UESTC/ARM-Processor/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://efterklang.github.io/Home/%E8%93%AC%E6%88%B7%E6%89%8B%E5%8D%B7/"/>
    <id>https://efterklang.github.io/Home/%E8%93%AC%E6%88%B7%E6%89%8B%E5%8D%B7/</id>
    <published>2024-03-08T06:43:54.631Z</published>
    <updated>2024-03-28T04:45:18.829Z</updated>
    
    <content type="html"><![CDATA[<style>h2 {    font-family: Microsoft JhengHei;    /* font-family: 楷体; */    color: #426cc2;    /* text-align: center; */    font-style: bold;}</style><div><h2>蓬户掩兮井径荒 青苔满兮履綦绝 园种邵平之瓜 门栽先生之柳 晓起呼童子 问山桃落乎 辛夷开未 手瓮灌花 除虫丝蛛总于时 不巾不履 坐水窗 追凉风 焚好香 烹苦茗 忽见异鸟来鸣树间 小倦即卧 康凉枕一觉  美睡萧然无梦 即梦亦不离竹坪茶坞间 </h2></div>]]></content>
    
    
      
      
    <summary type="html">

&lt;style&gt;
h2 {
    font-family: Microsoft JhengHei;
    /* font-family: 楷体; */
    color: #426cc2;
    /* text-align: center; */
    font-st</summary>
      
    
    
    
    
    <category term="中国古代诗词" scheme="https://efterklang.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BB%A3%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>Git for Android</title>
    <link href="https://efterklang.github.io/Dev/Git/GitForAndroid/"/>
    <id>https://efterklang.github.io/Dev/Git/GitForAndroid/</id>
    <published>2024-03-08T05:24:31.000Z</published>
    <updated>2024-04-27T11:45:30.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DownLoad"><a href="#DownLoad" class="headerlink" title="DownLoad"></a>DownLoad</h2><ol><li>在F-Droid 中搜索<code>Mgit</code>，下载并安装。(Play商店中也有,但功能不能正常使用)</li><li>在<a href="https://github.com/maks/MGit">Github</a>仓库选择合适的版本下载</li></ol><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Clone-a-remote-repository"><a href="#Clone-a-remote-repository" class="headerlink" title="Clone a remote repository"></a>Clone a remote repository</h3><ul><li>Click on the <code>+</code> icon to add a new repository</li><li>Enter remote URL <a href="#URL-format">see URL format below</a></li><li>Enter local repository name - note that this is not the full path, as MGit stores all repositories in the same local directory (can be changed in MGit settings)</li><li>Click the Clone button</li><li>If required, you will be prompted for credentials to connect to the remote repo. MGit will download the repository (all branches) to your device</li></ul><h3 id="Create-a-local-repository"><a href="#Create-a-local-repository" class="headerlink" title="Create a local repository"></a>Create a local repository</h3><ul><li>Click on the + icon to add a new repository</li><li>Click on Init Local to create a local repository</li><li>Enter the name for this repository when prompted</li><li>A local empty repo will be created</li></ul><h3 id="URL-format"><a href="#URL-format" class="headerlink" title="URL format"></a>URL format</h3><p><strong>SSH URLs</strong><br>SSH running on standard port (22): <code>ssh://username@server_name/path/to/repo</code><br>SSH running on non-standard port: <code>ssh://username@server_name:port/path/to/repo</code><br>username is needed - by default, MGit tries to connect as root.<br><strong>HTTP(S) URLs</strong><br>HTTP(S) URL: <code>https://server_name/path/to/repo</code></p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p><strong>MGit App</strong><br><code>Settings -&gt; SSH Keys -&gt; + icon -&gt; input NewFileName -&gt; Generate Key -&gt; Open File and Copy the content</code><br><strong>Github</strong><br><a href="https://github.com/settings/keys">Settings&#x2F;keys</a><br>New SSH Key -&gt; input Title -&gt; Paste the content</p>]]></content>
    
    
    <summary type="html">安卓平台Git客户端的使用</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Git" scheme="https://efterklang.github.io/categories/Dev/Git/"/>
    
    
    <category term="Git" scheme="https://efterklang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>ProcessSync</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch2-2ProcessSync/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch2-2ProcessSync/</id>
    <published>2024-03-08T03:42:42.000Z</published>
    <updated>2024-04-06T08:04:02.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h2><h3 id="定义-Definition"><a href="#定义-Definition" class="headerlink" title="定义 Definition"></a>定义 Definition</h3><p>每一个进程具有<strong>顺序性</strong>，但是在多道程序设计系统中，多个进程要<strong>竞争</strong>，<strong>轮流占用</strong>处理器。<br>有两个进程 A 和 B，它们各自顺序执行时的操作序列如下：<br>进程 A ： <code>a1，a2，a3，…，am</code><br>进程 B ： <code>b1，b2，b3，…，bm</code><br>在多道程序设计系统中，处理器可能执行的操作序列<br><code>a1， b1 ，a2， b2 ，a3， b3 …</code><br><code>a1， a2， b1 ，a3 ，b2 ，b3 …</code></p><p>进程的并发性:在一个进程的工作没有完成之前，另一个进程就可以开始工作，这些进程就称为可同时执行的。或者称它们<strong>具有并发性</strong>，并且把可同时执行的进程称为<strong>并发进程</strong>。</p><ul><li>如果一个进程的执行不影响另一个进程的执行结果，也不依赖另一个进程的进展情况，即它们是各自独立的，则称这些进程相互之间是<strong>无关</strong>的。</li><li>如果一个进程的执行要依赖其他进程的进展状况，或者可能会影响其他进程的执行结果，则说这些进程是有<strong>交互</strong>的。<ul><li>对于有交互的并发进程来说，并发会破坏“封闭性”和“可再现性”</li></ul></li></ul><p><strong>进程互斥</strong>:多个进程不能同时使用同一个资源，某个进程使用该资源时，其他进程必须等待。<br><strong>进程同步</strong>:多个进程的调用存在时序关系，某些进程的执行必须先于另一些进程。<br><strong>进程通信</strong>:多个进程之间传递消息。</p><h3 id="问题引入-Intro"><a href="#问题引入-Intro" class="headerlink" title="问题引入 Intro"></a>问题引入 Intro</h3><p>由于进程交替修改了共享变量造成结果可能不正确。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     生产者                           消费者</span><br><span class="line"> register1∶ = counter;             register2∶= counter;</span><br><span class="line"> register1∶= register1+1;         register2∶ = register2-1;</span><br><span class="line"> counter∶= register1;               counter∶ = register2;</span><br><span class="line">假设：counter的当前值是5。</span><br><span class="line">无论生产者先执行，还是消费者先执行，结果都是5.</span><br><span class="line">但是，如果按下述顺序执行：</span><br><span class="line">         register1 ∶  = counter;               (register1 = 5)</span><br><span class="line">         register1 ∶  = register1 + 1;        (register1 =6)</span><br><span class="line">         register2 ∶  = counter;               (register2 = 5)</span><br><span class="line">         register2 ∶  = register2 - 1;         (register2=4)</span><br><span class="line">         counter  ∶  = register 1;             (counter=6)</span><br><span class="line">         counter  ∶  = register2;               (counter=4)</span><br><span class="line">Counter的值最终为4。</span><br><span class="line">两次结果不一致，程序执行失去了再现性</span><br></pre></td></tr></table></figure><p>有交互的并发进程执行时出现<strong>与时间有关</strong>(time-dependent,即与进程调度的顺序有关)的错误，其根本原因是<strong>对共享资源（变量）的使用不受限</strong>，为了使并发进程能正确地执行，必须对共享变量的使用加以限制。</p><p>进程竞争资源首先必须解决“互斥”问题。某些资源必须互斥使用，如打印机、共享变量、表格、文件等。这类资源又称为<strong>临界资源 critical resource</strong>，访问临界资源的那段代码称为<strong>临界区 critical section</strong>。<br>任何时刻，只允许一个进程进入临界区，以此实现进程对临界资源的互斥访问。</p><p>可把一个访问临界资源的循环进程描述如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">    entry section</span><br><span class="line">    critical section</span><br><span class="line">    exit section</span><br><span class="line">    remainder section</span><br><span class="line">until false</span><br><span class="line"></span><br><span class="line">&lt;entry section&gt;:判断是否可以进入临界区，如果可以进入，则必须设置临界区使用标志，</span><br><span class="line">阻止其它后来的进程进入临界区。</span><br><span class="line">&lt;critical section&gt;:进入临界区，使用临界资源。</span><br><span class="line">&lt;exit section&gt;:当临界区内的进程执行完毕并退出临界区时，在“退出区”修改临界区使用标志，</span><br><span class="line">并负责唤醒阻塞队列中的一个进程，让其进入临界区。</span><br><span class="line">&lt;remainder section&gt;:其它代码</span><br></pre></td></tr></table></figure><p><strong>阻塞队列 Blocking Queue</strong>:当一个进程试图进入临界区，而临界区已经被其它进程占用时，该进程必须等待，直到临界区空闲为止。这些等待进程的队列称为阻塞队列。<br><strong>死锁 Deadlock</strong>:当两个或多个进程互相等待对方释放资源，而导致它们都无法继续执行时，称为死锁。</p><p><strong>临界区使用原则</strong>(互斥条件)</p><ol><li><strong>空闲让进Entry Allowed WHen Free</strong>:如果临界区空闲，则只要有进程申请就立即让其进入 </li><li><strong>忙则等待Bust Then Wait</strong>:每次仅允许一个进程处于临界区 </li><li><strong>有限等待Limited Waiting</strong>:进程只能在临界区内逗留有限时间，不得使其他进程在临界区外无限期等待 </li><li><strong>让权等待Yeilding While Waiting</strong>:当进程不能进入自己的临界区时，应立即释放处理机，以免进程处于“忙等”状态</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-06-15-40-04.png" alt="Critical Section"></p><h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3><p>1965 年，荷兰的 E.W.Dijkstra 提出了信号量同步机制用于进程同步,现广泛应用于存在临界资源和临界区控制的场合<br>信号量是一个一般的锁,信号量即信号的数量;开锁实际上就是发一个信号,等待锁打开就是等待一个信号<br><code>锁: &#123;0,1&#125;  信号量: &#123;-∞, … , -2, -1, 0, 1, 2, … , ∞&#125;</code></p><p>信号量按照<strong>功能</strong>来分：</p><ul><li>互斥信号量：用于申请或释放资源的使用权，常初始化为 1。</li><li>资源信号量：用于申请或归还资源，可以初始化为大于 1 的正整数，表示系统中某类资源的可用个数。<br>按照<strong>信号量机制的发展</strong>分为：</li><li>整形信号量</li><li>记录型信号量</li><li>AND 型信号量</li><li>信号量集</li></ul><blockquote><p>In computer science, a semaphore is a variable or abstract data type used to control access to a common resource by multiple threads and avoid critical section problems in a concurrent system such as a multitasking operating system. Semaphores are a type of synchronization primitive. A trivial semaphore is a plain variable that is changed (for example, incremented or decremented, or toggled) depending on programmer-defined conditions.<br>The semaphore concept was invented by Dutch computer scientist Edsger Dijkstra in 1962 or 1963, when Dijkstra and his team were developing an operating system for the Electrologica X8. That system eventually became known as the THE multiprogramming system.</p></blockquote><p>两个或多个进程可以通过传递信号进行合作，可以迫使进程在某个位置暂时停止执行（阻塞等待），直到它收到一个可以“向前推进”的信号（被唤醒）。相应地，将实现信号灯作用的变量称为信号量。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-13-57-59.png"></p><h4 id="整形信号量-Integer-Semaphore"><a href="#整形信号量-Integer-Semaphore" class="headerlink" title="整形信号量 Integer Semaphore"></a>整形信号量 Integer Semaphore</h4><p>定义为一个整形量, 用来表示空闲资源的数目;仅能通过两个标准的原子操作 <code>wait(s),signal(s)</code>来访问它,又称为<strong>P 操作和 V 操作</strong></p><ul><li><em>Proberen</em>(荷兰语，意为“尝试”): <code>wait(s)</code> 操作用于申请资源（或使用权），进程执行 wait 原语时，可能会阻塞自己；<br><code>while S &lt;= 0 do no-op; S--; // 申请资源</code></li><li><em>Verhogen</em>(荷兰语，意为“增加”): <code>signal(s)</code>操作用于释放资源（或归还资源使用权），进程执行 signal 原语时，有责任唤醒一个阻塞进程。<br><code>S++; // 释放资源</code></li></ul><p><strong>Note</strong></p><ol><li>必须成对使用 <code>wait</code>和 <code>signal</code>原语</li><li>wait、signal 原语不能出现次序错误、重复或遗漏<ul><li>遗漏 wait 原语则不能保证互斥访问</li><li>遗漏 signal 原语则不能在使用临界资源之后将其释放</li></ul></li></ol><h4 id="记录型信号量-Record-Semaphore"><a href="#记录型信号量-Record-Semaphore" class="headerlink" title="记录型信号量 Record Semaphore"></a>记录型信号量 Record Semaphore</h4><p>记录型信号量机制，是一种不存在<strong>忙等现象</strong>的进程同步机制。<br>操作系统内核以系统调用形式提供 <code>wait</code>和 <code>signal</code>原语，应用程序通过该系统调用实现进程间的互斥。<br>工程实践证明，利用信号量方法实现进程互斥是高效的，一直被广泛采用。</p><p>记录型信号量的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点，用于表示等待队列中的进程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> pid;  <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录型信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// value的初值表示系统中某类资源的数目， value的初始值&gt;1时，称为资源信号量， value的初始值=1时，称为互斥信号量</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* listOfProcess;  <span class="comment">// 信号量的阻塞队列</span></span><br><span class="line">&#125; RecordSemaphore;</span><br></pre></td></tr></table></figure><blockquote><p>“忙等”（Busy Waiting）是一种进程同步策略中的现象，也被称为”自旋等待”。当一个进程试图进入一个被其他进程占用的临界区时，如果使用了忙等策略，那么这个进程会在一个循环中不断检查临界区是否可用，直到它变为可用状态。换句话说，进程在等待期间保持活跃，并消耗 CPU 时间，而不是被挂起或转移到等待状态。<br>虽然忙等可以在某些情况下（如等待时间预期非常短）提供很好的响应时间，但它通常被视为一种效率低下的策略，因为它浪费了 CPU 的计算能力，尤其是在等待时间较长的情况下。<br>与此相反，记录型信号量机制（Blocking or Sleeping Semaphore Mechanism）允许进程在等待进入临界区时进入睡眠状态，从而不消耗 CPU 时间。当临界区可用时，进程会被唤醒。这种方法更有效，但可能导致上下文切换的开销，因为系统需要在运行和等待的进程之间切换。</p></blockquote><p>记录型信号量的 P，V 操作 wait(s)和 signal(s)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/cProcessSync-2024-03-06-22-28-32.png"></p><p><code>s.value&gt;=0</code> 时，<code>s.queue</code> 为空；<br><code>s.value&lt;0</code> 时，<code>s.value</code> 的 绝对值为 <code>s.queue</code> 中等待进程的个数<br><code>s.value</code> 初始值为 1 时，称为互斥信号量；<code>s.value</code> 初始值&gt;1 时，称为资源信号量。<br>当仅有两个并发进程共享临界资源时，互斥信号量仅能取值 1、0、－1。其中，</p><ul><li><code>s.value=1</code>, 表示无进程进入临界区</li><li><code>s.value=0</code>，表示已有一个进程进入临界区</li><li><code>s.value=-1</code>,则表示已有一进程正在等待进入临界区<br>当用 s 来实现 n 个进程的互斥时，<code>s.value</code> 的取值范围为 1 ～-(n-1)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(RecordSemaphore* s)</span> &#123;</span><br><span class="line">    s-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        block(s-&gt;listOfProcess); <span class="comment">//进程阻塞, 进入S.L队列；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">singal</span><span class="params">(RecordSemaphore* s)</span> &#123;</span><br><span class="line">    s-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt;= <span class="number">0</span>) &#123; <span class="comment">// s-&gt;value=0时,则在s-&gt;value++之前value=-1,即有1个进程在等待</span></span><br><span class="line">        wakeup(s-&gt;listOfProcess); <span class="comment">// 唤醒阻塞队列中的一个进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AND-型信号量-AND-Semaphore"><a href="#AND-型信号量-AND-Semaphore" class="headerlink" title="AND 型信号量 AND Semaphore"></a>AND 型信号量 AND Semaphore</h4><p>如果一个进程需要事先获得一个或多个共享资源后才能执行任务。例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process A:                 process B:</span><br><span class="line">wait(Dmutex);            wait(Emutex);</span><br><span class="line">wait(Emutex);             wait(Dmutex);</span><br></pre></td></tr></table></figure><p>最后，进程 A 和 B 就处于僵持状态，在无外力作用下，两个进程都无法从僵持状态中解脱出来，这此 A 和 B 进入<strong>死锁</strong>状态。</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-10-25-04.png" alt="DeadLock"></p></center><p>AND 同步机制的基本思想：将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。<br>原子操作：所有资源要么全部分配到进程，要么一个也不分配 .<br>在 wait 操作中，增加了一个“AND”条件，故称为 <code>AND同步</code>，或称为 <code>同时wait</code>操作.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swait</span><span class="params">(S1, S2, …, Sn)</span>&#123; <span class="comment">//P原语；</span></span><br><span class="line">  <span class="keyword">if</span> (S1 ≥<span class="number">1</span> and S2 ≥ <span class="number">1</span> … Sn ≥ <span class="number">1</span>) &#123;<span class="comment">//满足资源要求时的处理；</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      <span class="comment">// wait的处理是s先减1，再判断是否&lt;0，若是就进入阻塞队列。如果要不阻塞，则s的初始值需要&gt;=1</span></span><br><span class="line">      <span class="comment">// Swait与wait的处理不同，这里是在确信可满足资源要求时，才进行减1操作</span></span><br><span class="line">      Si=Si<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*某些资源不够时的处理；</span></span><br><span class="line"><span class="comment">    进程进入第一个小于1的信号量的阻塞队列 ;</span></span><br><span class="line"><span class="comment">    恢复PC寄存器为Swait开始时的状态；*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  Ssignal(S1, S2, …, Sn)&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    Si++; <span class="comment">//释放占用的资源；</span></span><br><span class="line">    <span class="keyword">for</span> (each process P waiting in Si.L)&#123;</span><br><span class="line">      <span class="comment">//检查每种资源的阻塞队列中的所有进程；</span></span><br><span class="line">      <span class="comment">//从阻塞队列Si.queue中取出进程P;</span></span><br><span class="line">      P = Si.<span class="built_in">queue</span>.getHead();</span><br><span class="line">      <span class="keyword">if</span>(判断P是否通过Swait中的测试)&#123;<span class="comment">//注:与signal不同，需重新判断进程P进入就绪队列;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">//未通过检查（资源不够用）时的处理；</span></span><br><span class="line">        进程P进入某阻塞队列；<span class="comment">//然后继续循环判断下一个进程</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="信号量集-Semaphore-Set"><a href="#信号量集-Semaphore-Set" class="headerlink" title="信号量集 Semaphore Set"></a>信号量集 Semaphore Set</h4><p>在记录型信号量机制中，<code>wait(S)</code>或 <code>signal(S)</code>操作仅能对信号量施以加 1 或减 1 操作，意味着每次只能获得或释放一个单位的临界资源。<br>在每次分配时，采用信号量集来控制，可以分配多个单位的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Si—i 类资源现有数量；ti—i 类资源的分配下限值；di—申请i 类资源数量;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swait</span> <span class="params">( S1, t1, d1; ... ; Sn, tn, dn )</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (S1 ≥ t1 and S2 ≥ t2 … Sn ≥ tn) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      Si=Si-di;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//假设首先发现 Sj &lt; tj，进程进入Sj.L队列；</span></span><br><span class="line">    <span class="comment">//进程投入与Sj相关的阻塞队列</span></span><br><span class="line">    <span class="comment">//恢复PC寄存器为Swait开始时的状态；</span></span><br><span class="line">    <span class="comment">//启动进程调度程序，调度其它进程执行；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//si—i 类资源现有数；di—i 类资源释放数量 ;</span></span><br><span class="line"><span class="type">void</span> Ssignal ( S1, d1; ... ; Sn, dn )&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    Si=Si+di;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把与Si有关队列中的进程移入就绪队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“信号量集机制”可以用于各种情况的资源分配和释放，几种特殊情况：</p><ul><li><code>Swait(S, d, d)</code>表示每次申请 d 个资源，当少于 d 个时，便不分配</li><li><code>Swait(S, 1, 1)</code>表示一般的记录型互斥信号量（S&#x3D;1 时）或资源信号量（S&gt;1 时）</li><li><code>Swait(S, 1, 0)</code>可作为一个可控开关（当 S1 时，允许多个进程进入临界区；当 S&#x3D;0 时，禁止任何进程进入临界区）</li></ul><h4 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h4><p><strong>利用信号量实现进程互斥</strong><br>为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量 mutex，并设其初始值为 1，然后将各进程访问该资源的临界区 CS 置于 wait（mutex）和 signal（mutex）操作之间即可。<br><strong>利用信号量来描述前趋（合作）关系</strong><br>假设我们有两个任务 A 和 B，其中任务 B 依赖于任务 A 的完成。我们可以使用一个初始值为 0 的信号量来描述这种前驱关系。具体的操作步骤如下：<br>任务 A 在完成后，执行一个信号量的 V 操作（signal），将信号量的值加 1。<br>任务 B 在开始前，执行一个信号量的 P 操作（wait）。如果信号量的值大于 0，那么将信号量的值减 1 并继续执行。如果信号量的值等于 0，那么任务 B 将阻塞，直到信号量的值大于 0。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-14-10-39.png"></p><blockquote><p><code>parbegin</code> 和 <code>parend</code> 是并发编程中用来表示并行开始和并行结束的关键字</p></blockquote><p>例：用 And 信号量来描述如下的前趋图<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-14-12-29.png" alt="Precedence Graph"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var a,<span class="keyword">b,c,d,e,f,g: </span>semaphore: <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;</span><br><span class="line">Parbegin</span><br><span class="line">       <span class="keyword">begin </span><span class="built_in">S1</span><span class="comment">; Ssignal(a,b); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(a); </span><span class="built_in">S2</span><span class="comment">; Ssignal(c,d); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(b); </span><span class="built_in">S3</span><span class="comment">; signal(e); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(c); </span><span class="built_in">S4</span><span class="comment">; signal(f); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(d); </span><span class="built_in">S5</span><span class="comment">; signal(g); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">Swait(e,f,g); </span><span class="built_in">S6</span><span class="comment">; end;</span></span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure><h3 id="硬件同步机制-Hardware-Synchronization-Mechanism"><a href="#硬件同步机制-Hardware-Synchronization-Mechanism" class="headerlink" title="硬件同步机制 Hardware Synchronization Mechanism"></a>硬件同步机制 Hardware Synchronization Mechanism</h3><p><strong>利用计算机硬件指令解决临界区问题</strong><br>对临界区管理将标识看做一个锁，“锁开”进入，“锁关”等待。<br>初始打开，每个进入临界区的进程必须对锁进行测试。<br>测试和关锁操作必须连续（原子操作）</p><blockquote><p>虽然可以利用软件方法解决诸进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。相应地，目前许多计算机已提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。</p></blockquote><ol><li>关中断</li><li>利用 Test-and-Set 指令实现互斥</li><li>利用 Swap 指令实现进程互斥</li></ol><h4 id="关中断实现互斥-Disable-Interrupts"><a href="#关中断实现互斥-Disable-Interrupts" class="headerlink" title="关中断实现互斥 Disable Interrupts"></a>关中断实现互斥 Disable Interrupts</h4><p><strong>中断</strong>是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得 CPU 暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。<br><strong>中断处理</strong>是指 CPU 响应中断，转入中断处理程序，系统开始处理中断。<br><strong>中断响应</strong>是指 CPU 收到中断请求后转向相应的事件处理程序。<br><strong>开中断</strong>就是指系统可以在连续运行时中断，去运行中断服务函数<br><strong>关中断</strong>就是指关闭系统中断，系统不响应其他的中断，不允许系统打断连续的运行</p><p><strong>关中断</strong><br>进入锁测试前关闭中断，完成锁测试并上锁后打开中断<br>进程在临界区时计算机系统不响应中断，不会引发调度</p><p><strong>Pros And Cons</strong></p><ul><li>关中断是实现互斥的最简单的方法之一。</li></ul><hr><ul><li>滥用关中断权力可能导致严重后果；</li><li>关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；</li><li>关中断方法也不适用于多 CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">bool</span> <span class="title function_">are_interrupts_enabled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_operation</span><span class="params">(<span class="type">void</span> (*operation)())</span> &#123;</span><br><span class="line">    start_atomic_operation();</span><br><span class="line">    operation();</span><br><span class="line">    end_atomic_operation(are_interrupts_enabled());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_atomic_operation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果中断是开启的，那么关闭中断</span></span><br><span class="line">    <span class="keyword">if</span> (are_interrupts_enabled()) &#123;</span><br><span class="line">        disable_interrupts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">end_atomic_operation</span><span class="params">(<span class="type">bool</span> were_interrupts_enabled)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果在原子操作开始之前中断是开启的，那么重新开启中断</span></span><br><span class="line">    <span class="keyword">if</span> (were_interrupts_enabled) &#123;</span><br><span class="line">        enable_interrupts();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    enable_interrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Test-And-Set-指令实现互斥"><a href="#Test-And-Set-指令实现互斥" class="headerlink" title="Test And Set 指令实现互斥"></a>Test And Set 指令实现互斥</h4><p>这是一种借助 TS(Test-and-Set)硬件指令以实现互斥的方法。在许多计算机中都提供了这种指令。</p><p><code>lock=false</code>表示资源空闲，<code>*lock=TURE</code>表示资源正在被使用。<br>当资源被使用时，TS 返回 ture，则 <code>while TS（&amp;lock)</code>；语句条件为真会一直循环等待。</p><p>这段代码是一个实现了简单的自旋锁（spinlock）的例子，使用了一个称为 Test-and-Set（TS）的原子操作。自旋锁是一种用于同步的低级别的原子操作，通常用于保护短期的临界区（critical section）。<br>自旋锁可能会导致资源浪费，因为在等待获取锁的过程中，线程并不会释放 CPU，而是会一直忙等待。因此，自旋锁通常只用于保护非常短期的临界区。对于保护长期的临界区，通常会使用其他的同步机制，如互斥锁（mutex）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">boolen <span class="title function_">TS</span><span class="params">(boolen *lock)</span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock =TURE;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">while</span> <span class="title function_">TS</span><span class="params">( &amp;lock)</span>;</span><br><span class="line">    critical section;</span><br><span class="line">    lock :=FALSE;</span><br><span class="line">    remainder section;</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="利用-Swap-指令实现进程互斥"><a href="#利用-Swap-指令实现进程互斥" class="headerlink" title="利用 Swap 指令实现进程互斥"></a>利用 Swap 指令实现进程互斥</h4><p>该指令称为对换指令，在 <code>Intel 80x86</code>中又称为 <code>XCHG</code>指令，用于交换两个字的内容。</p><h4 id="管程-Moniter"><a href="#管程-Moniter" class="headerlink" title="管程 Moniter"></a>管程 Moniter</h4><p>虽然信号量机制是一种既方便、又有效的进程同步机制，但每个要访问临界资源的进程都必须自备同步操作 wait（S）和 signal（s）。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。这样，在解决上述问题的过程中，便产生了一种新的进程同步工具——管程 。</p><blockquote><p>Monitors are a higher-level synchronization construct that simplifies process synchronization by providing a high-level abstraction for data access and synchronization. Monitors are implemented as programming language constructs, typically in object-oriented languages, and provide mutual exclusion, condition variables, and data encapsulation in a single construct.<br><a href="#ref">Moniter-Ref</a></p></blockquote><h3 id="经典同步问题-Classic-Synchronization-Problems"><a href="#经典同步问题-Classic-Synchronization-Problems" class="headerlink" title="经典同步问题 Classic Synchronization Problems"></a>经典同步问题 Classic Synchronization Problems</h3><ul><li>生产者&#x2F;消费者问题 Producer-Consumer Problem</li><li>哲学家进餐问题 Dining Philosophers Problem</li><li>读者&#x2F;写者问题 Readers-Writers Problem</li></ul><h4 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer-Consumer Problem"></a>Producer-Consumer Problem</h4><p>生产者与消费者是一个广义的概念，可以代表一类具有相同属性的进程。生产者和消费者进程共享一个大小固定的缓冲池;一个或多个生产者生产数据，并将生产的数据存入缓冲池;一个或多个消费者从缓冲池中取数据。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ProcessSync-2024-03-08-11-03-26.png" alt="Producer-Consumer Problem"></p><p>必须使生产者和消费者互斥进入缓冲区。即，某时刻只允许一个实体（生产者或消费者）访问缓冲区，生产者互斥消费者和其它任何生产者。<br>生产者不能向满缓冲池写数据，消费者也不能在空缓冲池中取数据，即生产者与消费者必须同步。</p><p><strong>涉及两类进程</strong>：<br>生产者进程和消费者进程<br><strong>需要保证以下同步关系</strong>：</p><ol><li>多个进程互斥地访问公共缓冲池；互斥信号量 mutex</li><li>不能向满的缓冲池中添加产品；可用的空资源信号量 empty</li><li>不能从空的缓冲池中提取产品。可用的满资源信号量 full<br>full + empty&#x3D;N</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ProcessSync-2024-03-08-11-9-11.png"></p><blockquote><p>每个进程中各个 wait 操作的次序是重要的：先检查资源数目，再检查是否互斥.否则可能死锁<br>如：producer 先申请互斥，进入后，申请空资源，发现空资源不可用，必须等待 comsumer 先申请满资源，使用后释放出来。但此时，由于 producer 占用了互斥资源，因此 consumer 无法进入。故而陷入死锁状态</p></blockquote><h4 id="Dining-Philosophers-Problem"><a href="#Dining-Philosophers-Problem" class="headerlink" title="Dining Philosophers Problem"></a>Dining Philosophers Problem</h4><p>五个哲学家五只筷子，哲学家循环做着思考和吃饭的动作，吃饭程序是：先取左边筷子，再取右边筷子，再吃饭，再放筷子。</p><ol><li>至多只允许四个哲学家同时进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。</li><li>在哲学家进餐问题中，要求每个哲学家先获得两个临界资源(筷子)后方能进餐，这在本质上就是前面所介绍的 AND 同步问题，故用 AND 信号量机制可获得最简洁的解法,且可避免死锁。</li><li>规定奇数号的哲学家先拿起他左边的筷子,然后再去拿他右边的筷子;而偶数号的哲学家则相反.按此规定,将是 2,3 号哲学家竞争 3 号筷子,4,5 号哲学家竞争 5 号筷子.即三个哲学家都  竞争奇数号筷子,获得后,再去竞争偶数号筷子,最后总会 1 个哲学家能获得两支筷子而进餐.</li></ol><h4 id="Readers-Writers-Problem"><a href="#Readers-Writers-Problem" class="headerlink" title="Readers-Writers Problem"></a>Readers-Writers Problem</h4><p>该问题为多个进程访问一个共享数据区建立了一个通用模型，如数据库、文件、内存区及一组寄存器等数据。若干读进程只能读数据，若干写进程只能写数据。</p><p>例如，一个联网售票系统，数据的查询和更新非常频繁，不可避免会出现多个进程试图查询或修改（读&#x2F;写）其中某一条数据的情形。多个进程同时读一条记录是可以的。如果一个进程正在更新数据库中的某条记录，则所有其他进程都不能访问（读或写）该记录，否则可能会将同一个座位销售多次。</p><p><strong>读者&#x2F;写者进程满足的条件</strong></p><ol><li>允许多个读者进程可以同时读数据；</li><li>不允许多个写者进程同时写数据，即只能互斥写数据；</li><li>若有写者进程正在写数据，则不允许读者进程读数据。</li></ol><p><strong>Sol</strong><br>利用记录型信号量解决读者-写者问题<br>利用信号量集解决读者-写者问题</p><h4 id="Exercies"><a href="#Exercies" class="headerlink" title="Exercies"></a>Exercies</h4><blockquote><p><strong>EX1</strong><br>三个进程 P1，P2，P3 协作解决文件打印问题，P1 将文件记录从磁盘读入内存的缓冲区 1，每执行一次读一个记录；P2 将缓冲区 1 的内容取出放到缓冲区 2 中；P3 将缓冲区 2 的内容打印出来，每执行一次打印一个记录。缓冲区的大小和一个记录大小一样。<br>用 P、V 操作来保证文件的正确打印。<br><strong>引申</strong><br>有三个进程 A1、A2、A3，它们共享两个缓冲区 B1 和 B2。缓冲区 B1 中可以存放 n 件产品，缓冲区 B2 中可以存放 m 件产品。进程 A1 每次生产一件产品，并把产品存入缓冲区 B1。进程 A2 每次生产一件产品，并把产品存入缓冲区 B2。进程 A3 每次从缓冲区 B2 中取一件产品区消费。为了防止把产品存入已满的缓冲，或者从空缓冲中取产品，或重复取一产品，用 PV 操作实现它们的相互制约关系。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ProcessSync-2024-03-08-11-24-27.png" alt="ex"></p><hr><p><strong>EX2</strong><br>某工厂有一个可以存放设备的仓库，总共可以存放 8 台设备。生产部门生产的每一台设备都必须入库，销售部门可以从仓库中提出设备供应客户。设备出&#x2F;入库需要借助运输工具，现只有一套运输工具，每次只能运一台设备<br>请设计生产部门和销售部门进程。</p><hr><p><strong>EX3</strong><br>桌上放一个盘子，每次只能放一个水果，爸爸像盘子里放苹果，妈妈向盘子里放橘子，女儿专吃苹果,儿子专吃橘子。盘子空的时候爸爸或妈妈才能向盘子里面放一个水果，仅当盘子里有自己需要的水果时才可取一个水果。把爸爸、妈妈、儿子、女儿看做四个进程，用 PV 操作进行管理，使这四个进程能正确地并发执行。<br><strong>引申</strong><br>如果盘子的容量改为 2，且任何时刻只允许爸爸、妈妈、女儿、儿子中的一个进程去访问盘子（放或者取）。</p></blockquote><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://en.wikipedia.org/wiki/Semaphore_(programming)">Semaphore-wikipedia</a><br><a href="https://www.cnblogs.com/youxin/p/3586577.html">https://www.cnblogs.com/youxin/p/3586577.html</a><br><a href="https://www.geeksforgeeks.org/monitors-in-process-synchronization/">Moniter</a></p>]]></content>
    
    
    <summary type="html">进程同步</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>进程的描述及控制</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch2-1ProcessContorl/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch2-1ProcessContorl/</id>
    <published>2024-03-06T06:00:51.000Z</published>
    <updated>2024-04-27T11:23:40.799Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前驱图和程序执行-Precedence-Graph-and-Program-Execution"><a href="#前驱图和程序执行-Precedence-Graph-and-Program-Execution" class="headerlink" title="前驱图和程序执行 Precedence Graph and Program Execution"></a>前驱图和程序执行 Precedence Graph and Program Execution</h2><h3 id="前驱图-Precedence-Graph"><a href="#前驱图-Precedence-Graph" class="headerlink" title="前驱图 Precedence Graph"></a>前驱图 Precedence Graph</h3><p><strong>前趋图(Precedence Graph)</strong>:一个<strong>有向无循环</strong>图 DAG(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。图中的每个结点可用于表示一条语句、一个程序段等；结点间的有向边表示在两个结点之间存在的前趋关系。<br><strong>初始结点(InitialNode)</strong> 前趋图中没有前趋的结点<br><strong>终止结点(FinalNode)</strong> 前趋图中没有后继的结点</p><pre><code>→=&#123;(Pi, Pj)|Pi must complete before Pj may start&#125;(Pi, Pj)∈→ 或 Pi→PjPi是Pj的直接前趋，Pj是Pi的直接后继。</code></pre><p>若一个程序由若干程序段（即操作）组成，而这些操作必须按照某种先后次序执行，这类执行过程就是程序的顺序执行。</p><h3 id="程序执行-Program-Execution"><a href="#程序执行-Program-Execution" class="headerlink" title="程序执行 Program Execution"></a>程序执行 Program Execution</h3><p><strong>程序执行方式</strong></p><ul><li>顺序执行—单道批处理系统</li><li>并发执行–多道批处理系统<ul><li>应用级并发是指若干应用程序的并发执行。</li><li>系统级并发是指操作系统自身软件的并发执行。</li></ul></li></ul><p><strong>顺序执行</strong></p><p>若一个程序由若干程序段（即操作）组成，而这些操作必须按照某种先后次序执行，这类执行过程就是<strong>程序的顺序执行</strong></p><ul><li><strong>顺序性</strong>：处理机的操作严格按照程序所规定的顺序执行。</li><li><strong>封闭性</strong>：程序运行时独占全机资源，程序一旦开始执行，其执行结果不受外界因素影响。</li><li><strong>可再现性</strong>：只要程序执行时的环境和初始条件相同，都将获得相同的结果。</li></ul><p><strong>并发执行的特征</strong></p><ul><li><strong>间断性</strong>：由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间，形成了相互制约的关系，导致并发程序具有“执行——暂停——执行”这种间断性的活动规律。</li><li><strong>失去封闭性</strong>：是多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的运行已失去了封闭性。</li><li><strong>不可再现性</strong>：程序在并发执行时，由于失去了封闭性，导致不可再现性 。</li></ul><h2 id="进程的描述-Process"><a href="#进程的描述-Process" class="headerlink" title="进程的描述 Process"></a>进程的描述 Process</h2><h3 id="Definition-Features-Components-States"><a href="#Definition-Features-Components-States" class="headerlink" title="Definition,Features,Components,States"></a>Definition,Features,Components,States</h3><p><strong>为什么引入进程?</strong></p><p>并发执行：进程使得多个任务可以在同一时间段内交替执行，这种并发执行使得 CPU 可以在等待一个任务的 IO 操作完成时执行另一个任务，从而提高了系统的效率和吞吐量。<br>独立性：每个进程都有自己的私有地址空间，这意味着一个进程不能直接访问另一个进程的内存。这种内存保护机制有助于防止一个进程意外或恶意地干扰另一个进程。<br>简化编程模型：在没有进程的情况下，程序员必须手动管理多任务执行和资源分配。有了进程，这些任务就由操作系统自动处理，程序员可以专注于应用程序的逻辑。<br>资源管理：进程是资源分配和管理的基本单位。操作系统可以根据每个进程的需要和优先级分配资源，如 CPU 时间、内存空间等。</p><p>[<a href="ProcessvsThread.md" title="Process &amp; Thread">ProcessvsThread#Process</a>]</p><h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>PCB 是操作系统中用于描述进程的一种数据结构，它是操作系统中最重要的数据结构之一。PCB 中包含了进程的所有信息，是操作系统对进程进行控制和管理的数据结构。它包含以下<strong>主要信息</strong>：</p><ul><li><strong>进程标识符信息</strong></li><li><strong>处理机的状态信息</strong></li><li><strong>进程的调度信息</strong></li><li><strong>进程控制信息</strong></li></ul><h4 id="PCB-的主要信息"><a href="#PCB-的主要信息" class="headerlink" title="PCB 的主要信息"></a>PCB 的主要信息</h4><ol><li><p><strong>进程标识符 PID</strong></p><p><strong>进程标识符</strong>用于唯一地标识一个进程。一个进程通常有两种标识符：</p><ul><li>内部标识符。为每一个进程赋予一个唯一的数字标识符，通常是进程的序号。设置内部标识符主要是为了方便操作系统使用。</li><li>外部标识符。它由创建者提供，通常是由字母、数字组成，往往是由用户（进程）在访问该进程时使用。</li></ul></li><li><p><strong>处理机状态信息 Processor State Information</strong></p><p>处理机状态信息主要是由处理机的各种寄存器的内容组成的。例如:</p><ul><li>通用寄存器，又称为用户可视寄存器。</li><li>指令计数器 PC，其中存放了要访问的下一条指令的地址。</li><li>程序状态字 PSW，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等</li><li>用户栈指针 SP，用于存放系统调用参数及调用地址。栈指针指向该栈的栈顶。</li></ul></li><li><p><strong>进程调度信息 Scheduling Information</strong></p><p>在 PCB 中还存放一些与进程调度和进程对换有关的信息。</p><ul><li><strong>进程状态</strong>。指明进程的当前状态</li><li><strong>进程优先级</strong>。</li><li><strong>事件</strong>。是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。</li><li><strong>其它信息</strong>。如：进程已等待 CPU 的时间总和、进程已执行的时间总和等；<br>可参考<code>linux kernel sched.h task_struct</code>结构</li></ul></li><li><p><strong>进程控制信息 Process Control Information</strong></p><ul><li><strong>程序和数据的地址</strong> 进程的程序和数据所在的内存或外存地址。</li><li><strong>进程同步和通信机制</strong> 实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等。</li><li><strong>资源清单</strong> 进程所需的全部资源及已经分配到该进程的资源的清单；</li><li><strong>链接指针</strong> 本队列下一个进程的 PCB 的首地址。</li></ul></li></ol><h4 id="PCB-的组织方式"><a href="#PCB-的组织方式" class="headerlink" title="PCB 的组织方式"></a>PCB 的组织方式</h4><ol><li><strong>线性方式</strong>:把系统中所有的 PCB 都组织在一张线性表中。</li><li><strong>链接方式</strong>:把具有同一状态的 PCB，用其中的链接指针链接成一个队列。(通常，可根据等待事件的不同，组织多个不同的阻塞队列,如等待打印机和等待内存等)</li><li><strong>索引方式</strong>:相同状态的进程 PCB 组织在一张表格中，系统根据所有进程的状态建立几张索引表，系统分别记载各 PCB 表格的起始地址<br>因为进程的主要操作就是插入和删除，因此，链接方式使用更多一些</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-2024-03-04-21-52-11.png" alt="进程管理-2024-03-04-21-52-11"></p><h4 id="PCB-的作用"><a href="#PCB-的作用" class="headerlink" title="PCB 的作用"></a>PCB 的作用</h4><p>进程控制块的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位(进程)。<br>在进程的整个生命期中，操作系统总是通过 PCB 对进程进行控制的。所以说，PCB 是进程存在的唯一标志。<br>OS 是根据 PCB 来对并发执行的进程进行控制和管理的，如：<br>进程创建：分配进程控制块<br>进程调度：保存和读取进程控制块<br>进程撤销：回收进程控制块</p><h2 id="进程控制-Process-Control"><a href="#进程控制-Process-Control" class="headerlink" title="进程控制 Process Control"></a>进程控制 Process Control</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>进程控制 Process Control</strong>:操作系统的核心功能之一。包括进程的创建,终止,调度,状态转换,同步,通信等。进程控制一般是由 OS 内核中的一组原语来实现的。<br><strong>原语 Primitive</strong>:操作系统内核或微核提供核外调用的过程或函数称为原语,其由若干条指令构成，用于完成特定功能的一段程序。原语在执行过程不允许被中断。<br><strong>原子操作 Atom Operation</strong>：执行中不能被其它进程（线程）打断的操作就叫原子操作。当该次操作不能完成的时候，必须回到操作之前的状态，原子操作不可拆分。<br><strong>内核 Kernel</strong>:计算机硬件的第一层扩充软件，为系统对进程控制、存储器管理等提供有效的机制。内核常驻内存，紧靠硬件，运行效率较高。在不同操作系统中，内核所包含的功能不尽相同，但一般应包含以下功能：<br>支撑功能:中断处理,时钟管理,原语操作<br>资源管理功能:进程管理,存储器管理,设备管理</p><h3 id="进程的创建与终止"><a href="#进程的创建与终止" class="headerlink" title="进程的创建与终止"></a>进程的创建与终止</h3><p><strong>进程创建原语</strong>执行的操作:</p><ol><li>申请空白 PCB。</li><li>为新进程分配资源。</li><li>初始化进程控制块。</li></ol><ul><li>初始化标识信息。</li><li>初始化处理机状态信息。使程序计数器指向程序的入口地址，使栈指针指向栈顶；</li><li>初始化处理机控制信息：进程的状态、优先级。</li></ul><ol start="4"><li>将新进程插入就绪队列，启动调度。</li></ol><p><strong>引起进程创建的主要事件</strong></p><p>用户登录<br>作业调度<br>提供服务<br>应用请求</p><p><strong>引起进程终止的事件</strong></p><ol><li><p>正常结束。</p></li><li><p>异常结束：</p><ul><li>越界错误。</li><li>保护错。</li><li>非法指令。</li><li>特权指令错。</li><li>运行超时。</li><li>等待超时。</li><li>算术运算错、被 0 除：</li><li>I&#x2F;O 故障。</li></ul></li><li><p>外界干预:外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。</p><ul><li>操作员或操作系统干预。由于某种原因，例如，发生了死锁，由操作员或操作系统终止该进程；</li><li>父进程请求终止该进程；</li><li>当父进程终止时，OS 也将他的所有子孙进程终止。</li></ul></li></ol><p><strong>进程的终止过程</strong></p><ol><li>根据被终止进程的 PID 找到它的 PCB，从中读出该进程的状态。</li><li>若被终止进程正处于执行状态，应立即终止该进程的执行，重新进行调度。</li><li>若该进程还有子孙进程，立即将其所有子孙进程终止。</li><li>将被终止进程所拥有的全部资源，归还给其父进程，或者归还给系统。</li><li>将被终止进程的 PCB 从所在队列中移出</li></ol><h3 id="进程的阻塞与唤醒-Block-and-Wakeup"><a href="#进程的阻塞与唤醒-Block-and-Wakeup" class="headerlink" title="进程的阻塞与唤醒 Block and Wakeup"></a>进程的阻塞与唤醒 Block and Wakeup</h3><p><strong>引起进程阻塞的原因</strong></p><ul><li>请求系统服务。</li><li>启动某种操作：如 I&#x2F;O 操作。</li><li>新数据尚未到达。</li><li>无新工作可做</li></ul><p><strong>进程阻塞的过程</strong></p><p>处于运行状态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息，当被等待的事件未发生时，由进程自己执行阻塞原语 block，使自己由运行态变为阻塞态。可见，进程的阻塞是进程自身的一种主动行为。</p><ol><li>正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语<code>block</code>把自己阻塞；（阻塞是主动行为）</li><li>把进程控制块中的现行状态由<code>running</code>改为<code>blocked</code>，并将 PCB 插入阻塞队列；</li><li>转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换。</li></ol><p><strong>进程的唤醒过程</strong></p><p>当被阻塞进程所期待的事件出现时，例如，当进程提出 I&#x2F;O 请求时，进程会进入到阻塞状态，但是不能让这个进程一直处于阻塞状态，等到其 I&#x2F;O 操作完成时，那么系统就要采用唤醒原语 wakeup 唤醒这个处于阻塞的进程，以使它继续执行。</p><ol><li>当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该 I&#x2F;O 设备的进程）调用唤醒原语 <code>wakeup()</code>，将等待该事件的进程唤醒。（唤醒是一种被动行为）</li><li>唤醒原语的执行过程是：<br>把被阻塞的进程从等待该事件的阻塞队列中移出<br>将其 PCB 中的现行状态由阻塞改为就绪<br>将该 PCB 插入到就绪队列中等待 CPU 调度</li></ol><h3 id="进程的挂起与激活-Suspend-and-Active"><a href="#进程的挂起与激活-Suspend-and-Active" class="headerlink" title="进程的挂起与激活 Suspend and Active"></a>进程的挂起与激活 Suspend and Active</h3><p>当有引起进程挂起的事件，系统利用挂起原语<code>suspend（）</code>将指定进程或者处于阻塞状态的进程挂起。<br>当有发生激活进程的事件发生，若该进程在外存中已有足够的空间时，可将在外存上处于静止就绪的进程从外存调入内存，系统利用激活原语<code>active()</code>将指定进程激活</p><p><strong>进程的挂起</strong><br>当出现了引起进程挂起的事件时，系统将利用挂起原语<code>suspend()</code>将指定进程挂起或处于阻塞状态的进程挂起。（挂起是主动行为）<br>调用挂起原语的进程只能挂起自己或其子孙进程;内核的 sleep()函数是在挂起原语的基础上利用定时器实现的。</p><p><strong>挂起原语的执行过程</strong></p><ol><li>检查将要被挂起的进程的状态<br><code>running</code>：将该进程的 PCB 中的现行状态由<code>running</code>改为<code>ready suspend</code>,设置 CPU 调度标志为真；<br><code>ready</code>: PCB 中的现行状态由<code>running</code>改为<code>ready suspend</code>；<br><code>blocked</code>：将该进程的 PCB 中的现行状态由<code>blocked</code>改为<code>blocked suspend</code>；</li><li>将被挂起进程的 PCB 复制到指定的内存区域。</li><li>若处于运行状态，则转向调度程序重新调度</li></ol><blockquote><p><strong>Ex</strong>:请判断下列说法哪些的正确的？</p><ul><li><input disabled="" type="checkbox"> 进程可以由自己创建(❌,进程可以创建子进程,但不能自己创建自己)</li><li><input checked="" disabled="" type="checkbox"> 进程可以由自己阻塞</li><li><input checked="" disabled="" type="checkbox"> 进程可以由自己挂起</li><li><input disabled="" type="checkbox"> 进程可以由自己激活</li><li><input disabled="" type="checkbox"> 进程可以由自己唤醒</li><li><input disabled="" type="checkbox"> 进程可以由自己撤消</li></ul></blockquote>]]></content>
    
    
    <summary type="html">操作系统进程管理:前趋图和程序执行,进程的描述,进程控制</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Process &amp; Thread</title>
    <link href="https://efterklang.github.io/UESTC/OS/ProcessvsThread/"/>
    <id>https://efterklang.github.io/UESTC/OS/ProcessvsThread/</id>
    <published>2024-03-04T06:24:55.000Z</published>
    <updated>2024-03-29T07:03:52.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ul><li>A process is an instance of a program running in a computer.</li><li>A process is an independent unit of execution in a computer program, including the complete set of instructions and the associated memory and resources.</li><li>It is a program that is under execution.</li></ul><p>典型的进程定义有：</p><ul><li>进程是程序的一次执行。</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li><li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li></ul><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul><li><strong>动态性 Dynamic</strong>:进程的实质是进程实体的一次执行过程，因此，动态性是进程的最基本的特征。动态性表现在“它由创建而产生，由调度而执行，由撤消而消亡”。可见，进程实体有一定的生命期。</li><li><strong>并发性 Concurrency</strong>:多个进程实体同存于内存中，且能在一段时间内同时运行。</li><li><strong>独立性 Independence</strong>:进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。</li><li><strong>异步性 Asynchronism</strong>:进程按各自独立的、不可预知的速度向前推进，或说进程实体按异步方式运行。</li></ul><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p><strong>进程实体 Process Entity</strong>包括：</p><ul><li><strong>程序块 Program Block</strong>: The code that is to be executed.</li><li><strong>数据块 Data Block</strong>: The variables and data that are used by the program.</li><li><strong>堆栈 Stack</strong>: The stack that is used to store the temporary data and function calls.</li><li><strong>进程控制块 Process control block(PCB)</strong>: It is a data structure that contains information about the process. It includes process state, process ID, CPU registers, CPU scheduling information, memory management information, and other information. It is used by the operating system to manage the process.</li></ul><p>[<a href="Ch2-1ProcessContorl" title="进程的描述及控制">Ch2-1ProcessContorl#进程控制块 PCB</a>]</p><h3 id="States"><a href="#States" class="headerlink" title="States"></a>States</h3><ul><li><strong>新建态 New</strong>: 进程已经创建，但未被 OS 接纳为可执行进程，并且程序还在辅存，PCB 在内存</li><li><strong>就绪态 Ready</strong>: The process is ready to be executed.</li><li><strong>运行态 Running</strong>: The process is currently being executed.</li><li><strong>阻塞态 Blocked&#x2F;等待态 Waiting</strong>: The process is waiting for some event to occur.</li><li><strong>终止态 Exit</strong>: 因停止或取消，被 OS 从执行状态释放</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-04-13-43-46.png" alt="5 states model"></p><p>当出现了引起进程挂起的事件时，用户请求将自己挂起，或者父进程请求挂起自己的子进程，这时使用挂起原语<code>Suspend()</code><br>当发生激活事件后，系统利用激活原语<code>Active()</code> 将指定进程激活。激活原语将进程从外存调入内存，然后检查进程状态<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-04-14-00-16.png"><br>挂起状态又称为静止状态，一个就绪进程被挂起，变为静止就绪；阻塞状态进程被挂起，称为静止阻塞。处于静止状态的进程保存在磁盘(外存)上，它只有被对换到内存才能被调度执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-04-13-59-41.png"></p><p><strong>Note</strong></p><ul><li>即使进程等待的事件已经发生，只要进程处于挂起状态，它就不能执行。只有当进程从挂起状态恢复时，它才能根据自身的就绪条件（如等待的事件是否已经发生）决定是否可以执行。</li><li>使之挂起的进程可以为：自身、其父进程、OS</li><li>只有挂起它的进程才能使之由挂起状态转换为其他状态</li></ul><p><strong>Causes of Suspension</strong></p><ul><li>终端用户的请求。</li><li>父进程请求。</li><li>负荷调节的需要。当实时系统中的工作负荷较重，把一些不重要的进程挂起，以保证系统能正常运行。</li><li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。</li></ul><blockquote><p><strong>Blocked VS Suspend</strong></p><p><strong>阻塞</strong>：正在执行的进程<strong>由于发生某事件（如 I&#x2F;O 请求、申请缓冲区失败等）</strong>暂时无法继续执行。此时引起进程调度，OS 把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种状态称为阻塞状态。<br><strong>挂起</strong>：由于<strong>系统和用户的需要</strong>引入了挂起的操作，进程被挂起意味着该进程处于静止状态。如果进程正在执行，它将暂停执行，若原本处于就绪状态，则该进程此时暂不接受调度。</p><p><strong>Same</strong>：</p><ul><li>进程都暂停执行</li><li>进程都释放 CPU，即两个过程都会涉及上下文切换</li></ul><p><strong>Diff</strong>：</p><ul><li><strong>对系统资源占用不同</strong>：虽然都释放了 CPU，但阻塞的进程仍处于内存中，而挂起的进程通过“对换 Swapping”技术被换出(Swap Out)到外存（磁盘）中。</li><li><strong>发生时机不同</strong>：阻塞一般在进程等待资源（IO 资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS 为了提高内存利用率需要将暂时不能运行的进程（处于就绪或阻塞队列的进程）调出到磁盘</li><li><strong>恢复时机不同</strong>：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其激活</li></ul></blockquote><blockquote><p>Program vs Process: A program is a passive entity, such as a file containing a list of instructions stored on disk, whereas a process is an active entity, with a program counter specifying the next instruction to execute and a set of associated resources.</p><p><strong>可执行程序和进程的区别</strong></p><ul><li>程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li><li>程序是静态的观念，进程是动态的观念；</li><li>进程具有并发性，而程序没有；</li><li>进程是竞争计算机资源的基本单位，程序不是。</li><li>进程和程序不是一一对应的：<ul><li>一个程序可对应多个进程即多个进程可执行同一程序；</li><li>一个进程可以执行一个或几个程序。</li></ul></li></ul></blockquote><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li>A thread is a basic unit of CPU utilization.</li><li>It is a single sequence stream within a process.</li><li>A thread is a lightweight process. It shares the same memory space and system resources with other threads in the same process.</li></ul><p>也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。</p><blockquote><p>[<a href="Ch2-4Thread" title="Thread">Ch2-4Thread#线程概述</a>]</p></blockquote><h3 id="Features-1"><a href="#Features-1" class="headerlink" title="Features"></a>Features</h3><ul><li><strong>Lightweight</strong>: Threads are lightweight compared to processes. It takes less time to create and terminate threads.</li><li><strong>Shared resources</strong>: Threads in the same process share the same memory space and system resources.</li><li><strong>Efficiency</strong>: Threads are more efficient than processes because they share the same memory space and system resources.</li></ul><h3 id="Components-1"><a href="#Components-1" class="headerlink" title="Components"></a>Components</h3><p><strong>TCB Components</strong></p><ul><li><p><strong>Tid</strong>: A unique thread identifier in the process.</p><blockquote><p>同进程一样，每个线程也有一个线程 ID;进程 ID 在整个系统中是唯一的，线程 ID 只在它所属的进程环境中唯一</p></blockquote></li><li><p><strong>Register set</strong>: These are small storage areas that quickly hold and release data. They store intermediate values during execution.Including <strong>Program counter</strong> which keeps track of the execution of the thread, indicating the address of the next instruction to be executed.</p></li><li><p><strong>Stack</strong>: It is a data structure that stores temporary data like function parameters, return addresses, and local variables.</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-13-10-44-36.png" alt="Components"></p><h3 id="States-1"><a href="#States-1" class="headerlink" title="States"></a>States</h3><p>同进程一样，线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。<br>线程运行时有以下 3 种状态：</p><ul><li><strong>Running 执行状态</strong>:表示线程正获得 CPU 而运行；</li><li><strong>Ready 就绪状态</strong>:表示线程已具备了各种运行条件，一旦获得 CPU 便可执行；</li><li><strong>Blocked 阻塞状态</strong>:表示线程在运行中因某事件而受阻，处于暂停执行的状态；</li></ul><h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><strong>线程</strong>具有许多传统进程所具有的特征，所以又称为<strong>轻型进程</strong>(Light-Weight Process) ，相应地把传统<strong>进程</strong>称为<strong>重型进程</strong>(Heavy-Weight Process)，传统进程相当于只有一个线程的任务。<br>在引入了线程的操作系统中，通常一个进程都拥有若干个线程，至少也有一个线程。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-4Thread-2024-03-13-09-23-33.png" alt="Create Thread vs Create Process"></p><p>下面从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较。</p><ul><li><strong>调度</strong> 在传统的操作系统中，进程作为拥有资源和独立调度、分派的基本单位。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。</li><li><strong>并发性</strong> 在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。</li><li><strong>拥有资源</strong> 一般而言，线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I&#x2F;O 设备等，可以供该进程中的所有线程所共享。</li><li><strong>独立性</strong> 同一进程中的不同线程共享进程的内存空间和资源</li><li><strong>系统开销</strong> 线程的切换只需要保存和设置少量的寄存器内容，不涉及存储器管理方面的操作。 由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。</li><li><strong>支持多处理机系统</strong> 一个进程分为多个线程分配到多个处理机上并行执行，可加速进程的完成。</li></ul><p><strong>Linux Process&#x2F;Thread Control Operations Comparison</strong></p><table><thead><tr><th align="center">应用功能</th><th align="center">线程</th><th align="center">进程</th></tr></thead><tbody><tr><td align="center">创建</td><td align="center">pthread_create</td><td align="center">fork,vfork</td></tr><tr><td align="center">退出</td><td align="center">pthread_exit</td><td align="center">exit</td></tr><tr><td align="center">等待</td><td align="center">pthread_join</td><td align="center">wait、waitpid</td></tr><tr><td align="center">取消&#x2F;终止</td><td align="center">pthread_cancel</td><td align="center">abort</td></tr><tr><td align="center">读取 ID</td><td align="center">pthread_self()</td><td align="center">getpid()</td></tr><tr><td align="center">同步互斥&#x2F;通信机制</td><td align="center">互斥锁、条件变量、读写锁</td><td align="center">无名管道、有名管道、信号、消息队列、信号量、共享内存</td></tr></tbody></table><h3 id="Java-Example"><a href="#Java-Example" class="headerlink" title="Java Example"></a>Java Example</h3><p>摘录自<a href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">javaguide</a></p><p>从下图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-04-14-13-53.png" width="80%"></center><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。<br>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h3 id="有了进程为什么还需要线程"><a href="#有了进程为什么还需要线程" class="headerlink" title="有了进程为什么还需要线程?"></a>有了进程为什么还需要线程?</h3><p>进程切换是一个开销很大的操作，线程切换的成本较低。<br>线程更轻量，一个进程可以创建多个线程。<br>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。<br>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</p><h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程?"></a>为什么要使用多线程?</h3><p><strong>总体上</strong></p><p><strong>从计算机底层来说</strong>： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。<br><strong>从当代互联网发展趋势来说</strong>： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><p><strong>计算机底层</strong></p><p><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。<br><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><p><a href="https://teaching.csse.uwa.edu.au/units/CITS2002/lectures/lecture07/singlepage.html">https://teaching.csse.uwa.edu.au/units/CITS2002/lectures/lecture07/singlepage.html</a></p>]]></content>
    
    
    <summary type="html">介绍进程和线程</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Copilot GPT4 Service</title>
    <link href="https://efterklang.github.io/Tech/Others/CopilotGPT4Service/"/>
    <id>https://efterklang.github.io/Tech/Others/CopilotGPT4Service/</id>
    <published>2024-03-01T09:05:01.000Z</published>
    <updated>2024-04-27T11:23:40.665Z</updated>
    
    <content type="html"><![CDATA[<article class="message is-danger">        <div class="message-header"><p>文章已过时</p></div>        <div class="message-body">            <p>Copilot-GPT4-Service Repo 已被邪恶的微软帝国禁用,无法继续使用👾</p>        </div>    </article><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><p>拥有一个 github 账号,并且订阅了 Github Copilot 服务<br>在通过 <a href="https://education.github.com/students">Github 学生认证</a>后,可免费使用 Github Copilot</p><h2 id="Step1-下载-Copilot-GPT4-Service"><a href="#Step1-下载-Copilot-GPT4-Service" class="headerlink" title="Step1.下载 Copilot-GPT4-Service"></a>Step1.下载 Copilot-GPT4-Service</h2><p><a href="https://github.com/aaamoon/copilot-gpt4-service/releases/tag/0.2.0">https://github.com/aaamoon/copilot-gpt4-service/releases/tag/0.2.0</a><br><a href="https://gitlab.com/aaamoon/copilot-gpt4-service">https://gitlab.com/aaamoon/copilot-gpt4-service</a></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/copilot-gpt4-service.png" alt="Copilot-GPT4-Service"></p><h2 id="Step2-运行-service-获取-copilot-token"><a href="#Step2-运行-service-获取-copilot-token" class="headerlink" title="Step2.运行 service,获取 copilot token"></a>Step2.运行 service,获取 copilot token</h2><p>解压缩,并以管理员权限运行<code>Step1</code>中下载的可执行文件;然后按照如下步骤 copilot token</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>运行脚本(二选一即可),按照脚本提示进行操作即可;复制得到的 token,形如 <code>ghu_6lGZ6JxxxxxxxxxxxxxxxxD0kykBm</code><br><strong>方法一: python script</strong></p><!-- [get_copilot_token.py](https://raw.githubusercontent.com/aaamoon/copilot-gpt4-service/master/shells/get_copilot_token.py) --><p><a href="https://gitlab.com/aaamoon/copilot-gpt4-service/-/raw/master/shells/get_copilot_token.py?ref_type=heads">get_copilot_token.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"></span><br><span class="line">PROXY = &#123;</span><br><span class="line">    <span class="string">&quot;http&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;https&quot;</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> typing</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;requests is not installed, please install it by running `pip install requests`&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LoginError</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    AUTH_PENDING = <span class="number">1</span></span><br><span class="line">    EXPIRED_TOKEN = <span class="number">2</span></span><br><span class="line">    NETWORK_ERROR = <span class="number">3</span></span><br><span class="line">    OTHER_ERROR = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">HEADERS = &#123;</span><br><span class="line">    <span class="string">&quot;accept&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">    <span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getLoginInfo</span>(<span class="params">proxy=<span class="literal">None</span></span>) -&gt; (LoginError, typing.<span class="type">Union</span>[<span class="built_in">dict</span>, Exception]):</span><br><span class="line">    url = <span class="string">&quot;https://github.com/login/device/code&quot;</span></span><br><span class="line">    body = &#123;</span><br><span class="line">        <span class="string">&quot;client_id&quot;</span>: <span class="string">&quot;Iv1.b507a08c87ecfe98&quot;</span>,</span><br><span class="line">        <span class="string">&quot;scope&quot;</span>: <span class="string">&quot;read:user&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = requests.post(url, headers=HEADERS, json=body, proxies=proxy, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.ConnectionError:</span><br><span class="line">        <span class="keyword">return</span> LoginError.NETWORK_ERROR, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> LoginError.OTHER_ERROR, e</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span>, resp.json()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pollAuth</span>(<span class="params">device_code: <span class="built_in">str</span>, proxy=<span class="literal">None</span></span>) -&gt; (LoginError, <span class="built_in">str</span>):</span><br><span class="line">    url = <span class="string">&quot;https://github.com/login/oauth/access_token&quot;</span></span><br><span class="line">    body = &#123;</span><br><span class="line">        <span class="string">&quot;client_id&quot;</span>: <span class="string">&quot;Iv1.b507a08c87ecfe98&quot;</span>, <span class="comment"># client_id of gh copilot</span></span><br><span class="line">        <span class="string">&quot;device_code&quot;</span>: device_code,</span><br><span class="line">        <span class="string">&quot;grant_type&quot;</span>: <span class="string">&quot;urn:ietf:params:oauth:grant-type:device_code&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        resp = requests.post(url, headers=HEADERS, json=body, proxies=proxy, timeout=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">except</span> requests.exceptions.ConnectionError:</span><br><span class="line">        <span class="keyword">return</span> LoginError.NETWORK_ERROR, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">return</span> LoginError.OTHER_ERROR, e</span><br><span class="line"></span><br><span class="line">    data = resp.json()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> data.get(<span class="string">&quot;error&quot;</span>) == <span class="string">&quot;authorization_pending&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> LoginError.AUTH_PENDING, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> data.get(<span class="string">&quot;error&quot;</span>) == <span class="string">&quot;expired_token&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> LoginError.EXPIRED_TOKEN, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&quot;access_token&quot;</span> <span class="keyword">in</span> data:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, data[<span class="string">&quot;access_token&quot;</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> LoginError.OTHER_ERROR, data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getToken</span>(<span class="params">proxy=<span class="literal">None</span></span>) -&gt; (LoginError, <span class="built_in">str</span>):</span><br><span class="line">    <span class="comment"># get login info</span></span><br><span class="line">    err, login_info = getLoginInfo(proxy)</span><br><span class="line">    <span class="keyword">if</span> err <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> err == LoginError.NETWORK_ERROR:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;network error, please check your network.&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> err == LoginError.OTHER_ERROR:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;unknown error occurred when getting login info.&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error message:&quot;</span>, login_info)</span><br><span class="line">        <span class="keyword">return</span> err, <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    interval = login_info[<span class="string">&#x27;interval&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Please open <span class="subst">&#123;login_info[<span class="string">&#x27;verification_uri&#x27;</span>]&#125;</span> in browser and enter <span class="subst">&#123;login_info[<span class="string">&#x27;user_code&#x27;</span>]&#125;</span> to login.&quot;</span>)</span><br><span class="line">    <span class="comment"># poll for auth status</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        err, access_token = pollAuth(login_info[<span class="string">&#x27;device_code&#x27;</span>], proxy)</span><br><span class="line">        <span class="keyword">if</span> err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>, access_token</span><br><span class="line">        <span class="keyword">elif</span> err == LoginError.AUTH_PENDING:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> err == LoginError.EXPIRED_TOKEN:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;session expired, please try again.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> err, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> err == LoginError.NETWORK_ERROR:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;network error, please check your network.&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> err, <span class="literal">None</span></span><br><span class="line">        <span class="keyword">elif</span> err == LoginError.OTHER_ERROR:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;unknown error occurred when pulling auth info.&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error message:&quot;</span>, access_token)</span><br><span class="line">            <span class="keyword">return</span> err, <span class="literal">None</span></span><br><span class="line">        time.sleep(interval)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> PROXY.items():</span><br><span class="line">        <span class="keyword">if</span> v == <span class="string">&quot;&quot;</span>:</span><br><span class="line">            PROXY[k] = os.getenv(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>_proxy&quot;</span>.upper()) <span class="keyword">or</span> os.getenv(<span class="string">f&quot;<span class="subst">&#123;k&#125;</span>_proxy&quot;</span>.lower()) <span class="keyword">or</span> <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">if</span> re.<span class="keyword">match</span>(<span class="string">r&quot;^.+://.+$&quot;</span>, PROXY[k]) <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> PROXY[k] != <span class="string">&quot;&quot;</span>:</span><br><span class="line">                PROXY[k] = <span class="string">&quot;http://&quot;</span> + PROXY[k]</span><br><span class="line">    err, token = getToken(PROXY)</span><br><span class="line">    <span class="keyword">if</span> err <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Your token is:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(token)</span><br></pre></td></tr></table></figure><p><strong>方法二:batch script</strong><br><a href="https://raw.githubusercontent.com/aaamoon/copilot-gpt4-service/master/shells/get_copilot_token.bat">get_copilot_token.bat</a></p><h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># method <span class="number">1</span></span><br><span class="line">bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/aaamoon/copilot-gpt4-service/master/shells/get_copilot_token.sh)&quot;</span><br><span class="line"># method <span class="number">2</span></span><br><span class="line">pip install requests</span><br><span class="line">python3 &lt;(curl -fsSL https://raw.githubusercontent.com/aaamoon/copilot-gpt4-service/master/shells/get_copilot_token.py)</span><br></pre></td></tr></table></figure><h2 id="Step3-config-NextChat"><a href="#Step3-config-NextChat" class="headerlink" title="Step3. config NextChat"></a>Step3. config NextChat</h2><p>下载<a href="https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web/releases/tag/v2.11.2">NextChat</a></p><p>参照下图进行配置,其中 <code>OpenAI API Key</code>填入在 Step2 中获得的<code>token</code></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/NextChat.png" alt="NextChat Settings"></p><p>后台运行<code>Copilot-GPT4-Service</code>后即可无限制使用 GPT4</p>]]></content>
    
    
    <summary type="html">使用Github Copilot的GPT4服务</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="Others" scheme="https://efterklang.github.io/categories/Tech/Others/"/>
    
    
    <category term="Others" scheme="https://efterklang.github.io/tags/Others/"/>
    
  </entry>
  
</feed>

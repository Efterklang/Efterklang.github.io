<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Efterklang</title>
  
  
  <link href="https://efterklang.github.io/atom.xml" rel="self"/>
  
  <link href="https://efterklang.github.io/"/>
  <updated>2024-06-11T09:41:35.009Z</updated>
  <id>https://efterklang.github.io/</id>
  
  <author>
    <name>Efterklang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://efterklang.github.io/Essay/Poems/%E3%80%8A%E5%94%90%E5%A4%9A%E4%BB%A4%C2%B7%E8%8A%A6%E5%8F%B6%E6%BB%A1%E6%B1%80%E6%B4%B2%E3%80%8B/"/>
    <id>https://efterklang.github.io/Essay/Poems/%E3%80%8A%E5%94%90%E5%A4%9A%E4%BB%A4%C2%B7%E8%8A%A6%E5%8F%B6%E6%BB%A1%E6%B1%80%E6%B4%B2%E3%80%8B/</id>
    <published>2024-06-11T09:41:35.009Z</published>
    <updated>2024-06-11T09:41:35.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="唐多令·芦叶满汀洲"><a href="#唐多令·芦叶满汀洲" class="headerlink" title="唐多令·芦叶满汀洲"></a>唐多令·芦叶满汀洲</h1><p>南宋 刘过</p><p>安远楼小集，侑觞歌板之姬黄其姓者，乞词于龙洲道人，为赋此《唐多令》。同柳阜之、刘去非、石民瞻、周嘉仲、陈孟参、孟容。时八月五日也。</p><p>芦叶满汀洲，寒沙带浅流。二十年重过南楼。柳下系船犹未稳，能几日，又中秋。<br>黄鹤断矶头，故人今在否？旧江山浑是新愁。欲买桂花同载酒，终不似，少年游。</p><h2 id="创作背景"><a href="#创作背景" class="headerlink" title="创作背景"></a>创作背景</h2><blockquote><p>安远楼，在武昌黄鹄山上，一名南楼。建于1186年（淳熙十三年）。<a href="https://so.gushiwen.cn/authorv_f8b6b7d9fab9.aspx">姜夔</a>曾自度《翠楼吟》词纪之。<a href="https://so.gushiwen.cn/authorv_5f5ca596d67c.aspx">刘过</a>重访南楼，距上次登览几二十年。词人刘过以垂暮之身，逢此乱局，虽风景不殊，却触目有忧国伤时之恸。这种心境深深地反映到他的词中。</p></blockquote><h2 id="赏析"><a href="#赏析" class="headerlink" title="赏析"></a>赏析</h2><blockquote><p>​<a href="https://so.gushiwen.cn/authorv_5f5ca596d67c.aspx">刘过</a>词能够在辛派阵营中占据重要一席，并不仅仅是因为那些与<a href="https://so.gushiwen.cn/authorv_a7900666497f.aspx">辛弃疾</a>豪纵恣肆之风相近的作品，还在于那些豪迈中颇显俊致的独特词风，正如刘熙载所说：“刘改之词，狂逸之中自饶俊致，虽沉着不及稼轩，足以自成一家。”（《艺概》）此词就是这么一首具有独特风格的词。</p><p>　　这是一首登临名作。作者借重过武昌南楼之机，感慨时事，抒写昔是今非和怀才不遇的思想感情。安远楼，在武昌黄鹄山上，一名南楼。建于1186年（淳熙十三年）。<a href="https://so.gushiwen.cn/authorv_f8b6b7d9fab9.aspx">姜夔</a>曾自度《翠楼吟》词纪之。其小序云“淳熙丙午冬，武昌安远楼成，与刘去非诸友落之，度曲见志”，具载其事。 　</p><p>　　刘过重访南楼，距上次登览几二十年。当时韩侂胄掌握实权，轻举妄动，意欲伐金以成就自己的“功名”。而当时南宋朝廷军备废驰，国库空虚，将才难觅，一旦挑起战争，就会兵连祸连，生灵涂炭。词人刘过以垂暮之身，逢此乱局，虽风景不殊，却触目有忧国伤时之恸。这种心境深深地反映到他的词中。</p><p>　　词一起用了两个偶句，略点景物，写登楼之所见。 　</p><p>　　但既无金碧楼台，也没写清嘉的山水。呈现在人们面前的只是一泓寒水，满目荒芦而已。这里的“满”字和“寒”字下得好，把萧疏的外景同低徊的心境交融在一起，勾勒出一幅黯淡的画面，为全词着上了一层“底色”。细味这残芦满目、浅流如带的词境，不止气象萧瑟，而且写出了居高临下的眺望之感来，是统摄全篇的传神之笔。接下去，作者以时空交错的技法把词笔从空间的凭眺折入时间的溯洄，以虚间实，别起波澜。“二十年重过南楼”，一句里包含了多少感慨！二十年前，也就是安远楼落成不久，刘过离家赴试，曾在这里过了一段狂放不羁的生活。所谓“醉槌黄鹤楼，一掷赌百万。”（《湖学别苏召叟》）以及“黄鹤楼前识楚卿，彩云重叠拥娉婷”（《浣溪沙。赠妓徐楚楚》），这就是他当年游踪的剪影。二十年过去了，可是以身许国的刘过却“四举无成，十年不调”，仍然一袭布衣。此时故地重经，而且是在这个危机四伏祸乱不远的时候，怎不令人凄然以悲呢？句中的“过”字点明此行不过是“解鞍少驻初程”的暂歇而已，并为下文伏线。“柳下”三句，一波三折，文随意转，极见工力。“未稳”上承“过”字，说明行色匆匆，钩锁紧密，见出文心之细。“能几日，又中秋”，意谓不消几天，中秋又来到了。一种时序催人的忧心、烈士暮年的悲感和无可奈何的叹喟都从这一个“又”字里泄露出来。三句迭用“犹”、“能”、“又”等虚字呼应提携，真能将词人灵魂的皱折淋漓尽致地揭示无余。</p><p>　　过片以后纯乎写情，都从“重过”一义生发。曰“故人”，曰“旧江山”，曰“新愁”，曰“不似”，莫不如此。章法之精严，风格之浑成，堪称《龙洲词》中上上之作。“黄鹤”二句从设问提起，妙处在能从虚际转身。“矶头”上缀一“断”字，便有残山剩水的凄凉意味，不是泛泛之笔。“旧江山浑是新愁”，是深化题旨之重笔。前此种种灰黯的心绪，所为伊何？</p><p>　　难道仅仅是怀人、病酒、叹老、悲秋么？被宋子虚誉为“天下奇男子，平生以气义撼当世”（《龙洲词跋》）的刘过是不会自溺于此的，刘过此词的忧国伤时之感无疑要高于<a href="https://so.gushiwen.cn/authorv_c364b4db5ff7.aspx">宋玉</a>《九辨》单纯的寒土悲秋之感。他此刻所感受的巨大的愁苦，就是对韩侂胄引火的冒险政策的担忧，就是对江河日下的南宋政局的悲痛。</p><p>　　旧日的壮丽江山笼罩着战争的阴影，而他对于这场可怕的灾难竟然无能为力，这怎么不教人悲从中来不可断绝呢？“浑是新愁”，四字包括三层含义。本有旧愁，是一层；添了新愁，是第二层。愁到了“浑是”的程度，极言分量之重，是第三层。旧愁为何？就是他《忆鄂渚》诗所云“书生岂无一策奇，叩阍击鼓天不知”之怀才不遇报国无门的苦闷。卒章三句买花载酒，本想苦中求乐，来驱散一下心头的愁绪。可是这家国恨、身世愁又岂是些许花酒所冲淡得了的！先用“欲”字一顿，提出游乐的意愿，接着用“不似”一转，则纵去也无复当年乐趣，表示了否定的态度。“少年”，是一个比较宽泛的概念，相对而言。刘过初到南楼，年方三十，故可称为少年。且可与上片之“二十年重过南楼”相绾合，论其章法，确有草蛇灰线之妙。如此结尾，既沉郁又浑成，令人读之有无穷哀感。</p><p>　　刘过的爱国词篇，多为豪爽奔放，痛快淋漓之作。但这首《唐多令》却写得蕴藉含蓄，耐人咀嚼。与其他爱国词比较，的确别具一格，故而流传甚广。《唐多令》，原为僻调，罕有填者。自刘词出而和者如林，其调乃显。<a href="https://so.gushiwen.cn/authorv_5452bed2115f.aspx">刘辰翁</a>即追和七阕，<a href="https://so.gushiwen.cn/authorv_894a6c66e6a6.aspx">周密</a>而因其有“重过南楼”之语，为更名曰《南楼令》。可见此词影响之大</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;唐多令·芦叶满汀洲&quot;&gt;&lt;a href=&quot;#唐多令·芦叶满汀洲&quot; class=&quot;headerlink&quot; title=&quot;唐多令·芦叶满汀洲&quot;&gt;&lt;/a&gt;唐多令·芦叶满汀洲&lt;/h1&gt;&lt;p&gt;南宋 刘过&lt;/p&gt;
&lt;p&gt;安远楼小集，侑觞歌板之姬黄其姓者，乞词于龙洲道人，为赋此《</summary>
      
    
    
    
    
    <category term="中国古代诗词" scheme="https://efterklang.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BB%A3%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>Death Stranding Gallery</title>
    <link href="https://efterklang.github.io/Essay/Game/DeathStranding/"/>
    <id>https://efterklang.github.io/Essay/Game/DeathStranding/</id>
    <published>2024-06-11T06:14:52.000Z</published>
    <updated>2024-06-11T09:41:35.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="I-won’t-break-Fragile"><a href="#I-won’t-break-Fragile" class="headerlink" title="I won’t break Fragile"></a>I won’t break Fragile</h2><div class="justified-gallery"><p><img src="/img/gallery/Games/DeathStranding/Fragile-0.jpg" alt="Fragile"><br><img src="/img/gallery/Games/DeathStranding/Fragile-1.jpg" alt="Fragile"><br><img src="/img/gallery/Games/DeathStranding/Fragile-2.jpg" alt="Fragile"><br><img src="/img/gallery/Games/DeathStranding/Fragile-3.jpg" alt="Fragile"><br><img src="/img/gallery/Games/DeathStranding/Fragile-4.jpg" alt="Fragile"><br><img src="/img/gallery/Games/DeathStranding/Fragile-5.jpg" alt="Fragile"></p></div><h2 id="Mama"><a href="#Mama" class="headerlink" title="Mama"></a>Mama</h2><div class="justified-gallery"><p><img src="/img/gallery/Games/DeathStranding/Mama-0.jpg" alt="Mama"><br><img src="/img/gallery/Games/DeathStranding/Mama-1.jpg" alt="Mama"><br><img src="/img/gallery/Games/DeathStranding/Mama-2.jpg" alt="Mama"></p></div><h2 id="Cliff-Unger-Higgs-Monaghan"><a href="#Cliff-Unger-Higgs-Monaghan" class="headerlink" title="Cliff Unger &amp; Higgs Monaghan"></a>Cliff Unger &amp; Higgs Monaghan</h2><article class="message is-warning">        <div class="message-header"><p>Clifford</p></div>        <div class="message-body">            <p>They told me your name was Sam Porter..But you’re Sam Bridges.<br>My son..My bridge to the future.<br>Without you, I was just lick any other cliff.<br>A dead end. No way forward.<br>Nothing but an obstacle——Looking on at the world,<br>people like you were trying to build.<br>Dividing people was the only thing I was ever good at.</p><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1400013102&auto=0&height=66"></iframe></center><p>But not you Sam.You bring people together, you’re their bridge to the future…and mine”</p><p><a href="https://www.youtube.com/watch?v=gXNaHYEOoQ8">DEATH STRANDING - CLIFF Tell SAM That He’s His Son and He’s BB-28 Himself</a></p>        </div>    </article><div class="justified-gallery"><p><img src="/img/gallery/Games/DeathStranding/Cliff-Higgs-0.jpg" alt="Higgs"><br><img src="/img/gallery/Games/DeathStranding/Cliff-Higgs-4.jpg" alt="Higgs"><br><img src="/img/gallery/Games/DeathStranding/Cliff-Higgs-1.jpg" alt="Cliff"><br><img src="/img/gallery/Games/DeathStranding/Cliff-Higgs-2.jpg" alt="Cliff"><br><img src="/img/gallery/Games/DeathStranding/Cliff-Higgs-3.jpg" alt="Cliff"><br><img src="/img/gallery/Games/DeathStranding/Cliff-Higgs-5.jpg" alt="Cliff"></p></div><h2 id="Thank-you-for-everything-Lou"><a href="#Thank-you-for-everything-Lou" class="headerlink" title="Thank you for everything Lou"></a>Thank you for everything Lou</h2><div class="justified-gallery"><p><img src="/img/gallery/Games/DeathStranding/Lou-0.jpg" alt="Lou"><br><img src="/img/gallery/Games/DeathStranding/Lou-1.jpg" alt="Lou"><br><img src="/img/gallery/Games/DeathStranding/Lou-2.jpg" alt="Lou"><br><img src="/img/gallery/Games/DeathStranding/Lou-3.jpg" alt="Lou"><br><img src="/img/gallery/Games/DeathStranding/Lou-4.jpg" alt="Lou"><br><img src="/img/gallery/Games/DeathStranding/Lou-5.jpg" alt="Lou"></p></div><h2 id="Flowers-Cemetry"><a href="#Flowers-Cemetry" class="headerlink" title="Flowers &amp; Cemetry"></a>Flowers &amp; Cemetry</h2><p>DS 导演剪辑版剧情的最后一段</p><ul><li>Episode 15 未来在你手上</li><li>首都结点城西边的配送中心</li><li>【No.79 订单】将数据传输装置送到废弃工厂</li></ul><div class="justified-gallery"><p><img src="/img/gallery/Games/DeathStranding/The_flowers_and_the_cemetery-1.jpg" alt="Flower"><br><img src="/img/gallery/Games/DeathStranding/The_flowers_and_the_cemetery-2.jpg" alt="Photos"><br><img src="/img/gallery/Games/DeathStranding/The_flowers_and_the_cemetery-3.jpg" alt="Her mother"><br><img src="/img/gallery/Games/DeathStranding/The_flowers_and_the_cemetery-4.jpg" alt="Flower"><br><img src="/img/gallery/Games/DeathStranding/The_flowers_and_the_cemetery-5.jpg" alt="Tomb"><br><img src="/img/gallery/Games/DeathStranding/The_flowers_and_the_cemetery-6.jpg" alt="overlooking"></p></div><center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=28909946&auto=0&height=66"></iframe></center><h2 id="Landscape"><a href="#Landscape" class="headerlink" title="Landscape"></a>Landscape</h2><div class="justified-gallery"><p><img src="/img/gallery/Games/DeathStranding/TheAurora.jpg" alt="The Aurora"><br><img src="/img/gallery/Games/DeathStranding/TheStorm.jpg" alt="The Storm"><br><img src="/img/gallery/Games/DeathStranding/WeatherStations.jpg" alt="Weather Station"><br><img src="/img/gallery/Games/DeathStranding/Whale_BT.jpg" alt="Whale BT"><br><img src="/img/gallery/Games/DeathStranding/SnowMountain.jpg" alt="Snow Mountain"><br><img src="/img/gallery/Games/DeathStranding/beach-0.jpg" alt="The Beach"><br><img src="/img/gallery/Games/DeathStranding/beach-1.jpg" alt="The Beach"></p></div><h2 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h2><ul><li><em>Fragile —— Midge Ure</em></li><li><em>BB’s Theme —— Ludvig Forssell,Jenny Plant</em></li></ul><p><a href="https://www.gamesradar.com/death-stranding-ending-story-explained-meaning/">Death Stranding ending explained</a></p>]]></content>
    
    
    <summary type="html">Keep on,keeping on👍👍👍👍👍</summary>
    
    
    
    <category term="Essay" scheme="https://efterklang.github.io/categories/Essay/"/>
    
    <category term="Game" scheme="https://efterklang.github.io/categories/Essay/Game/"/>
    
    
    <category term="Games" scheme="https://efterklang.github.io/tags/Games/"/>
    
  </entry>
  
  <entry>
    <title>应用层 ApplicationLayer Part Ⅱ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-2ApplicationLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-2ApplicationLayer/</id>
    <published>2024-06-10T10:24:23.000Z</published>
    <updated>2024-06-12T09:23:35.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS——The-Internet’s-Directory-Service"><a href="#DNS——The-Internet’s-Directory-Service" class="headerlink" title="DNS——The Internet’s Directory Service"></a>DNS——The Internet’s Directory Service</h2><h3 id="Services-Provided-by-DNS"><a href="#Services-Provided-by-DNS" class="headerlink" title="Services Provided by DNS"></a>Services Provided by DNS</h3><p>识别主机的两种方式：通过<strong>hostname</strong>或者<strong>IP address</strong>。人们喜欢记忆主机名标识方式，而路由器喜欢定长的、有着层次结构的 IP 地址。DNS 提供了一种将主机名转换为 IP 地址的服务。</p><p><strong>DNS(Domain Name System),域名系统</strong></p><ul><li>分布式数据库：一个由分层 DNS 服务器实现的分布式数据库</li><li>应用层协议：DNS 服务器实现域名转换,域名&#x2F;地址转换;DNS 协议运行在 <code>UDP</code>之下，使用 <code>53</code>号端口；<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-16-31.png"></li></ul><p><strong>DNS 服务器提供的功能</strong></p><ul><li>主机名到 IP 地址的转换（hostname to IP address translation）；</li><li>主机别名（host aliasing）：一个主机可以有一个规范主机名和多个主机别名,应用程序调用 DNS 获取主机别名对应的规范主机名（canonical hostname）以及主机的 IP 地址；</li><li>邮件服务器别名（mail server aliasing）；</li><li>负载分配（load distribution）：繁忙的站点被<strong>冗余分布在多台服务器</strong>上，每台服务器运行在不同的端系统上，每个都有着不同的 IP 地址。由于这些冗余的 Web 服务器，一个 IP 地址集合对应<strong>一个规范主机名</strong>。当客户对映射到某处到某地址集合的名字发出一个 DNS 请求时，该服务器用 IP 地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常<strong>总是向 IP 地址排在最前面的服务器发送 HTTP 请求报文</strong>，所以 DNS 就在所有这些冗余的 Web 服务器之间循环分配了负载；</li></ul><h3 id="Overview-of-How-DNS-Works"><a href="#Overview-of-How-DNS-Works" class="headerlink" title="Overview of How DNS Works"></a>Overview of How DNS Works</h3><h4 id="集中式设计的问题"><a href="#集中式设计的问题" class="headerlink" title="集中式设计的问题"></a>集中式设计的问题</h4><ul><li>单点故障（a single point of failure）；</li><li>通信容量（traffic volume）；</li><li>远距离的集中式数据库（distant centralized database）；</li><li>维护（maintenance）；</li></ul><h4 id="分布式-DNS-服务器的层次结构"><a href="#分布式-DNS-服务器的层次结构" class="headerlink" title="分布式 DNS 服务器的层次结构"></a>分布式 DNS 服务器的层次结构</h4><ul><li>Root DNS servers:负责记录顶级域名服务器的信息</li><li>Top-Level Domain DNS servers:负责顶级域名 com, org, net, edu, etc, 和所有国家的顶级域名 uk, fr, ca, jp.</li><li>Authoritative DNS servers:在因特网上具有公共可访问主机（如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。组织机构的权威 DNS 服务器负责保存这些 DNS 记录。</li><li>Local DNS servers:严格来说不属于该服务器的层次结构,每个 ISP（如居民区 ISP、公司、大学）都有一个本地 DNS,也叫默认服务器,当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器,它起着代理的作用，转发请求到层次结构中。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-18-29.png"></p><blockquote><p>PS:你可以通过<code>ipconfig /all</code>命令查看本地 DNS 服务器的地址。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Wireless LAN adapter WLAN:</span><br><span class="line">Connection<span class="literal">-specific</span> DNS Suffix . :</span><br><span class="line">Description . . . . . . . . . . . : Intel(<span class="built_in">R</span>) Wi<span class="literal">-Fi</span> <span class="number">6</span> AX200 <span class="number">160</span>MHz</span><br><span class="line">Physical Address. . . . . . . . . : <span class="number">48</span><span class="literal">-51-C5-27-0C-9F</span></span><br><span class="line">DHCP Enabled. . . . . . . . . . . : Yes</span><br><span class="line">Autoconfiguration Enabled . . . . : Yes</span><br><span class="line">IPv4 Address. . . . . . . . . . . : <span class="number">113.54</span>.<span class="number">231.1</span>(Preferred)</span><br><span class="line">Subnet Mask . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">224.0</span></span><br><span class="line">Lease Obtained. . . . . . . . . . : Thursday, March <span class="number">28</span>, <span class="number">2024</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">52</span> PM</span><br><span class="line">Lease Expires . . . . . . . . . . : Thursday, March <span class="number">28</span>, <span class="number">2024</span> <span class="number">3</span>:<span class="number">16</span>:<span class="number">27</span> PM</span><br><span class="line">Default Gateway . . . . . . . . . : <span class="number">113.54</span>.<span class="number">224.1</span></span><br><span class="line">DHCP Server . . . . . . . . . . . : <span class="number">113.54</span>.<span class="number">224.1</span></span><br><span class="line">DNS Servers . . . . . . . . . . . : <span class="number">202.112</span>.<span class="number">14.21</span></span><br><span class="line"><span class="number">202.112</span>.<span class="number">14.11</span></span><br><span class="line">NetBIOS over Tcpip. . . . . . . . : Enabled</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-41-23.png"></p></blockquote><h4 id="DNS-查询方法"><a href="#DNS-查询方法" class="headerlink" title="DNS 查询方法"></a>DNS 查询方法</h4><p><strong>递归 Recursive Query</strong>：客户端只发一次请求，要求对方给出最终结果。<br><strong>迭代 Iterated Quert</strong>：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-57-53.png"></p><h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><ul><li>一旦名字服务器获得 DNS 映射, 它将缓存该映射到局部内存<ul><li>服务器在一定时间后将丢弃缓存的信息</li><li>本地 DNS 服务器可以缓存 TLD 服务器的 IP 地址</li><li>因此根 DNS 服务器不会被经常访问</li></ul></li><li>权威 DNS 服务器记录更新：IETF 动态更新&#x2F;通报机制</li></ul><h3 id="DNS-Records-and-Messages"><a href="#DNS-Records-and-Messages" class="headerlink" title="DNS Records and Messages"></a>DNS Records and Messages</h3><h4 id="DNS-Resource-Records"><a href="#DNS-Resource-Records" class="headerlink" title="DNS Resource Records"></a>DNS Resource Records</h4><p>DNS 服务器中存储了大量的资源记录——Resource Record(RR),RR 是一个包含了下列字段的 4 元组<code>(name, value, type, ttl)</code><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-15-31-40.png"></p><h4 id="DNS-Messages"><a href="#DNS-Messages" class="headerlink" title="DNS Messages"></a>DNS Messages</h4><ul><li>Identification 标识符: 16 位，查询和应答报文使用相同的标识符</li><li>Flags 标志:有若干个标志构成，分别标识不同的功能<ul><li>查询&#x2F;应答－0&#x2F; 1</li><li>查询希望是&#x2F;非递归查询－1&#x2F;0</li><li>应答可&#x2F;否获得(支持)递归查询－1&#x2F;0</li><li>应答是&#x2F;否来自权威名字服务器－1&#x2F; 0</li></ul></li><li>Questions 问题部分:查询的 Name, type</li><li>Answers 回答部分:对于查询,应答的资源记录可以多个资源记录，由于可以有多个 IP 地址</li><li>Authority 权威部分:域对应的权威名字服务器的信息</li><li>Additional information 附加信息部分:权威名字服务器的 IP 地址等其他有帮助的记录.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-15-32-48.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dns.message</span><br><span class="line"><span class="keyword">import</span> dns.query</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 DNS 查询报文对象</span></span><br><span class="line">query = dns.message.make_query(<span class="string">&quot;baidu.com&quot;</span>, dns.rdatatype.ANY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 DNS 查询并接收响应报文,设置DNS服务器的IP地址为202.112.14.21</span></span><br><span class="line">response = dns.query.tcp(query, <span class="string">&quot;202.112.14.21&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印输出报文的信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Identification: <span class="subst">&#123;response.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Flags: <span class="subst">&#123;response.flags&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Questions: <span class="subst">&#123;response.question&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Answers: <span class="subst">&#123;response.answer&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Authority: <span class="subst">&#123;response.authority&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Additional information: <span class="subst">&#123;response.additional&#125;</span>&quot;</span>)</span><br><span class="line">[OUTPUT]</span><br><span class="line">Identification: <span class="number">41532</span></span><br><span class="line">Flags: <span class="number">33152</span></span><br><span class="line">Questions: [&lt;DNS baidu.com. IN ANY RRset: []&gt;]</span><br><span class="line">Answers: [&lt;DNS baidu.com. IN A RRset: [&lt;<span class="number">110.242</span><span class="number">.68</span><span class="number">.66</span>&gt;, &lt;<span class="number">39.156</span><span class="number">.66</span><span class="number">.10</span>&gt;]&gt;, &lt;DNS baidu.com. IN NS RRset: [&lt;ns7.baidu.com.&gt;, &lt;ns2.baidu.com.&gt;, &lt;dns.baidu.com.&gt;, &lt;ns3.baidu.com.&gt;, &lt;ns4.baidu.com.&gt;]&gt;]</span><br><span class="line">Authority: []</span><br><span class="line">Additional information: [&lt;DNS dns.baidu.com. IN A RRset: [&lt;<span class="number">110.242</span><span class="number">.68</span><span class="number">.134</span>&gt;]&gt;, &lt;DNS ns2.baidu.com. IN A RRset: [&lt;<span class="number">220.181</span><span class="number">.33</span><span class="number">.31</span>&gt;]&gt;, &lt;DNS ns3.baidu.com. IN A RRset: [&lt;<span class="number">153.3</span><span class="number">.238</span><span class="number">.93</span>&gt;, &lt;<span class="number">36.155</span><span class="number">.132</span><span class="number">.78</span>&gt;]&gt;, &lt;DNS ns4.baidu.com. IN A RRset: [&lt;<span class="number">111.45</span><span class="number">.3</span><span class="number">.226</span>&gt;, &lt;<span class="number">14.215</span><span class="number">.178</span><span class="number">.80</span>&gt;]&gt;, &lt;DNS ns7.baidu.com. IN A RRset: [&lt;<span class="number">180.76</span><span class="number">.76</span><span class="number">.92</span>&gt;]&gt;, &lt;DNS ns7.baidu.com. IN AAAA RRset: [&lt;240e:bf:b801:<span class="number">1002</span>:<span class="number">0</span>:ff:b024:26de&gt;, &lt;240e:<span class="number">940</span>:<span class="number">603</span>:<span class="number">4</span>:<span class="number">0</span>:ff:b01b:589a&gt;]&gt;]</span><br></pre></td></tr></table></figure><h2 id="Peer-to-Peer-File-Distribution"><a href="#Peer-to-Peer-File-Distribution" class="headerlink" title="Peer-to-Peer File Distribution"></a>Peer-to-Peer File Distribution</h2><ul><li>没有总是在线的服务器</li><li>任意端系统之间直接通信</li><li>对等方之间可以间断连接并可以改变 IP 地址</li></ul><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>BitTorrent 是一种用于高效分发文件的协议和技术。它是一种点对点（P2P）文件共享协议，允许用户在互联网上分享和下载文件。</p><p>相比于传统的文件下载方式，BitTorrent 采用了一种分布式的下载模式，使得文件可以同时从多个来源下载，从而提高了下载速度和可靠性。BitTorrent 协议的核心思想是让下载者同时充当上传者，即将下载好的文件块分享给其他下载者，从而实现文件的高效传输。</p><p>以下是 BitTorrent 的工作原理：</p><p>种子文件（Torrent File）的创建和分享：对于要被共享的文件，首先需要创建一个种子文件，该文件包含了文件的元数据和跟踪器（Tracker）的信息。跟踪器是协调下载者之间连接的服务器，帮助下载者找到其他参与文件共享的人。这个种子文件被分享给其他用户。</p><p>Peers 的连接和数据交换：下载者（也称为 Peer）通过 BitTorrent 客户端连接到跟踪器，并获取参与共享文件的其他 Peer 的信息。然后，下载者与这些 Peer 建立连接，开始交换文件块。下载者不仅从上传者下载文件块，也同时将自己已经下载好的文件块分享给其他下载者。</p><p>分块下载和校验：文件被分成小块（通常为 256KB 或 512KB），下载者通过与其他 Peer 交换文件块来逐步下载文件。每个文件块都有一个唯一的标识符，以便下载者之间进行正确的数据交换。下载者还会进行校验，确保下载的文件块的完整性和准确性。</p><p>做种（Seeding）：当下载者完全获得整个文件后，他们可以选择继续将文件保持在 BitTorrent 网络中作为种子继续分享给其他下载者，这称为做种。通过做种，更多的用户可以从他们那里下载文件，从而促进整个网络的稳定性和可扩展性。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-15-52-44.png"></p><h2 id="Video-Streaming-and-Content-Distribution-Networks"><a href="#Video-Streaming-and-Content-Distribution-Networks" class="headerlink" title="Video Streaming and Content Distribution Networks"></a>Video Streaming and Content Distribution Networks</h2><h3 id="HTTP-Streaming-And-DASH"><a href="#HTTP-Streaming-And-DASH" class="headerlink" title="HTTP Streaming And DASH"></a>HTTP Streaming And DASH</h3><p>HTTP 流所有客户接受到相同编码的视频，但对不同用户或者不同时间，客户可用的带宽大小有很大不同。<strong>HTTP 的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）</strong>：视频编码成几个不同的版本，其中每个版本具有不同的比特率，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒的视频段数据块。</p><p>每个视频版本存储在 HTTP 服务器中，每个版本都有一个不同的 URL。HTTP 服务器也有一个<strong>告示文件（manifest file）</strong>，为每个版本提供了一个 URL 及其比特率。</p><h3 id="Content-Distribution-Networks"><a href="#Content-Distribution-Networks" class="headerlink" title="Content Distribution Networks"></a>Content Distribution Networks</h3><p>如何从海量的视频中，挑选出某些内容，采用流的方式发送给成千上万的用户?<br>CDN 使用多台分布在全球各地的服务器（这些服务器被称为边缘节点），这些服务器存储了网站中内容的副本。当用户请求访问网站时，CDN 会根据用户的地理位置，选择距离用户最近的边缘节点来响应请求。</p><ul><li><strong>Private CDN</strong> 私有 CDN 是由单个组织或企业自己建立和管理的内容分发网络。它通常由该组织或企业在自己的数据中心或云环境中架设服务器节点，用于存储和分发自己的内容。私有 CDN 的优势在于对内容的控制权和安全性更高。</li><li><strong>Third-party CDN</strong> 第三方 CDN 是由专业的 CDN 提供商运营和管理的网络基础设施。这些提供商拥有全球分布的服务器节点，并为各种网站和应用提供内容分发服务。第三方 CDN 通过在全球各地部署服务器节点，将站点或应用的静态和动态内容缓存到离用户近的节点，并通过智能路由和负载均衡，将用户的请求引导到最近的节点。</li></ul><p><strong>CDN Operation:</strong></p><p>When a browser in a user’s host is instructed to retrieve a specific video (identified by a URL), the CDN must intercept(截获) the request so that it can</p><ol><li>Determine a suitable CDN server cluster(集群) for that<br>client at that time</li><li>Redirect the client’s request to a server in that cluster.<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-20-11-15.png"><blockquote><p>许多 CDN 利用 DNS 截获用户请求并将用户重定向到最近的 CDN 服务器。</p></blockquote></li></ol><p>如下是一个用户访问 NetCinema 网页中视频的过程：</p><ul><li>用户访问 NetCinema 的网页。</li><li>当用户点击链接<code>http://video.netcinema.com/6Y7B23V</code>时，用户的主机会发送一个寻找<code>video.netcinema.com</code>的 DNS 查询。</li><li>用户的本地 DNS 服务器（LDNS）将 DNS 查询转发到 NetCinema 的权威 DNS 服务器，该服务器注意到主机名<code>video.netcinema.com</code>中的字符串 video。为了将 DNS 查询交给 KingCDN，NetCinema 的权威 DNS 服务器不返回 IP 地址，而是返回 KingCDN 域中的主机名，例如<code>a1105.kingcdn.com</code></li><li>DNS 查询进入 KingCDN 的私有 DNS 基础设施;用户的 LDNS 然后发送查询<code>a1105.kingcdn.com</code>的请求;KingCDN 的 DNS 系统指定合适的 KingCDN 内容服务器,将其 IP 地址返回给 LDNS。</li><li>LDNS 将提供内容的 CDN 节点的 IP 地址转发给用户的主机。</li><li>一旦客户端收到 KingCDN 内容服务器的 IP 地址，它就会与该 IP 地址的服务器建立 TCP 连接，并发出一个 HTTP GET 请求获取视频。如果使用 DASH，服务器会首先向客户端发送一个清单文件，其中包含一个 URL 列表，每个版本的视频对应一个 URL，客户端会动态地从不同的版本中选择块。</li></ul><h2 id="Socket-Programming-Creating-Network-Applications"><a href="#Socket-Programming-Creating-Network-Applications" class="headerlink" title="Socket Programming: Creating Network Applications"></a>Socket Programming: Creating Network Applications</h2><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-20-40-38.png"></p>]]></content>
    
    
    <summary type="html">Application Layer Part Ⅱ,DNS,P2P,Video Streaming,CDN,Socket Programming</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="计算机网络" scheme="https://efterklang.github.io/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://efterklang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>vue</title>
    <link href="https://efterklang.github.io/Dev/Java/Web/Vue/"/>
    <id>https://efterklang.github.io/Dev/Java/Web/Vue/</id>
    <published>2024-06-10T06:27:06.000Z</published>
    <updated>2024-06-11T09:41:35.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Vue-js-Introduction"><a href="#Vue-js-Introduction" class="headerlink" title="Vue.js Introduction"></a>Vue.js Introduction</h2><p><strong>框架</strong>（Framework）是一种预先定义好的软件结构，旨在为开发者提供一种标准的解决方案来快速构建应用程序。它提供了一系列可重用的组件、库以及约定，帮助开发者遵循最佳实践，减少重复编码工作，专注于业务逻辑的实现，而不必关心实现细节。</p><p>常见的软件开发框架按照应用领域可以分为 Web 框架、移动应用框架、游戏开发框架等。对于 Java 而言，Junit 就是一个常见的测试框架。</p><p><strong>Vue.js</strong>（通常简称 Vue）是一个开源的渐进式 JavaScript 框架，用于构建用户界面。Vue 的核心特点是其易用性、灵活性以及强大的组件系统，使其成为构建单页应用（SPA）和其他类型 Web 应用的热门选择。Vue 遵循“数据驱动视图”的思想，让开发者能够轻松地将数据模型的变化实时反映到界面上</p>]]></content>
    
    
    <summary type="html">vue</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Java" scheme="https://efterklang.github.io/categories/Dev/Java/"/>
    
    
    <category term="Java" scheme="https://efterklang.github.io/tags/Java/"/>
    
    <category term="Web" scheme="https://efterklang.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Unix/Linux OS Introduction</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch7-1LinuxUnix/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch7-1LinuxUnix/</id>
    <published>2024-06-09T13:25:57.000Z</published>
    <updated>2024-06-12T09:26:00.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-操作系统的简介"><a href="#Linux-操作系统的简介" class="headerlink" title="Linux 操作系统的简介"></a>Linux 操作系统的简介</h2><h3 id="什么是-Linux-操作系统"><a href="#什么是-Linux-操作系统" class="headerlink" title="什么是 Linux 操作系统"></a>什么是 Linux 操作系统</h3><p>Linux 是一套免费使用和自由传播的 Unix Like 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p>Linux 操作系统由 Linux 内核，LinuxShell，Linux 文件系统，Linux 应用程序四大主要部分组成。</p><ul><li>内核是操作系统的核心，提供了操作系统最基本的功能</li><li>Shell 是系统的用户界面，提供了用户与内核进行交互操作的一种接口</li><li>文件系统是文件存放在磁盘等存储设备上的组织方法</li><li>标准的 Linux 系统一般都有一套称为应用程序的程序集，即 Linux 应用程序</li></ul><h3 id="Linux-操作系统的组成"><a href="#Linux-操作系统的组成" class="headerlink" title="Linux 操作系统的组成"></a>Linux 操作系统的组成</h3><h4 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h4><p><strong>内核是操作系统的核心，提供了操作系统最基本的功能</strong>，如支持虚拟内存、多任务、共享库、需求加载、可执行程序和 TCP&#x2F;IP 网络等<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-LinuxOS-2024-05-23-15-18-43.png" style="zoom:100%;"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> –a 查看内核版本号</span><br><span class="line">Linux Efterklang 5.15.146.1-microsoft-standard-WSL2 <span class="comment">#1 SMP Thu Jan 11 04:09:03 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line"><span class="built_in">ls</span> –l /boot 查看内核文件</span><br></pre></td></tr></table></figure><h4 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h4><p><strong>Shell 是系统的用户界面，提供了用户与内核进行交互操作的一种接口</strong>。它接收用户输入的命令并把它送入内核去执行。实际上 Shell 是一个命令解释器(command-language interpreter)，它解释由用户输入的命令并且把它们送到内核。<br>Linux 系统的 Shell 是命令语言、命令解释程序及程序设计语言的统称。</p><ul><li>Shell 是一个命令语言解释器<br>它拥有自己内建的 Shell 命令集，Shell 也能被系统中其他应用程序所调用。用户在提示符下输入的命令都由 Shell 先解释然后传给 Linux 核心。使用户不必关心一个命令是建立在 Shell 内部还是一个单独的程序。</li><li>Shell 是一个解释型的程序设计语言。<br>shell 程序设计语言支持绝大多数在高级语言中能见到的程序元素，如函数、变量、数组和程序控制结构。shell 编程语言简单易学，任何在提示符中能键入的命令都能放到一个可执行的 Shell 程序中。</li></ul><p><strong>执行过程</strong><br>shell 首先检查命令是否是内部命令，不是的话再检查是否是一个应用程序，这里的应用程序可以是 Linux 本身的实用程序，比如 ls rm，<br>然后 shell 试着在搜索路径($PATH)里寻找这些应用程序。搜索路径是一个能找到可执行程序的目录列表。如果你键入的命令不是一个内部命令并且在路径里没有找到这个可执行文件，将会显示一条错误信息。而如果命令被成功的找到的话，shell 的内部命令或应用程序将被分解为系统调用并传给 Linux 内核。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-LinuxOS-2024-05-23-15-27-36.png" style="zoom:100%;"></p><h4 id="File-System"><a href="#File-System" class="headerlink" title="File System"></a>File System</h4><p><strong>Linux 文件系统中的文件是数据的集合，文件系统不仅包含着文件中的数据而且还有文件系统的结构</strong>，所有 Linux 用户和程序看到的文件、目录、软连接及文件保护信息等都存储在其中。<br>每个实际文件系统都是从操作系统和系统服务中分离出来的，它们之间通过一个接口层——虚拟文件系统（VFS）通信。<br>文件类型主要包括：</p><ul><li>普通文件（regularfile）</li><li>目录文件（directory）</li><li>连接文件（link）</li><li>设备与设备文件（device）</li><li>套接字（sockets）</li><li>管道（FIFO,pipe）</li></ul><h3 id="Linux-操作系统的功能特征"><a href="#Linux-操作系统的功能特征" class="headerlink" title="Linux 操作系统的功能特征"></a>Linux 操作系统的功能特征</h3><p>Linux 操作系统功能强大，与其他操作系统相比，其具有下述主要的功能特征。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-LinuxOS-2024-05-23-15-35-13.png" style="zoom:100%;"></p><ol><li><strong>开放性</strong>：遵循开放系统互连(OSI)国际标准。</li><li><strong>多用户</strong>：Linux 支持多用户，操作系统资源可以被不同用户使用，每个用户对自己的资源(例如：文件、设备)具有特定的权限，这样可以保证每个用户之间互不影响。</li><li><strong>多任务</strong>：Linux 可以使多个程序同时并独立地运行。**计算机同时执行多个程序，而同时各个程序的运行互相独立。</li><li><strong>良好的用户界面</strong>：Linux 向用户提供了两种界面：字符界面和图形界面。在字符界面用户可以通过键盘输入相应的指令来进行操作。Linux 还为用户提供了图形用户界面，它类似于 Windows 图形界面的 X-Window 系统。它利用鼠标、菜单、窗口、滚动条等设施，给用户呈现一个直观、易操作、交互性强的友好的图形化界面。在 X-Window 环境中就和在 Windows 中相似，可以说是一个 Linux 版的 Windows。</li><li><strong>设备独立性</strong>：操作系统把所有外部设备统一当作文件来看待，只要安装驱动程序，任何用户都可以像使用文件一样，操纵和使用这些设备。Linux 是具有设备独立性的操作系统，内核具有高度适应能力。</li><li><strong>提供了丰富的网络功能</strong>：完善的内置网络是 Linux 操作系统的一大特点。</li><li><strong>可靠的安全系统</strong>：Linux 采取了许多安全技术措施，包括对读写控制，带保护的子系统，审计跟踪，核心授权等，这为网络多用户环境中的用户提供了必要的安全保障。</li><li><strong>良好的可移植性</strong>：将 Linux 操作系统从一个平台转移到另一个平台使它仍然能够按照其自身的方式运行。Linux 是一种可移植的操作系统，能够在从微型计算机到大型计算机的任何环境中和任何平台上运行。Linux 可以运行在多种硬件平台上，如具有 x86、ARM、SPARC、Alpha 等处理器的平台。此外 Linux 还是一种嵌入式操作系统，可以运行在掌上电脑、机顶盒或游戏机上。2001 年 1 月份发布的 Linux 2.4 版内核已经能够完全支持 Intel 64 位芯片架构。同时 Linux 也支持多处理器技术。多个处理器同时工作，使系统性能大大提高</li></ol><hr><p>Linux 核心特征：多用户、多进程<br>Linux 核心特征—多用户、多进程管理的实现方式如下：<br>（1）账户管理<br>系统依据账户 ID 来区分每个用户的文件、进程、任务，给每个用户提供特定的工作环境（如用户的工作目录、Shell 版本以及 XWindow 环境的配置等），使每个用户的工作都能独立不受干扰地进行。<br>（2）权限管理<br>在 Linux 中，将使用系统资源的人员分为 4 类三组：超级用户、文件或目录的属主；属主的同组人；其他人员。对每组用户分别分配对文件和目录的不同的访问权限。<br>（3）进程管理<br>进程控制是 Shell 的一个特性，使用户能在多个独立进程间进行切换。<br>例如，用户可以挂起一个正在运行的进程，稍后再恢复其运行。bash 记录所有启动的进程并保持对所有已启动的进程的跟踪，在每一个正在运行的进程生命期内的任何时候，用户可以任意地挂起进程或重新启动进程恢复运行。</p><h3 id="Linux-操作系统的主要版本"><a href="#Linux-操作系统的主要版本" class="headerlink" title="Linux 操作系统的主要版本"></a>Linux 操作系统的主要版本</h3><p>Linux 操作系统主要分为内核版本以及发行版本，其具体内容如下。<br>（1）Linux 的内核版本：<br>Linux 内核使用主要分为两种不同的版本编号方式。第一种方式用于 1.0 版本之前（包括 1.0）。第二种方式用于 1.0 之后到 2.6，数字由三部分“A.B.C”，A 代表主版本号，B 代表次主版本号，C 代表较小的末版本号。</p><p>（2）Linux 的发行版本<br>Linux 的发行版本实质在于 Linux 核心加上外围的实用程序组成的一个大软件包。<br>把 SUSE、RedHat(现在通常称为 Red Hat Enterprise Linux，简称 RHEL)、Ubuntu、Slackware 等直接称呼为 Linux 是不确切的，它们是 Linux 的发行版本。更确切地说，应该称为以 Linux 为核心的操作系统软件包</p><p>发行版主要可分为 Debian 系和 RedHat 系。Debian 系主要分为 Ubuntu、Debian、Linux Mint、Linux Lite 等。RedHat 系主要分为 CentOS、Fedora、RedHat Enterprise Linux、Oracle Linux 等。Debian 是一个非商业化的项目，完全由社区驱动。Red Hat 提供了一个免费的社区版本（Fedora），同时通过其企业版（RHEL）提供商业支持和服务。</p><h2 id="文件操作与权限管理"><a href="#文件操作与权限管理" class="headerlink" title="文件操作与权限管理"></a>文件操作与权限管理</h2><p>Linux 文件系统架构遵循 Unix 的设计理念，其核心哲学之一就是“一切皆文件”（Everything is a file）。这意味着无论是普通的文本文件、目录、设备（如打印机、磁盘）、管道、套接字还是其他系统资源，都被抽象成文件的形式进行操作，从而提供了一致的接口和简单的编程模型。</p><p><strong>层次树状结构</strong>：Linux 文件系统采用分层的树状目录结构，其中所有文件和目录都始于一个称为根目录（&#x2F;）的单一节点。每个目录可以包含文件和子目录，形成一个层次化的组织结构。</p><h3 id="UNIX-Linux-文件系统的基本结构"><a href="#UNIX-Linux-文件系统的基本结构" class="headerlink" title="UNIX&#x2F;Linux 文件系统的基本结构"></a>UNIX&#x2F;Linux 文件系统的基本结构</h3><p><strong>虚拟文件系统</strong>（VFS）：虚拟文件系统是 Linux 内核中的一个软件层，允许不同的文件系统（如 ext4、XFS、Btrfs 等）以统一的方式被内核和用户空间应用程序访问。VFS 定义了所有文件系统都支持的基本、抽象接口和数据结构<br>,实际文件系统实现 VFS 定义的抽象接口和数据结构（文件、目录等概念在形式上与 VFS 的定义保持一致），在统一的接口和数据结构下隐藏了具体的实现细节</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-LinuxOS-2024-06-09-17-03-39.png" style="zoom:100%;"><br><blockquote><p>ext2 (Second Extended Filesystem)<br>ext2 是 Linux 内核最早支持的文件系统之一，设计用于替代较早的 ext 文件系统。它引入了许多改进，如更快的文件访问速度和更大的文件系统容量。ext2 支持大文件（理论上可达 2^32 个块，受限于文件系统大小）、长文件名等特性。然而，ext2 是一个非日志文件系统，这意味着在系统崩溃时可能需要较长的文件系统检查和修复过程来恢复一致性。<br>ext3 (Third Extended Filesystem)<br>ext3 是 ext2 的升级版，主要增加了日志功能（journaling），这极大地提高了文件系统的可靠性和恢复速度。在系统崩溃后，ext3 能够快速恢复文件系统的状态，因为它维护了一个事务日志，记录了文件系统更改的操作</p><p>ext4 (Fourth Extended Filesystem)<br>ext4 是 ext3 的进一步发展，它不仅继承了 ext3 的稳定性，还引入了多项增强特性，如更大的文件系统和文件大小支持（理论上可达到 1 EB 减 1 字节）、更高效的空间分配策略（延迟分配和多块分配）、无限数量的子目录、更快的文件系统检查和更强大的日志功能。此外，ext4 还优化了 inode（索引节点）的使用，允许存储更多的扩展属性，并支持快速扩展和收缩文件系统大小。</p><p>XFS (eXtended File System)<br>XFS 是一个高性能的 64 位日志文件系统，最初为 SGI 的 IRIX 操作系统设计，后来被移植到 Linux。XFS 特别适合处理大型文件和高并发的读写操作，广泛应用于企业级服务器和大数据存储场景。它提供了极快的文件系统增长速度、延迟分配策略以减少文件碎片、以及动态 inode 分配等功能。XFS 能够支持非常大的文件和文件系统（理论上可达 18 EB），并且其日志机制设计得更加健壮和高效，尤其在处理大量小文件和高 I&#x2F;O 负载时表现优秀。</p></blockquote><p><strong>挂载点</strong>：Linux 允许将不同的物理或逻辑磁盘分区挂载到文件系统的特定目录下，这个目录称为挂载点。这样可以扩展文件系统的存储空间，并且不同的文件系统可以有各自的属性和功能。</p><h3 id="索引节点的功能"><a href="#索引节点的功能" class="headerlink" title="索引节点的功能"></a>索引节点的功能</h3><h4 id="文件在磁盘中的表现形式"><a href="#文件在磁盘中的表现形式" class="headerlink" title="文件在磁盘中的表现形式"></a>文件在磁盘中的表现形式</h4><ul><li>物理表现形式：<ul><li>超级块：用于存储文件系统的控制信息的数据结构。描述文件系统的状态、文件系统类型、大小、区块数、索引节点数等，存放于磁盘的特定扇区中。</li><li>索引节点（i 节点）：用于存储文件的元数据（文件的基本信息）的一个数据结构，包含诸如文件的大小、拥有者、创建时间、数据块&#x2F;目录块位置等信息。</li><li>目录块：存放目录文件的内容</li><li>数据块：存放非目录文件的内容<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-LinuxOS-2024-06-09-17-13-01.png" style="zoom:100%;"></li></ul></li></ul><h4 id="目录文件内容"><a href="#目录文件内容" class="headerlink" title="目录文件内容"></a>目录文件内容</h4><p>一系列目录项（dirent）的列表，每个目录项由两部分组成：</p><ul><li>所包含文件的文件名</li><li>文件名对应的索引节点（inode）号</li></ul><p>使用<code>ls -i</code>可查看文件对应的 inode 号</p><h4 id="文件在内核中的表现形式"><a href="#文件在内核中的表现形式" class="headerlink" title="文件在内核中的表现形式"></a>文件在内核中的表现形式</h4><p>内核使用的三种表来表示进程使用的文件</p><ul><li>每个进程在 PCB 中有一个文件描述符表，每个描述符表项指向一个文件表</li><li>内核为每一个被该进程使用（打开）的文件维护一张文件表</li><li>每个文件（或设备）都有一个索引节点，它包含了文件类型属性及文件数据</li></ul><p>在 UNIX&#x2F;Linux 内核中每个打开的文件（或设备）都有一个对应的 V 节点结构，V 节点包含了文件类型和对此文件进行各种操作的函数指针。对于大多数文件，v 节点还包含了该文件的 i 节点。i 节点与具体的逻辑文件系统有关，存储在磁盘上，在打开文件时从磁盘上读入到内存中。i 节点包含了文件的所有者、文件长度、文件所在设备、指向文件实际数据块在磁盘上所在位置的指针等等。<br>UNIX&#x2F;Linux 每个进程在内核中都有一个结构体来维护进程相关的信息称为进程控制块 (PCB,Process Control Block)。UNIX&#x2F;Linux 中每个打开的文件在内核中都有一个结构体来维护文件相关的信息，成为文件表。每一个 PCB 中有一个指针数组，数组中的每一个成员指向一个该进程打开的文件表,称为文件描述符表。<br>用户程序不能直接访问内核中的文件描述符表,而只能使用文件描述符表的索引,这些索引就称为<strong>文件描述符</strong>(File Descriptor),对于内核而言，所有打开文件都用文件描述符标识,文件描述符是一个非负整数。当打开一个现存文件或创建一个新文件时，内核向进程返回一个文件描述符（打开文件的计数）</p><p>通常情况下，文件描述符 0、1、2 特指标准输入、标准输出、标准错误（用户程序可直接使用而不需要打开）。它们也可以由常数代替（在头文件中 unistd.h 定义） ：</p><ul><li><code>STDIN_FILENO</code></li><li><code>STDOUT_FILENO</code></li><li><code>STDERR_FILENO</code></li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-LinuxOS-2024-06-09-17-32-15.png" style="zoom:100%;"><p>Linux 内核通过一个被称为进程描述符的 task_struct 结构体来管理进程，这个结构体包含了一个进程所需的所有信息。它定义在<code>/usr/src/linux-headers-4.15.0-141/include/linux/sched.h</code> 文件中。</p><p>文件的打开和关闭都是资源的一种操作，Linux 中的 task_struct 中有两个结构体储存这两个信息。</p><ul><li><code>Struct fs_struct *fs</code>：进程的可执行映象所在的文件系统，有两个索引点，称为 root 和 pwd，分别指向对应的根目录和当前目录。</li><li><code>Struct files_struct *files</code>：进程打开的文件, 指向 files_struct 结构体, 称为文件描述符表<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// files_struct的主要成员</span></span><br><span class="line"><span class="type">atomic_t</span> count;         共享该表的进程数 </span><br><span class="line"><span class="type">int</span> max_fds;              当前文件对象的最大数</span><br><span class="line"><span class="type">int</span> max_fdset;           当前文件描述符的最大数</span><br><span class="line"><span class="type">int</span> next_fd;                已分配的文件描述符加<span class="number">1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> ** <span class="title">fd</span>;</span>          指向文件表（文件对象）指针数组</span><br><span class="line">fd_set *close_on_exec;  执行exec时需要关闭的文件描述符</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">fd_array</span>[32];</span> 文件表（文件对象）指针的初始化数组</span><br></pre></td></tr></table></figure></li></ul><p>已打开的文件在 Linux 内核中用 file 结构体表示,文件描述符表中的指针指向 file 结构体</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-LinuxOS-2024-06-09-17-38-28.png" style="zoom:100%;"><p>文件描述符表中每个表项包含一个指向已打开的文件的指针（指向 file 结构的指针）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file的主要成员</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">f_list</span>;</span>     所有打开的文件形成链表</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>    *<span class="title">f_dentry</span>;</span>     指向对应目录项的指针(directory entry)</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span>  *<span class="title">f_op</span>;</span>  这个结构体的成员都是函数指针,指向实现各种文件操作的内核函数</span><br><span class="line"><span class="type">mode_t</span> f_mode;                  文件的状态标志/打开模式</span><br><span class="line"><span class="type">loff_t</span> f_pos;                   文件的当前位置</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> f_flags;         打开文件时所指定的标志</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> f_count;         使用该结构的进程数</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>   f_uid, f_gid;    用户的UserID和GroupID</span><br></pre></td></tr></table></figure><h5 id="目录项对象——dentry-结构体"><a href="#目录项对象——dentry-结构体" class="headerlink" title="目录项对象——dentry 结构体"></a>目录项对象——dentry 结构体</h5><p>Linux 中引入目录项对象的概念主要目的是方便查找文件的索引节点<br>一个路径的各个组成部分，不管是目录还是普通的文件，都是一个目录项对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dentry 主要结构成员</span></span><br><span class="line">Atomic_t d_count;                      目录项dentry引用计数</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> d_flags;                   dentry状态标志</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> * <span class="title">d_inode</span>;</span>               与文件关联的索引节点</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> * <span class="title">d_parent</span>;</span>             父目录的dentry结构</span><br><span class="line"><span class="type">int</span> d_mounted;                             目录项的安装点</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>                      文件名</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> d_time;                  重新生效时间</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span>  操作目录项的函数</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>              目录项树的根</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> d_iname［DNAME_INLINE_LEN］;文件名前<span class="number">16</span>个字符</span><br></pre></td></tr></table></figure><p>在内存中, 每个文件都有一个 dentry(目录项)和 inode(索引节点)结构，dentry 记录着文件名，上级目录等信息，正是它形成了我们所看到的树状结构；而有关该文件的组织和管理的信息主要存放 inode 里面，它记录着文件在存储介质上的位置与分布。<br>同时 <code>dentry-&gt;d_inode</code> 指向相应的 inode 结构。dentry 与 inode 是多对一的关系，因为有可能一个文件有好几个文件名(硬链接, hard link)</p><h5 id="索引节点表——inode-结构"><a href="#索引节点表——inode-结构" class="headerlink" title="索引节点表——inode 结构"></a>索引节点表——inode 结构</h5><p>文件系统中的每个物理文件由一个索引节点表（索引节点对象）描述，且只能由一个索引节点对象描述。索引节点指向物理文件的具体存储位置，系统通过索引节点来定位每一个文件（文件名可以随时更改，但是索引节点对于物理文件是唯一的，并且随物理文件的存在而存在），索引节点包含了文件的长度、创建及修改时间、权限、所属关系、磁盘中的位置等信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iNode 主要结构成员</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> i_ino;              inode号</span><br><span class="line">kdevt  idev;                      常规文件所在设备号</span><br><span class="line"><span class="type">umode_t</span>  i_mode;                  文件类型以及存取权限</span><br><span class="line"><span class="type">nlink_t</span>  i_nlink;                 连接到该inode的硬连接数</span><br><span class="line"><span class="type">uid_t</span>  i_uid;                     文件属主的用户ID</span><br><span class="line"><span class="type">gid_t</span>  i_gid;                     文件属主所在组的ID</span><br><span class="line"><span class="type">kdev_t</span>  i_rdev;                   特殊文件所在设备号</span><br><span class="line"><span class="type">loff_t</span>  i_size;                   文件大小（以字节为单位）</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span>  *<span class="title">i_op</span>;</span>   指向inode进行操作的函数指针</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span>  *<span class="title">i_sb</span>;</span>        指向该文件系统超级块的指针</span><br><span class="line"><span class="type">atomic_t</span> i_count;                 当前使用该inode的引用计数</span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">minix_inode_info</span> <span class="title">minix_i</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Ext2_inode_info</span> <span class="title">Ext2_i</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">hpfs_inode_info</span> <span class="title">hpfs_i</span>;</span></span><br><span class="line">  …</span><br><span class="line">&#125; u;</span><br></pre></td></tr></table></figure><p>inode 代表物理意义上的文件，通过 inode 可以得到一个数组，这个数组记录了文件内容的位置，如该文件位于硬盘的第 3，8，10 块，那么这个数组的内容就是 3,8,10。其索引节点号 inode-&gt;i_ino，在同一个文件系统中是唯一的，内核只要根据 i_ino，就可以计算出它对应的 inode 在介质上的位置。就硬盘来说，根据 i_ino 就可以计算出它对应的 inode 属于哪个块(block)，从而找到相应的 inode 结构。</p><h3 id="文件的分类与权限"><a href="#文件的分类与权限" class="headerlink" title="文件的分类与权限"></a>文件的分类与权限</h3><h4 id="文件类型："><a href="#文件类型：" class="headerlink" title="文件类型："></a>文件类型：</h4><table><thead><tr><th>类型</th><th>标识符</th><th>description</th></tr></thead><tbody><tr><td>普通文件</td><td><code>-</code></td><td>存储数据的常规文件，如文本文件、图片、可执行程序等。</td></tr><tr><td>目录文件</td><td><code>d</code></td><td>特殊类型文件，存储其他文件名及 inode 号码。</td></tr><tr><td>字符设备文件</td><td><code>c</code></td><td>与字符设备（如终端、鼠标）交互，支持读写操作。</td></tr><tr><td>块设备文件</td><td><code>b</code></td><td>与块设备（如硬盘）交互，适合大量数据传输。</td></tr><tr><td>管道&#x2F;FIFO</td><td><code>p</code></td><td>进程间通信，内存中数据缓存通道。</td></tr><tr><td>套接字</td><td><code>s</code></td><td>支持网络或同一主机进程间通信的文件表现形式。</td></tr><tr><td>符号链接</td><td><code>l</code></td><td>指向另一文件或目录的特殊文件，类似 Windows 快捷方式。</td></tr></tbody></table><h4 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h4><table><thead><tr><th>权限标识</th><th>对文件的含义</th><th>对目录的含义</th></tr></thead><tbody><tr><td><code>r</code> (read)</td><td>浏览文件内容</td><td>浏览目录中内容</td></tr><tr><td><code>w</code> (write)</td><td>修改文件内容</td><td>增删及重命名目录内的文件</td></tr><tr><td><code>x</code> (execute)</td><td>允许执行文件（如果文件是可执行的）</td><td>进入目录的权限</td></tr></tbody></table><p><strong>目录权限的特殊性</strong></p><ul><li>当打开一个任意类型的文件时，对该文件路径名中包含的每一个目录都应具有执行权限</li><li>为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限</li><li>为了删除一个文件，必须对包含该文件的目录具有写权限和执行权限，对该文件本身则不需要有读、写权限</li></ul><p><strong>基于用户的文件权限管理</strong><br>文件用户分类</p><ul><li>文件所有者：建立文件和目录的用户；</li><li>文件所有者所在组用户：文件所有者所属用户组中的其他用户；</li><li>其他用户：既不是文件所有者，又不是文件所有组所在组的其他所有用户。</li><li>超级用户：负责整个系统的管理和维护，拥有系统中所有文件的全部访问权限。</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">字母表示法</span><br><span class="line">rwx              rwx            rwx</span><br><span class="line">👆🏻文件所有者   👆🏻同组用户    👆🏻其他用户</span><br><span class="line"></span><br><span class="line">数字表示法</span><br><span class="line">---        --x        -w-       -wx       r--       r-x      rw-       rwx</span><br><span class="line">000        001        010       011       100       101      110       111</span><br></pre></td></tr></table></figure><p>命令<code>chmod</code> 可用于修改文件的访问权限</p><ul><li>format: <code>chmod &lt;mode&gt; &lt;file&gt;</code></li><li>mode:<ul><li>user: u(user，所有者),g(group，同组用户),o(other，其它用户),a(all)</li><li>operation: +（添加权限）、-（移除权限）或 &#x3D;（设置权限）</li><li>permission: r(read)、w(write)、x(execute)、s(setuid，设置用户 ID)、t(setgid，设置组 ID)</li></ul></li></ul><h3 id="文件-I-O"><a href="#文件-I-O" class="headerlink" title="文件 I&#x2F;O"></a>文件 I&#x2F;O</h3><h4 id="open-creat-close"><a href="#open-creat-close" class="headerlink" title="open &amp; creat &amp; close"></a><code>open</code> &amp; <code>creat</code> &amp; <code>close</code></h4><p><code>int open(const char *pathname, int flags, ...);</code></p><p>这个函数用于打开一个文件或者设备，返回一个文件描述符(当前进程中最小未使用的描述符数值)。pathname 是文件或设备的路径名，flags 指定了打开文件的模式（比如读、写、创建、追加等）</p><p><code>int  creat( const char *pathname, mode_t  mode);</code><br>该函数用于创建一个新文件，其等效于<code>open( pathname, O_WRONLY | O_CREAT | O_TRUNC, mode);</code><br>creat 函数的一个不足之处是它以只写方式打开所创建的文件,早期 UNIX 版本中 open 的第二个参数不包含 O_CREAT ，无法打开一个尚未存在的文件。如果要创建一个临时文件，并要先写后读该文件。则必须先依次调用<code>creat，close，open</code></p><p><code>int  close( int  filedes );</code></p><p>该函数关闭打开的一个文件。内核对文件描述符表、对应的文件表项和索引节点表项进行相应的处理，来完成关闭文件的操作。<br>进程关闭文件后，就不能再通过该文件描述符操作该文件。当一个进程终止时，它所有的打开文件将由内核自动关闭</p><h4 id="read-write-lseek"><a href="#read-write-lseek" class="headerlink" title="read &amp; write &amp; lseek"></a><code>read</code> &amp; <code>write</code> &amp; <code>lseek</code></h4><p><code>ssize_t  read( int filedes,  void *buf, size_t  nbytes);</code></p><p>read 函数从打开的文件中读数据。如成功，则返回实际读到的字节数，如已到达文件的末尾或无数据可读，则返回 0,读操作完成后，文件的当前位置将从读之前的位置加上实际读的字节数；有多种情况可使实际读到的字节数少于要求读的字节数：</p><ul><li>读普通文件，在读到要求字节数之前就到达文件尾；</li><li>当从终端设备读，通常一次最多读一行；</li><li>当从网络读时，网络中的缓冲机构可能造成返回值小于所要求读的字节数；</li><li>某些面向记录的设备，如磁带，一次最多返回一个记录。</li></ul><p><code>ssize_t  write( int filedes,  const void *buf, size_t  nbytes);</code></p><p>该函数返回实际写的字节数，通常与参数 nbytes 的值相同，否则表示出错。<br>如果出错，则返回<code>-1</code>。write 出错的原因可能是磁盘满、没有访问权限、或写超过文件长度限制等等。<br>对于普通文件，写操作从文件当前位置开始写（除非打开文件时指定了 O_APPEND 选项）。<br>写操作完成后，文件的当前位置将从写之前的位置加上实际写的字节数。</p><p><code>off_t  lseek( int  filedes,  off_t  offset,  int  whence);</code></p><p>进程中每打开一个文件都有一个与其相关联的“文件当前位置”（读写位置）<br>打开文件时，如果指定了<code>O_APPEND</code>选项则文件当前位置为文件尾，其他情况下文件当前位置默认为文件头（0）<br>lseek 函数用于设置或查询文件当前位置<br>函数对参数的解释与参数 whence 的值有关(offset 可正可负，以字节为单位)</p><ul><li>若<code>whence</code>是<code>SEEK_SET</code>，则将该文件当前位置设为文件头+offset</li><li>若<code>whence</code>是<code>SEEK_CUR</code>，则将该文件当前位置设为文件当前位置+offset</li><li>若<code>whence</code>是<code>SEEK_END</code>，则将该文件当前位置设为文件尾+offset 个字节</li></ul><p>若 lseek 成功执行，则返回新的文件当前位置。因此可用 lseek 查询文件文件当前位置<code>currpos = lseek( fd, 0, SEEK_CUR)</code><br>lseek 仅将文件当前位置记录在内核 file 结构中，它并不引起任何 I&#x2F;O 操作，然后用于影响下一次读、写操作。<br>文件当前位置可以大于文件的当前长度，但并不改变索引节点中文件长度信息（下一次写将延长该文件，并在文件中构成一个空洞，但文件大小并不是文件当前位置指示的值。对空洞位置的读操作将返回 0）</p><h3 id="目录操作与文件属性"><a href="#目录操作与文件属性" class="headerlink" title="目录操作与文件属性"></a>目录操作与文件属性</h3><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><table><thead><tr><th>功能</th><th>常用函数</th><th>头文件</th></tr></thead><tbody><tr><td>获取当前工作路径</td><td><code>getcwd</code>, <code>get_current_dir_name</code></td><td><code>unistd.h</code></td></tr><tr><td>打开关闭目录</td><td><code>opendir</code>, <code>closedir</code></td><td><code>dirent.h</code></td></tr><tr><td>读取目录文件</td><td><code>readdir</code></td><td><code>sys/types.h</code>, <code>dirent.h</code></td></tr></tbody></table><p>Linux 命令演示可见[[LinuxCmds#目录操作]]</p><h4 id="文件属性管理"><a href="#文件属性管理" class="headerlink" title="文件属性管理"></a>文件属性管理</h4><p>读取文件属性 常用函数：stat，lstat，fstat 头文件： <code>sys/stat.h</code></p><p>函数定义：</p><ul><li><code>int stat(const char *path, struct stat *buf);</code></li><li><code>int lstat(const char *path, struct stat *buf);</code></li></ul><p>两个函数参数相同，功能类似<br>读取 path 参数所指定文件的文件属性并将其填充到 buf 参数所指向的结构体中<br>对于符号链接文件，lstat 返回符号链接的文件属性，stat 返回符号链接引用文件的文件属性<br><code>int fstat(int filedes, struct stat *buf);</code><br>与前两个函数功能类似，指定文件的方式改为通过文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">  <span class="type">mode_t</span>     st_mode;       文件类型与访问权限</span><br><span class="line">  <span class="type">ino_t</span>         st_ino;            i节点号</span><br><span class="line">  <span class="type">dev_t</span>        st_dev;          文件使用的设备号</span><br><span class="line">  <span class="type">dev_t</span>        st_rdev;         设备文件的设备号</span><br><span class="line">  <span class="type">nlink_t</span>      st_nlink;        文件的硬链接数</span><br><span class="line">  <span class="type">uid_t</span>         st_uid;           文件所有者用户ID</span><br><span class="line">  <span class="type">gid_t</span>         st_gid;           文件所有者组ID</span><br><span class="line">  <span class="type">off_t</span>         st_size;           文件大小（以字节为单位）</span><br><span class="line">  <span class="type">time_t</span>      st_atime;       最后一次访问该文件的时间</span><br><span class="line">  <span class="type">time_t</span>      st_mtime;      最后一次修改该文件的时间</span><br><span class="line">  <span class="type">time_t</span>      st_ctime;        最后一次改变该文件状态的时间</span><br><span class="line">  <span class="type">blksize_t</span>  st_blksize;     包含该文件的磁盘块的大小</span><br><span class="line">  <span class="type">blkcnt_t</span>   st_blocks;      该文件所占的磁盘块数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>mode_t  st_mode</code> 为无符号整数，其低 16 位定义如下</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-LinuxOS-2024-06-09-21-12-00.png" style="zoom:100%;"><p><strong>判断文件类型</strong></p><ul><li>是否为普通文件: <code>S_ISREG(st_mode)</code><ul><li><code>#define S_IFMT 0170000</code></li><li><code>#define S_IFREG 0100000</code></li><li><code>#define S_ISREG(m) (((m) &amp; S_IFMT) == S_IFREG)</code></li></ul></li><li>是否为目录文件 <code>S_ISDIR(st_mode)</code></li><li>是否为字符设备 <code>S_ISCHR(st_mode)</code></li><li>是否为块设备 <code>S_ISBLK(st_mode)</code></li><li>是否为 FIFO <code>S_ISFIFO(st_mode)</code></li><li>是否为套接字 <code>S_ISSOCK(st_mode)</code></li><li>是否为符号连接 <code>S_ISLINK(st_mode)</code></li></ul>]]></content>
    
    
    <summary type="html">Linux操作系统的简介、文件操作与权限管理</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="操作系统" scheme="https://efterklang.github.io/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://efterklang.github.io/tags/Linux/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Unix/Linux OS Introduction</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch7-2LinuxUnix/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch7-2LinuxUnix/</id>
    <published>2024-06-09T13:25:57.000Z</published>
    <updated>2024-06-12T09:25:58.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程运行与监控"><a href="#进程运行与监控" class="headerlink" title="进程运行与监控"></a>进程运行与监控</h2><h3 id="Linux-进程控制块"><a href="#Linux-进程控制块" class="headerlink" title="Linux 进程控制块"></a>Linux 进程控制块</h3><h3 id="进程的启动"><a href="#进程的启动" class="headerlink" title="进程的启动"></a>进程的启动</h3><h3 id="进程的运行控制"><a href="#进程的运行控制" class="headerlink" title="进程的运行控制"></a>进程的运行控制</h3><h3 id="进程的监测"><a href="#进程的监测" class="headerlink" title="进程的监测"></a>进程的监测</h3><h2 id="操作系统接口与应用开发"><a href="#操作系统接口与应用开发" class="headerlink" title="操作系统接口与应用开发"></a>操作系统接口与应用开发</h2>]]></content>
    
    
    <summary type="html">Linux操作系统进程运行与监控、操作系统接口与应用开发</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="操作系统" scheme="https://efterklang.github.io/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux" scheme="https://efterklang.github.io/tags/Linux/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Tomcat</title>
    <link href="https://efterklang.github.io/Dev/Java/Web/Tomcat/"/>
    <id>https://efterklang.github.io/Dev/Java/Web/Tomcat/</id>
    <published>2024-06-08T12:59:14.000Z</published>
    <updated>2024-06-11T09:41:35.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Apache-Tomcat-简介"><a href="#Apache-Tomcat-简介" class="headerlink" title="Apache Tomcat 简介"></a>Apache Tomcat 简介</h2><p><strong>Tomcat</strong>对外扮演的角色是 Web 服务器，它接收客户端的请求，将请求转发给 Tomcat 的核心容器进行处理，处理完后再将响应返回给客户端。对内部，Tomcat 扮演 Servlet 容器的角色，负责处理 Servlet 请求。Servlet 是 Java Servlet 的简称，是一种用 Java 编写的服务器端程序，主要用于创建动态网页内容和处理客户端请求。</p><blockquote><p>Apache 本义是一个北美原住民部落的名字。在 19 世纪美洲印第安人战争期间的对抗中，美国陆军发现阿帕奇十分凶猛善战<br><br> <img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/tomcat-2024-06-08-20-42-49.png" style="zoom:40%;"> <br><br>此处 Apache 指的是 Apache Software Foundation (ASF) 是一家美国非营利性公司,成立于 1999 年</p></blockquote><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><ul><li><code>bin</code> 包含启动和停止 Tomcat 服务器所需的脚本文件,<code>.bat</code> for Windows, <code>.sh</code> for Unix&#x2F;Linux</li><li><code>conf</code> Configuration files for the Tomcat server<ul><li>server.xml：定义 Tomcat 服务器的全局设置，包括端口、连接器、引擎、虚拟主机等。</li><li>web.xml：定义所有 Web 应用程序的默认配置，如错误页面、MIME 类型等。</li><li>tomcat-users.xml：包含 Tomcat 用户账号和角色定义，用于管理访问控制。</li><li>context.xml：定义所有 Web 应用的共享默认上下文配置。</li></ul></li><li><code>lib</code> 存放 Tomcat 服务器运行所需的共享库文件（JAR 包）。这些库对所有部署在 Tomcat 上的 Web 应用都可用。</li><li><code>logs</code> 运行日志</li><li><code>webapps</code> 默认的 Web 应用程序部署目录。将 WAR 文件或直接将 Web 应用的文件夹放置于此目录下，Tomcat 会自动部署它们。</li></ul><h3 id="1-2-核心组件"><a href="#1-2-核心组件" class="headerlink" title="1.2 核心组件"></a>1.2 核心组件</h3><ul><li><strong>Catalina</strong>：是 Tomcat 的核心容器，负责处理 Servlet 请求。</li><li><strong>Connector</strong>：连接器，负责接收客户端请求并将其转发给 Catalina 进行处理，处理完后再将响应返回客户端。</li><li><strong>Engine</strong>、<strong>Host</strong>、<strong>Context</strong>：构成层次化的 Web 应用部署结构，分别代表整个引擎、虚拟主机和单个 Web 应用。</li><li><strong>Jasper</strong>：用于编译 JSP 页面为 Servlet。</li></ul><h2 id="部署-Web-应用"><a href="#部署-Web-应用" class="headerlink" title="部署 Web 应用"></a>部署 Web 应用</h2><h3 id="直接部署"><a href="#直接部署" class="headerlink" title="直接部署"></a>直接部署</h3><p>将 Web 应用打包成 WAR 文件或直接放置在<code>webapps</code>目录下，Tomcat 会自动部署。</p><h3 id="配置文件部署"><a href="#配置文件部署" class="headerlink" title="配置文件部署"></a>配置文件部署</h3><p>通过修改<code>server.xml</code>或在<code>conf/Catalina/localhost</code>下创建对应的<code>.xml</code>文件来配置更复杂的部署需求。</p><h2 id="Tomcat-管理"><a href="#Tomcat-管理" class="headerlink" title="Tomcat 管理"></a>Tomcat 管理</h2><h3 id="管理界面"><a href="#管理界面" class="headerlink" title="管理界面"></a>管理界面</h3><p>默认情况下，Tomcat 提供了管理界面，可通过<code>http://localhost:8080/manager/html</code>访问。需要在<code>tomcat-users.xml</code>中配置管理员用户。</p><h3 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h3><p>确保禁用或保护管理界面，修改默认端口，强化用户权限管理，定期更新以修复安全漏洞。</p><h2 id="五、性能优化与监控"><a href="#五、性能优化与监控" class="headerlink" title="五、性能优化与监控"></a>五、性能优化与监控</h2><h3 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h3><p>调整 JVM 参数，如堆内存大小(-Xms, -Xmx)，垃圾收集策略等，以提高性能。</p><h3 id="连接器优化"><a href="#连接器优化" class="headerlink" title="连接器优化"></a>连接器优化</h3><p>调整连接器参数，如最大线程数(maxThreads)、接受缓冲区大小(acceptCount)等。</p><h3 id="监控工具"><a href="#监控工具" class="headerlink" title="监控工具"></a>监控工具</h3><p>利用 Tomcat 自带的管理工具、JMX 或第三方工具如 VisualVM、JProfiler 监控系统状态。</p><h2 id="进阶话题"><a href="#进阶话题" class="headerlink" title="进阶话题"></a>进阶话题</h2><h3 id="Clustering-与-Session-复制"><a href="#Clustering-与-Session-复制" class="headerlink" title="Clustering 与 Session 复制"></a>Clustering 与 Session 复制</h3><p>为了实现高可用和负载均衡，Tomcat 支持集群配置，通过 Session 复制或分布式缓存共享会话信息。</p><h3 id="SSL-配置"><a href="#SSL-配置" class="headerlink" title="SSL 配置"></a>SSL 配置</h3><p>为 Web 应用启用 HTTPS，保护数据传输安全。需配置 SSL 证书并调整连接器设置。</p><h3 id="AJP-连接器与反向代理"><a href="#AJP-连接器与反向代理" class="headerlink" title="AJP 连接器与反向代理"></a>AJP 连接器与反向代理</h3><p>与 Apache HTTP Server 集成，通过 AJP 协议提高静态资源处理效率和安全性。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Tomcat 作为 Java Web 开发的基石，其灵活性和可扩展性使其成为开发者手中的利器。无论是初学者还是资深工程师，深入理解 Tomcat 的工作原理和最佳实践都将大大提升开发效率和应用性能。随着技术的不断演进，持续学习 Tomcat 的新特性和优化技巧是每个 Java Web 开发者不可或缺的任务。希望本文能为您的 Tomcat 学习之旅提供一份有价值的指南。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://en.wikipedia.org/wiki/The_Apache_Software_Foundation">wiki-The_Apache_Software_Foundation</a></p>]]></content>
    
    
    <summary type="html">Apache Tomcat，简称 Tomcat，是一个开源的、轻量级的 Web 应用服务器，它实现了 Java Servlet、JavaServer Pages（JSP）和 Java Expression Language（EL）等技术规范。Tomcat 以其简单易用、资源占用少的特点，成为了开发和部署 Java Web 应用程序的首选平台之一。本文旨在为初学者提供 Tomcat 的基本概念，同时为进阶学习者深入剖析其高级特性与优化技巧。</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Java" scheme="https://efterklang.github.io/categories/Dev/Java/"/>
    
    
    <category term="Java" scheme="https://efterklang.github.io/tags/Java/"/>
    
    <category term="Web" scheme="https://efterklang.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>应用层 ApplicationLayer Part Ⅰ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-1ApplicationLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-1ApplicationLayer/</id>
    <published>2024-06-07T12:34:19.000Z</published>
    <updated>2024-06-12T09:23:34.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Principles-of-Network-Applications"><a href="#Principles-of-Network-Applications" class="headerlink" title="Principles of Network Applications"></a>Principles of Network Applications</h2><h3 id="Network-application-architecture"><a href="#Network-application-architecture" class="headerlink" title="Network application architecture"></a>Network application architecture</h3><p><strong>应用程序体系结构（application architecture）</strong>由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。现代网络应用程序中所使用的两种主流体系结构：<strong>the client-server architecture 和 the peer-to-peer (P2P) architecture.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-18-49-55.png"></p><h4 id="Client-Server-Architecture"><a href="#Client-Server-Architecture" class="headerlink" title="Client-Server Architecture"></a>Client-Server Architecture</h4><ul><li><p>Server</p><ul><li>总是在线（always on host）；</li><li>永久的 IP 地址（permanent IP address）；</li><li>配置在数据中心（often in data centers）；</li></ul></li><li><p>Client</p><ul><li>与服务器沟通联系；</li><li>被间歇性（intermittently）的连接；</li><li>拥有动态地址；</li><li>客户之间不直接联系；</li></ul></li></ul><h4 id="P2P-Architecture"><a href="#P2P-Architecture" class="headerlink" title="P2P Architecture"></a>P2P Architecture</h4><ul><li>没有总是打开的服务器</li><li>任意一对主机(peer)直接相互通信</li><li>对等方间歇连接并且可以改变 IP 地址</li><li>自我可扩展性 self-scalability</li></ul><blockquote><p>P2P (Peer-to-Peer) 网络的自我可扩展性（self-scalability）是指网络的能力，随着参与节点数量的增加，其性能和效率不会显著下降，甚至可能会提高。这种特性是由 P2P 网络的分散性和去中心化特性赋予的。<br>在许多传统的客户端-服务器模型中，所有的请求都会集中到一台或几台服务器上，随着用户数量的增加，服务器可能会遭受过载，导致性能下降。然而，在 P2P 网络中，每个节点都可以成为数据的提供者和消费者，因此负载可以在所有的节点上进行分布，使得网络能够更好地扩展。<br>然而，这并不意味着 P2P 网络没有扩展性问题。例如，当网络规模变得非常大时，查找和路由可能会变得复杂和昂贵。因此，需要使用高效的查找和路由算法，例如分布式哈希表（DHT），来确保网络的可扩展性。</p></blockquote><h4 id="C-S-与-P2P-混合的体系结构"><a href="#C-S-与-P2P-混合的体系结构" class="headerlink" title="C&#x2F;S 与 P2P 混合的体系结构"></a>C&#x2F;S 与 P2P 混合的体系结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-19-44-10.png"></p><h3 id="Processes-Communicating"><a href="#Processes-Communicating" class="headerlink" title="Processes Communicating"></a>Processes Communicating</h3><h4 id="Client-And-Server-Process"><a href="#Client-And-Server-Process" class="headerlink" title="Client And Server Process"></a>Client And Server Process</h4><ul><li>进程：运行在端系统中的程序[<a href="../OS/ProcessvsThread.md" title="Process &amp; Thread">ProcessVsThread#Definition</a>]</li><li>同一主机上的两个进程通过内部进程通信机制进行通信</li><li>不同主机上的进程通过交换报文(message)相互通信</li></ul><blockquote><p><strong>客户进程</strong>：发起通信的进程；<br><strong>服务进程</strong>：在会话开始时等待联系的进程；</p></blockquote><h4 id="The-Interface-Between-the-Process-and-the-Computer-Network"><a href="#The-Interface-Between-the-Process-and-the-Computer-Network" class="headerlink" title="The Interface Between the Process and the Computer Network"></a>The Interface Between the Process and the Computer Network</h4><p>大多数应用程序由许多<strong>互相通信的进程对</strong>(pairs of communicating processes)组成,任何两个进程之间发送的报文都需要经由底层的网络;<strong>套接字 Socket</strong>作为软件接口,向进程提供发送和接受报文功能</p><p>由于该套接字是建立网络应用的可编程接口，因此套接字被称为应用程序和网络之间的<strong>应用程序编程接口（Application Programming Interface，API）</strong>。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-20-09-22.png"></p><h4 id="Addressing-Processes"><a href="#Addressing-Processes" class="headerlink" title="Addressing Processes"></a>Addressing Processes</h4><ul><li><strong>IP Address</strong> 用于唯一标识 Internet 上的主机</li><li><strong>Port</strong> 用于标识目的主机的接受进程</li></ul><blockquote><p>发送进程还必须识别在主机中运行的接收进程（更具体地说，是接收信息的 Socket）。这个信息是必要的，因为通常一个主机可能运行着许多网络应用。目标端口号就是为了这个目的而设立的。一些流行的应用已经被分配了特定的端口号。例如，Web 服务器被标识为 80 号端口。邮件服务器进程（使用 SMTP 协议）被标识为 25 号端口。</p></blockquote><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-20-15-36.png" style="zoom:50%;" /></center><h3 id="Transport-Services-Available-to-Applications"><a href="#Transport-Services-Available-to-Applications" class="headerlink" title="Transport Services Available to Applications"></a>Transport Services Available to Applications</h3><ol><li><p><strong>Reliable Data Transfer</strong></p><ul><li>一些应用需要 100%可靠数据传输,如金融应用</li><li>loss-tolerant applications 允许丢包(loss),常见的有多媒体应用,如视频通话等</li></ul></li><li><p><strong>Throughout</strong></p><ul><li>具有吞吐量要求是应用程序被称为带宽敏感的应用（bandwidth-sensitive application）；</li><li>弹性应用（elastic application）能够根据当时可用的带宽或多或少地利用可供使用的吞吐量；</li></ul></li><li><p><strong>Timing</strong></p><ul><li>低延时（low delay）要求；</li></ul></li><li><p><strong>Security</strong></p><ul><li>传输数据的 Cryption&amp;Decryption</li><li>Confidentiality(保密性)<ul><li>数据完整性 Data Integrity</li><li>终端验证 end-point authentication</li></ul></li></ul><table><thead><tr><th>Application</th><th>Data Loss</th><th>Throughtput</th><th>Time-Senstive</th></tr></thead><tbody><tr><td>文件传输</td><td>No loss</td><td>elastic</td><td>no</td></tr><tr><td>电子邮件</td><td>No loss</td><td>elastic</td><td>no</td></tr><tr><td>Web</td><td>No loss</td><td>elastic</td><td>no</td></tr><tr><td>实时音频&#x2F;视频</td><td>Loss-tolernet</td><td>音频: 几 kbps-1Mbps</td><td>yes,100 msec</td></tr><tr><td>存储音频&#x2F;视频</td><td>Loss-tolernet</td><td>视频:10kbps-5Mbps</td><td>yes, 几秒</td></tr><tr><td>交互式游戏</td><td>Loss-tolernet</td><td>视频:10kbps-5Mbps</td><td>yesy, 100 msec</td></tr><tr><td>即时讯息</td><td>No loss</td><td>几 kbps 以上 elastic</td><td>yes and no</td></tr></tbody></table></li></ol><h3 id="Transport-Services-Provided-by-the-Internet"><a href="#Transport-Services-Provided-by-the-Internet" class="headerlink" title="Transport Services Provided by the Internet"></a>Transport Services Provided by the Internet</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-23-27-14.png"></p><ol><li><p><strong>TCP 服务</strong></p><ul><li><p>面向连接的服务（connection-oriented）：报文开始流动之前，TCP 让客户和服务器互相交换运输层控制信息（握手阶段），握手阶段后，一条 TCP 连接（TCP connection）就在两条进程的套接字之间建立；</p></li><li><p>可靠的数据传送服务（reliable transport）：无差别、按适当顺序交付所有发送的数据；</p></li><li><p>拥塞控制机制（congestion control）</p></li><li><p>安全套接字层（Secure Sockets Layer，SSL）提供了关键的进程到进程的安全性服务<br>🚥<code>http + SSL = https</code></p> <center> <img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-23-01-46.png" style="zoom:50%;" /> </center></li></ul></li><li><p><strong>UDP 服务</strong></p><ul><li>无连接</li><li>尽最大努力交付</li><li>面向报文</li><li>无拥塞控制</li><li>支持一对一，一对多，多对一和多对多的交互通信</li><li>首部开销小</li></ul></li></ol><h3 id="Application-Layer-Protocols"><a href="#Application-Layer-Protocols" class="headerlink" title="Application Layer Protocols"></a>Application Layer Protocols</h3><p>**应用层协议(Application Layer Protocols)**定义了在不同端系统上运行的应用程序进程如何相互传递消息。具体来说，应用层协议定义了：</p><ul><li>交换的消息类型，例如，请求消息和响应消息</li><li>报文类型的语法：报文中的各个字段及其详细描述</li><li>字段的语义，即包含在字段中的信息的含义</li><li>进程何时、如何发送报文及对报文进行响应</li></ul><p>应用层协议根据其是否公开可供所有人使用，可以分为两种类型：公共领域协议和专用协议:</p><ul><li><strong>公共领域协议</strong>:由 RFC 文档定义,可供所有人使用,例如 HTTP,SMTP,POP3</li><li><strong>专用协议</strong>:由公司或组织定义,例如 Skype, KaZaA</li></ul><blockquote><p>RFC，全称是 Request for Comments（征求意见书），是由互联网工程任务组（IETF）出版的一系列备忘录，用于描述、规定或者建议互联网标准、协议、程序、或者概念。RFC 文档是互联网技术和协议的主要来源，包括了诸如 TCP&#x2F;IP、HTTP、SMTP 等核心互联网协议的规范。<br>RFC 文档的内容可以是互联网社区的共识、工作小组的产品、个人的观点，或者只是为了获取公众的反馈。RFC 文档一旦发布，编号就不再改变，如果需要对 RFC 进行修改或者更新，会以新的 RFC 编号发布。<br>值得注意的是，尽管 RFC 是”征求意见书”的缩写，但是大部分 RFC 文档实际上是互联网标准的官方规范，而不仅仅是征求意见的提案。</p></blockquote><h3 id="Network-Applications"><a href="#Network-Applications" class="headerlink" title="Network Applications"></a>Network Applications</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-18-20-57.png"></p><h2 id="The-Web-and-HTTP"><a href="#The-Web-and-HTTP" class="headerlink" title="The Web and HTTP"></a>The Web and HTTP</h2><h3 id="Overview-of-HTTP"><a href="#Overview-of-HTTP" class="headerlink" title="Overview of HTTP"></a>Overview of HTTP</h3><ul><li><strong>网页 WebPage，或称 Document</strong>由许多<strong>对象 Object</strong>组成。</li><li>对象就是文件，可以是 HTML 文件, JPEG 图像, Java applet, 音频文件…</li><li>多数网页由单个<strong>基本 HTML 文件 base HTML</strong>和若干个所引用的对象构成</li><li>每个对象被一个 <strong>统一资源定位符 URL Uniform Resource Locator</strong>寻址</li><li><strong>Web 浏览器（Web browser）</strong>实现了 HTTP 的客户端；<strong>Web 服务器（Web server）</strong>实现了 HTTP 的服务器端；</li><li>HTTP 使用 TCP 作为运输协议；</li><li>HTTP 超文本传输协议（HyperText Transfer Protocol）</li><li>因为 HTTP 服务器不维护客户先前的状态信息， 是无状态协议（stateless protocol）；</li></ul><blockquote><p>维护状态的协议非常复杂</p><ul><li><p>必须维护过去历史 (状态信息)</p></li><li><p>如果 server&#x2F;client 崩溃, 它们各自的状态视图可能不一致, 因此必须保持协调一致。</p></li></ul></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.someschool.edu/someDept/pic.gif</span><br><span class="line">👆🏻协议      👆🏻主机名         👆🏻路径名</span><br></pre></td></tr></table></figure><h3 id="Non-Persistent-and-Persistent-Connections"><a href="#Non-Persistent-and-Persistent-Connections" class="headerlink" title="Non-Persistent and Persistent Connections"></a>Non-Persistent and Persistent Connections</h3><p><strong>非持久 HTTP 连接</strong></p><ul><li>每个 TCP 连接上只传送一个对象，下载多个对象需要建立多个 TCP 连接</li><li>HTTP&#x2F;1.0 使用非持久 HTTP 连接</li></ul><p><strong>持久 HTTP 连接</strong></p><ul><li>一个 TCP 连接上可以传送多个对象</li><li>HTTP&#x2F;1.1 默认使用持久 HTTP 连接</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-01-03.png"></p><blockquote><p><strong>往返时间（Round-Trip Time，RTT）</strong>定义：该时间是指一个短分组从客户到服务器然后在返回客户所需要的时间；[<a href="Ch1-NetworkOverview.md" title="Computer Networks Overview">Ch1-NetworkOverview#往返时间 Round Trip Time</a>]</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-02-41.png" style="zoom:50%;" /></center></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-35-15.png"></p><h3 id="HTTP-Message-Format"><a href="#HTTP-Message-Format" class="headerlink" title="HTTP Message Format"></a>HTTP Message Format</h3><p>终端输入<code>curl -v &quot;https://baidu.com&quot;</code>或使用 wireshark 等抓包工具可以</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> curl -v &quot;https://baidu.com&quot;</span><br><span class="line">* Host baidu.com:443 was resolved.</span><br><span class="line">* IPv6: (none)</span><br><span class="line">* IPv4: 110.242.68.66, 39.156.66.10</span><br><span class="line">*   Trying 110.242.68.66:443...</span><br><span class="line">* Connected to baidu.com (110.242.68.66) port 443</span><br><span class="line">* schannel: disabled automatic use of client certificate</span><br><span class="line">* ALPN: curl offers http/1.1</span><br><span class="line">* ALPN: server accepted http/1.1</span><br><span class="line">* using HTTP/1.x</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl/8.6.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 302 Moved Temporarily</span><br><span class="line">&lt; Server: bfe/1.0.8.18</span><br><span class="line">&lt; Date: Wed, 27 Mar 2024 07:08:02 GMT</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Content-Length: 161</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Location: http://www.baidu.com/</span><br><span class="line">&lt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;bfe/1.0.8.18&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Connection #0 to host baidu.com left intact</span><br></pre></td></tr></table></figure><h4 id="HTTP-Request-Message"><a href="#HTTP-Request-Message" class="headerlink" title="HTTP Request Message"></a>HTTP Request Message</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/somedir/page.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.someschool.edu</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">User-agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept-language</span><span class="punctuation">: </span>fr</span><br></pre></td></tr></table></figure><ul><li><strong>请求行 request line</strong>请求报文的第一行,其有 3 个字段：方法字段、URL 字段和 HTTP 版本字段；<ul><li>方法包含<code>GET,POST,HEAD,PUT,DELETE</code>；</li></ul></li><li><strong>首部行 header line</strong> 请求行后继的行叫作</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-57-34.png" alt="Request"></p><h4 id="HTTP-Response-Message"><a href="#HTTP-Response-Message" class="headerlink" title="HTTP Response Message"></a>HTTP Response Message</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">Connection：close</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sat, 06 Aug 2011 12:00:15 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/1.3.0 (Unix)</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Thu, 22 Jun 2011 …...</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>6821</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-haskell"><span class="class"><span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> ...</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong>状态行 status line</strong>响应报文的第一行,其有 3 个字段：HTTP 版本字段、状态码字段和状态码短语字段；</p></li><li><p><strong>首部行 header line</strong> 响应行后继的行叫作</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-17-21-22.png"></p></li></ul><blockquote><p><strong>HTTP 状态码</strong><br>1xx （信息性状态码）：表示服务器已经接收到请求，正在处理。</p><ul><li>100 Continue: 服务器已收到请求的初始部分，客户端应继续发送其余部分。</li><li>101 Switching Protocols: 服务器已经理解客户端的请求，并将切换到更适合的协议进行通信。</li></ul><hr><p>2xx （成功状态码）：表示请求已成功处理。</p><ul><li>200 OK: 请求成功，返回所请求的内容。</li><li>201 Created: 请求成功，并在服务器上创建了一个新的资源。</li><li>202 Accepted: 请求已被接受，但尚未处理完成。</li><li>204 No Content: 请求成功，但服务器没有返回任何内容。</li></ul><hr><p>3xx （重定向状态码）：表示需要进一步操作以完成请求。</p><ul><li>301 Moved Permanently: 被请求的资源已永久移动到新位置，并且将来的请求应使用新的 URL。</li><li>302 Found: 被请求的资源暂时移动到了新位置。</li><li>304 Not Modified: 资源未被修改，可以直接使用缓存的版本。</li></ul><hr><p>4xx （客户端错误状态码）：表示客户端发送了错误的请求。</p><ul><li>400 Bad Request: 客户端发送的请求语法错误。</li><li>401 Unauthorized: 请求需要身份验证。</li><li>403 Forbidden: 服务器拒绝了请求，客户端没有权限访问请求的资源。</li><li>404 Not Found: 请求的资源在服务器上未找到。</li></ul><hr><p>5xx （服务器错误状态码）：表示服务器在处理请求时发生了错误。</p><ul><li>500 Internal Server Error: 服务器在执行请求时遇到了未知的错误。</li><li>502 Bad Gateway: 作为代理或网关的服务器收到无效的响应。</li><li>503 Service Unavailable: 服务器暂时无法处理请求，通常是由于过载或维护。</li></ul></blockquote><h3 id="User-Server-Interaction-Cookies"><a href="#User-Server-Interaction-Cookies" class="headerlink" title="User-Server Interaction: Cookies"></a>User-Server Interaction: Cookies</h3><p>前面提到 HTTP 服务器为无状态的，而一个 Web 站点通常希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来。为此，HTTP 使用了 cookie(最初被称作 magic cookie)🍪<br><a href="https://en.wikipedia.org/wiki/Magic_cookie">Magic_cookie</a></p><p>cookie technology has four components:</p><ol><li>a cookie header line in the HTTP response message;</li><li>a cookie header line in the HTTP request message;</li><li>a cookie file kept on the user’s end system and managed by the user’s browser</li><li>a back-end database at the Web site.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-17-30-02.png"></p><p><strong>Cookies 跟踪用户</strong><br>cookies 允许网站更加了解你<br>你可以提供名字和 e-mail 给网站<br>广告公司通过网站获得信息<br>Cookies 不适合游动用户<br><strong>Cookie 可用于：</strong><br>跟踪用户在给定网站上的行为（第一方 cookie）<br>在多个网站上跟踪用户行为（第三方 cookie），而无需用户选择访问跟踪器网站！<br>跟踪可能对用户不可见：可能是一个不可见的链接<br>通过 Cookie 进行的第三方跟踪：在 Firefox、Safari 浏览器中默认禁用，将于 2023 年在 Chrome 浏览器中禁用</p><h3 id="Web-Caching-proxy-server"><a href="#Web-Caching-proxy-server" class="headerlink" title="Web Caching(proxy server)"></a>Web Caching(proxy server)</h3><p><strong>Web 缓存器 Web cache,也称代理服务器 proxy server</strong>，设计它的目标是代表<strong>初始 Web 服务器（origin server）</strong>满足 HTTP 请求;一般的，Web 缓存器既是服务器又是客户机,典型的缓存器由 ISP 提供（大学、公司或居民 ISP）;引入 Weh 缓存器减少了对客户机请求的响应时间,内部网络与接入链路上的通信量,并从整体上大大降低因特网上的 Web 流量</p><blockquote><p>如图,加入 cache 后,客户端请求的对象可能在缓存器中(称作缓存命中),缓存器直接返回给客户端;图中接入链路(access link)的速率为 15Mbps,远低于局域网的网络速率,$total delay &#x3D; LAN delay + access dalay + Internet delay$,可见接入时延为该例中提升传播速率的瓶颈;可选择更快的接入链路,但这需要更多的费用;而缓存器可以减少接入链路上的流量,从而减少接入时延,同时费用相对较低</p><p>LAN delay: 在局域网中传输一个报文所需的时间<br>Access delay: 在两个路由器之间传输一个报文所需的时间<br>Internet delay: 在因特网中传输一个报文所需的时间<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-18-50-25.png" style="zoom:50%;" /></p></blockquote><p><strong>Request Steps:</strong></p><ol><li>浏览器创建一个到 Web 缓存器的 TCP 连接，并向 Web 缓存器中的对象发送一个 HTTP 请求；</li><li>Web 缓存器进行检查，看看本地是否存储该对象副本。如果有，Web 缓存器向客户返回该对象；</li><li>如果缓存器中没有该对象，它就打开一个与该对象的初始服务器的 TCP 连接。Web 缓存器向初始服务器发送请求，并得到初始服务器的响应；</li><li>当 Web 缓存器接受对象后，在本地创建给对象的副本，并向客户发送响应报文返回该对象；<br>通过使用<strong>内容分发网络（Content Distribution Network，CDN）</strong>，Web 缓存器正在因特网中发挥着越来越重要的作用。[<a href="Ch6-2ApplicationLayer.md" title="应用层 ApplicationLayer Part Ⅱ">Ch6-2ApplicationLayer#Content Distribution Networks</a>]<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-17-35-49.png"></li></ol><p>尽管高速缓存器能减少用户感受到的响应时间，但引入了一个新的问题，即存放在缓存器中的副本可能陈旧的。为验证缓存器中的副本是否仍然有效，你可以使用<strong>条件 GET 请求</strong>,参照如下 python 代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义报文内容和首部</span></span><br><span class="line">request = <span class="string">&quot;GET /index.html HTTP/1.1\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;Host: www.baidu.com\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;If-Modified-Since: Sat, 01 Jan 2022 00:00:00 GMT\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;Connection: close\r\n\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建套接字并连接目标服务器</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送报文</span></span><br><span class="line">s.send(request.encode())</span><br><span class="line"></span><br><span class="line">response = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = s.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    response += data</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.decode())</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line">[OUTPUT]</span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Accept-Ranges: <span class="built_in">bytes</span></span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Length: <span class="number">9508</span></span><br><span class="line">Content-<span class="type">Type</span>: text/html</span><br><span class="line">Date: Fri, <span class="number">29</span> Mar <span class="number">2024</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">29</span> GMT</span><br><span class="line">P3p: CP=<span class="string">&quot; OTI DSP COR IVA OUR IND COM &quot;</span></span><br><span class="line">P3p: CP=<span class="string">&quot; OTI DSP COR IVA OUR IND COM &quot;</span></span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: BWS/<span class="number">1.1</span></span><br><span class="line"><span class="type">Set</span>-Cookie: BAIDUID=E79C6BEF6A7F8AA35FBC1FD6742520D8:FG=<span class="number">1</span>; expires=Thu, <span class="number">31</span>-Dec-<span class="number">37</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">55</span> GMT; <span class="built_in">max</span>-age=<span class="number">2147483647</span>; path=/; domain=.baidu.com</span><br><span class="line"><span class="type">Set</span>-Cookie: BIDUPSID=E79C6BEF6A7F8AA35FBC1FD6742520D8; expires=Thu, <span class="number">31</span>-Dec-<span class="number">37</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">55</span> GMT; <span class="built_in">max</span>-age=<span class="number">2147483647</span>; path=/; domain=.baidu.com</span><br><span class="line"><span class="type">Set</span>-Cookie: PSTM=<span class="number">1711717229</span>; expires=Thu, <span class="number">31</span>-Dec-<span class="number">37</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">55</span> GMT; <span class="built_in">max</span>-age=<span class="number">2147483647</span>; path=/; domain=.baidu.com</span><br><span class="line"><span class="type">Set</span>-Cookie: BAIDUID=E79C6BEF6A7F8AA30F2B2E6688EB66DE:FG=<span class="number">1</span>; <span class="built_in">max</span>-age=<span class="number">31536000</span>; expires=Sat, <span class="number">29</span>-Mar-<span class="number">25</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">29</span> GMT; domain=.baidu.com; path=/; version=<span class="number">1</span>; comment=bd</span><br><span class="line">Traceid: <span class="number">1711717229235279668210477533425964763324</span></span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=<span class="number">1</span></span><br><span class="line">X-Xss-Protection: <span class="number">1</span>;mode=block</span><br><span class="line">Connection: close</span><br><span class="line"><span class="comment"># html file</span></span><br><span class="line">data data ... data</span><br></pre></td></tr></table></figure><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>HTTP1.1：</p><ul><li>在单个 TCP 连接上引入了多个流水线 GET</li><li>服务器按顺序响应 GET 请求（FCFS: first-come-first-served scheduling）</li><li>对于 FCFS，小对象可能必须在大对象后面等待传输 head-of-line(HOL)blocking, 线头阻塞 HOL</li><li>丢失恢复（重新传输丢失的 TCP 段）对对象传输时间的影响</li></ul><p>HTTP&#x2F;2:[RFC 7540，2015]</p><ul><li>增加了服务器向客户端发送对象的灵活性</li><li>方法、状态代码、大多数头字段与 HTTP1.1 相比没有变化</li><li>基于客户端指定的对象优先级的请求对象的传输顺序（不一定是 FCFS）</li><li>将未请求的对象推送到客户端</li><li>将对象划分为帧 frames 以减少 HOL 阻塞<blockquote><p><a href="https://www.jianshu.com/p/63fe1bf5d445">详细分析 http2 和 http1.1 区别</a></p></blockquote></li></ul><p>HTTP&#x2F;3：通过 UDP 增加了安全性、每个对象的错误和拥塞控制（更多的流水线操作）</p><h2 id="Electronic-Mail-in-the-Internet"><a href="#Electronic-Mail-in-the-Internet" class="headerlink" title="Electronic Mail in the Internet"></a>Electronic Mail in the Internet</h2><p>邮箱系统的 3 个主要组成部分:</p><ul><li><strong>用户代理 user agents</strong><ul><li>允许用户阅读,回复,转发,保存,编辑邮件；</li><li>服务器上存储的传入和传出的消息；</li><li>例如：Outlook, foxmail 等</li></ul></li><li><strong>邮件服务器 mail servers</strong><ul><li>邮箱（mailbox）包括用户传入的消息；</li><li>报文队列（message queue）中为待发送的邮件报文；</li></ul></li><li><strong>简单邮件传送协议 SMTP</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-28-09-35-41.png"></li></ul><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><h4 id="SMTP-服务概述"><a href="#SMTP-服务概述" class="headerlink" title="SMTP 服务概述"></a>SMTP 服务概述</h4><p>SMTP（Simple Mail Transfer Protocol）是一种用于电子邮件传输的标准协议。它定义了电子邮件客户端（如邮件程序）和邮件服务器之间的通信规则，以便可靠地将邮件从发送方传递到接收方。</p><ul><li>SMTP 使用持久连接</li><li>SMTP 要求邮件消息(header &amp; body)必须是 7-bit ASCII</li><li>SMTP 服务器使用 CRLF.CRLF 来判断邮件消息的结束</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-28-09-59-42.png"></p><ul><li><strong>用户代理与发送服务器的连接</strong>：用户代理（例如电子邮件客户端）使用 SMTP 协议与发送服务器建立连接。连接过程包括身份验证和协议握手等步骤。<br>用户代理提交邮件：<br>用户代理将邮件发送到发送服务器。邮件的内容、收件人、发件人等信息被打包成一个 SMTP 消息。</li><li><strong>发送服务器的邮件传递</strong>：发送服务器接收到用户代理提交的邮件后，开始根据收件人的电子邮件地址确定邮件的路由。它可能会通过 DNS 查找 MX 记录来找到目标邮件服务器，并将邮件转发给目标邮件服务器。</li><li><strong>目标邮件服务器的接收与存储</strong>：目标邮件服务器接收到邮件后将其存储，并等待用户代理或接收器以后续协议（如 POP3 或 IMAP）请求获取邮件。</li><li><strong>用户代理收取邮件</strong>：用户代理使用 POP3 或 IMAP 协议从接收服务器上下载邮件，并将邮件显示在用户界面上供用户查看和管理。</li></ul><h4 id="SMAP-与-HTTP-的区别"><a href="#SMAP-与-HTTP-的区别" class="headerlink" title="SMAP 与 HTTP 的区别"></a>SMAP 与 HTTP 的区别</h4><table><thead><tr><th>特性</th><th>SMTP</th><th>HTTP</th></tr></thead><tbody><tr><td>协议类型</td><td>推协议 push protocol</td><td>拉协议 pull protocol</td></tr><tr><td>数据编码</td><td>要求采用 7 比特 ASCII 码格式</td><td>不受 7 比特 ASCII 码限制</td></tr><tr><td>消息传递</td><td>发送文件的机器发起 TCP 连接</td><td>接收文件的机器发起 TCP 连接</td></tr><tr><td>报文封装</td><td>所有报文对象放在一个报文中</td><td>每个对象封装在不同的 HTTP 响应报文中</td></tr></tbody></table><h3 id="Mail-Message-Format"><a href="#Mail-Message-Format" class="headerlink" title="Mail Message Format"></a>Mail Message Format</h3><p>一般格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To:发件人地址</span><br><span class="line">From:收件人地址</span><br><span class="line">Subject:邮件主题</span><br><span class="line"></span><br><span class="line">...邮件正文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>MIME</strong>: Multipurpose Internet mail Extensions 多用途因特网邮件扩展, RFC 2045, 2046;增添额外的信头头部声明 MIME content-type,实现多媒体邮件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">From: alice@crepes.fr</span><br><span class="line">To: bob@hamburger.edu</span><br><span class="line">Subject: Picture of yummy crepe.</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">base64 encoded data .....</span><br><span class="line">.........................</span><br><span class="line">......base64 encoded data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Mail-Access-Protocols"><a href="#Mail-Access-Protocols" class="headerlink" title="Mail Access Protocols"></a>Mail Access Protocols</h3><p>收件人的用户代理不能使用 SMTP 得到报文，因为取得报文是一个 pull 操作，而 SMTP 协议是一个 push 协议。通过引用一个特殊的邮件访问协议来解决这个问题，该协议将收件人邮件服务器上的报文传送给他的本地<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-28-13-22-24.png"></p><ul><li>SMTP: 递送&#x2F;存储邮件消息到接收者邮件服务器</li><li>邮件访问协议: 从服务器获取邮件消息<ul><li>POP3: Post Office Protocol-Version3 邮局协议[RFC 1939]110 端口号<br>身份认证 (代理 &lt;–&gt;服务器) 并 下载邮件消息</li><li>IMAP: Internet Message Access Protocol [RFC 3501] 143 端口<br>更多功能特征,允许用户像对待本地邮箱那样操纵远程邮箱的邮件</li><li>HTTP: Hotmail , Yahoo! Mail, etc.</li></ul></li></ul><p><strong>POP3 VS IMAP</strong></p><table><thead><tr><th>特性</th><th>POP3</th><th>IMAP</th></tr></thead><tbody><tr><td>邮件存储</td><td>下载邮件至本地客户端</td><td>在服务器上保留邮件副本</td></tr><tr><td>邮件同步</td><td>单设备上的邮件删除操作不会同步更新</td><td>多设备上的邮件操作同步更新</td></tr><tr><td>邮件管理</td><td>仅支持简单的邮件收发操作</td><td>支持复杂的邮件管理功能</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">应用层与互联网冲浪活动息息相关，该部分主要介绍网络应用原理，Web&amp;HTTP相关内容，电子邮箱原理。</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="计算机网络" scheme="https://efterklang.github.io/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://efterklang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://efterklang.github.io/Home/%E8%93%AC%E6%88%B7%E6%89%8B%E5%8D%B7/"/>
    <id>https://efterklang.github.io/Home/%E8%93%AC%E6%88%B7%E6%89%8B%E5%8D%B7/</id>
    <published>2024-06-02T02:42:26.366Z</published>
    <updated>2024-03-28T04:45:18.829Z</updated>
    
    <content type="html"><![CDATA[<style>h2 {    font-family: Microsoft JhengHei;    /* font-family: 楷体; */    color: #426cc2;    /* text-align: center; */    font-style: bold;}</style><div><h2>蓬户掩兮井径荒 青苔满兮履綦绝 园种邵平之瓜 门栽先生之柳 晓起呼童子 问山桃落乎 辛夷开未 手瓮灌花 除虫丝蛛总于时 不巾不履 坐水窗 追凉风 焚好香 烹苦茗 忽见异鸟来鸣树间 小倦即卧 康凉枕一觉  美睡萧然无梦 即梦亦不离竹坪茶坞间 </h2></div>]]></content>
    
    
      
      
    <summary type="html">

&lt;style&gt;
h2 {
    font-family: Microsoft JhengHei;
    /* font-family: 楷体; */
    color: #426cc2;
    /* text-align: center; */
    font-st</summary>
      
    
    
    
    
    <category term="中国古代诗词" scheme="https://efterklang.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BB%A3%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>Scoop</title>
    <link href="https://efterklang.github.io/Dev/Others/Scoop/"/>
    <id>https://efterklang.github.io/Dev/Others/Scoop/</id>
    <published>2024-06-01T05:48:12.000Z</published>
    <updated>2024-06-11T09:41:35.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><blockquote><p>Scoop is an installer<br>The goal of Scoop is to let you use Unix-y programs in a normal Windows environment<br>Mike Zick</p></blockquote><p><a href="https://scoop.sh/#/">Scoop</a>是一个 Windows 的下载工具，可以方便的安装各种软件。</p><h3 id="Directory-Structure"><a href="#Directory-Structure" class="headerlink" title="Directory Structure"></a>Directory Structure</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">┌─  windows                                                                                               <span class="number">0</span>s  RAM <span class="number">12</span>/<span class="number">13</span>GB 󰅐 <span class="number">3</span>:<span class="number">13</span> PM Sat  <span class="number">27</span>°C</span><br><span class="line">└   <span class="built_in">dir</span> D:\envir_vars\scoop\</span><br><span class="line">        Directory: D:\envir_vars\scoop</span><br><span class="line">Mode                LastWriteTime         Length Name</span><br><span class="line"><span class="literal">----</span>                <span class="literal">-------------</span>         <span class="literal">------</span> <span class="literal">----</span></span><br><span class="line">d<span class="literal">----</span>          <span class="number">6</span>/<span class="number">1</span>/<span class="number">2024</span>   <span class="number">3</span>:<span class="number">13</span> PM                󰀻  apps</span><br><span class="line">d<span class="literal">----</span>          <span class="number">6</span>/<span class="number">1</span>/<span class="number">2024</span>   <span class="number">2</span>:<span class="number">48</span> PM                  buckets</span><br><span class="line">d<span class="literal">----</span>          <span class="number">6</span>/<span class="number">1</span>/<span class="number">2024</span>   <span class="number">3</span>:<span class="number">13</span> PM                  cache</span><br><span class="line">d<span class="literal">----</span>          <span class="number">6</span>/<span class="number">1</span>/<span class="number">2024</span>   <span class="number">2</span>:<span class="number">49</span> PM                  persist</span><br><span class="line">d<span class="literal">----</span>          <span class="number">6</span>/<span class="number">1</span>/<span class="number">2024</span>   <span class="number">3</span>:<span class="number">13</span> PM                  shims</span><br></pre></td></tr></table></figure><ul><li><strong>Apps</strong>: 安装的各个软件或程序</li><li><strong>Buckets</strong>: 存放各种 app 的集合,buckets 目录下存放许多个 bucket，例如 main 为默认的 bucket，extras 包括部分未收录 main bucket 的常用软件，nerdfonts 为存放字体 app 的 bucket,每一个 bucket 都是一个 github 仓库，仓库里维护许多 app 的 json 文件，json 文件里存放了 app 的安装信息，包括 app 的版本，LICENSE，下载地址 url etc,这些 json 文件被称作 App manifest，下面是一个简单的示例<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/lukesampson/cowsay-psh/archive/master.zip&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extract_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cowsay-psh-master&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cowsay.ps1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><strong>Cache</strong>: 存放下载的临时文件</li><li><strong>Shims</strong>: scoop 在 environment variable 中添加了该目录;通过 scoop 安装的程序,scoop 会自动为其在 Shims 目录下生成一个对应的 exe 文件，这样程序安装后可以直接在命令行中调用。对于 GUI 程序，scoop 会自动在开始菜单中添加其快捷方式，目录<code>C:\Users\&lt;user&gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Scoop Apps</code></li></ul><h3 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h3><h4 id="Default-Installation"><a href="#Default-Installation" class="headerlink" title="Default Installation"></a>Default Installation</h4><p>在终端中使用 Powershell 执行以下命令即可安装 Scoop。默认把 scoop 安装到 <code>C:\Users\&lt;YOUR USERNAME&gt;\scoop</code> 目录下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> <span class="literal">-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"><span class="built_in">Invoke-RestMethod</span> <span class="literal">-Uri</span> https://get.scoop.sh | <span class="built_in">Invoke-Expression</span></span><br></pre></td></tr></table></figure><h4 id="Advance-Installation。"><a href="#Advance-Installation。" class="headerlink" title="Advance Installation。"></a>Advance Installation。</h4><p>如果希望把 scoop 安装到其它目录，可以执行以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">┌─  windows    D/envir_vars                                                                            0.002s  RAM 12/13GB 󰅐 2:24 PM Sat  26°C</span><br><span class="line">└   irm get.scoop.sh -outfile <span class="string">&#x27;install.ps1&#x27;</span></span><br><span class="line"></span><br><span class="line">┌─  windows    D/envir_vars                                                                            1.137s  RAM 12/13GB 󰅐 2:24 PM Sat  26°C</span><br><span class="line">└   <span class="built_in">ls</span> | grep ps1</span><br><span class="line">-a---          6/1/2024   2:24 PM          25628 󰞷  install.ps1</span><br><span class="line"></span><br><span class="line">┌─  windows    D/envir_vars                                                                            0.092s  RAM 12/13GB 󰅐 2:24 PM Sat  26°C</span><br><span class="line">└   .\install.ps1 -?</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    D:\envir_vars\install.ps1</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    Scoop installer.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SYNTAX</span><br><span class="line">    D:\envir_vars\install.ps1 [[-ScoopDir] &lt;String&gt;] [[-ScoopGlobalDir] &lt;String&gt;] [[-ScoopCacheDir] &lt;String&gt;] [-NoProxy] [[-Proxy] &lt;Uri&gt;]</span><br><span class="line">    [[-ProxyCredential] &lt;PSCredential&gt;] [-ProxyUseDefaultCredentials] [-RunAsAdmin] [&lt;CommonParameters&gt;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    The installer of Scoop. For details please check the website and wiki.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RELATED LINKS</span><br><span class="line">    https://scoop.sh</span><br><span class="line">    https://github.com/ScoopInstaller/Scoop/wiki</span><br><span class="line"></span><br><span class="line">REMARKS</span><br><span class="line">    To see the examples, <span class="built_in">type</span>: <span class="string">&quot;Get-Help D:\envir_vars\install.ps1 -Examples&quot;</span></span><br><span class="line">    For more information, <span class="built_in">type</span>: <span class="string">&quot;Get-Help D:\envir_vars\install.ps1 -Detailed&quot;</span></span><br><span class="line">    For technical information, <span class="built_in">type</span>: <span class="string">&quot;Get-Help D:\envir_vars\install.ps1 -Full&quot;</span></span><br><span class="line">    For online <span class="built_in">help</span>, <span class="built_in">type</span>: <span class="string">&quot;Get-Help D:\envir_vars\install.ps1 -Online&quot;</span></span><br><span class="line"></span><br><span class="line">┌─  windows    D/envir_vars                                                                            0.178s  RAM 11/13GB 󰅐 2:25 PM Sat  26°C</span><br><span class="line">└   .\install.ps1 -ScoopDir <span class="string">&#x27;D:\envir_vars\scoop\&#x27;</span> -ScoopGlobalDir <span class="string">&#x27;D:\envir_vars\scoop\GlobalApps&#x27;</span> -NoProxy</span><br><span class="line">Initializing...</span><br><span class="line">Downloading...</span><br><span class="line">Creating shim...</span><br><span class="line">Adding D:\envir_vars\scoop\\shims to your path.</span><br><span class="line">Scoop was installed successfully!</span><br><span class="line">Type <span class="string">&#x27;scoop help&#x27;</span> <span class="keyword">for</span> instructions.</span><br></pre></td></tr></table></figure><p>如果你已经安装了 Scoop，想要把 scoop 安装到其它目录，可参考<a href="https://github.com/ScoopInstaller/scoop/issues/249">Change Directory</a><br>迁移应用也可以通过<code>scoop export</code>导出 json 然后再通过 import 导入下载,若直接移动源目录下的文件,shims 实际上是无效的,它指向的位置仍然是原先目录</p><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><h3 id="Install-Update-Uninstall"><a href="#Install-Update-Uninstall" class="headerlink" title="Install &amp; Update &amp; Uninstall"></a>Install &amp; Update &amp; Uninstall</h3><ul><li><code>scoop search vim</code> 查找 app</li><li><code>scoop install neovim</code> 安装指定 app</li><li><code>scoop install git@2.23.0.windows.1</code> 安装指定版本 app</li><li><code>scoop install -g git</code> 安装全局 app<br>Install Options:<br>-g, –global Install the app globally<br>-i, –independent Don’t install dependencies automatically<br>-k, –no-cache Don’t use the download cache<br>-u, –no-update-scoop Don’t update Scoop before installing if it’s outdated<br>-s, –skip Skip hash validation (use with caution!)<br>-a, –arch &lt;32bit|64bit&gt; Use the specified architecture, if the app supports it</li></ul><hr><ul><li><code>scoop list</code> List installed apps</li><li><code>scoop status</code> Show status and check for new app versions<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Name      Installed Version Latest Version Missing Dependencies Info</span><br><span class="line">----      ----------------- -------------- -------------------- ----</span><br><span class="line">7zip      23.01             24.05</span><br><span class="line">aria2     1.36.0-1          1.37.0-1</span><br><span class="line">eza       0.18.15           0.18.16</span><br><span class="line">fastfetch 2.11.3            2.14.0</span><br><span class="line">fd        9.0.0             10.1.0</span><br><span class="line">git       2.42.0.2          2.45.1</span><br><span class="line">gitui     0.26.1            0.26.2</span><br><span class="line">kotlin    1.9.22            2.0.0</span><br><span class="line">neovim    0.9.5             0.10.0</span><br></pre></td></tr></table></figure></li><li><code>scoop update</code> update scoop</li><li><code>scoop update neovim 7zip aria2</code> 更新指定软件</li><li><code>scoop update *</code> 更新所有软件</li></ul><hr><ul><li><code>scoop uninstall neovim</code> 卸载指定软件</li><li><code>scoop uninstall -p python</code> 卸载软件及其配置文件</li><li><code>scoop uninstall -g git</code> 卸载全局软件</li></ul><h3 id="Clean"><a href="#Clean" class="headerlink" title="Clean"></a>Clean</h3><ul><li><code>scoop cleanup git</code> 清理指定软件</li><li><code>scoop cleanup *</code> 清理所有软件</li><li><code>scoop cache rm *</code> 清理缓存</li></ul><h3 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h3><p>在同一程序的不同版本之间切换</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scoop reset python@<span class="number">3.10</span>.<span class="number">6</span></span><br><span class="line"><span class="comment"># do something</span></span><br><span class="line">scoop reset python@<span class="number">3.12</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure><ul><li><code>alias</code> Manage scoop aliases</li><li><code>bucket</code> Manage Scoop buckets</li><li><code>cache</code> Show or clear the download cache</li><li><code>cat</code> Show content of specified manifest.</li><li><code>checkup</code> Check for potential problems</li><li><code>create</code> Create a custom app manifest</li><li><code>depends</code> List dependencies for an app, in the order they’ll be installed</li><li><code>download</code> Download apps in the cache folder and verify hashes</li><li><code>export</code> Exports installed apps, buckets (and optionally configs) in JSON format</li><li><code>help</code> Show help for a command</li><li><code>hold</code> Hold an app to disable updates</li><li><code>home</code> Opens the app homepage</li><li><code>import</code> Imports apps, buckets and configs from a Scoopfile in JSON format</li><li><code>info</code> Display information about an app</li><li><code>prefix</code> Returns the path to the specified app</li><li><code>shim</code> Manipulate Scoop shims</li><li><code>unhold</code> Unhold an app to enable updates</li><li><code>virustotal</code> Look for app’s hash or url on virustotal.com</li><li><code>which</code> Locate a shim&#x2F;executable (similar to ‘which’ on Linux)</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://github.com/ScoopInstaller/Scoop/wiki">Scoop_Wiki</a></p>]]></content>
    
    
    <summary type="html">Scoop —— A command-line installer for Windows.</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Others" scheme="https://efterklang.github.io/categories/Dev/Others/"/>
    
    
    <category term="Productivity" scheme="https://efterklang.github.io/tags/Productivity/"/>
    
  </entry>
  
  <entry>
    <title>WSL迁移至其它盘符</title>
    <link href="https://efterklang.github.io/Dev/Linux/WSL/"/>
    <id>https://efterklang.github.io/Dev/Linux/WSL/</id>
    <published>2024-05-31T09:38:59.000Z</published>
    <updated>2024-05-31T10:23:23.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WSL-Migration-Manual"><a href="#WSL-Migration-Manual" class="headerlink" title="WSL Migration Manual :"></a>WSL Migration Manual :</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Usage: wsl.exe [Argument] [Options...] [CommandLine]</span><br><span class="line">Arguments <span class="keyword">for</span> managing distributions <span class="keyword">in</span> Windows Subsystem <span class="keyword">for</span> Linux:</span><br><span class="line"></span><br><span class="line">    --<span class="built_in">export</span> &lt;Distro&gt; &lt;FileName&gt; [Options]</span><br><span class="line">        Exports the distribution to a tar file.</span><br><span class="line">        The filename can be - <span class="keyword">for</span> stdout.</span><br><span class="line"></span><br><span class="line">        Options:</span><br><span class="line">            --vhd</span><br><span class="line">                Specifies that the distribution should be exported as a .vhdx file.</span><br><span class="line"></span><br><span class="line">    --import &lt;Distro&gt; &lt;InstallLocation&gt; &lt;FileName&gt; [Options]</span><br><span class="line">        Imports the specified tar file as a new distribution.</span><br><span class="line">        The filename can be - <span class="keyword">for</span> stdin.</span><br><span class="line"></span><br><span class="line">        Options:</span><br><span class="line">            --version &lt;Version&gt;</span><br><span class="line">                Specifies the version to use <span class="keyword">for</span> the new distribution.</span><br><span class="line"></span><br><span class="line">            --vhd</span><br><span class="line">                Specifies that the provided file is a .vhdx file, not a tar file.</span><br><span class="line">                This operation makes a copy of the .vhdx file at the specified install location.</span><br></pre></td></tr></table></figure><h2 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h2><ol><li><code>wsl -l -v</code> 查看WSL Distros</li><li><code>wsl --export &lt;Distro&gt; &lt;FileName&gt; [Options]</code>将要迁移的WSL Distro导出为tar</li><li><code>wsl --unregister &lt;Distro&gt;</code>卸载WSL Distro</li><li><code>wsl --import &lt;Distro&gt; &lt;InstallLocation&gt; &lt;FileName&gt; [Options]</code>将tar导入到新的WSL Distro</li><li><code>wsl --set-default &lt;UserName&gt;</code>为WSL Distro设置默认用户</li><li><code>wsl -d &lt;Distro&gt;</code>Linux,启动😎</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show distributions</span></span><br><span class="line">┌─  windows    /Desktop                                                                               0.081s  RAM 11/13GB 󰅐 5:35 PM Fri  33°C</span><br><span class="line">└   wsl -l -v</span><br><span class="line">  NAME                   STATE           VERSION</span><br><span class="line">* docker-desktop-data    Stopped         2</span><br><span class="line">  Ubuntu-24.04           Running         2</span><br><span class="line">  docker-desktop         Stopped         2</span><br><span class="line">  Arch                   Running         2</span><br><span class="line"><span class="comment"># export to tar</span></span><br><span class="line">┌─  windows    /Desktop                                                                                     0.046s  RAM 11/13GB 󰅐 5:35 PM Fri</span><br><span class="line">└   wsl --<span class="built_in">export</span> Arch E:\wsl\Arch.tar</span><br><span class="line">Export <span class="keyword">in</span> progress, this may take a few minutes.</span><br><span class="line">The operation completed successfully.</span><br><span class="line"><span class="comment"># unregister Ubuntu</span></span><br><span class="line">┌─  windows    /Desktop                                                                                     58.532s  RAM 9/13GB 󰅐 5:41 PM Fri</span><br><span class="line">└   wsl --unregister Ubuntu-24.04</span><br><span class="line">Unregistering.</span><br><span class="line">The operation completed successfully.</span><br><span class="line"><span class="comment"># import from tar</span></span><br><span class="line">┌─  windows    /Desktop                                                                                     0.145s  RAM 10/13GB 󰅐 5:44 PM Fri</span><br><span class="line">└   wsl --import Ubuntu e:\wsl\Arch e:\wsl\Arch.tar</span><br><span class="line">Import <span class="keyword">in</span> progress, this may take a few minutes.</span><br><span class="line">The operation completed successfully.</span><br><span class="line"><span class="comment"># set default user</span></span><br><span class="line">┌─  windows    /Desktop                                                                                    21.622s  RAM 12/13GB 󰅐 6:00 PM Fri</span><br><span class="line">└   Arch config --default-user efterklang</span><br><span class="line"><span class="comment"># launch</span></span><br><span class="line">┌─  windows    /Desktop                                                                                     0.182s  RAM 10/13GB 󰅐 6:02 PM Fri</span><br><span class="line">└   wsl -d Arch ff</span><br><span class="line"></span><br><span class="line">                                                                                gjx@Efterklang</span><br><span class="line"></span><br><span class="line">       I use Arch BTW(●ˇ∀ˇ●)                    ┌──────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line"></span><br><span class="line">                     ▄                           OS             ➜   Arch Linux 20240101.0.204074 x86_64</span><br><span class="line">                    ▟█▙                         │ ├ Kernel      ➜   Linux 5.15.146.1-microsoft-standard-WSL2</span><br><span class="line">                   ▟███▙                        │ ├󰏖 Packages    ➜   190 (pacman)</span><br><span class="line">                  ▟█████▙                       │ └ Shell       ➜   fish 3.7.1</span><br><span class="line">                 ▟███████▙                      󰧨 LM             ➜   login (TTY)</span><br><span class="line">                ▂▔▀▜██████▙                     │ ├ Terminal    ➜   WezTerm 20240203-110809-5046fc22</span><br><span class="line">               ▟██▅▂▝▜█████▙                     PC             ➜   Windows Subsystem <span class="keyword">for</span> Linux - Arch</span><br><span class="line">              ▟█████████████▙                   │ ├ CPU         ➜   AMD Ryzen 7 5800H (16) @ 3.19 GHz</span><br><span class="line">             ▟███████████████▙                  │ ├󰍛 GPU         ➜   NVIDIA GeForce RTX 3060 Laptop GPU (5.87 GiB) [Discrete]</span><br><span class="line">            ▟█████████████████▙                 │ ├󰍛 GPU         ➜   AMD Radeon(TM) Graphics (1.98 GiB) [Integrated]</span><br><span class="line">           ▟███████████████████▙                │ ├󰋊 Disk        ➜   2.09 GiB / 1006.85 GiB (0%) - ext4</span><br><span class="line">          ▟█████████▛▀▀▜████████▙               │ ├󰋊 Disk        ➜   165.95 GiB / 200.00 GiB (83%) - 9p</span><br><span class="line">         ▟████████▛      ▜███████▙              │ ├󰋊 Disk        ➜   101.74 GiB / 275.69 GiB (37%) - 9p</span><br><span class="line">        ▟█████████        ████████▙             │ ├󰋊 Disk        ➜   166.97 GiB / 475.45 GiB (35%) - 9p</span><br><span class="line">       ▟██████████        █████▆▅▄▃▂            │ ├ Memory      ➜   793.43 MiB / 6.71 GiB (12%)</span><br><span class="line">      ▟██████████▛        ▜█████████▙           │ ├󰓡 Swap        ➜   0 B / 2.00 GiB (0%)</span><br><span class="line">     ▟██████▀▀▀              ▀▀██████▙          │ ├󰅐 Uptime      ➜   7 seconds</span><br><span class="line">    ▟███▀▘                       ▝▀███▙         󰩟 Local IP       ➜   113.54.240.64/19</span><br><span class="line">   ▟▛▀                               ▀▜▙        󰩟 Public IP      ➜   89.116.88.203 (Tokyo, JP)</span><br><span class="line"></span><br><span class="line">                                                └──────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">                                                                                   ● ● ● ● ● ● ● ●</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">将WSL迁移至其它盘符</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Linux" scheme="https://efterklang.github.io/categories/Dev/Linux/"/>
    
    
    <category term="Linux" scheme="https://efterklang.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>运输层 TransportLayer Part Ⅱ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-2TransportLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-2TransportLayer/</id>
    <published>2024-05-20T09:04:46.000Z</published>
    <updated>2024-06-14T07:45:56.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Connection-Oriented-Transport-TCP"><a href="#Connection-Oriented-Transport-TCP" class="headerlink" title="Connection-Oriented Transport: TCP"></a>Connection-Oriented Transport: TCP</h2><h3 id="TCP-Connection"><a href="#TCP-Connection" class="headerlink" title="TCP Connection"></a>TCP Connection</h3><ul><li><strong>面向连接 connection-oriented</strong>：相互发送预备报文段，以建立确保数据传输的参数；</li><li><strong>全双工服务 full-duplex service</strong>：如果一台主机上的进程 A 与另一台主机上的进程 B 存在一条 TCP 连接，那么应用层数据就可以在从进程 B 流向进程 A 的同时，也从进程 A 流向进程 B；</li><li><strong>点对点 point-to-point</strong>：即在单个发送方与单个接收方之间的连接；</li><li><strong>三次握手 three-way handshake</strong>：客户先发送一个特殊 TCP 报文段，服务器用另一个特殊的 TCP 报文段来响应，最后客户再用第三个特殊报文段作为响应。</li><li><strong>流量控制 Traffic control</strong>：TCP 通过流量控制机制来确保发送方不会淹没接收方；</li></ul><p>客户进程通过套接字，TCP 会将要发送的数据引导到该连接的发送缓存（send buffer），发送缓存是发起三次握手期间设置的缓存之一，TCP 发送缓存与接收缓存如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-23-15-09-31.png" style="zoom:100%;"></p><h3 id="TCP-Segment-Structure"><a href="#TCP-Segment-Structure" class="headerlink" title="TCP Segment Structure"></a>TCP Segment Structure</h3><ul><li><p><strong>源端口和目的端口字段</strong> Source Port Dest Port: 各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现</p></li><li><p><strong>序号字段</strong> Sequence number: 占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号</p></li><li><p><strong>确认号字段</strong> Acknowledge number: 占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号</p></li><li><p><strong>数据偏移</strong>(首部长度) header length 占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）</p></li><li><p><strong>保留字段</strong> Unused: 占 8 位，保留为今后使用，但目前应置为 0</p></li><li><p><strong>标识字段</strong> flag field 占 6bit</p><ul><li>URG (Urgent Pointer field significant)：当设置为 1 时，表示紧急指针字段有意义，即 TCP 报文段中存在紧急数据，需要优先传送。</li><li>ACK (Acknowledgement field significant)：当设置为 1 时，表示确认号字段有效。TCP 使用 ACK 标志和确认号字段来实现可靠传输，确认对方发送的数据已经成功接收。</li><li>PSH (Push Function)：当设置为 1 时，表示接收方应立即将这个报文段交给应用层，而不是等待缓冲区满后再交付。</li><li>RST (Reset the connection)：当设置为 1 时，表示连接出现严重问题，需要立即重置，即终止当前连接。</li><li>SYN (Synchronize sequence numbers)：在建立连接时使用。当 SYN 标志设置为 1，而 ACK 标志为 0 时，表示这是一个连接请求报文段。如果 SYN 和 ACK 都为 1，表示对方已确认连接请求，此时连接建立。</li><li>FIN (Finish,No more data from sender)：当设置为 1 时，表示此方已经没有数据要发送，希望关闭连接。<blockquote><p>实践中，PSH，URG，Urgent data pointer 不被广泛使用<br>在 RFC 3168 中添加了两个新的标志（ECE 和 CWR），<br>CWR：CWR 标志与后面的 ECE 标志都用于 IP 首部的 ECN 字段，ECE 标志为 1 时，则通知对方已将拥塞窗口缩小；<br>ECE：若其值为 1 则会通知对方，从对方到这边的网络有阻塞。在收到数据包的 IP 首部中 ECN 为 1 时将 TCP 首部中的 ECE 设为 1；</p></blockquote></li></ul></li><li><p><strong>窗口字段</strong> Receiver window: 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</p></li><li><p><strong>检验和</strong> Internet checksum:占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p></li><li><p><strong>紧急指针字段</strong> Urgent data pointer 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</p></li><li><p><strong>填充字段</strong> 这是为了使整个首部长度是 4 字节的整数倍。</p></li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-23-15-50-58.png" style="zoom:50%;"><h3 id="Seq-number-and-ACK-number"><a href="#Seq-number-and-ACK-number" class="headerlink" title="Seq number and ACK number"></a>Seq number and ACK number</h3><p>报文段的序号(Sequence number)和确认号(Acknowledgement number)是 TCP 提供可靠数据传输的关键。其中序号指数据段中第一个字节在数据流中的位置编号，确认号指期望从另外一边收到的下一个字节的序号。TCP 为全双工通信，因此每个方向的数据流都有自己的序号和确认号。</p><p>假设有两台主机，主机 A 启动了一个与主机 B 的 Telnet 会话。因为主机 A 启动了会话，所以它被标记为客户端，主机 B 被标记为服务器。<br>用户（在客户端）输入的每个字符都会被发送到远程主机；远程主机将会发送回每个字符的副本，这些字符将会显示在 Telnet 用户的屏幕上。这种“回显”用于确保 Telnet 用户看到的字符已经在远程站点被接收并处理。因此，每个字符在用户按下键盘到字符在用户的监视器上显示的时间内，都会在网络上传输两次<br>现在假设用户输入了一个单独的字母，‘C’，然后去拿咖啡。如图所示，这里我们假设客户端和服务器的起始序列号 ISN 分别是 42 和 79。一个段的序列号是数据字段中第一个字节的序列号。因此，从客户端发送的第一个段的序列号将是 42；从服务器发送的第一个段的序列号将是 79。回忆一下，确认号是主机正在等待的下一个数据字节的序列号。在 TCP 连接建立但在任何数据发送之前，客户端正在等待字节 79，服务器正在等待字节 42</p><blockquote><p>在 TCP 中，每一个新的连接都会从一个<strong>随机</strong>的起始序列号（ISN, Initial Sequence Number）开始。ISN 是在 TCP 三次握手过程的第一步中由连接的发起方确定。实际的 TCP 连接中，起始序列号会是一个随机的、32 位的数值。这里我们使用 42 和 79 只是为了简化讨论。<br>为什么要用随机 ISN?一方面是为了防止连接失效后 SOCKET 被重用使得以前残留的包被错误的接受；另一方面是为了防止黑客轻易的知道序列号之后制造 tcp 序列号攻击，不过即使这样 tcp 序列号攻击也是有办法进行的，所以有很多 tcp 序列号的生成算法被提出和改进。</p></blockquote><p>如图所示，发送了三个段。第一个段从客户端发送到服务器，其数据字段中包含字母‘C’的 1 字节 ASCII 表示。正如我们刚才描述的，这个第一个段的序列号字段中有 42。另外，因为客户端还没有从服务器接收到任何数据，所以这个第一个段的确认号字段中会有 79。</p><p>第二个段从服务器发送到客户端。它有两个目的。首先，它确认了服务器接收到的数据。通过在确认字段中放入 43，服务器告诉客户端它已经成功接收了直到字节 42 的所有内容，现在正在等待字节 43 及其后的数据。这个段的第二个目的是<strong>回显</strong>字母‘C’。因此，这个第二个段的数据字段中有字母‘C’的 ASCII 表示。这个第二个段的序列号是 79，这是这个 TCP 连接的服务器到客户端数据流的初始序列号，因为这是服务器发送的第一个数据字节。注意，对客户端到服务器数据的确认是在携带服务器到客户端数据的段中进行的；这个确认被说成是在服务器到客户端的数据段上的捎带确认。</p><blockquote><p>回显 Echo Protocol 通常用于网络测试和故障排查。它是一种简单的协议，客户端发送给服务器的任何数据，服务器都会原封不动地发送回来。这种机制可以用于测试网络连接的质量，包括延迟、数据包丢失率等。它在 RFC 862 中有详细的描述。然而，需要注意的是，TCP Echo 并不常用，因为它可能会被利用进行拒绝服务攻击（Denial of Service attack，DoS attack）</p></blockquote><p>第三个段从客户端发送到服务器。它的唯一目的是确认它从服务器接收到的数据。（回忆一下，第二个段包含了从服务器到客户端的数据——字母‘C’。）这个段的数据字段是空的（也就是说，确认没有与任何客户端到服务器的数据捎带）。这个段的确认号字段中有 80，因为客户端已经接收了直到字节序列号 79 的字节流，现在正在等待字节 80 及其后的数据。你可能会觉得奇怪，这个段也有一个序列号，虽然段中没有数据。但是，因为 TCP 有一个序列号字段，所以这个段需要有一些序列号。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-26-17-03-10.png" style="zoom:80%;"><p>TCP，就像我们在 3.4 节中的 rdt 协议一样，使用超时&#x2F;重传机制来从丢失的段中恢复。虽然这在概念上很简单，但是当我们在实际的协议如 TCP 中实现超时&#x2F;重传机制时，会出现许多微妙的问题。也许最明显的问题是超时间隔的长度。显然，超时应该大于连接的往返时间（RTT），即从发送一个段到它被确认的时间。否则，会发送不必要的重传。但是超时应该大多少？首先应该如何估计 RTT？是否应该与每个未确认的段关联一个定时器？</p><h3 id="Round-Trip-Time-Estimation-and-Timeout"><a href="#Round-Trip-Time-Estimation-and-Timeout" class="headerlink" title="Round-Trip Time Estimation and Timeout"></a>Round-Trip Time Estimation and Timeout</h3><p><strong>如何估计往返时间</strong></p><p>样本 RTT(SampleRTT): 测量从报文段发送到收到确认的时间<br><strong>EstimatedRTT</strong> TCP 维持的 SampleRTT 均值，其更新方式如下:$\alpha$ 推荐值为 0.125</p><p>$$<br>EstimatedRTT&#x3D;(1-\alpha)\times EstimatedRTT+\alpha\times SampleRTT<br>$$</p><p>上述平均方法被称为<strong>指数加权移动平均（Exponential Weighted Moving Average，EWMA）</strong></p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-26-21-06-22.png" style="zoom:65%;"><p><strong>RTT 偏差</strong>(RTT Deviation,DevRTT)，用于估算 SampleRTT 一般会偏离 EstimatedRTT 的程度：$\beta$ 推荐值为 0.25</p><p>$$<br>DevRTT&#x3D;(1-\beta)\times DevRTT+\beta\times |SampleRTT-EstimatedRTT|<br>$$</p><hr><p><strong>Timeout 时间设置</strong><br>超时间隔应该大于等于 EstimatedRTT 以避免不必要的重传。同时要考虑到 RTT 的变化，因此要加上 RTT 偏差</p><p>$$<br>TimeoutInterval &#x3D; EstimatedRTT + 4\times DevRTT<br>$$</p><hr><ol><li>初始时$TimeoutInterval$设置为 1s</li><li>第一个样本 RTT 获得后， $EstimatedRTT&#x3D;SampleRTT，DevRTT&#x3D;SampleRTT&#x2F;2$</li><li>$TimeoutInterval &#x3D;EstimatedRTT + max (G, K*DevRTT)$ （K&#x3D;4，G 是用户设置的时间粒度）</li></ol><h3 id="Reliable-Data-Transfer"><a href="#Reliable-Data-Transfer" class="headerlink" title="Reliable Data Transfer"></a>Reliable Data Transfer</h3><p>TCP 在 IP 不可靠服务之上创建了一种<strong>可靠数据传输服务（reliable data transfer service,rdt）</strong>。为了减少多个定时器管理带来的相当大的开销，TCP 在即使有多个已发送但未确认的报文段的情况下，定时器的管理过程仅使用<strong>单一</strong>的定时器。简化的 TCP 发送方如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Assume sender is not constrained by TCP flow or congestion control, that data from above is less than MSS in size, and that data transfer is in one direction only. */</span></span><br><span class="line"></span><br><span class="line">NextSeqNum=InitialSeqNumber <span class="comment">// 表示下一个要发送的数据段的序列号</span></span><br><span class="line">SendBase=InitialSeqNumber <span class="comment">// 表示已发送但尚未被确认的最早的数据段的序列号</span></span><br><span class="line"></span><br><span class="line">loop (forever) &#123;</span><br><span class="line">    <span class="keyword">switch</span>(event)</span><br><span class="line"></span><br><span class="line">        event: data received from application above</span><br><span class="line">            create TCP segment with sequence number NextSeqNum</span><br><span class="line">            <span class="keyword">if</span> (timer currently not running)</span><br><span class="line">            start timer</span><br><span class="line">            pass segment to IP</span><br><span class="line">            NextSeqNum=NextSeqNum+length(data)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        event: timer timeout</span><br><span class="line">            retransmit not-yet-acknowledged segment with smallest sequence number</span><br><span class="line">            start timer</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        event: ACK received, with ACK field value of y</span><br><span class="line">            <span class="title function_">if</span> <span class="params">(y &gt; SendBase)</span> &#123;</span><br><span class="line">                SendBase=y</span><br><span class="line">                <span class="keyword">if</span> (there are currently any not-yet-acknowledged segments)</span><br><span class="line">                start timer</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="comment">/* end of loop forever */</span></span><br></pre></td></tr></table></figure><p><strong>简化的 TCP 发送方</strong></p><ul><li>data received from application above: 当从上层应用接收到数据时，创建一个 TCP Segment，其序列号为 NextSeqNum，如果没有启动定时器，则启动定时器，然后将该段传递给 IP 层以进行传输，<code>NextSeqNum += length(data)</code></li><li>timer timeout: 当定时器超时时（这通常意味着一个 TCP 段丢失了，因为我们没有在预期的时间内收到 ACK），会重新传输序列号最小的尚未确认的段，然后重新启动定时器</li><li>ACK received, with ACK field value of y: 当收到一个 ACK 时，如果 ACK 字段的值 y 大于 SendBase，则更新 SendBase 为 y。这意味着我们已经收到了序列号小于或等于 y 的所有段的确认。然后，如果还有尚未确认的段，就启动定时器<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-26-21-25-57.png" style="zoom:80%;"></li></ul><hr><p><strong>Retransmission Scenarios</strong></p><p>当发生 timeout 事件时，TCP 重传时都会将下一次的 timeout 间隔设为先前值的两倍；当发生其他两个事件计时器重启时，<code>TimeoutInterval</code>由最近的 <code>EstimatedRTT</code>值与 <code>DevRTT</code>值推算得到。这种修改提供了一个形式受限的拥塞控制,在拥塞时期，如果源继续坚持重新传输数据包，拥塞可能会变得更,通过延长超时时间，TCP 可以减少重传的次数，从而减少拥塞。如下图 p2 所示，Seq92 超时重传，TimeoutInterval 加倍，$TimeoutInterval \lt Seq100 Transport Time \lt 2 \times TimeoutInterval $, 从而 Seq100 不会被重传</p><p>累计确认机制避免了重传第一个段，如下图 p3 所示，Seq92 和 Seq100 已经被确认，虽然 ACK100 丢失，但 ACK120 被接收，由于累计确认机制，Seq92 和 Seq100 都被确认，因此不会被重传</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-26-22-42-12.png" style="zoom:100%;"><blockquote><p>p1: Retransmission due to a lost acknowledgment<br>p2：Segment 100 not retransmitted<br>p3: A cumulative acknowledgment avoids retransmission of the first segmen</p></blockquote><p><strong>Fast Retransmit</strong></p><p>当比期望序号大的失序报文段到达，接收方立即发送<strong>冗余 ACK（duplicate ACK）</strong>，指明下一个期待字节的序号<br>如果发送方收到一个确认后再收到 3 个对同样报文段的确认，发送方应意识到不对劲。生成三个重复 ACK，是因为接收方存在缺失报文段；于是启动快速重传(fast retransmit): 在定时器超时之前重发丢失的报文段</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-30-15-08-41.png" style="zoom:80%;"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">event: ACK received, with ACK field value of y</span><br><span class="line"><span class="title function_">if</span> <span class="params">(y &gt; SendBase)</span> &#123;</span><br><span class="line">    SendBase = y</span><br><span class="line">    <span class="keyword">if</span> (there are currently not-yet-acknowledged segments)</span><br><span class="line">            start timer</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    increment count of dup ACKs received <span class="keyword">for</span> y</span><br><span class="line">    <span class="keyword">if</span> (count of dup ACKs received <span class="keyword">for</span> y == <span class="number">3</span>) &#123;</span><br><span class="line">        resend segment with sequence number y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-30-16-01-48.png" style="zoom:100%;"><p><strong>GBN or SR</strong></p><p>TCP 错误恢复机制是 GBN（Go-Back-N）协议还是 SR（Selective Repeat）协议？</p><p>TCP 的确认是累积的，正确接收但是顺序错误的段并不会被接收者单独确认。因此，TCP 发送者只需要维护传输但未确认的字节的最小序列号（SendBase）和下一个要发送的字节的序列号（NextSeqNum）。从这个意义上说，TCP 看起来很像一个 GBN 风格的协议。<br>但是 TCP 和 GBN 之间有一些显著的差异。许多 TCP 实现会缓存(buffer)正确接收但顺序错误的 Segment [Stevens 1994]。<br>对 TCP 的一项提议修改，所谓的选择性确认 [RFC 2018]，允许 TCP 接收者选择性地确认顺序错误的段，而不是只是累积地确认最后正确接收的，顺序正确的段。当与选择性重传结合使用，TCP 看起来很像我们的通用 SR 协议。因此，TCP 的错误恢复机制可能最好被分类为 GBN 和 SR 协议的混合体。</p><h3 id="Flow-Control"><a href="#Flow-Control" class="headerlink" title="Flow Control"></a>Flow Control</h3><p>TCP 通过让发送方维护一个称为<strong>接收窗口（receive window）</strong>的变量来提供流量控制。通俗的说，接收窗口用于给发送方一个指示——该接收方还有多少可用的缓存空间。因为 TCP 是全双工通信，在连接两端的发送方都各自维护一个接收窗口。<br>接收窗口（<code>rwnd</code>）和接收缓存（<code>RcvBuffer</code>）如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-30-16-03-28.png" style="zoom:80%;"></p><p>通过 TCP 连接的主机都会为连接设置一个接收缓冲区。当 TCP 连接接收到正确且顺序正确的字节时，它会将数据放入接收缓冲区(TCP data in buffer)。相关的应用程序进程(Application process )将从这个缓冲区读取数据。进程从 buffer 中读取数据的时机是不确定的，可能在数据到达的瞬间读取，也可能在数据到达很久之后才尝试读取数据。如果应用程序读取数据的速度相对较慢，发送者很容易通过过快地发送过多的数据来溢出连接的接收缓冲区。</p><p>TCP 为其应用程序提供了一种<strong>流量控制服务 Flow Control</strong>，以消除发送者溢出接收者缓冲区的可能性。因此，流量控制是一种速度匹配服务(匹配发送者发送的速率与接收应用程序读取的速率)。</p><p>如前所述，由于 IP 网络内的拥塞，TCP 发送者也可能被节流(throttled)；这种称为<strong>拥塞控制 Congestion Control</strong>。尽管流量控制和拥塞控制采取的行动相似（即节流发送者），但它们显然是出于非常不同的原因。</p><p>TCP 通过让发送者维护一个叫做 receive window 的变量来提供<strong>流量控制</strong>。接收窗口用于告诉 sender 关于 receiver 有多少可用缓冲区空间的信息。因为 TCP 是全双工的，连接的每一侧的发送者都维护一个独立的接收窗口。让我们在文件传输的上下文中研究接收窗口。</p><p>假设主机 A 正在通过 TCP 连接向主机 B 发送一个大文件。主机 B 为这个连接分配一个接收缓冲区；表示其大小为 RcvBuffer。不时地，主机 B 的应用程序进程从缓冲区中读取数据。定义以下变量：</p><ul><li><code>LastByteRead</code>：这是应用程序从接收缓冲区中读取的数据流的最后一个字节的序号。换句话说，这是应用程序最后读取的数据的字节序号。例如，如果 LastByteRead 的值为 1000，那么意味着应用程序已经读取了序号为 1 到 1000 的字节。</li><li><code>LastByteRcvd</code>：这是已经从网络到达并被放入主机 B 的接收缓冲区的数据流的最后一个字节的序号。换句话说，这是最后一个被接收并放入缓冲区的数据的字节序号。例如，如果 LastByteRcvd 的值为 1500，那么意味着已经接收了序号为 1 到 1500 的字节，并且这些字节已经被放入了接收缓冲区。<blockquote><p>$LastByteRcvd - LastByteRead$即为应用程序未读取的数据量，它存放于 Buffer 中</p></blockquote></li></ul><p>因为 TCP 不允许溢出分配的缓冲区，我们必须有 $LastByteRcvd – LastByteRead \lt RcvBuffer$<br>接收窗口，表示为 rwnd，设置为缓冲区的空闲空间：$rwnd &#x3D; RcvBuffer – (LastByteRcvd – LastByteRead)$，因为空闲空间随时间变化，rwnd 是动态变化的。</p><p>连接如何使用变量 rwnd 来提供流量控制服务呢？</p><p>主机 B 通过在每个发送给 A 的 Segment 的<a href = "#TCP-Segment-Structure">接收窗口字段(Receieve Window)</a>中放置其 rwnd 的当前值，告诉主机 A 连接缓冲区中有多少空闲空间。最初，主机 B 设置$rwnd &#x3D; RcvBuffer$。注意，要实现这一点，主机 B 必须跟踪几个特定于连接的变量。</p><p>反过来，主机 A 跟踪两个变量，LastByteSent 和 LastByteAcked。这两个变量之间的差值 $LastByteSent – LastByteAcked$ 表示 A 已发送但未被确认的数据的量。通过保持未确认的数据量小于 rwnd 的值，主机 A 可以确保它没有溢出接收者的缓冲区。</p><p>这个方案有一个小的技术问题。为了看到这一点，假设主机 B 的接收缓冲区变满了，所以 rwnd &#x3D; 0。在向主机 A 广告 rwnd &#x3D; 0 后，假设 B 没有任何数据要发送给 A。现在考虑会发生什么。当 B 的应用程序进程清空缓冲区时，TCP 不会向主机 A 发送新的段和新的 rwnd 值；实际上，只有当 TCP 有数据要发送，或者有确认要发送时，才会向主机 A 发送段。因此，主机 A 永远不会被通知主机 B 的接收缓冲区已经有了一些空间——主机 A 被阻塞了，不能再传输任何数据<br>为了解决这个问题，TCP 规范要求主机 A 得知 B 的接收窗口为零时继续发送带有一个数据字节的段。这些段将被 B 确认。最终，缓冲区将开始清空，确认将包含一个非零的 rwnd 值。<br><a href="https://www2.tkn.tu-berlin.de/teaching/rn/animations/flow/">Flow Control Animations</a></p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-04-30-17-50-43.png" style="zoom:80%;"><blockquote><p>UDP 不提供流量控制，因此，由于缓冲区溢出，接收者可能会丢失段。例如，考虑从主机 A 的一个进程发送一系列 UDP 段到主机 B 的一个进程。对于典型的 UDP 实现，UDP 会将段附加在一个有限大小的缓冲区中，这个缓冲区“位于”相应的套接字之前。进程一次从缓冲区中读取一个完整的段。如果进程从缓冲区中读取段的速度不够快，缓冲区将溢出，段将被丢弃。</p></blockquote><p><strong>Flow Control 例题</strong></p><blockquote><p><strong>Q</strong>: 主机甲和主机乙之间已建立一个 TCP 连接，TCP 最大段长度为 1000 字节，若主机甲的当前拥塞窗口为 5000 字节，在主机甲向主机乙连接发送 2 个最大段后，成功收到主机乙发送的第一段的确认段，确认段中通告的接收窗口大小为 3000 字节，则此时主机甲还可以向主机乙发送的最大字节数是？<br><strong>A</strong>: 第一个段的 ACK 段中通告的接收窗口 rwnd 大小为 3000 字节，即表明在接受到第一个报文段后，还有 2000 字节的缓存空间可用。 由于发送方发送了二个报文段，第二个段将占用剩下的 3000 字节中的 1000 字节，即一共还有 3000-1000&#x3D;2000 字节，min{2000,CongestionWindowSize} &#x3D; 2000,所以此时主机甲还可以向主机乙发送的最大字节数是 2000Byte</p></blockquote><h3 id="TCP-Connection-Management"><a href="#TCP-Connection-Management" class="headerlink" title="TCP Connection Management"></a>TCP Connection Management</h3><p><strong>How a TCP connection is established and torn down?</strong></p><h4 id="three-way-handshake"><a href="#three-way-handshake" class="headerlink" title="three-way handshake"></a>three-way handshake</h4><p>假设一个主机（客户端）上的进程希望与另一个主机（服务器）上的进程建立连接。客户端应用程序首先通知客户端的 TCP 它希望与服务器中的进程建立连接。然后，客户端的 TCP 按照以下方式与服务器的 TCP 建立连接：</p><ul><li><p><strong>Step 1</strong>：客户端 TCP 首先向服务器 TCP 发送一个特殊的 TCP 段。这个特殊段中不包含应用层数据。但是段头部(Segment Header)中的 SYN 标志位，被设置为 1。因此，这个特殊段被称为 SYN Segment。此外，客户端随机选择一个初始序列号（client_isn），并将此号码放入初始 TCP SYN 段的序列号字段中。此段被封装在一个 IP 数据报中并发送到服务器</p></li><li><p><strong>Step 2</strong>：一旦包含 TCP SYN 段的 IP 数据报到达服务器主机，服务器将 TCP SYN 段从数据报中提取出来，为连接分配 TCP 缓冲区和变量，并向客户端 TCP 发送连接确认段。这个连接确认段也不包含应用层数据。然而，它在段头部包含三个重要的信息。首先，SYN 位被设置为 1。其次，TCP 段头部的确认字段被设置为 client_isn+1。最后，服务器选择自己的初始序列号（server_isn）并将此值放入 TCP 段头部的序列号字段中。这个连接确认段实际上在说，“我收到了你的 SYN 包，要求以你的初始序列号 client_isn 开始一个连接。我同意建立这个连接。我的初始序列号是 server_isn。”这个连接确认段被称为 SYNACK 段。</p></li><li><p><strong>Step 3</strong>：收到 SYNACK 段后，客户端也为连接分配缓冲区和变量。然后，客户端主机向服务器发送另一个段；这个最后的段确认了服务器的连接确认段（客户端通过将值 server_isn+1 放入 TCP 段头部的确认字段中来做到这一点）。SYN 位被设置为零，因为连接已经建立。第三次握手时客户端可以在报文中加入数据</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-05-07-14-45-07.png" style="zoom:80%;"></li></ul><blockquote><p>为什么需要三次握手<br>三次握手（Three-Way Handshake）是 TCP&#x2F;IP 协议中建立连接的过程，其主要目的是在两个 TCP 节点之间建立一个可靠的连接。这个过程为什么需要三次握手，主要有以下几个原因：<br>确认双方的接收与发送能力：三次握手确保了双方都有发送和接收数据的能力。当客户端发送 SYN 包给服务器时，这表明客户端有发送数据的能力；当服务器回应 SYN-ACK 包给客户端时，这表明服务器有接收和发送数据的能力；当客户端再回应 ACK 包给服务器时，这表明客户端有接收数据的能力。<br>防止过期的连接请求到达服务器：如果只有一次握手，那么过期的连接请求可能会导致服务器错误地打开连接。例如，如果客户端发送了一个连接请求，但是因为网络延迟，这个请求晚到了，而在此期间，客户端已经关闭了连接，那么如果服务器接收到这个过期的请求，就会错误地打开一个已经不存在的连接。而三次握手可以防止这种情况，因为即使服务器接收到了过期的第一个 SYN 包，但是在没有收到最后一个 ACK 包之前，服务器是不会打开连接的。<br>初始化序列号：每个 TCP 连接都有各自独立的序列号，这些序列号在连接过程中被初始化。客户端和服务器都在 SYN 包中发送自己的初始序列号，这样，双方都能知道对方的初始序列号，以便后续的数据传输。</p></blockquote><h4 id="four-way-handshake"><a href="#four-way-handshake" class="headerlink" title="four-way handshake"></a>four-way handshake</h4><ul><li><strong>Step 1</strong>: 客户发送 TCP FIN 控制报文段到服务器</li><li><strong>Step 2</strong>: 服务器接收 FIN, 回复 ACK. 进入半关闭连接状态；</li><li><strong>Step 3</strong>: 服务器发送 FIN 到客户，客户接收 FIN, 回复 ACK，<br>进入 “time wait”状态<br>等待结束时释放连接资源</li><li><strong>Step 4</strong>: 服务器接收 ACK. 连接关闭.<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-05-07-14-47-37.png" style="zoom:80%;"></li></ul><blockquote><p>为什么需要四次挥手，而不是两次或者三次呢？这是因为 TCP 是一个全双工协议，也就是说，数据可以在两个方向上同时传输。因此，每个方向都需要一个 FIN 和一个 ACK。A 需要告诉 B 它已经没有数据要发送了（FIN-1），并且需要确认 B 已经知道这一点（ACK-2）。同样，B 也需要告诉 A 它已经没有数据要发送了（FIN-2），并且需要确认 A 已经知道这一点（ACK-1）。这就是为什么我们需要四次挥手来关闭一个 TCP 连接。</p></blockquote><h4 id="TCP-State"><a href="#TCP-State" class="headerlink" title="TCP State"></a>TCP State</h4><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-05-07-14-57-59.png" style="zoom:100%;"><h2 id="Principles-of-Congestion-Control"><a href="#Principles-of-Congestion-Control" class="headerlink" title="Principles of Congestion Control"></a>Principles of Congestion Control</h2><p><strong>拥塞 Congestion</strong><br>从信息角度看: “太多源主机发送太多的数据，速度太快以至于网络来不及处理”<br>表现:<br>丢失分组 (路由器的缓冲区溢出)<br>长延迟 (在路由器的缓冲区排队)</p><blockquote><p>流量控制主要目的是防止发送端发送过多的数据，从而溢出接收端的缓冲区。<br>拥塞控制的目标是防止过多的数据填充网络，以避免网络拥塞。当网络中的数据包过多，超过了网络的承载能力，就会导致网络拥塞。网络拥塞可能导致数据包的丢失，进而引发发送端的超时重传，这反过来又会加剧网络拥塞，形成恶性循环。</p></blockquote><h3 id="The-Causes-and-the-Costs-of-Congestion"><a href="#The-Causes-and-the-Costs-of-Congestion" class="headerlink" title="The Causes and the Costs of Congestion"></a>The Causes and the Costs of Congestion</h3><ul><li>当分组的到达速率接近链路容量时，分组经历巨大的排队时延；</li><li>发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本；</li><li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉；</li></ul><h3 id="Approaches-to-Congestion-Control"><a href="#Approaches-to-Congestion-Control" class="headerlink" title="Approaches to Congestion Control"></a>Approaches to Congestion Control</h3><p><strong>端到端拥塞控制 End-to-end congestion control</strong><br>在端到端拥塞控制方法中，网络层没有为运输层拥塞控制显示支持。即使网络中存在拥塞，端系统也必须通过对网络行为的观察来判断；<br><strong>网络辅助的拥塞控制 Network-assisted congestion control</strong><br>网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显示反馈信息；</p><h2 id="TCP-Congestion-Control"><a href="#TCP-Congestion-Control" class="headerlink" title="TCP Congestion Control"></a>TCP Congestion Control</h2><p>TCP 采取的方法是让每个发送者根据感知到的网络拥塞情况来限制其发送流量的速率。如果 TCP 发送者感知到自己和目的地之间的路径上几乎没有拥塞，那么 TCP 发送者会增加其发送速率；如果发送者感知到路径上存在拥塞，那么发送者会降低其发送速率。<br>但是这种方法引出了三个问题。首先，TCP 发送者如何限制其向其连接发送流量的速率？其次，TCP 发送者如何感知到自己和目的地之间的路径上存在拥塞？第三，发送者应该使用什么算法来根据感知到的端到端拥塞来改变其发送速率？</p><hr><p><strong>如何限制速率</strong><br>前文讲到每个 TCP 连接的两端都有一个接收缓冲区，一个发送缓冲区，以及几个变量（LastByteRead，rwnd 等）。实现拥塞控，，需要维护一个额外的变量，即拥塞窗口 congestion window,记为 cwnd，对 TCP 发送者可以向网络发送流量的速率施加了约束。</p><div>$$LastByteSent-LastByteACKed\le \min\{CongWin,RcvWindow\} \\大体上有 rate = \frac{CongWin}{RTT} Bytes/sec$$</div>上面的约束限制了发送者处未确认的数据量，因此间接地限制了发送者的发送速率。<hr><p><strong>如何感知拥塞</strong></p><p>当存在过度拥塞时，路径上的一个（或多个）路由器缓冲区会溢出，导致一个数据报（包含一个 TCP 段）被丢弃。丢弃的数据报反过来导致发送者处出现一个丢失事件——要么超时，要么接收到三个重复 ACK——这被发送者视为发送者到接收者路径上存在拥塞的指示。</p><p>因为 TCP 使用确认来触发（或时钟）其拥塞窗口大小的增加，所以 TCP 被称为自计时(self-clocking)。<br>TCP 基于本地信息设置它们的发送速率的指导性原则：</p><ul><li>一个丢失的报文段表意味着拥塞，TCP 发送方在丢失事件发生后降低发送速率 (通过减少 CongWin)</li><li>一个确认报文段指示该网络正在向接收方交付发送方的报文段，因此，当对先前未确认报文段的确认到达时，能够增加发送方的速率；</li><li>探求带宽 Bandwidth probing.</li></ul><hr><p><strong>拥塞控制算法实现</strong></p><p>拥塞控制算法主要包括<strong>慢启动（slow-start）</strong>、<strong>拥塞避免（congestion avoidance）</strong>、<strong>快速恢复（fast recovery）</strong></p><p>在慢启动（slow-start）状态，<code>cwnd</code>的初始值为 1 个 MSS， 每当传输的报文段首次被确认就增加 1 个 MSS。TCP 发送速率起始很慢，但在慢启动阶段以<strong>指数</strong>增长，尽快达到期待的速率，故将以 2 的指数方式增加速率，直到产生丢失事件，或者 cwnd 大于等于 ssthresd(进入 Congestion Avoidance 模式),cwnd 会由指数增长变为线性增长</p><blockquote><p>MSS: Maximum Segment Size, 一个 TCP 报文段的最大长度<br>ssthresh: slow start threshold, 慢启动阈值</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-05-07-16-13-57.png" style="zoom:50%;"><p>如果存在一个由超时指示的丢包事件，TCP 发送方将 <code>cwnd</code>(Congestion Window)设置为 1 并重新开始慢启动过程。并将变量 <code>ssthresh</code>设置为 <code>cwnd/2</code><br>收到三个重复的确认时,将变量 <code>ssthresh</code>设置为 <code>cwnd/2</code>, <code>cwnd</code>设置为 <code>ssthresh(更新后的) + 3MSS</code>，并进入快速恢复状态</p><blockquote><p>怎么理解不同的丢包事件？<br>3 个重复的 ACKs 表明网络具有传输一些数据段的能力<br>在三个重复的确认之前超时，表明网络不具备传输数据段的能力<br>上述为 TCP Reno 版本的内容，在 TCP Tahoe 版本里，<br>无论超时还是三个重复，都直接将 CongWin 置为 1 个 MSS</p></blockquote><p>三个状态变换 FSM 如下图：</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-2TransportLayer-2024-05-07-16-27-02.png" style="zoom:80%;"><blockquote><p>TCP AIMD(Additive-increase,multiplicative-decrease)<br>发送方增加传输速率（窗口大小），探测可用带宽，直到发生丢包事件<br>乘性递减: 发生丢包事件后将拥塞窗口减半<br>加性递增: 每个 RTT 内如果没有丢失事件发生，拥塞窗口增加一个 MSS</p></blockquote><p><strong>Congestion Control 例题</strong></p><article class="message is-info">                <div class="message-body">            <p><strong>Q</strong> 主机甲和主机乙已建立了 TCP 连接，甲始终以 MSS&#x3D;1KB 大小的段发送数据，并一直有数据发送；乙每收到一个数据段都会发出一个接收窗口为 10KB 的确认段。若甲在 t 时刻发生超时时拥塞窗口为 8KB，则从 t 时刻起，不再发生超时的情况下，经过 10 个 RTT 后，甲的发送窗口是？<br><strong>A</strong> <code>ssthresh</code> 被设定为 8 的一半即 4，拥塞窗口被设为 1KB;拥塞窗口经 10 个 RTT 依次变化为 2、4（未超过 <code>ssthresh</code> 值之前以指数级增长，后面超过 <code>ssthresh</code> 之后以数量级增长）、5、6、7、8、9、10、11、12，最终达到 12KB;而流量控制的角度出发，接受窗口恒为 10KB,发送方的发送窗口&#x3D;min(拥塞窗口，接收窗口),故最后答案是 10KB</p>        </div>    </article><p><strong>总结</strong></p><ul><li>当 CongWin 低于阀值, 发送方处于慢启动阶段, 窗口指数增长.</li><li>当 CongWin 高于阀值, 发送方处于拥塞避免阶段, 窗口线性增长.</li><li>当三个重复的 ACK 出现时,阀值置为 CongWin&#x2F;2 并且 CongWin 置为阀值加上 3 个 MSS 并进入快速恢复阶段，此时每收到一个重复的 ACK 拥塞窗口增加 1MSS，如果收到新的 ACK 则 cwnd &#x3D; ssthresh</li><li>当超时发生时 ，阀值置为 CongWin&#x2F;2 并且 CongWin 置为 1 MSS.</li></ul><p><strong>TCP 平均吞吐量</strong><br>假设忽略慢启动<br>假设在丢失发生时，设 W 是窗口大小<br>如果窗口为 W, 吞吐量是 W&#x2F;RTT<br>丢失发生后, 窗口降为 W&#x2F;2, 吞吐量为 W&#x2F;2RTT.<br>平均吞吐量为 0 .75 W&#x2F;RTT</p><h3 id="TCP-CUBIC"><a href="#TCP-CUBIC" class="headerlink" title="TCP CUBIC"></a>TCP CUBIC</h3><p>CUBIC 是一种 TCP 拥塞控制算法，它是 Linux 内核的默认拥塞控制算法。CUBIC 主要用于长距离、高带宽网络，它的目标是更充分地利用可用带宽，同时保持网络的稳定性。</p><p>CUBIC 的关键特性是它的拥塞窗口调整函数，这个函数是时间的三次立方函数。这与传统的 TCP 拥塞控制算法（如 TCP Reno 或 TCP NewReno）不同，后者使用线性或者二次函数来调整拥塞窗口。</p><p>CUBIC 的工作原理如下：</p><p>当网络出现拥塞（例如，丢失了一个数据包）时，CUBIC 会减小其拥塞窗口，就像其他 TCP 拥塞控制算法一样。</p><p>当网络没有拥塞时，CUBIC 不会像传统的 TCP 算法那样线性地增加其拥塞窗口。相反，它会根据时间的立方函数来增加拥塞窗口。这意味着在网络条件良好时，CUBIC 可以更快地增加其发送速率。</p><p>当网络再次出现拥塞时，CUBIC 会再次减小其拥塞窗口，但是减小的速度会比上次慢。这使得 CUBIC 能够更好地适应网络的变化，避免过度反应。</p><p>CUBIC 的这些特性使其在高带宽、长距离的网络环境中表现得非常出色，这也是为什么它被选为 Linux 内核的默认拥塞控制算法。</p>]]></content>
    
    
    <summary type="html">记录运输层学习笔记, 第二部分。主要内容为TCP报文结构、序号和确认号、超时和重传、流量控制、可靠数据传输、快速重传、GBN和SR、流量控制、TCP连接管理(三次握手、四次挥手),拥塞控制</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="计算机网络" scheme="https://efterklang.github.io/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://efterklang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>运输层 TransportLayer Part Ⅰ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-1TransportLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-1TransportLayer/</id>
    <published>2024-05-17T03:34:02.000Z</published>
    <updated>2024-06-12T09:23:34.451Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction-and-Transport-Layer-Services"><a href="#Introduction-and-Transport-Layer-Services" class="headerlink" title="Introduction and Transport-Layer Services"></a>Introduction and Transport-Layer Services</h2><h3 id="Relationship-Between-Transport-and-Network-Layers"><a href="#Relationship-Between-Transport-and-Network-Layers" class="headerlink" title="Relationship Between Transport and Network Layers"></a>Relationship Between Transport and Network Layers</h3><p>运输层协议为运行在不同的主机上的应用进程之间提供了<strong>逻辑通信（logic communication）</strong>功能<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-14-43-16.png" style="zoom:50%;" /><br>传输层协议运行在端系统而非路由器</p><ul><li>发送方: 将从发送应用程序接收到的报文转换成传输层分组(segment)传递给网络层</li><li>接受方: 将数据段重新组装成报文传递到应用层</li></ul><p>传输层: <strong>进程之间</strong>的逻辑通信;传输层建立在网络层之上，负责端到端的通信会话和数据的可靠传输。传输层使用端口号来区分主机上的不同应用程序，并确保数据被正确地发送到接收应用程序。<br>网络层: <strong>主机之间</strong>的逻辑通信; 网络层负责处理数据包的发送和路由，包括 IP 地址处理和路由选择。网络层的主要目标是确定如何将数据从源主机传输到目标主机，即使这两台主机在物理上可能相隔很远，并且在它们之间可能存在多个中间节点（路由器）。网络层的一个关键协议是互联网协议（IP），它定义了数据包的格式和地址。</p><h3 id="Overview-of-the-Transport-Layer-in-the-Internet"><a href="#Overview-of-the-Transport-Layer-in-the-Internet" class="headerlink" title="Overview of the Transport Layer in the Internet"></a>Overview of the Transport Layer in the Internet</h3><p>Internet 的传输层协议有两个:<br><strong>传输控制协议 TCP,Transmission COntrol Protocol</strong>: 提供了一种可靠的、面向连接的服务。<br><strong>用户数据报协议 UDP,User Datagram Protocol</strong>:提供不可靠、无连接的服务</p><blockquote><p>网络层的 IP 协议(Internet Protocol)提供了一种不可靠的、无连接的服务;IP 的服务模型是尽力而为交付服务（best-effort delivery service）</p></blockquote><p>UDP 和 TCP 最基本的责任是，将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>。</p><h2 id="Multiplexing-and-Demultiplexing"><a href="#Multiplexing-and-Demultiplexing" class="headerlink" title="Multiplexing and Demultiplexing"></a>Multiplexing and Demultiplexing</h2><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-15-57-37.png" style="zoom:50%;" /><p>运输层的多路复用与多路分解，也就是将由网络层提供的主机到主机的交付服务延伸到为运行在主机上的应用程序提供进程到进程的服务。一个进程（作为网络应用的一部分）有一个或多个<strong>套接字（socket）</strong>，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。下图为进程交付过程：</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-15-48-45.png"></p><ul><li><strong>多路复用</strong>（Multiplexing）：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文传递到网络层；</li><li><strong>多路分解</strong>（Demultiplexing）：它是多路复用的逆过程;在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字，即将运输层报文段的数据交付到正确的套接字的工作；</li></ul><hr><p>主机收到 IP 数据报(IP Datagram),每个 IP 数据报中有源 IP 地址和目的 IP 地址,每个数据报搬运一个数据段,数据段中有源端口号和目的端口号,这样就可以将数据段交付给正确的 Socket。</p><p>运输层多路复用要求:</p><ol><li>套接字由唯一标识符；</li><li>每个报文段通过<strong>源端口号字段</strong>（source port number field）和<strong>目的端口号字段</strong>（destination port number field）来指示该报文段所要交付的套接字；<blockquote><p>端口号是一个 16 比特的数，其大小在 <code>0~65535</code>之间。<code>0~1023</code>范围的端口号称为<strong>周知端口号（well-know port number）</strong>，是受限制的。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-16-00-52.png" alt="Ch5-1TransportLayer-2024-04-02-16-00-52"></p></blockquote></li></ol><ul><li><strong>UDP 的 Socket 表示</strong><br><code>(source port， dest port)</code><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-10-08-58-17.png" style="zoom:50%;" /></li><li><strong>TCP 的 Socket 表示</strong><br><code>(source IP， source port， dest IP， dest port)</code><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-10-08-58-22.png" style="zoom:50%;" /></li></ul><h2 id="Connectionless-Transport-UDP"><a href="#Connectionless-Transport-UDP" class="headerlink" title="Connectionless Transport: UDP"></a>Connectionless Transport: UDP</h2><h3 id="UDP-Segment-Structure"><a href="#UDP-Segment-Structure" class="headerlink" title="UDP Segment Structure"></a>UDP Segment Structure</h3><p>使用 UDP 时，在发送报文段之前，发送方和接收方的运送层实体之间没有握手，UDP 被称为<strong>无连接的 connectionless</strong>;UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。</p><ul><li>是无连接的，即发送数据之前不需要建立连接(no connection establishment)</li><li>简单: 在发送者接受者之间不需要连接状态(no connection state)</li><li>没有拥塞控制，很适合多媒体通信的要求,UDP 能够用尽可能快的速度传递(no congestion control)</li><li>UDP 的首部开销小，只有 8 个字节(small header size)</li><li>支持一对一、一对多、多对一和多对多的交互通信</li></ul><p>UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。<br>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。<br>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。<br>应用程序必须选择合适大小的报文。<br>虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。</p><blockquote><p>UDP 首部有 8 个字节，由 4 个字段构成，每个字段都是两个字节： 1.源端口： 源端口号，需要对方回信时选用，不需要时全部置 0. 2.目的端口：目的端口号，在终点交付报文的时候需要用到。 3.长度：UDP 的数据报的长度（包括首部和数据）其最小值为 8（只有首部） 4.校验和：检测 UDP 数据报在传输中是否有错，有错则丢弃,该字段是可选的，当源主机不想计算校验和，则直接令该字段全为 0.<br>当传输层从 IP 层收到 UDP 数据报时，就根据首部中的目的端口，把 UDP 数据报通过相应的端口，上交给应用进程。<br>如果接收方 UDP 发现收到的报文中的目的端口号不正确（不存在对应端口号的应用进程），就丢弃该报文，并由 ICMP 发送“端口不可达”差错报文给对方。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-10-10-19-15.png"></p><p>伪首部中 17 是协议代号，表示 UDP<br><strong>伪首部的作用</strong><br>第一，通过伪首部的 IP 地址检验，UDP 可以确认该数据报是不是发送给本机 IP 地址的；第二，通过伪首部的协议字段检验，UDP 可以确认 IP 有没有把不应该传给 UDP 而应该传给别的高层的数据报传给了 UDP。</p><p>伪首部包括了 IPv4 头部中的一些信息，但它并不是发送 IP 数据包时使用的 IP 数据包的头部。接收主机在收到 UDP 报文以后，<strong>从 IP 首部获悉 IP 地址信息构造 UDP 伪首部</strong>。在进行校验和计算。<br>识别一个通信应用需要 5 个因素。”源 IP 地址”、”目标 IP 地址”、”源端口”、”目标端口”、”协议号”。UDP 首部只包含了（源端口和目标端口），用此来校验，如果其他三项信息被破坏，极有可能导致应收包应用收不到，不应该收包的应用收到。<br>为此，有必要在通信中，验证这 5 项的识别码是否正确，就引入了伪首部的概念。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-11-09-54-10.png"></p><h3 id="UDP-Checksum"><a href="#UDP-Checksum" class="headerlink" title="UDP Checksum"></a>UDP Checksum</h3><p><a href="https://zhuanlan.zhihu.com/p/184884139">UDP&#x2F;IP 硬件协议栈设计（三）：校验</a></p><p><strong>Sender</strong>:<br>将数据段看成 16bit 的整数序列<br>校验和: 数据段内容相加 (1 的补码和，即反码)<br>发送者将校验和值放入 UDP 的校验和域<br><strong>Receiver</strong><br>计算接收到数据段的校验和<br>检查 计算的校验和是否等于校验和域中的值:<br>NO – 检测到错误<br>YES – 没有检测到错误,但是可能是错误的</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-15-56-24.png"></p><h2 id="Principles-of-Reliable-Data-Transfer"><a href="#Principles-of-Reliable-Data-Transfer" class="headerlink" title="Principles of Reliable Data Transfer"></a>Principles of Reliable Data Transfer</h2><p>[[Ch3-1DataLinkLayer#可靠传输 Reliable Transmission]]</p><p>可靠数据传输的框架：为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-16-19-54.png"></p><blockquote><p>rdt: reliable data transfer</p></blockquote><h3 id="Building-a-Reliable-Data-Transfer-Protocol"><a href="#Building-a-Reliable-Data-Transfer-Protocol" class="headerlink" title="Building a Reliable Data Transfer Protocol"></a>Building a Reliable Data Transfer Protocol</h3><h4 id="Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt1-0"><a href="#Reliable-Data-Transfer-over-a-Perfectly-Reliable-Channel-rdt1-0" class="headerlink" title="Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0"></a>Reliable Data Transfer over a Perfectly Reliable Channel: rdt1.0</h4><p>发送方和接收方的表示使用<strong>有限状态机（Finite-State Machine，FSM）</strong>定义，如果对一个事件没有动作，我们将在横线上方或下方使用<strong>符号$\Lambda$<strong>，以表示发生这个事件后不进行处理。<br>我们考虑最简单的情况，</strong>即底层信道是完全可靠的</strong>，我们称该协议为 <code>rdt1.0</code>，发送方和接收方的 FSM 定义如下：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-16-37-28.png" alt="rdt1.0 FSM"></p><h4 id="Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt2-0"><a href="#Reliable-Data-Transfer-over-a-Channel-with-Bit-Errors-rdt2-0" class="headerlink" title="Reliable Data Transfer over a Channel with Bit Errors: rdt2.0"></a>Reliable Data Transfer over a Channel with Bit Errors: rdt2.0</h4><blockquote><p><strong>下层信道可能让传输分组中的 bit 受损</strong></p><ul><li>校验和将检测到 bit 错误</li></ul><p><strong>问题: 如何从错误中恢复</strong></p><ul><li>确认(ACKs): 接收方明确告诉发送方 分组接收正确</li><li>否认 (NAKs):接收方明确告诉发送方 分组接收出错</li><li>发送方收到 NAK 后重发这个分组</li></ul><p><strong>在 rdt2.0 中的新机制 (在 rdt1.0 中没有的):</strong></p><ul><li>差错检测</li><li>接收方反馈: 控制信息 (ACK,NAK) rcvr-&gt;sender</li></ul></blockquote><p>实际上的底层信道是可能出现比特受损的；在分组传输、传播或缓存的过程中，这种比特差错通常会出现在网络的物理部件中。在接收方得到比特差错的信息时，需要发送方进行重传。在计算机网络环境中，基于这种重传机制的可靠数据传输协议称为<strong>自动重传请求（Automatic Repeat reQuest，ARQ）协议</strong>。ARQ 协议中还需要另外三种协议来处理存在比特差错的情况：</p><ul><li><strong>Error Detection</strong>：发送方同时发送检测和（checksum）到接收端判断是否出现比特差错；</li><li><strong>Receiver feedback</strong>：<ul><li><strong>肯定确认（ACKnowledgement，ACK）</strong>：接收方告诉发送方包数据无差错；</li><li><strong>否定确认（Negative AcKnowledgement，NAK）</strong>：接收方告诉发送方包数据有错误；</li></ul></li><li><strong>Retransmission</strong>：接收方收到有差错的分组时，发送方将重传该分组文；</li></ul><blockquote><p>rdt2.0 中，当发送方为<code>Wait for ACK or NAK</code>状态时，它不能再接收上层传来的数据，即<code>rdt_send()</code>事件不能再出现；直到接收到 ACK 并离开该状态，才能再次接收上层传来的数据。因此，rdt2.0 也被称为<strong>停等协议（stop-and-wait protocol）</strong>。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-17-03-03.png" alt="rdt2.0 FSM" style="zoom:50%;" /></p></blockquote><p><code>rdt2.0</code>协议存在致命的缺陷，它并没有考虑 ACK 和 NAK 受损的情况,一个困难的问题是协议该如何 从错误中恢复。<br>为了解决这一问题，就是在数据分组中添加一新字段，让发送方对其数据分组编号(编号占用 1bit，为 0&#x2F;1)，即将发送数据分组的<strong>序号（sequence number）</strong>放在该字段。于是，接收方只需要检查序号即可确定收到的分组是否一次重传。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-16-18-55-34.png" alt="rdt2.1 FSM"></p><p>rdt2.2: 一个不要 NAK 的协议;同 rdt2.1 一样的功能, 只用 ACKs 不用 NAK。如果上个报文接收正确接收方发送 ACK;接收方必须明确包含被确认的报文的序号；如果接受到受损的数据，那就发送一个 ACK，序号为最后一个正确的数据包的序号。发送方收到重复 ACK(duplicate ACK)等同于收到 NAK,将重发当前报文<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-17-09-18-24.png"></p><h4 id="Reliable-Data-Transfer-over-a-Lossy-Channel-with-Bit-Errors-rdt3-0"><a href="#Reliable-Data-Transfer-over-a-Lossy-Channel-with-Bit-Errors-rdt3-0" class="headerlink" title="Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0"></a>Reliable Data Transfer over a Lossy Channel with Bit Errors: rdt3.0</h4><p>新假设: 下层信道还要丢失报文 (数据或者 ACKs);校验和, 序号, 确认, 重发将会有帮助，但是不够<br>引入<strong>倒计数定时器（countdown timer）</strong>，实现基于时间的重传机制；只有在定时器超时时才触发重发</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-17-09-39-00.png" style="zoom:50%;"><p>因为分组序号在 0 和 1 之间交替，因此 <code>rdt3.0</code>也被称为<strong>比特交替协议（alternating-bit protocol）</strong>。运行如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-17-09-43-49.png" style="zoom:100%;"><h3 id="Pipelined-Reliable-Data-Transfer-Protocols"><a href="#Pipelined-Reliable-Data-Transfer-Protocols" class="headerlink" title="Pipelined Reliable Data Transfer Protocols"></a>Pipelined Reliable Data Transfer Protocols</h3><p>sender 信道利用率$U_{sender}&#x3D;\frac{L&#x2F;R}{RTT+L&#x2F;R}$</p><p>Stop-and-Wait 方式发送方信道利用率很低，解决方案是<strong>流水线化（pipelining）</strong>，即发送方可以发送多个分组，而不需要等待接收方的确认。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-17-10-03-56.png" style="zoom:100%;"><h3 id="GBN-SR"><a href="#GBN-SR" class="headerlink" title="GBN &amp; SR"></a>GBN &amp; SR</h3><p><strong>Ref</strong><br>[[Ch3-1DataLinkLayer#回退 N 帧协议 Go-Back-N Protocol]]<br>[[Ch3-1DataLinkLayer#选择重传协议 Selective Repeat Protocol]]</p>]]></content>
    
    
    <summary type="html">Transport Layer Part Ⅰ</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="计算机网络" scheme="https://efterklang.github.io/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://efterklang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>File System</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch6-1FileSystem/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch6-1FileSystem/</id>
    <published>2024-05-15T05:44:32.000Z</published>
    <updated>2024-06-12T09:26:00.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件系统概述"><a href="#文件系统概述" class="headerlink" title="文件系统概述"></a>文件系统概述</h2><p><strong>文件系统的功能</strong></p><ul><li>有效地管理文件的存储空间；</li><li>管理文件目录；</li><li>完成文件的读&#x2F;写操作；</li><li>实现文件共享与保护；</li><li>为用户提供交互式命令接口和程序调用接口。</li></ul><p><strong>定义</strong>：操作系统中的各类文件、管理文件的软件，以及管理文件所涉及到的数据结构等信息的集合。<br>有少数实时操作系统没有文件系统功能,绝大多数操作系统都包含文件管理系统部分。</p><h3 id="文件、记录和数据项-file-record-data-item"><a href="#文件、记录和数据项-file-record-data-item" class="headerlink" title="文件、记录和数据项 file record data item"></a>文件、记录和数据项 file record data item</h3><p><strong>文件</strong><br>文件是指由创建者所定义的、 具有文件名的一组相关元素的集合。</p><ul><li>在有结构的文件中，文件由若干个相关记录组成；</li><li>而无结构文件则被看成是一个字符流。</li><li>文件在文件系统中是一个最大的数据单位，它描述了一个对象集。</li></ul><p>文件的属性可以包括：</p><ol><li>文件类型</li><li>文件长度</li><li>文件的物理位置</li><li>文件的建立时间</li></ol><p><strong>记录</strong><br>记录是一组相关数据项的集合，用于描述一个对象在某方面的属性。</p><p><strong>数据项</strong><br>是最低级的数据组织形式，可把它分成以下两种类型：<br>(1) 基本数据项<br>这是用于描述一个对象的某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位， 即原子数据，又称为数据元素或字段。<br>(2) 组合数据项<br>它是由若干个基本数据项组成的，简称组项。</p><h3 id="文件类型-file-type"><a href="#文件类型-file-type" class="headerlink" title="文件类型 file type"></a>文件类型 file type</h3><ol><li><strong>按用途分类</strong><ul><li>系统文件 这是指由系统软件构成的文件。大多数的系统文件只允许用户调用，但不允许用户去读，更不允许修改；有的系统文件不直接对用户开放。</li><li>用户文件 由用户的源代码、目标文件、可执行文件或数据等所构成的文件。</li><li>库文件 这是由标准子例程及常用的例程等所构成的文件。这类文件允许用户调用，但不允许修改。</li></ul></li><li><strong>按文件中数据的形式分类</strong><ul><li>源文件:指由源程序和数据构成的文件<br>.c .cpp .java .py etc</li><li>目标文件:指把源程序经过相应语言的编译程序编译过，但尚未经过链接程序链接的目标代码所构成的文件。它属于二进制文件<br>.obj, .o</li><li>可执行文件:指把编译后所产生的目标代码再经过链接程序链接后所形成的文件<br>.exe,.dll; linux 的可执行文件一般没有后缀,但文件权限通常设置为可执行</li></ul></li><li><strong>按存取控制属性分类</strong><br>根据系统管理员或用户所规定的存取控制属性<ul><li>只执行文件 x:该类文件只允许被核准的用户调用执行，既不允许读，更不允许写</li><li>只读文件 r:该类文件只允许文件主及被核准的用户去读，但不允许写</li><li>读写文件 rw:这是指允许文件主和被核准的用户去读或写的文件</li></ul></li><li><strong>按组织形式和处理方式分类</strong><ul><li>普通文件：由 ASCII 码或二进制码组成的字符文件。一般用户建立的源程序文件、数据文件、目标代码文件及操作系统自身代码文件、库文件、实用程序文件等都是普通文件，它们通常存储在外存储设备上。</li><li>目录文件：由文件目录组成的，用来管理和实现文件系统功能的系统文件，通过目录文件可以对其它文件的信息进行检索。由于目录文件也是由字符序列构成，因此对其可进行与普通文件一样的种种文件操作。</li><li>特殊文件：特指系统中的各类 I&#x2F;O 设备。为了便于统一管理，linux 系统将所有 IO 设备都视为文件，按文件方式提供给用户使用</li></ul></li></ol><h3 id="文件系统模型-file-system-model"><a href="#文件系统模型-file-system-model" class="headerlink" title="文件系统模型 file system model"></a>文件系统模型 file system model</h3><h4 id="模型的层次结构"><a href="#模型的层次结构" class="headerlink" title="模型的层次结构"></a>模型的层次结构</h4><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1FileSystem-2024-05-13-20-44-15.png" style="zoom:70%;"><ol><li><strong>对象及其属性</strong><br>文件管理系统管理的对象有：<ul><li>文件。它作为文件管理的直接对象。</li><li>目录。为了方便用户对文件的存取和检索，在文件系统中必须配置目录。对目录的组织和管理是方便用户和提高对文件存取速度的关键。</li><li>磁盘(磁带)存储空间。 文件和目录必定占用存储空间，对这部分空间的有效管理，不仅能提高外存的利用率，而且能提高对文件的存取速度。</li></ul></li><li><strong>对对象操纵和管理的软件集合</strong><br>这是文件管理系统的核心部分。文件系统的功能大多是在这一层实现的，其中包括：<ul><li>对文件存储空间的管理</li><li>对文件目录的管理</li><li>用于将文件的逻辑地址转换为物理地址的机制</li><li>对文件读和写的管理</li><li>对文件的共享与保护等功能</li></ul></li><li><strong>文件系统的接口</strong><br>为方便用户使用文件系统，文件系统通常向用户提供两种类型的接口：<ul><li>命令接口。这是指作为用户与文件系统交互的接口。 用户可通过键盘终端键入命令，取得文件系统的服务。</li><li>程序接口。这是指作为用户程序与文件系统的接口。 用户程序可通过系统调用来取得文件系统的服务。</li></ul></li></ol><h4 id="文件操作示例"><a href="#文件操作示例" class="headerlink" title="文件操作示例"></a>文件操作示例</h4><p>用户通过文件系统提供的系统调用实施对文件的操作。</p><ol><li>最基本的文件操作有：创建文件、删除文件。读文件、写文件、截断文件和设置文件的读／写位置。</li><li>文件的“打开”和“关闭”操作：所谓“打开”，是指系统将指名文件的属性（包括该文件在外存上的物理位置）从外存拷贝到内存打开文件表的一个表目中，并将该表目的编号（或称为索引）返回给用户。 利用“关闭”（close）系统调用来关闭此文件，OS 将会把该文件从打开文件表中的表目上删除掉。</li><li>其它文件操作：对文件属性的操作，改变文件名、改变文件的拥有者，查询文件的状态等；</li></ol><blockquote><ul><li>open：打开一个文件，并指定访问该文件的方式，调用成功后返回一个文件描述符。</li><li>creat：打开一个文件，如果该文件不存在，则创建它，调用成功后返回一个文件描述符。</li><li>close：关闭文件，进程对文件所加的锁全都被释放。</li><li>read：从文件描述符对应的文件中读取数据，调用成功后返回读出的字节数。</li><li>write：向文件描述符对应的文件中写入数据，调用成功后返回写入的字节数。</li></ul></blockquote><h2 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h2><p>文件是由一系列的记录组成的。<br>对于任何一个文件，都存在着以下两种形式的结构：</p><ol><li>文件的逻辑结构:从用户观点出发所观察到的文件组织形式</li><li>文件的物理结构:指文件在外存上的存储组织形式</li></ol><p>从逻辑组织的角度看，文件由若干记录构成；<br>从物理组织的角度看，文件由若干数据块组成.<br>操作系统或文件管理系统负责为文件分配和管理数据块。</p><p>如何划分磁盘空间？<br>如何为一个新建文件分配空间？<br>如何为一个已存在的文件增加存储空间？<br>用什么数据结构记载文件已分配到的数据块和空闲数据块？</p><h3 id="文件的物理组织—存储空间的管理"><a href="#文件的物理组织—存储空间的管理" class="headerlink" title="文件的物理组织—存储空间的管理"></a>文件的物理组织—存储空间的管理</h3><p>在为文件分配外存空间时所要考虑的主要问题是：怎样才能有效地利用外存空间和如何提高对文件的访问速度。<br>目前，常用的外存分配方法有:</p><ul><li>连续分配</li><li>链接分配</li><li>索引分配</li></ul><h4 id="连续分配-Continuous-Allocation"><a href="#连续分配-Continuous-Allocation" class="headerlink" title="连续分配 Continuous Allocation"></a>连续分配 Continuous Allocation</h4><p>连续分配(Continuous Allocation)要求为每一个文件分配一组相邻接的盘块。一组盘块的地址定义了磁盘上的一段线性地址。<br>把逻辑文件中的数据顺序地存储到物理上邻接的各个数据块中，这样形成的物理文件可以进行顺序存取。<br>文件目录中为每个文件建立一个表项，其中记载文件的第一个数据块地址及文件长度。<br>对于顺序文件，连续读&#x2F;写多个数据块内容时，性能较好。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1FileSystem-2024-05-13-21-28-25.png" style="zoom:100%;"></p><p><strong>Pros</strong></p><ul><li>顺序访问容易。能很快检索文件中的一个数据块。例如，如果一个文件的第一个数据块的序号为 x，需要检索文件的第 y 块，则该数据块在外存中的位置为 x+y-1。</li><li>顺序访问在处理大量连续数据(如视频和音频流)时非常有效。磁头移动距离短，效率最高</li></ul><p><strong>Cons</strong></p><ul><li>要求有连续的存储空间。该分配方案可能会导致磁盘碎片，严重降低外存空间的利用率。解决方法之一，系统定期或不定期采用紧凑技术，将小分区合并为大的、连续分区，将文件占用空间合并在一起。</li><li>必须事先知道文件的长度。空间利用率不高；不利于文件尺寸的动态增长。</li></ul><h4 id="链接分配-Linked-Allocation"><a href="#链接分配-Linked-Allocation" class="headerlink" title="链接分配 Linked Allocation"></a>链接分配 Linked Allocation</h4><p>连续分配的文件分区太大，不利于存储空间的有效利用。<br>如果在将一个逻辑文件存储到外存上时，可以考虑将文件装到多个离散的盘块中。<br>链接文件：采用链接分配方式时，可通过在每个盘块上的链接指针，将同属于一个文件的多个离散的盘块链接成一个链表，把这样形成的物理文件称为链接文件。</p><h5 id="隐式链接-Implicit-Linking"><a href="#隐式链接-Implicit-Linking" class="headerlink" title="隐式链接 Implicit Linking"></a>隐式链接 Implicit Linking</h5><p>在采用隐式链接分配方式时，在文件目录的每个目录项中，都须含有指向链接文件第一个盘块和最后一个盘块的指针。每个盘块中都含有一个指向下一个盘块的指针。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1FileSystem-2024-05-13-21-53-18.png" style="zoom:100%;"></p><p><strong>Cons</strong><br>隐式链接分配方式的主要问题在于：它只适合于顺序访问，它对随机访问是极其低效的。<br>如果要访问文件所在的第 i 个盘块，则必须先读出文件的第一个盘块，然后顺序地查找直至第 i 块。</p><p>为了提高检索速度和减小指针所占用的存储空间，可以将几个盘块组成一个簇(cluster)。<br>比如，一个簇可包含 4 个盘块，在进行盘块分配时，是以簇为单位进行的。在链接文件中的每个元素也是以簇为单位的。<br>这减少了查找时间和指针所占空间，但增大了内部碎片,同时这种改进也是非常有限的。</p><h5 id="显式链接-Explicit-Linking"><a href="#显式链接-Explicit-Linking" class="headerlink" title="显式链接 Explicit Linking"></a>显式链接 Explicit Linking</h5><p>这是指把用于链接文件各物理块的指针，显式地存放在内存的一张链接表中。<br>整个磁盘仅设置一张文件分配表 FAT(File Allocation Table)</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1FileSystem-2024-05-14-10-47-47.png" style="zoom:100%;"><p>在该表中，凡是属于某一文件的第一个盘块号，均作为文件地址被填入相应文件的 FCB (File Control Block)的“物理地址”字段中。<br>查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且大大减少了访问磁盘的次数。<br>由于分配给文件的所有盘块号都放在该表中，故把该表称为文件分配表 FAT (File Allocation Table)。</p><p>链接分配方式虽然解决了连续分配方式所存在的问题， 但又出现了另外两个问题， 即：<br>(1) 不能支持高效的直接存取。要对一个较大的文件进行直接存取，须首先在 FAT 中顺序地查找许多盘块号。<br>(2) FAT 需占用较大的内存空间。由于一个文件所占用盘块的盘块号是随机地分布在 FAT 中的，因而只有将整个 FAT 调入内存，才能保证在 FAT 中找到一个文件的所有盘块号。</p><blockquote><p><strong>NTFS (New Technology File System)</strong><br>NTFS 是 Microsoft 在 Windows NT 3.1 中引入的文件系统，它提供了比 FAT 更高级的特性和性能。在 NTFS 中，文件的存储和链接方式与 FAT 有所不同。NTFS 使用了一种叫做 B+ 树的数据结构来存储文件和目录的信息。每个文件或目录在 NTFS 中都有一个叫做 MFT (Master File Table) 记录。MFT 记录包含了文件的所有信息，包括其属性、位置、大小等。对于较小的文件，其数据可能直接存储在 MFT 记录中。对于较大的文件，MFT 记录会包含一个指向文件数据块的指针列表。<br>总的来说，FAT 和 NTFS 在链接文件数据方面使用了不同的数据结构和算法。FAT 使用了相对简单的链表结构，而 NTFS 使用了更复杂但也更高效的 B+ 树结构。</p></blockquote><h4 id="索引分配-Indexed-Allocation"><a href="#索引分配-Indexed-Allocation" class="headerlink" title="索引分配 Indexed Allocation"></a>索引分配 Indexed Allocation</h4><h5 id="单级索引分配-Single-level-Indexing"><a href="#单级索引分配-Single-level-Indexing" class="headerlink" title="单级索引分配 Single-level Indexing"></a>单级索引分配 Single-level Indexing</h5><p>索引分配能解决连续分配和链接分配存在的诸多问题。<br>原理：为每个文件分配一个索引块(表)，再把分配给该文件的所有盘块号都记录在该索引块中，因而该索引块就是一个含有许多盘块号的数组。<br>在建立一个文件时，只需在为之建立的目录项中填上指向该索引块的指针。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1FileSystem-2024-05-14-13-11-51.png" style="zoom:100%;"></p><p><strong>Pros</strong><br>索引分配方式支持直接访问。当要读文件的第 i 个盘块时，可以方便地直接从索引块中找到第 i 个盘块的盘块号；<br>基于数据块的分区能消除外部碎片<br><strong>Cons</strong><br>大文件索引项较多，可能使一个数据块容纳不了一个文件的所有分区的索引。索引块可能要花费较多的外存空间。每当建立一个文件时，便须为之分配一个专门的索引块，将分配给该文件的所有盘块号记录于其中。对于小文件如果采用这种方式，索引块的利用率将是极低的。</p><h5 id="两级索引分配-Two-level-Indexing"><a href="#两级索引分配-Two-level-Indexing" class="headerlink" title="两级索引分配 Two-level Indexing"></a>两级索引分配 Two-level Indexing</h5><p>当文件太大，其一级索引块太多时，应为这些索引块再建立一级索引，形成两级索引分配方式。<br>即系统再分配一个索引块，作为第一级索引的索引块，将第一块、第二块……等索引块的盘块号填入到此索引表中</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1FileSystem-2024-05-14-13-20-23.png" style="zoom:100%;" alt ="混合索引方式"><h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><p>文件管理要解决的重要问题之一是如何为新创建的文件分配存储空间。<br>存储空间的基本分配单位是磁盘块。<br>其分配方法与内存的分配有许多相似之处，即同样可采取连续分配方式或离散分配方式。<br>系统应为分配存储空间而设置相应的数据结构；其次，系统应提供对存储空间进行分配和回收的手段。</p><p>文件存储空间的管理方法包括：</p><ul><li>空闲分区表</li><li>空闲链表法</li><li>位示图</li><li>成组链接法</li></ul><h3 id="空闲表法-Free-Space-Table"><a href="#空闲表法-Free-Space-Table" class="headerlink" title="空闲表法 Free Space Table"></a>空闲表法 Free Space Table</h3><p>空闲表法属于连续分配方式，它为每个文件分配一块连续的存储空间，即系统也为外存上的所有空闲区建立一张空闲表，每个空闲区对应于一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块数等信息。</p><table><thead><tr><th>表项序号</th><th>空闲区起始盘块号</th><th>空闲盘块数</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>4</td></tr><tr><td>2</td><td>9</td><td>3</td></tr><tr><td>3</td><td>15</td><td>5</td></tr><tr><td>4</td><td>…</td><td>…</td></tr></tbody></table><p><strong>Steps</strong></p><ul><li>为文件分配存储空间时，首先顺序查找空闲分区表中的各个表项，直至找到第一个大小适合的空闲分区。</li><li>可以采用首次适应分配算法、最佳适应分配算法等。</li><li>然后，将该分区分配给文件，同时修改空闲分区表，删除相应表项。</li><li>当删除文件释放出空间时，系统回收其存储空间，合并相邻空闲分区.</li></ul><p>对交换分区一般都采用连续分配方式。<br>对于文件系统，当文件较小(1 ～ 4 个盘块)时，仍采用连续分配方式，为文件分配相邻接的几个盘块；<br>当文件较大时，便采用离散分配方式。</p><p><strong>Pros</strong><br>实现简单。对于最佳适应分配算法，可以将各空闲分区按照（长度）从小到大的顺序进行排列，再利用有效的查找算法，能很快找到需要大小的空闲分区<br><strong>Cons</strong><br>当存储空间中的空闲分区分布较分散且数量较多时，空闲分区表将会很大。需要很大的内存空间，会降低空闲分区表的检索速度。</p><h3 id="空闲链表法-Linked-Free-Space-List"><a href="#空闲链表法-Linked-Free-Space-List" class="headerlink" title="空闲链表法 Linked Free Space List"></a>空闲链表法 Linked Free Space List</h3><p>用专门的空闲分区表登记空闲分区信息会浪费一定的存储空间，而且不适合登记分散且数目很多的空闲分区，不利于基于存储块的链接文件和索引文件的存储空间分配。<br>空闲链表法是将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，可把链表分成两种形式：</p><ul><li>空闲盘块链</li><li>空闲盘区链</li></ul><h4 id="空闲盘区链-Free-Space-List"><a href="#空闲盘区链-Free-Space-List" class="headerlink" title="空闲盘区链 Free Space List"></a>空闲盘区链 Free Space List</h4><p>将磁盘上的所有空闲空间，以盘块为单位拉成一条链。<br>当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户。<br>当用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。</p><p><strong>Pros</strong><br>用于分配和回收一个盘块的过程非常简单.</p><h4 id="空闲盘块链-Free-Block-List"><a href="#空闲盘块链-Free-Block-List" class="headerlink" title="空闲盘块链 Free Block List"></a>空闲盘块链 Free Block List</h4><p>将磁盘上的所有空闲盘区(每个盘区可包含若干个盘块)拉成一条链。<br>在每个盘区上含有用于指示下一个空闲盘区的指针和能指明本盘区大小(盘块数)的信息。<br>分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法。<br>在回收盘区时，同样也要将回收区与相邻接的空闲盘区相合并。</p><p>为了提高对空闲盘区的检索速度，可以采用显式链接方法，亦即，在内存中为空闲盘区建立一张链表。<br>每个分区结点内容：起始盘块号、盘块数、指向下一个空闲盘区的指针。</p><p><strong>Cons</strong><br>一段时间以后，可能会使空闲分区链表中包含太多小分区，使文件分配到的存储空间过分离散。<br>删除一个由许多离散小分区组成的文件时，将回收的小分区链接到空闲分区链表中需要很长时间。<br>若一个文件申请连续存储空间，则需要花费较长的时间查找相邻的空闲分区。<br>因此，这种空闲空间组织方法适合于非连续存储文件。</p><h3 id="位示图-Bit-Map"><a href="#位示图-Bit-Map" class="headerlink" title="位示图 Bit Map"></a>位示图 Bit Map</h3><p>利用二进制位 0、1 表示存储空间中存储块的使用状态。例如规定空闲分区为 0，已分配分区为 1<br>磁盘上的所有盘块都有一个二进制位与之对应，这样，由所有盘块所对应的位构成一个集合，称为位示图。<br>通常可用 m × n 个位数来构成位示图，并使 m × n 等于磁盘的总块数。位示图也可描述为一个二维数组<code>map[m][n]</code></p><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>2</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>3</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>4</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p><strong>Steps</strong><br>申请盘块</p><p>(1) 顺序扫描位示图(m×n)，从中找出一个或一组其值为<code>0</code>的二进制位。<br>(2) 将所找到的一个或一组二进制位转换成与之相应的盘块号。<br>假 找到的其值为<code>0</code>的二进制位位于位示图的第 i 行、第 j 列，则其相应的盘块号应按下式计算：<br>b &#x3D; n(i- 1) + j<br>(3) 修改位示图，令 <code>map[i,j]=1</code></p><p>回收盘块<br>(1) 将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为：</p><p>$$<br>i &#x3D; (b - 1) DIV n + 1<br>j &#x3D; (b - 1) MOD n + 1<br>$$</p><p>(2) 修改位示图,令 <code>map[i,j] =0</code></p><p><strong>Pros</strong><br>可以容易地找到一个或一组连续的空闲分区。例如，需要找到 8 个相邻接的空闲盘块，只需在位示图中找出 8 个其值连续为“0”的位即可。<br>BitMap 占据空间为 Disk Space(Byte) ÷ （Block Size × 8），对于容量较小的磁盘，位示图占用的空间会很小<br><strong>Cons</strong><br>对于一个 16GB 的磁盘，若数据块大小为 512 字节，则位示图大小为 4MB，大约需要占用 8000 个磁盘块的存储空间。</p><div>$$Block_num = \frac{16GB}{512B} = 2^{25}个\\即共有2^{25}个0或1,每个位占1bit\\所以位示图大小为\frac{2^{25}Bit}{8Bit/Byte} = 4MB$$</div>很难一次性将该位示图全部装入内存。即使内存足够大，可以存放全部或绝大部分位示图数据，搜索一个很大的位示图将会降低文件系统的性能。<p>尤其当磁盘空间快用完，剩下的空闲磁盘块很少时，文件系统的性能将严重降低</p><h3 id="成组链接法-Grouping-Linkage"><a href="#成组链接法-Grouping-Linkage" class="headerlink" title="成组链接法 Grouping Linkage"></a>成组链接法 Grouping Linkage</h3><p>将磁盘所有空闲盘块分组；<br>设置空闲盘块号栈，存放当前可用的一组空闲盘块的盘块号和栈中尚有的空闲盘块总数；<br>后一组的所有盘块号以及盘块总数登记在前一组的第一个盘块中……依次类推，组与组之间形成链接关系；<br>最后一组少登记一个盘块号，多登记一个空闲盘块链的结束标志。</p><p><strong>空闲盘块的组织</strong></p><ol><li>空闲盘块号栈：用来存放当前可用的一组空闲盘块的盘块号(最多含 100 个号)，以及栈中尚有的空闲盘块号数 N。顺便指出，N 还兼作栈顶指针用。例如，当 N&#x3D;100 时，它指向 S.free(99)。由于栈是临界资源，每次只允许一个进程去访问，故系统为栈设置了一把锁。（只有这个是放在内存中的，其它是在磁盘上。）</li><li>文件区中的所有空闲盘块被分成若干个组，比如，将每 100 个盘块作为一组。假定盘上共有 10 000 个盘块，每块大小为 1 KB，其中第 201 ～ 7999 号盘块用于存放文件，即作为文件区，这样，该区的最末一组盘块号应为 7901 ～ 7999；次末组为 7801 ～ 7900……；第二组的盘块号为 301 ～ 400；第一组为 201 ～ 300，如上图右部所示。</li><li>将每一组含有的盘块总数 N 和该组所有的盘块号记入其前一组的第一个盘块（从后往前分组）的 S.free(0)～ S.free(99)中。</li><li>将第一组的盘块总数和所有的盘块号记入空闲盘块号栈中，作为当前可供分配的空闲盘块号。</li><li>最末一组只有 99 个盘块，其盘块号分别记入其前一组的 S.free(1) ～ S.free(99)中，而在 S.free(0)中则存放“0”，作为空闲盘块链的结束标志。(注：最后一组的盘块数应为 99，不应是 100，因为这是指可供使用的空闲盘块，其编号应为(1 ～ 99)，0 号中放空闲盘块链的结尾标志。)</li></ol><p><strong>空闲盘块的分配与回收</strong></p><ol><li>当系统要为用户分配文件所需的盘块时，须调用盘块分配过程来完成。该过程首先检查空闲盘块号栈是否上锁，如未上锁，便从栈顶取出一空闲盘块号，将与之对应的盘块分配给用户，然后将栈顶指针下移一格。</li><li>若该盘块号已是栈底，即 S.free(0)，这是当前栈中最后一个可分配的盘块号。由于在该盘块号所对应的盘块中记有下一组可用的盘块号，因此，须调用磁盘读过程，将栈底盘块号所对应盘块的内容读入栈中，作为新的盘块号栈的内容，并把原栈底对应的盘块分配出去(其中的有用数据已读入栈中)。然后，再分配一相应的缓冲区(作为该盘块的缓冲区)。最后，把栈中的空闲盘块数减 1 并返回。</li><li>在系统回收空闲盘块时，须调用盘块回收过程进行回收。它是将回收盘块的盘块号记入空闲盘块号栈的顶部，并执行空闲盘块数加 1 操作。当栈中空闲盘块号数目已达 100 时，表示栈已满，便将现有栈中的 100 个盘块号记入新回收的盘块中，再将其盘块号作为新栈底。</li></ol><h2 id="文件目录-File-Directory"><a href="#文件目录-File-Directory" class="headerlink" title="文件目录 File Directory"></a>文件目录 File Directory</h2><h3 id="文件目录管理"><a href="#文件目录管理" class="headerlink" title="文件目录管理"></a>文件目录管理</h3><p><strong>文件控制块</strong>（FCB）：用于描述和控制文件的数据结构。它包括：</p><ul><li>基本信息：文件名、文件类型等；</li><li>地址信息：卷（存储文件的设备）、起始地址（起始物理地址）、文件长度（以字节、字或块为单位）等。</li><li>访问控制信息：文件所有者、访问信息（用户名和口令等）、合法操作等；</li><li>使用信息：创建时间、创建者身份、当前状态、最近修改时间、最近访问时间等。</li><li>…</li></ul><p><strong>文件目录</strong>：文件控制块的有序集合。</p><p>对目录管理的要求如下：<br>(1)实现“按名存取”。<br>(2) 提高对目录的检索速度。<br>(3) 文件共享。<br>(4) 允许文件重名。</p><p><strong>目录项的两种组织方式</strong>：</p><ol><li>FCB 存储全部目录内容</li><li>存储部分目录信息，如文件名、索引节点指针等，其余部分保存在索引节点（i Node）。打开文件时将索引节点从磁盘读到内存中。</li></ol><blockquote><p>iNode（索引节点）是 Unix 和类 Unix 操作系统中的文件系统的一个重要概念。每个文件或目录在文件系统中都由一个 iNode 来表示。iNode 包含了关于文件系统对象（如普通文件、目录或者其他类型）的重要信息，包括：</p><ul><li>文件大小</li><li>文件所有者和组</li><li>文件权限（读、写、执行）</li><li>文件创建、访问和修改的时间戳</li><li>文件的数据块的位置</li></ul><p>iNode 并不包含文件名或文件的路径，这些信息是由目录文件维护的。目录文件包含了文件名到 iNode 的映射。这种设计允许在文件系统中实现一些复杂的功能，如硬链接和软链接。</p><p>需要注意的是，每个 iNode 都有一个唯一的 iNode 编号，这个编号在文件系统中用来唯一标识一个文件或目录。</p></blockquote><p><strong>目录文件及操作</strong><br>目录文件：一个文件目录也被看做是一个文件，即目录文件。是多个文件的目录项构成的一种特殊文件。目录的操作包括</p><ul><li>搜索目录</li><li>创建目录</li><li>删除目录</li><li>显示目录</li><li>修改目录</li></ul><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h4><p>所有用户的全部文件目录保存在一张目录表中，每个文件的目录项占用一个表项。<br><strong>Pros</strong> 简单，易于实现，能实现目录管理的基本功能——按名存取。<br><strong>Cons</strong> 查找速度慢，不允许重名，不便于实现文件共享</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dir_entry_1-&gt;file1</span><br><span class="line">dir_entry_1-&gt;file2</span><br><span class="line">...</span><br><span class="line">dir_entry_n-&gt;filen</span><br></pre></td></tr></table></figure><h4 id="两级目录结构"><a href="#两级目录结构" class="headerlink" title="两级目录结构"></a>两级目录结构</h4><p>主文件目录 MFD(Master File Directory)、用户文件目录 UFD(User File Directory)<br><strong>Pros</strong> 一定程度解决了重名问题,提高了文件目录检索效率,能实现简单的文件共享<br><strong>Cons</strong> 不便用户文件的逻辑分类；进一步解决重名、共享、检索效率等问题</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">MainFolder</span><br><span class="line">│</span><br><span class="line">├── User1</span><br><span class="line">│   │</span><br><span class="line">│   ├── file1</span><br><span class="line">│   │</span><br><span class="line">│   └── file2</span><br><span class="line">│</span><br><span class="line">├── User2</span><br><span class="line">│   │</span><br><span class="line">│   ├── file1</span><br><span class="line">│   │</span><br><span class="line">│   └── file2</span><br><span class="line">│</span><br><span class="line">└── User3</span><br><span class="line">    │</span><br><span class="line">    ├── file1</span><br><span class="line">    │</span><br><span class="line">    └── file2</span><br></pre></td></tr></table></figure><h4 id="层次目录结构"><a href="#层次目录结构" class="headerlink" title="层次目录结构"></a>层次目录结构</h4><p><strong>多级目录&#x2F;树形目录结构</strong></p><ol><li><strong>目录结构</strong>：多级目录结构又称为树型目录结构，主目录在这里被称为根目录，把数据文件称为树叶，其它的目录均作为树的结点。</li><li><strong>路径名</strong>：从树的根（即主目录）开始，把全部目录文件名与数据文件名，依次地用“&#x2F;”连接起来，即构成该数据文件的路径名（path name）。<br>系统中的每一个文件都有惟一的路径名。</li><li><strong>当前目录</strong>：为每个进程设置一个“当前目录”，又称为“工作目录”进程对各文件的访问都相对于“当前目录”而进行。</li></ol><p><strong>Pros</strong></p><ul><li>层次结构清晰，便于管理和保护</li><li>有利于文件分类</li><li>解决重名问题</li><li>提高文件检索速度</li><li>能进行存取权限的控制</li></ul><p><strong>Cons</strong><br>查找一个文件按路径名逐层检查，由于每个文件都放在外存，多次访盘影响速度</p><h3 id="目录查询技术"><a href="#目录查询技术" class="headerlink" title="目录查询技术"></a>目录查询技术</h3><p>★ 对目录进行查询的方式有两种：线性检索法和 Hash 方法:</p><ol><li><strong>线性检索法</strong><br>线性检索法又称为顺序检索法。<ul><li>在单级目录中，利用用户提供的文件名，用顺序查找法直接从文件目录中找到指名文件的目录项。</li><li>在树型目录中，用户提供的文件名是由多个文件分量名组成的路径名，此时须对多级目录进行查找。</li></ul></li></ol><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1FileSystem-2024-05-15-12-12-52.png" style="zoom:100%;" alt="查找/usr/ast/mbox"><ol start="2"><li>Hash 方法<ul><li>Hash 方法: 建立了一张 Hash 索引文件目录，系统利用用户提供的文件名并将它变换为文件目录的索引值，再利用该索引值到目录中去查找。</li><li>Hash 方法将显著地提高检索速度。</li><li>在文件名中使用了通配符“* ”、“？”等，系统便无法利用 Hash 法检索目录，因此，需要利用线性查找法查找目录。</li><li>在进行文件名的转换时，不同的文件名可能转换为相同的 Hash 值，即 Hash 冲突。</li><li><strong>Steps</strong> - 在利用 Hash 值查找目录时，如果目录表中相应的目录项是空的，则表示系统中并无指定文件。 - 如果目录项中的文件名与指定文件名相匹配，则表示该目录项正是所要寻找的文件所对应的目录项，故而可从中找到该文件所在的物理地址。 - 如果在目录表的相应目录项中的文件名与指定文件名并不匹配，则表示发生了“Hash 冲突”。 - 解决 Hash 冲突的方法 ：将其 Hash 值再加上一个常数（该常数应与目录表的长度值互质），形成新的索引值，再返回到第一步重新开始查找。<blockquote><p>使用一个和哈希表大小互质的步长，我们可以确保在经过足够多的步骤后，能够探测到哈希表中的每一个位置。这是因为两个互质的数的最小公倍数是它们的乘积，这意味着通过在原哈希值上加上步长，经过哈希表大小的步数后，我们可以覆盖到哈希表中的所有位置</p></blockquote></li></ul></li></ol><h2 id="文件共享和访问控制"><a href="#文件共享和访问控制" class="headerlink" title="文件共享和访问控制"></a>文件共享和访问控制</h2><p>文件共享的有效控制涉及两个方面：</p><ul><li>同时存取（Simultaneous Access）</li><li>存取权限（Access Rights）</li></ul><p><strong>控制同时存取</strong></p><ul><li>允许多个用户同时读文件内容，但不允许同时修改，或同时读且修改文件内容。</li><li>共享用户之一修改文件内容时，可以将整个文件作为临界资源，锁定整个文件，不允许其他共享用户同时读或写文件。</li><li>也可以仅仅锁定指定的一条记录，允许其他共享用户读&#x2F;写该文件的其它记录。后者的并发性能更好。</li><li>控制对文件的同时存取涉及进程的同步与互斥问题。</li></ul><p><strong>控制存取权限</strong><br>控制授权用户以合法的方式访问文件，包括：</p><ul><li><strong>执行</strong>（Execution） — 用户可以装载并执行程序，但不允许拷贝程序内容。</li><li><strong>读</strong>（Reading）— 允许用户读文件内容，包括拷贝和执行文件。某些系统严格地将浏览文件内容和拷贝权限分开，可以控制文件只能被浏览（显示），不能被拷贝。</li><li><strong>追加</strong>（Appending）— 允许用户向文件添加数据，通常只能将数据添加到文件尾。但是，不能修改或删除文件内容。例如，超市收银员只能将新结帐的数据添加到文件中，不允许其修改或删除已有的数据。</li><li><strong>更新</strong>（Updating）— 允许用户修改、删除、增加文件内容。包括创建文件、重写文件的全部或部分内容、移动文件的全部或部分数据等操作。</li><li><strong>更改权限</strong> (Changing protection) — 一般只有文件主才能更改共享该文件的其他用户对该文件的存取权限。有的系统允许文件主将更改文件存取权限赋予其他某个用户，但必须限制授权用户更改的权限范围。</li><li><strong>删除</strong> (Deletion) 允许用户删除文件</li></ul><h3 id="文件共享的实现"><a href="#文件共享的实现" class="headerlink" title="文件共享的实现"></a>文件共享的实现</h3><p>在树型结构的目录中，当有两个(或多个)用户要共享一个子目录或文件时，必须将共享文件或子目录链接到两个(或多个)用户的目录中，才能方便地找到该文件。此时该文件系统的目录结构已不再是树型结构，而是个有向非循环图。</p><p>实现文件共享的实质就是可以从不同地方打开同一个文件<br>打开文件的首要步骤就是找到文件的目录项，读取文件在外存的起始地址。<br>实现文件共享的方式：</p><ul><li>利用链接目录项实现法</li><li>利用索引节点实现法</li><li>利用符号链实现法等</li></ul><h4 id="链接目录项实现文件共享"><a href="#链接目录项实现文件共享" class="headerlink" title="链接目录项实现文件共享"></a>链接目录项实现文件共享</h4><p>文件目录项中设置一个链接指针，用于指向共享文件的目录项。</p><ul><li>访问文件时，根据链接指针内容找到共享文件的目录项，读取该目录项中文件起始位置等信息，操作该文件。</li><li>每当有用户（进程）共享文件时，共享文件目录项中的“共享计数”加 1；当用户不再共享该文件，撤消链接指针时，“共享计数”减 1。</li><li>只有当共享文件用户数为 1 时，才能删除共享文件。</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/root</span><br><span class="line">│</span><br><span class="line">├── /dir1</span><br><span class="line">│   │</span><br><span class="line">│   ├── file1 (链接指针-&gt; /root/dirShared/file)</span><br><span class="line">│</span><br><span class="line">├── /dir2</span><br><span class="line">│   │</span><br><span class="line">│   ├── file2 (链接指针-&gt; /root/dirShared/file)</span><br><span class="line">│</span><br><span class="line">└── /dirShared</span><br><span class="line">    │</span><br><span class="line">    └── file</span><br></pre></td></tr></table></figure><h4 id="索引节点实现文件共享"><a href="#索引节点实现文件共享" class="headerlink" title="索引节点实现文件共享"></a>索引节点实现文件共享</h4><blockquote><p>也称为【硬连接】Hard Link<br>硬连接指通过索引节点来进行连接。在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号，称为索引节点号(Inode Index)。在 Linux 中，多个文件名指向同一索引节点是存在的。一般这种连接就是硬连接。硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p></blockquote><p>[[Ch7-1LinuxUnix#索引节点表——inode 结构]]</p><p>文件的物理地址及其它的文件属性等信息，不再是放在目录项中，而是放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。</p><ul><li>由任何用户对文件进行 Append 操作或修改，所引起的相应结点内容的改变(例如，增加了新的盘块号和文件长度等)，都是其他用户可见的，从而也就能提供给其他用户来共享。</li><li>UNIX 操作系统的文件目录项中只包含文件名和指向索引节点的指针，文件的物理地址及其它说明信息保存在索引节点 iNode 中。</li><li>可以通过共享文件索引节点 iNode 来共享文件，即当用户需要共享文件时，在自己的文件目录中新建一个目录项，为共享文件命名(也可用原名)，并将索引节点指针指向共享文件的索引节点。</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/root</span><br><span class="line">│</span><br><span class="line">├── /dir1</span><br><span class="line">│   │</span><br><span class="line">│   ├── file1 (iNode指针-&gt; iNode#123)</span><br><span class="line">│   │</span><br><span class="line">│   └── file3 (iNode指针-&gt; iNode#124)</span><br><span class="line">│</span><br><span class="line">├── /dir2</span><br><span class="line">│   │</span><br><span class="line">│   ├── file2 (iNode指针-&gt; iNode#123)</span><br><span class="line">│   │</span><br><span class="line">│   └── file4 (iNode指针-&gt; iNode#125)</span><br><span class="line">│</span><br><span class="line">└── iNode Table</span><br><span class="line">    │</span><br><span class="line">    ├── iNode#123 (物理地址, 文件属性, 共享计数: 2)</span><br><span class="line">    │</span><br><span class="line">    ├── iNode#124 (物理地址, 文件属性, 共享计数: 1)</span><br><span class="line">    │</span><br><span class="line">    ├── iNode#125 (物理地址, 文件属性, 共享计数: 1)</span><br><span class="line">    │</span><br><span class="line">    └── ...</span><br></pre></td></tr></table></figure><p>在索引结点中还应有一个链接计数 count，用于表示链接到本索引结点(亦即文件)上的用户目录项的数目<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1FileSystem-2024-05-15-13-28-17.png" style="zoom:100%;"></p><ul><li>当用户 C 创建一个新文件时，他便是该文件的所有者，此时将 count 置 1。</li><li>当有用户 B 要共享此文件时，在用户 B 的目录中增加一目录项，并设置一指针指向该文件的索引结点，此时，文件主仍然是 C，count&#x3D;2。</li><li>如果用户 C 不再需要此文件，是否能将此文件删除呢？<br>只能删除硬链接，但是不能删除里面的实际内容，当所有硬链接都删除后，才可以删除其内容和索引节点。</li></ul><h4 id="符号链实现文件共享"><a href="#符号链实现文件共享" class="headerlink" title="符号链实现文件共享"></a>符号链实现文件共享</h4><p>为使 B 能共享 C 的一个文件 F，可以由系统创建一个 LINK 类型的新文件，也取名为 F 并将 F 写入 B 的目录中，以实现 B 的目录与文件 F 的链接；在新文件中只包含被创文件 F 的路径名。这样的链接方法被称为符号链接.<br>新文件中的路径名，则只被看作是符号链。当 B 要访问被链接的文件 F 且正要读 LINK 类新文件时，将被 OS 截获，OS 根据新文件中的路径名去读该文件，于是就实现了用户 B 对文件 F 的共享。</p><p>在利用符号链方式实现文件共享时，只有文件主才拥有指向其索引结点的指针,而共享该文件的其它用户，则只有该文件的路径名，并不拥有指向其索引结点的指针。</p><p><strong>Pros</strong> 能连接任何机器上的文件。每增加一个连接，就增加一个文件名，各用户使用自己的名字去共享文件。<br><strong>Cons</strong> 备份可能会产生多个拷贝。</p><p>符号连接（Symbolic Link），也叫软连接。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">touch</span> file</span><br><span class="line"> <span class="built_in">ln</span> file hard_link_f1 <span class="comment"># 硬连接</span></span><br><span class="line"> <span class="built_in">ln</span> -s file sym_link_f1 <span class="comment"># 软连接</span></span><br><span class="line"> <span class="built_in">ls</span> -li</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出如下，硬链接的inode相同，count=2；软连接的inode不同，count=1</span></span><br><span class="line">total 0</span><br><span class="line">122779 -rw-r--r-- 2 gjx gjx 0 May 22 15:03 file</span><br><span class="line">122779 -rw-r--r-- 2 gjx gjx 0 May 22 15:03 hard_link_f1</span><br><span class="line">122781 lrwxrwxrwx 1 gjx gjx 4 May 22 15:04 sym_link_f1 -&gt; file</span><br></pre></td></tr></table></figure><ul><li>删除符号连接 sym_linkf1,对 file,hard_link_f1 无影响；</li><li>删除硬连接 hard_link_f1，对 file,sym_link_f1 也无影响；</li><li>删除原文件 file，对硬连接 hard_link_f1 没有影响，导致符号连接 sym_link_f1 失效；</li><li>同时删除原文件 file,硬连接 hard_link_f1，整个文件会真正的被删除。</li></ul><h4 id="URL-实现文件共享"><a href="#URL-实现文件共享" class="headerlink" title="URL 实现文件共享"></a>URL 实现文件共享</h4><p>统一资源定位器 URL (Uniform Resource Locator)是 Internet 上用来链接超文本文件的一种方法。<br>它可以链接同一台计算机中的本地文件，也可链接 Internet 中任何主机上的远程文件。<br>一个完整的 URL 包括访问文件的方法（协议）、文件所在的主机域名、目录路径名和文件名几部份。例如</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file:<span class="regexp">//</span><span class="regexp">/C:/</span>Users<span class="regexp">/YourName/</span>Documents/file.txt</span><br><span class="line">http:<span class="regexp">//</span>www.uestc.edu.cn<span class="regexp">/templates/i</span>ndex2k3/index.html</span><br></pre></td></tr></table></figure><h3 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h3><p>不同对象允许实施的操作各不相同。例如，文件可施加读、写、执行等操作，信号量只能施加 <code>wait()</code>和<code>signal()</code>操作。<br>因此，系统为所有对象设置一个允许进程实施操作的操作集，任何对对象的操作必须符合操作集中的规定，防止未授权进程访问对象。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://blog.csdn.net/qq_42145681/article/details/103655253">【操作系统】成组链接法详解</a></p>]]></content>
    
    
    <summary type="html">①介绍文件的概念，文件系统的层次结构和文件的基本操作。②介绍目录管理的要求，文件控制块和索引节点，以及查询技术，文件的共享方式和访问控制机制。③文件的物理结构和外存空间的管理：外存组织的目的，连续组织和链接组织方式，空闲表法和位示图法和成组链接法。</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="操作系统" scheme="https://efterklang.github.io/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Storage Management PartⅢ</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch4-3StorageManagement/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch4-3StorageManagement/</id>
    <published>2024-05-13T12:33:50.000Z</published>
    <updated>2024-06-12T09:25:58.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="虚拟存储器-Virtual-Memory"><a href="#虚拟存储器-Virtual-Memory" class="headerlink" title="虚拟存储器 Virtual Memory"></a>虚拟存储器 Virtual Memory</h2><h3 id="虚拟存储器的引入"><a href="#虚拟存储器的引入" class="headerlink" title="虚拟存储器的引入"></a>虚拟存储器的引入</h3><p><strong>问题的提出</strong><br>一个程序要求的存储容量超过整个内存空间<br>有大量的作业需要装入内存运行而内存空间不足</p><p><strong>解决方案</strong><br>从物理上增加内存容量。但这会增加系统成本，并且增加是有限的<br>从逻辑上增加内存容量。这正是虚拟存储技术所要解决的主要问题。</p><hr><p><strong>常规存储器管理方式的特征</strong><br>“一次性”: 要求将一个作业全部装入内存才能运行，<br>1）大作业无法运行。<br>2）限制作业并发执行的程度。<br>“驻留性”: 作业装入后一直驻留内存直到作业完成。<br>内存中存在一些已无用的、或暂时不用的程序或数据，浪费内存空间。<br>一次性和驻留性严重降低内存利用率，减少系统吞吐量。<br><strong>内存的扩充方法</strong></p><ol><li>物理扩充：<br>增加硬件投入，受机器自身和成本的限制。</li><li>逻辑扩充：</li></ol><ul><li>覆盖（overlay）应用程序手动把需要的指令和数据保存在内存中；解决了“一次性”问题。</li><li>对换（swapping）操作系统自动把暂时不能执行的程序保存到外存中;解决了“驻留性”问题。</li><li>虚拟存储 在有限容量的内存中，自动装入更多更大的程序</li></ul><h3 id="局部性原理-Principle-of-Locality"><a href="#局部性原理-Principle-of-Locality" class="headerlink" title="局部性原理 Principle of Locality"></a>局部性原理 Principle of Locality</h3><p>程序执行的局部性原理：程序的执行总是呈现局部性。即在一个较短的时间段内，程序的执行仅限于某个部分；相应的，它所访问的存储空间也局限于某个区域。<br>因此，只要保证进程执行所需的部分程序和数据驻留在内存，一段时间内进程都能顺利执行。</p><p>局限性又表现在下述两个方面：</p><ol><li><strong>时间局限性</strong><br>如果程序中的某条指令一旦执行，则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。<br>产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作。</li><li><strong>空间局限性</strong><br>一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。<br>程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li></ol><p>不同程序编写方法的局部性特征</p><p>页面大小为 4K，分配给每个进程的物理页框数为 1。在一个进程中，定义了如下的二维数组<code>int A[1024][1024]</code>，该数组<strong>按行</strong>存放在内存，每一行放在一个页面中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 程序编写方法1：</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">    A[i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 程序编写方法2：</span></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;<span class="number">1024</span>; j++)</span><br><span class="line">    A[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">页号    页内数据</span><br><span class="line">0000    a0,0         a0,1        a0,2   ……………………        a0,1023</span><br><span class="line">0001    a1,0         a1,1        a1,2   ……………………        a1,1023</span><br><span class="line">        ……………………………</span><br><span class="line">        ……………………………</span><br><span class="line">1023    a1023,0      a1023,1   ……………………....…......... a1023,1023</span><br></pre></td></tr></table></figure><p>编写方式 1 发生了大量的缺页中断，因为程序按行存放，每次访问都会跨页，共计$1024 \times 1024 &#x3D; ^{24}$次缺页中断。<br>编写方式 2 发生了较少的缺页中断，共计$2^{10}$次缺页中断。</p><blockquote><p><strong>缺页中断</strong>（Page Fault）是计算机操作系统中的一种中断或异常，当程序访问一个页面时，如果这个页面已经在物理内存中，那么就可以直接读取或者写入。但是，如果这个页面在虚拟内存中，而并没有加载到物理内存中，那么就会发生缺页中断。</p></blockquote><h3 id="虚拟存储器概述"><a href="#虚拟存储器概述" class="headerlink" title="虚拟存储器概述"></a>虚拟存储器概述</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>虚拟存储器</strong>（Virtual Memory）是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定<br>其运行速度接近于内存速度，而成本却又接近于外存。<br>虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、中、小型机器和微型机中。</p><ul><li>当进程运行时，先将当前要运行的部分程序装入内存，其他部分暂留外存；</li><li>当要执行的指令不在内存时，处理器发生中断，通知操作系统将所缺部分从外存调入内存，保证程序继续执行；</li><li>当内存不足时，允许程序部分换入、换出。</li></ul><h4 id="虚拟存储器的基本工作情况"><a href="#虚拟存储器的基本工作情况" class="headerlink" title="虚拟存储器的基本工作情况"></a>虚拟存储器的基本工作情况</h4><ol><li>基于局部性原理。一个作业运行前，仅将那些当前要运行的页面（段）装入内存启动运行，其余暂在外存。</li><li>若运行所需页面（段）不在内存，则利用请求调页（段）功能将其调入内存。</li><li>若此时内存满，则利用置换功能，将内存中暂时不用的部分页面（段）调至外存，再将所需页面（段）调入。</li><li>这样，可实现大程序在小内存中运行，也可实现内存中同时装入更多的进程并发执行。</li></ol><h4 id="虚存容量"><a href="#虚存容量" class="headerlink" title="虚存容量"></a>虚存容量</h4><p>虚拟存储器虽然给用户提供了特大地址空间，但其容量不是无限大，主要受两个方面的限制：</p><ol><li>指令中表示地址的字长：这是由 CPU 的架构决定的。例如，如果 CPU 的有效地址长度为 32 位，那么它能够表示的地址空间最大为$2^{32}$，也就是 4GB。这意味着虚拟内存的最大容量为 4GB。这与物理内存的大小无关，即使物理内存小于 4GB，虚拟内存依然可以达到 4GB。但是，如果物理内存大于 4GB，那么超出 4GB 的部分将无法被 32 位的 CPU 编址。</li><li>外存的容量（对换区）：虚拟内存的另一个部分存储在硬盘的交换区中。如果硬盘的空间有限，那么虚拟内存的容量也会受到限制。即使 CPU 可以支持更大的虚拟内存，如果硬盘空间不足，那么虚拟内存的实际可用空间也会受到限制。</li></ol><h4 id="虚拟存储器的特征"><a href="#虚拟存储器的特征" class="headerlink" title="虚拟存储器的特征"></a>虚拟存储器的特征</h4><p>虚拟存储器具有以下主要特征：</p><ol><li><strong>多次性</strong> 多次性是指一个作业被分成多次调入内存运行。</li><li><strong>对换性</strong> 对换性是指作业的运行过程中进行换进、换出。换进和换出能有效地提高内存利用率。</li><li><strong>虚拟性</strong> 虚拟性是指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。</li></ol><blockquote><p>虚拟性是以多次性和对换性为基础的；而多次性和对换性又必须建立在离散分配的基础上。</p></blockquote><h3 id="虚拟存储管理与对换技术的区别"><a href="#虚拟存储管理与对换技术的区别" class="headerlink" title="虚拟存储管理与对换技术的区别"></a>虚拟存储管理与对换技术的区别</h3><table><thead><tr><th>技术</th><th>处理单位</th><th>主存容量大于系统空闲量时的处理方式</th></tr></thead><tbody><tr><td>虚拟存储管理</td><td>页或段</td><td>进程仍能运行</td></tr><tr><td>对换技术（中级调度，挂起和激活）</td><td>进程</td><td>无法解除挂起</td></tr></tbody></table><h3 id="虚拟存储器的实现方法"><a href="#虚拟存储器的实现方法" class="headerlink" title="虚拟存储器的实现方法"></a>虚拟存储器的实现方法</h3><h4 id="请求分页系统"><a href="#请求分页系统" class="headerlink" title="请求分页系统"></a>请求分页系统</h4><p>它是在纯分页系统的基础上增加了请求调页、页面置换两大功能所形成的页式虚拟存储系统。为了实现请求调页、页面置换两大功能，系统必须提供如下的硬件支持：</p><ol><li>请求分页的页表机制。</li><li>缺页中断机构。</li><li>地址变换机构。</li></ol><p>此外，实现请求调页、页面置换两大功能还需得到 OS 的支持。</p><h4 id="请求分段系统"><a href="#请求分段系统" class="headerlink" title="请求分段系统"></a>请求分段系统</h4><p>它是在纯分段系统的基础上增加了请求调段、分段置换两大功能所形成的段式虚拟存储系统。为了实现请求调段、分段置换两大功能，系统必须提供如下的硬件支持：</p><ol><li>请求分段的段表机制。</li><li>缺段中断机构。</li><li>地址变换机构。</li></ol><p>此外，实现请求调段、分段置换两大功能还需得到 OS 的支持。</p><h4 id="段页式虚拟系统"><a href="#段页式虚拟系统" class="headerlink" title="段页式虚拟系统"></a>段页式虚拟系统</h4><p>目前，许多虚拟存储管理系统是建立在段页式系统的基础上的，通过增加了请求调页、页面置换两大功能所形成的段页式虚拟存储系统。<br>如：Intel 80386 处理机便支持段页式虚拟存储系统。</p><h3 id="抖动-Thrashing"><a href="#抖动-Thrashing" class="headerlink" title="抖动 Thrashing"></a>抖动 Thrashing</h3><p>当进程要求装入新的页面或程序段时，如果当前没有足够的空闲空间，需要交换一些页面或段到外存。如果被交换出去的页面或段很快将被进程使用，则又需要将其换入内存。<br>如果系统花费大量的时间把程序和数据频繁地换入和换出内存而不是执行用户指令，那么，称系统出现了抖动。出现抖动现象时，系统显得非常繁忙，但是吞吐量很低，甚至产出为零。<br>根本原因：选择的页面或段不恰当。</p><h2 id="请求分页存储管理方式-Demand-Paging"><a href="#请求分页存储管理方式-Demand-Paging" class="headerlink" title="请求分页存储管理方式 Demand Paging"></a>请求分页存储管理方式 Demand Paging</h2><h3 id="原理及实现"><a href="#原理及实现" class="headerlink" title="原理及实现"></a>原理及实现</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>作业运行时，只将当前的一部分装入内存其余的放在辅存，一旦发现访问的页不在主存中，则发出缺页中断，由 OS 将其从辅存调入主存，如果内存无空块，则根据某种算法选择一个页淘汰以便装入新的页面。<br>利用这种方法，可使更多的作业处于就绪状态，且能支持比主存容量大的作业在系统中运行。从而提高存储空间利用率。<br>为了实现请求调页、页面置换两大功能，系统必须提供如下的硬件支持：</p><ol><li>请求分页的页表机制。</li><li>缺页中断机构。</li><li>地址变换机构。</li></ol><h4 id="页表机制-Page-Table"><a href="#页表机制-Page-Table" class="headerlink" title="页表机制 Page Table"></a>页表机制 Page Table</h4><p>在虚拟存储系统中的所有的页表，其页描述子有了新的扩充，这是进行地址变换机构所必须的，增加四个信息标识位。</p><table><thead><tr><th>页号</th><th>页框号 Q</th><th>状态位 D</th><th>访问位 A</th><th>修改位 M</th><th>外存地址</th></tr></thead></table><ol><li><strong>状态位&#x2F;存在位</strong>D：用于说明该页是否已调入内存，供程序访问时参考；<br><code>D=0，该页不在内存;D=1，该页在内存</code></li><li><strong>访问位</strong>A：用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问，提供给置换算法选择换出页面时参考。<br><code>A=0，该页未被访问;A=1，该页被访问</code></li><li><strong>修改位</strong>M：用于表示该页在调入内存后是否被修改过，也是提供给置换算法在换出页面时是否将该页面写回外存作参考。<br><code>M=0，该页在内存中未被修改;M=1，该页在内存中已经被修改</code></li><li><strong>外存地址</strong>：用于指出该页在外存上的地址，供调入该页时使用。</li></ol><h4 id="缺页中断机构-Page-Fault-Interrupt"><a href="#缺页中断机构-Page-Fault-Interrupt" class="headerlink" title="缺页中断机构 Page Fault Interrupt"></a>缺页中断机构 Page Fault Interrupt</h4><p>由上述页表机制知道，状态位记录了访问页面是否在内存。在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断，也称为缺页故障。OS 接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使作业继续运行下去。<br>缺页中断是一种特殊的中断，与一般中断相比，主要表现为：</p><ul><li>在指令执行期间产生和处理中断信号。通常，CPU 只能在指令之间接受中断；然而，一个缺页中断要求在指令执行中间得到服务，即发现所要访问的指令或数据不在内存时产生缺页中断并处理。</li><li>再则，一条指令可能引起多次不同的页面故障。<br>例如<code>COPY A,B</code>,指令本身跨了两个页面,数据 A 和 B 各自跨了两个页面,这条指令的执行需要访问六个不同的页面，对它们的访问都可能引起缺页中断,最多可能引起 6 次缺页中断(每个页面都不在内存中)</li></ul><p>由于缺页中断的独特性，系统中需要提供硬件寄存器或其它机构，在出现页面故障时，保存部分完成的指令的状态。此外，还需要使用一条特殊的返回指令，确保在出现缺页中断处恢复该指令的处理。</p><p><strong>缺页中断处理过程</strong></p><ol><li>操作系统接收到进程产生的缺页中断信号，启动中断处理例程，保留处理机现场；</li><li>操作系统通知处理机从外存读取指定的页面；</li><li>处理机激活 I&#x2F;O 设备；</li><li>检查内存有无足够的空闲空间装入该页面？若有，转（6），否则，执行（5）；</li><li>利用页面置换算法，选择内存中的某个页面，换出内存；</li><li>将指定页面从外存装入内存；</li><li>更新该进程的页表；</li><li>更新快表；</li><li>计算物理地址。</li></ol><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-12-21-24-35.png" style="zoom:90%;"><h4 id="地址变换机构-Address-Translation"><a href="#地址变换机构-Address-Translation" class="headerlink" title="地址变换机构 Address Translation"></a>地址变换机构 Address Translation</h4><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-12-21-30-38.png" style="zoom:100%;"><h3 id="内存分配策略和分配算法"><a href="#内存分配策略和分配算法" class="headerlink" title="内存分配策略和分配算法"></a>内存分配策略和分配算法</h3><p>在为进程分配物理块时，又将涉及到这样三个问题：</p><ul><li>确定进程能正常运行所需的最少物理块数；</li><li>为每个进程分配的物理块，其数目是固定的还是可变的；</li><li>对各进程所分配的物理块数，是采取平均分配算法还是根据进程的大小按比例予以分配等。</li></ul><p><strong>最小物理块数的确定</strong><br>显然，给每个进程所分配物理块数目越少，则进程执行中的缺页率越高，进程的执行速度也减慢。为使进程能有效地工作，应为它分配一定数目的物理块。<br>最小物理块数：是指能保证进程正常运行所需的最少物理块数。若系统为某进程所分配的物理块数少于此值时，进程将无法运行。<br>进程应获得的最少物理块数与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式。</p><p>例：对于某些简单的机器，若是单地址指令且采用直接寻址方式，则所需的最少物理块数为 2。如果该机器允许间接寻址时，则至少要求有物理块数为 3。对于前面所介绍的在缺页中断机构中要发生 6 次中断的情况，至少要为每个进程分配 6 个物理块，以装入 6 个页面。</p><p><strong>物理块的分配策略</strong></p><ol><li>固定分配局部置换 Fixed Allocation，Local Replacement</li><li>可变分配全局置换 Variable Allocation，Global Replacement</li><li>可变分配局部置换 Variable Allocation， Local Replacement</li></ol><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-12-21-35-58.png" style="zoom:50%;"><ol><li>固定分配局部置换<br>为每个进程分配一定数目的物理块，在整个运行期间都不再改变。<br>实现这种策略的困难在于：应为每个进程分配多少个物理块难以确定。<br>若太少，会频繁地出现缺页中断，降低了系统的吞吐量；<br>若太多，又必然使内存中驻留的进程数目减少，进而可能造成 CPU 空闲或其它资源空闲的情况，而且在实现进程对换时，会花费更多的时间。</li><li>可变分配全局置换 （常用方式）<br>在采用这种策略时，先为系统中的每个进程分配一定数目的物理块，而 OS 自身也保持一个空闲物理块队列。<br>当某进程发现缺页时，由系统从空闲物理块队列中，取出一个物理块分配给该进程，并将欲调入的（缺）页装入其中。<br>这样，凡产生缺页（中断）的进程，都将获得新的物理块；<br>仅当空闲物理块队列中的物理块用完时，OS 才能从内存中选择一页调出，该页可能是系统中任一进程的页，这样，自然又会使那个进程的物理块减少，进而使其缺页率增加。</li><li>可变分配局部置换<br>为每个进程分配一定数目的物理块，但当某进程发现缺页时，只允许从该进程在内存的页面中选出一页换出，这样就不会影响其它进程的运行。<br>在进程运行过程中统计进程的缺页率，如果缺页率高，则为其增加一定的内存页，否则适当减少其内存的页面数。<br>当需要置换时只从本进程的内存页中选择，但此方式实现复杂，对进程的缺页情况的统计需要额外的开销。</li></ol><hr><p><strong>物理块的分配算法</strong></p><p>在采用固定分配策略时，如何将系统中可供分配的所有物理块分配给各个进程，可采取下述几种方法。</p><ol><li>平均分配算法<br>将系统中所有可供分配的物理块，平均分配给各个进程。<br>例：当系统中有 100 个物理块，有 5 个进程在运行时，每个进程可分得 20 个物理块。如有一个进程其大小为 200 页，只分配给它 20 个块，这样，它必然会有很高的缺页率；而另一个进程只有 10 页，却有 10 个物理块闲置未用。<br>这种方式貌似公平，但实际上是不公平的。因为，它并未考虑到各进程本身的大小。</li><li>按比例分配算法<br>根据进程的大小按比例分配物理块的算法。<br>例：系统中共有 n 个进程，每个进程的页面数为$S_i$，则系统中各进程页面数的总和为：<br>$S &#x3D; \sum_{i&#x3D;1}^{n} S_i$<br>又假定系统中可用的物理块总数为 m，则每个进程所能分到的物理块数为$b_i$，将有：<br>$b_i &#x3D; \frac{S_i}{S} \times m$<br>b 应该向上取整，它必须大于最小物理块数。</li><li>考虑优先权的分配算法<br>通常采取的方法是把内存中可供分配的所有物理块分成两部分：<br>一部分按比例地分配给各进程；<br>另一部分则根据各进程的优先权，适当地增加其相应份额后，分配给各进程。<br>在有的系统中，如重要的实时控制系统，则可能是完全按优先权来为各进程分配物理块。</li></ol><h3 id="调页策略"><a href="#调页策略" class="headerlink" title="调页策略"></a>调页策略</h3><p>解决的问题：</p><ul><li>系统应当在何时把一个页面装入内存？</li><li>从何处调入页面？</li><li>页面调入过程？</li><li>页面置换算法？</li></ul><h4 id="装入时机"><a href="#装入时机" class="headerlink" title="装入时机"></a>装入时机</h4><p><strong>系统应当在何时把一个页面装入内存</strong>？</p><ul><li>预调页 (Prepaging)</li><li>请求调页 (Demand Paging)</li></ul><p>可采用一种以预测为基础的<strong>预调页</strong>策略，将那些预计在不久之后便会被访问的页面，预先调入内存。<br>处理过程：</p><ul><li>当进程创建时，预先为进程装入多个页面。</li><li>缺页中断时，系统为进程装入指定的页面以及与之相临的多个页面。</li><li>若局部性很差，预先装入的很多页面不会很快被引用，并会占用大量的内存空间，反而降低系统的效率。预调页的成功率仅约 50％。</li></ul><p><strong>请求调页</strong>：仅当进程执行过程中，通过检查页表发现相应页面不在内存时，才装入该页面。<br>当进程刚开始执行时，由于预先未装入进程的页面，故需要频繁地申请装入页面。执行一段时间以后，进程的缺页率将下降。<br>采用请求调页方式，磁盘 I&#x2F;O 的启动频率较高，系统的开销较大。</p><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h4><p>在请求分页系统中的外存分为两部分:用于存放文件的文件区和用于存放对换页面的对换区。<br>通常，由于对换区是采用连续分配方式，而文件区是采用离散分配方式，故对换区的磁盘 I&#x2F;O 速度比文件区的高。<br>这样，每当发生缺页请求时，系统应从何处将缺页调入内存，可分成如下三种情况。</p><ol><li>系统拥有足够的对换区空间，这时可以全部从对换区调入所需页面，以提高调页的速度。</li><li>系统缺少足够的对换区空间，这时凡是不会被修改的文件，都直接从文件区调入；<ul><li>而当换出这些页面时，由于它们未被修改而不必再将它们换出到对换区，以后再调入时，仍从文件区直接调入。</li><li>但对于那些可能被修改的部分，在将它们换出时，便须调到对换区，以后需要时，再从对换区调入。</li></ul></li><li>UNIX 方式。由于与进程有关的文件都放在文件区，应从文件区调入。故凡是未运行过的页面，都应从文件区调入。而对于曾经运行过但又被换出的页面，由于是被放在对换区，因此在下次调入时，应从对换区调入。</li></ol><h4 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h4><ol><li>每当程序所要访问的页面未在内存时，便向 CPU 发出一缺页中断。</li><li>中断处理程序首先保留 CPU 环境，分析中断原因后，转入缺页中断处理程序。</li><li>如果内存已满，则须先按照某种置换算法从内存中选出一页准备换出；如果此页已被修改，则必须将它写回磁盘。</li><li>然后再把所缺的页调入内存，并修改页表中的相应表项，置其存在位为“1”，并将此页表项写入快表中。</li><li>形成所要访问数据的物理地址，再去访问内存数据。</li></ol><p>整个页面的调入过程对用户是透明的。</p><h4 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h4><p>页面置换算法的选择，是虚拟存储器管理系统的核心问题。<br>它的实质是，为系统提供一种方法，当从主存中需要换出页面时，应避免选择那些不久将再次要求访问的页面。<br>置换算法的选择在一定程度上取决于可用的硬件设施。</p><h5 id="最优置换算法-Optimal-Replacement-Algorithm"><a href="#最优置换算法-Optimal-Replacement-Algorithm" class="headerlink" title="最优置换算法 Optimal Replacement Algorithm"></a>最优置换算法 Optimal Replacement Algorithm</h5><p>最理想的页面置换策略是：从主存中移出永远不再需要的页面；如无这样的页面存在，则应选择最长时间不需要访问的页面。<br>最佳置换策略首先是由 Belady 于 1966 年提出的。<br>最佳置换策略本身不是一种实际的方法，因为页面访问的未来顺序是不知道的，但是，可将其它的实用方法与之比较来评价这些方法的优劣。所以，这种最佳策略具有理论上的意义。</p><blockquote><p>例 设页面请求次序 7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1<br>存储块为 3(驻留集为 3)，假定最初存储块为空，采用 OPT。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-07-17-43-04.png" style="zoom:80%;"><br>第一行为要请求访问的页面，第二行为存储块(内存)中存储的页，第三行为被移出内存的页。<br>从上面的演示知，利用 OPT，发生了 6 次页面置换,发生了 9 次缺页中断(前 3 次没有置换,但内存中未装入页面,发生中断)<br>缺页率&#x3D;缺页次数&#x2F;访问次数&#x3D;9&#x2F;20&#x3D;0.45</p></blockquote><h5 id="先进先出页面置换算法-FIFO"><a href="#先进先出页面置换算法-FIFO" class="headerlink" title="先进先出页面置换算法 FIFO"></a>先进先出页面置换算法 FIFO</h5><p>该算法的实质是：总是选择作业中驻留时间最长的一页淘汰。即先进入主存的页面先退出主存。<br>算法实现比较容易，如分配给一个作业的存储块数为 m，只需建立一个 m 个元素的队列表 Q(0)、Q(1)、…、Q(m-1)和一个替换指针。该队列是按页面调入主存的先后顺序排列的，而指针始终指向最早调入主存的一页。</p><blockquote><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-07-17-51-10.png" style="zoom:80%;">发生了12次页面置换,发生了15次缺页中断，缺页率=缺页次数/访问次数=15/20=0.75</blockquote><h5 id="二次机会页面置换算法-SCR，Second-Chance-Replacement-Policy"><a href="#二次机会页面置换算法-SCR，Second-Chance-Replacement-Policy" class="headerlink" title="二次机会页面置换算法 SCR，Second Chance Replacement Policy"></a>二次机会页面置换算法 SCR，Second Chance Replacement Policy</h5><p>二次机会算法是 FIFO 算法的升级版，而 clock 算法可以认为是二次机会算法的升级版本<br>该算法仍然使用标准的 FIFO 队列。</p><p>每个帧(frame)有一个 second chance 位，也叫做引用位。<br>当一个 frame 被引用到，它的 second chance 位设置为 1。这表示该 frame 后面还有可能会被引用到，所以下次置换先跳过这个 frame，也就是再给它一次机会留在内存中。这样可以减少 frame 置换，提高页面操作效率。<br>当一个新的页面被读到内存中时，它的 second chance 被设置为 0。<br>当你需要替换内存中的一个页面时，使用轮询的方式来查找可以被替换的页面：</p><ul><li>如果页面的 second chance 是 1，那么置为 0，继续查找；</li><li>如果页面的 second chance 是 0，那么将这个页面置换出去。</li></ul><h5 id="最近最久未使用置换算法-LRU"><a href="#最近最久未使用置换算法-LRU" class="headerlink" title="最近最久未使用置换算法 LRU"></a>最近最久未使用置换算法 LRU</h5><p>LRU(least Recently Used)算法的基本思想是，利用局部性原理，根据一个作业在执行过程中过去的页面访问踪迹来推测未来的行为。它认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。<br>算法的实质是：当需要置换一页面时，选择在最近一段时间内<strong>最久未使用</strong>的页面予以淘汰。<br>实现这种技术，是通过周期性地对“页面访问”位进行检查，并利用它来记录一个页面自上次访问以来所经历的时间 t，并选择 t 为最大的页予以淘汰。</p><blockquote><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-07-18-00-02.png" style="zoom:100%;">        发生了9次页面置换,发生了12次缺页中断，缺页率=缺页次数/访问次数=12/20=0.60</blockquote><p><strong>LRU 算法的硬件支持</strong><br>LRU 算法作为页面置换算法是比较好的，因为它适用于各种类型的程序。但是，实现起来比较困难，因为要对先前的访问历史时时加以记录和更新。如果这种连续的修改完全由软件来做，系统开销太大；如由硬件执行，则需要解决：</p><ul><li>一个进程在内存中的各个页面各有多久未被进程访问？</li><li>如何快速地知道哪一页是最近最久未使用的页面？</li></ul><p>为此，需要以下两类硬件的支持：</p><ul><li>寄存器。用于记录某进程在内存中各页使用情况。</li><li>栈。用于保存当前进程使用的各个页面的页面号。</li></ul><p><strong>移位寄存器</strong>：<br>为了记录某进程在内存中各页的使用情况，须为每个在内存中的页面配置一个移位寄存器可表示为：<br>$R &#x3D; R_{n-1}R_{n-2}R_{n-3}…R_2R_1R_0$</p><p>当进程访问某物理块时，要将相应寄存器的最高位$R_{n-1}$位置成 1。表示这个页面最近被访问过。系统每隔一定时间（例如 100 ms）将寄存器右移一位，这意味着如果一个页面在一段时间内没有被访问，它的寄存器值将逐渐变小。<br>如果我们把 n 位寄存器的数看作是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。<br>例如，假设我们有三个页面，其寄存器值分别为 100（4）、010（2）和 001（1）。在这种情况下，第三个页面的寄存器值最小，因此它是最近最久未使用的页面，应该被换出。<br><strong>栈</strong><br>操作系统维护一个栈，其中每个元素代表一个页面。栈顶的元素代表最近被访问的页面，而栈底的元素代表最近最久未使用的页面。</p><h5 id="最少使用置换算法-LFU"><a href="#最少使用置换算法-LFU" class="headerlink" title="最少使用置换算法 LFU"></a>最少使用置换算法 LFU</h5><p>最少使用置换算法(Least Frequently Used)选择到当前时间为止被访问次数最少的页面被置换。<br>1、基本方法：<br>记录每个页面的访问次数，最少访问的页面首先考虑淘汰<br>2、实际采取方法<br>为页面设置移位寄存器。统计 1 的个数,1 的个数越少，表示访问次数越少，越容易被淘汰。<br>与 LRU 的区别：<br>R1&#x3D;10000000<br>R2&#x3D;01110100<br>LRU———-淘汰 R2<br>LFU———-淘汰 R1</p><h5 id="Clock-置换算法"><a href="#Clock-置换算法" class="headerlink" title="Clock 置换算法"></a>Clock 置换算法</h5><p>简单的 Clock 置换算法（NRU）当采用简单 clock 算法时，为每页设置一位访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列。</p><ul><li>某页被访问时，其访问位被置 1。</li><li>置换程序从上次停止位置开始检查页面的访问位。<ul><li>如果是 0，就选择该页换出；</li><li>若为 1，则重新将它置 0，暂不换出，而给该页第二次驻留内存的机会。</li></ul></li><li>由于该算法是循环地检查各页面的使用情况，故称为 clock 算法。置换时是将未使用过的页面换出去，故又把该算法称为最近未用算法 NRU。</li></ul><h5 id="改进型-Clock-置换算法"><a href="#改进型-Clock-置换算法" class="headerlink" title="改进型 Clock 置换算法"></a>改进型 Clock 置换算法</h5><p>系统把一个页面移出内存时，如果该页面驻留内存期间没有被修改过，那么不必把它写回辅存，否则系统必须把它写回辅存。这表明，换出未修改过的页面比换出被修改过的页面开销小。<br>显然，我们可以依据上述结论改进 CLOCK 算法。改进后的 CLOCK 算法将在置换范围内首选符合下面条件的作为被置换页面</p><ol><li>在最近没有被使用过；</li><li>在驻留内存期间没有被修改过的页面</li></ol><p>由访问位 A(Access)和修改位 M(Modify)可以组合成下面四种类型的页面,淘汰优先级依次下降：<br>1 类（A&#x3D;0，M&#x3D;0）：表示该页最近既未彼访问，又未被修改，是最佳淘汰页。<br>2 类（A&#x3D;0，M&#x3D;1）：表示该页最近未被访问，但已被修改，并不是很好的淘汰页。<br>3 类（A&#x3D;1，M&#x3D;0）：最近已被访问，但未被修改：该页有可能再被访问。<br>4 类（A&#x3D;1，M&#x3D;1）：最近已被访问且被修改，该页可能再被访问。</p><p>执行过程可分成以下三步：<br>（1）从指针所指示的当前位置开始，扫描循环队列，寻找 A&#x3D;0 且 M&#x3D;0 的第一类页面，将所遇到的第一个页面作为所选中的淘汰页。在第一次扫描期间不改变访问位 A。<br>（2）如果第一步失败，即查找一周后未遇到第一类页面，则开始第二轮扫描，寻找 A&#x3D;0 且 M ＝ 1 的第二类页面，将所遇到的第一个这类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位 A 都置 0。<br>（3）如果第二步也失败，亦即未找到第二类页面，则将指针返回到开始的位置，并将所有的访问位复 0。然后重复第一步，如果仍失败，必要时再重复第二步，此时就一定能找到被淘汰的页 .</p><h5 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h5><p>Q：存储块越多，缺页中断率越小吗？<br>A:<br>一般来说，对于任何一个页的访问顺序(或序列)和任何一种换页算法，如果分给的物理块数增加，则缺页(所访问页不在主存)的频率应该减少。但这个结论并不普遍成立，对于某些页面访问序列，FIFO 有随着分给的页架数增加，缺页频率也增加的异常现象。<br>例如某程序在内存中分配 m 页初始为空，页面走向为<br>1，2，3，4，1，2，5，1，2，3，4，5<br>当 m&#x3D;3，m&#x3D;4 时缺页中断分别为多少？用 FIFO 算法<br>m&#x3D;3 时，缺页中断 9 次<br>m&#x3D;4 时，缺页中断 10 次</p><h2 id="抖动与工作集-Thrashing-and-Working-Set"><a href="#抖动与工作集-Thrashing-and-Working-Set" class="headerlink" title="抖动与工作集 Thrashing and Working Set"></a>抖动与工作集 Thrashing and Working Set</h2><h3 id="缺页率对有效访问时间的影响"><a href="#缺页率对有效访问时间的影响" class="headerlink" title="缺页率对有效访问时间的影响"></a>缺页率对有效访问时间的影响</h3><p>有效访问时间是指访问存储器所需时间的平均值。<br>假设使用了快表，则 CPU 访问内存时有以下三种情况(设内存读写周期为 t，查找快表时间为 λ，缺页中断处理时间为 ɛ)：</p><ul><li>页面在内存且页表项在快表中：只需一次访问内存<br>EAT&#x3D; λ + t</li><li>页面在内存但页表项不在快表中：需两次访问内存，一次读取页表，一次读取数据，另外还需更新快表。<br>EAT&#x3D; λ + t + t + λ&#x3D;2(λ + t)</li><li>页面不在内存：考虑查找快表时间、查找页表时间、缺页中断处理时间、更新快表时间、访问实际物理地址时间<br>EAT&#x3D; λ + t +ɛ + λ + t &#x3D; 2(λ + t) + ɛ</li></ul><p>引入快表命中率为 α，缺页中断率为 f，则有效访问内存时间为：<br>EAT&#x3D; α(λ + t) + (1-α)[2(λ + t) + f(2(λ + t) + ɛ)]</p><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>系统内进程增多–&gt;每个进程的缺页率增大–&gt;缺页率增大到一定程度，进程总等待调页完成–&gt;CPU 利用率降低–&gt;进程进一步增多，缺页率更大 …<br>此时: 进程调入一页，需将一页淘汰出去，刚淘汰出去的页马上要需要调入;称这一现象为抖动或颠簸(thrashing)显然，防止的根本手段给进程分配足够多的帧</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-13-13-37-50.png" style="zoom:100%;"><p><strong>抖动</strong>：如果运行进程的大部分时间都用于页面的换入&#x2F;换出，而几乎不能完成任何有效的工作，则称此进程处于抖动状态。抖动又称为颠簸。</p><p>抖动分为：</p><ul><li>局部抖动</li><li>全局抖动</li></ul><p>抖动产生的原因有：</p><ul><li>进程分配的物理块太少</li><li>置换算法选择不当</li><li>全局置换使抖动传播</li></ul><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>在工作集模型中，工作集的定义是在最近的一段连续执行时间（称为工作集窗口，通常用 T 表示）内，进程实际引用过的页面集合。换句话说，工作集是进程当前正在使用或可能马上就要使用的页面的集合。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-13-13-42-08.png" style="zoom:100%;">只要分配的块空间能覆盖整个局部就不会出现太多的缺页;工作集模型就用来计算一个局部的宽度(块数)<h3 id="抖动的预防"><a href="#抖动的预防" class="headerlink" title="抖动的预防"></a>抖动的预防</h3><ul><li>抖动发生前会出现一些征兆，可利用这些征兆发现抖动并加以防范。这些技术有：</li><li>采取局部置换策略</li><li>引入工作集的算法</li><li>L&#x3D;S 准则<ul><li>L 缺页之间的平均时间，S 平均缺页服务时间</li></ul></li><li>选择暂停的进程</li></ul><h2 id="请求分段存储管理方式-Demand-Segmentation"><a href="#请求分段存储管理方式-Demand-Segmentation" class="headerlink" title="请求分段存储管理方式 Demand Segmentation"></a>请求分段存储管理方式 Demand Segmentation</h2><p>工作原理：请求分段系统中，程序运行之前，只需先调入若干个分段（不必调入所有的分段），便可启动运行。当所访问的段不在内存中时，可请求 OS 将所缺的段调入内存。</p><p>为了实现请求调段、分段置换两大功能，系统必须提供如下的硬件支持：</p><ul><li>请求分段的段表机制</li><li>缺段中断机构</li><li>地址变换机构</li></ul><h3 id="原理及实现-1"><a href="#原理及实现-1" class="headerlink" title="原理及实现"></a>原理及实现</h3><h4 id="请求分段的段表机制"><a href="#请求分段的段表机制" class="headerlink" title="请求分段的段表机制"></a>请求分段的段表机制</h4><p>在虚拟存储系统中的所有段表，其段描述子增加五个信息标识位。</p><table><thead><tr><th>段名</th><th>段长</th><th>段的机制</th><th>存取方式</th><th>状态位 P</th><th>访问位 A</th><th>修改位 M</th><th>增补位外存地址</th></tr></thead></table><ol><li><strong>状态位</strong>(存在位)P：用于说明该段是否已调入内存，供程序访问时参考；P&#x3D;0，该段不在内存;P&#x3D;1，该段在内存</li><li><strong>访问位</strong> A：用于记录本段在一段时间内被访问的次数，提供给置换算法选择换出段时参考。A&#x3D;0，该段未被访问;A&#x3D;1，该段被访问</li><li><strong>修改位</strong> M：用于表示该段在调入内存后是否被修改过，也是提供给置换算法在换出段时是否将该段写回外存作参考。M&#x3D;0，该段在内存中未被修改;M&#x3D;1，该段在内存中已经被修改</li><li><strong>外存地址</strong>：用于指出该段在外存上的地址，供调入该页时使用。</li><li><strong>增补位</strong>：说明该分段是否允许扩展，此外如该段已被增补，则在写回辅存时，需另选择辅存空间；</li></ol><h4 id="缺段中断机构-Demand-Segment-Fault"><a href="#缺段中断机构-Demand-Segment-Fault" class="headerlink" title="缺段中断机构 Demand Segment Fault"></a>缺段中断机构 Demand Segment Fault</h4><p>由上述段表机制知道，状态位记录了访问段是否在内存。在地址映射过程中，在段表中发现所要访问的段不在内存，则产生缺段中断。OS 接到此中断信号后，就调出缺段中断处理程序，根据段表中给出的外存地址，将该段调入内存，使作业继续运行下去。缺段中断与缺页中断类似，主要表现为：<br>① 一个缺段中断要求在指令执行中间得到服务，即发现所要访问的指令或数据不在内存时产生缺段中断并处理。<br>② 一条指令可能引起多次不同的缺段中断。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-13-14-49-15.png" style="zoom:100%;"></p><h4 id="地址变换机构-Address-Translation-1"><a href="#地址变换机构-Address-Translation-1" class="headerlink" title="地址变换机构 Address Translation"></a>地址变换机构 Address Translation</h4><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-13-14-50-32.png" style="zoom:100%;"><h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><h4 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h4><p>为了实现分段共享，可在系统中配置一张共享段表，所有共享段都在共享段表中占有一个表项。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-13-14-54-16.png" style="zoom:100%;"></p><ul><li>共享进程计数：记录有多少进程共享该段。</li><li>存取控制字段：对同一共享段，不同进程有不同的操作权限。</li><li>段号：共享段在不同进程中有不同的段号。</li></ul><h4 id="共享段的分配与回收"><a href="#共享段的分配与回收" class="headerlink" title="共享段的分配与回收"></a>共享段的分配与回收</h4><p><strong>共享段的分配</strong></p><p>在为共享段分配内存时，对第一个请求使用该共享段的进程，由系统为该共享段分配一物理区，再把共享段调入该区，同时将该区的始址填入请求进程的段表的相应项中，还须在<strong>共享段表</strong>中增加一表项，填写有关数据，把 count 置为 1；</p><p>之后，当又有其它进程需要调用该共享段时，由于该共享段已被调入内存，故此时无须再为该段分配内存，而只需在<strong>调用进程的段表</strong>中，增加一表项，填写该共享段的物理地址；在<strong>共享段表</strong>中，填上调用进程的进程名、存取控制等，再执行<code>count+=1</code>操作，以表明有两个进程共享该段。</p><p><strong>共享段的回收</strong><br>当共享此段的某进程不再需要该段时，应将该段释放， 包括撤消该进程段表中共享段所对应的表项，以及执行 <code>count-=1</code> 操作。<br>若 count 结果为 0，则须由系统回收该共享段的物理内存，以及取消在共享段表中该段所对应的表项，表明此时已没有进程使用该段；否则，则只是取消调用者进程在共享段表中的有关记录。</p><h4 id="分段的保护"><a href="#分段的保护" class="headerlink" title="分段的保护"></a>分段的保护</h4><ol><li>越界检查 Bounds Check<br>寄存器中放有段表长度信息，将逻辑地址空间的段号与段表长度进行比较 ，如果段号等于或大于段表长度，将发出地址越界中断信号。保证每个进程只能在自己的地址空间内运行。</li><li>存取控制检查 Access Control Check<br>Read-Only、Read-Write、Execute-Only、Execute-Read-Write etc</li><li>环保护机构 Ring Protection<br>低编号的环具有高优先权。OS 核心处于 0 环内；某些重要的实用程序和操作系统服务，占居中间环；而一般的应用程序在外环上。</li></ol><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-13-15-00-23.png" style="zoom:100%;" alt="Pentium中的环形保护结构"><p>环保护的基本原则是：<br>一个程序可以<strong>访问</strong>驻留在相同环或较低特权环中的数据；<br>一个程序可以<strong>调用</strong>驻留在相同环或较高特权环中的服务。</p><p>环保护的基本思想是将操作系统内的操作和资源划分为不同的”环”，每个环都有其特定的权限。通常，环的编号越小，权限越高。例如，在一个典型的四环模型中：</p><ul><li>环 0（Ring 0）：拥有全部权限，通常用于运行操作系统内核，可以访问所有硬件和内存资源。</li><li>环 1（Ring 1）和环 2（Ring 2）：通常用于运行操作系统服务，有一些特定的硬件和内存访问权限，但不如环 0 全面。</li><li>环 3（Ring 3）：权限最低，通常用于运行用户级的应用程序，只能访问有限的硬件和内存资源，对系统资源的访问需要通过系统调用。<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-3StorageManagement-2024-05-13-15-09-55.png" style="zoom:100%;"></li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/wingsless/p/12295246.html">Clock 置换算法</a></p>]]></content>
    
    
    <summary type="html">虚拟存储器的基本概念，请求分页存储管理方式,抖动与工作集合,请求分页存储管理方式</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="操作系统" scheme="https://efterklang.github.io/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Storage Management PartⅡ</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch4-2StorageManagement/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch4-2StorageManagement/</id>
    <published>2024-05-09T07:44:59.000Z</published>
    <updated>2024-06-12T09:25:59.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本分页存储管理方式-Paged-Storage-Management"><a href="#基本分页存储管理方式-Paged-Storage-Management" class="headerlink" title="基本分页存储管理方式 Paged Storage Management"></a>基本分页存储管理方式 Paged Storage Management</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>前面介绍的分区存储管理，一般都要求把一个作业的地址空间装入到连续的存储区域内。因此，在动态分区的存储空间中，常常由于存在着一些不足以装入任何作业的小的分区而浪费掉部分存储资源，这就是所谓存储器的零头问题。<br>尽管采用“紧凑”技术可以解决这个问题，但要为移动大量信息花去不少处理机时间，代价较高。<br>如果我们能取消对其存储区域的连续性要求，必然会进一步提高主存空间的利用率，又无需为移动信息付出代价。</p><p><strong>离散分配</strong> 即程序在内存中不一定连续存放<br>根据离散时的基本单位不同，可分为三种：</p><ul><li>分页存储管理</li><li>分段存储管理</li><li>段页式存储管理</li></ul><p><strong>离散的基础</strong></p><p>分页(Pages)：将程序地址空间分页<br>分块(Frames)：将内存空间分块</p><p><strong>离散分配的体现</strong><br>内存一块可以装入程序一页<br>连续的多个页不一定装入连续的多个块中<br>注：系统中页块的大小是不变的。</p><p><strong>离散分配的优点</strong><br>没有外零头。不受连续空间限制，每块都能分出去<br>仅有小于一个页面的内零头。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”或称为“内零头”。</p><p><strong>定义</strong></p><ul><li>页面&#x2F;页 Page: 作业的逻辑地址空间被分割成固定大小的片，称为页面</li><li>物理块&#x2F;页框 Page Frame：内存空间也分成与页相同大小的若干存储块。在为进程分配存储空间时，总是以页框为单位。<blockquote><p>Page 从 0 开始编号，页内地址是相对于 0 编址；<br>在进程调度时，必须把它所有的 Page 一次装入到主存的 Page Frame 内；如果当时 Page Frame 不足，则该进程必须等待，系统再调度另外的进程。（纯分页方式）</p></blockquote></li></ul><h3 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h3><p><strong>需解决的两个基本问题:</strong></p><ul><li>如何建立程序空间与主存空间的映射</li><li>如何进行地址变换(从程序逻辑地址到内存物理地址)<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-05-11-38-50.png" style="zoom:50%;"></li></ul><p><strong>页面大小的选择</strong><br>页面大小由机器的地址结构决定。某一机器只能采用一种大小的页面。页面的大小通常在 1KB~8KB 之间。</p><ul><li>小页面</li><li>大页面</li></ul><p><strong>实现分页存储管理的数据结构</strong><br>1）页表 Page Table：每个进程对应 1 个页表，由各个页表项(Page Table Entry，PTE)描述该进程的各页面在内存中对应的物理块号。<br>页表项中包括页号、物理块号、存储控制字段<br>状态位：这些位提供了关于页面的额外信息，例如该页面是否在内存中（有效位），是否可以写入（写保护位），是否被访问过（访问位），是否被修改过（脏位）等<br>注意：全部页表集中存放在主存的系统专用区中，只有系统有权访问页表，保证安全。<br>2）作业表 Job Table：整个系统 1 张，记录作业的页表情况，包含进程号、页表长度、页表始址等信息。<br>3）空闲块表：整个系统 1 张，记录主存当前空闲块。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-08-18-08-43.png" style="zoom:50%;"></p><p>某一作业被分成若干个 Page，每个 Page 可以去进程对应的页表中查找对应的物理块号，然后再去主存中找到对应的物理块(Page Frame)。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-08-18-12-27.png" style="zoom:50%;"></p><h3 id="分页存储管理的逻辑地址表示"><a href="#分页存储管理的逻辑地址表示" class="headerlink" title="分页存储管理的逻辑地址表示"></a>分页存储管理的逻辑地址表示</h3><h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><p>地址空间为程序限定的空间。物理空间为内存限定空间。<br>在页式管理系统中将地址空间分成大小相同的页面 Page。将内存空间分成与页面相同大小的存储块 Page Frame。<br>分页存储管理方式中，任何一个逻辑地址都可转变为：页号+页内位移量。<br>页号、位移量的划分是由系统自动完成的，对用户是透明的。</p><p>设有一逻辑地址 A，页面大小为 L，则在分页存储管理方式中，它的地址被转换：</p><div>$$Page Number = INT(\frac{A}{L}) \\Offset In Page = A \ mod \ L$$</div><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-08-18-17-40.png" style="zoom:100%;"><p>0 ～ 11 位表示页内位移量，则每页的大小为 212 &#x3D; 4KB。<br>12 ～ 31 位表示页号，220&#x3D;1M，即最多允许有 1M 个页面。</p><p>如有逻辑地址为：2170，页面大小为 1KB，则<code>P=INT[2170/1024]=2</code>；<code>W=2170 MOD 1024=122</code><br>这个地址的变换通常由系统中的某些硬件完成。</p><h4 id="地址变换机构-Address-Translation"><a href="#地址变换机构-Address-Translation" class="headerlink" title="地址变换机构 Address Translation"></a>地址变换机构 Address Translation</h4><p><strong>地址变换机构</strong>的功能是将用户的逻辑地址转变为内存中的物理地址。<br>逻辑地址由页号和页内位移量组成。页(Page)的大小和内存物理块(Pageframe)的大小是相同的，所以页内位移量即为物理块内位移量。<br>关键是页号到物理块号的转换，由页表完成。</p><p><strong>基本的地址变换机构</strong></p><ul><li>使用寄存器存放页表<br>速度快，成本高。特别对于大的系统，页表很长，不可能都用寄存器实现。</li><li>一般系统，将页表存储在内存中<br>设置一个页表寄存器（PTR），记录当前运行的进程的页表在内存中的始址和页表长度。（平时存于 PCB 中，要运行时才装入 PTR 中）</li></ul><p><strong>分页系统中的地址变换过程：</strong><br>（1）根据逻辑地址,计算出页号和页内偏移量；<br>（2）从 PTR 中得到页表首址，然后检索页表，查找指定页面对应的页框号；<br>（3）用页框号乘以页面大小获得其对应的起始地址，并将其送入物理地址的高端。<br>（4）将页内偏移量送入物理地址低端，形成完整的物理地址。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-09-52-23.png" style="zoom:100%;"><p><strong>具有快表的地址变换机构</strong></p><p>分页系统中处理机每次存取指令或数据至少需要访问两次物理内存：</p><ul><li>第一次访问页表，以得到物理地址</li><li>第二次访问物理地址，以得到数据。<br>存取速度几乎降低了一倍，代价太高。为了提高地址变换速度，为进程页表设置一个专用的高速缓冲存储器，称为快表 TLB(Translation Lookaside Buffer)或联想存储器（Associative Memory） 。</li></ul><blockquote><p>Lookaside buffer 是一种硬件缓存机制，用于加速对特定类型数据的访问。这种缓存机制通常在 CPU 或其他硬件组件中实现，例如网络接口卡或硬盘控制器。<br>Lookaside buffer 的工作原理是将最近或最常访问的数据存储在一个快速访问的缓存中，以减少对慢速内存的访问。当 CPU 或其他硬件组件需要访问数据时，它们首先查看 lookaside buffer。如果所需的数据在缓存中，那么就可以快速地从缓存中获取，而无需访问慢速的内存。这被称为缓存命中。如果数据不在缓存中，那么就需要访问慢速的内存，并将数据放入缓存中以备后用。这被称为缓存未命中。</p></blockquote><p>进程最近访问过的页面在不久的将来还可能被访问。快表的工作原理类似于系统中的数据高速缓存(cache)，其中专门保存当前进程最近访问过的一组页表项。</p><p><strong>快表地址转换过程</strong></p><ul><li>根据逻辑地址中的页号，查找快表中是否存在对应的页表项。</li><li>若快表中存在该表项，称为命中（hit），取出其中的页框号，加上页内偏移量，计算出物理地址。</li><li>若快表中不存在该页表项，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，更新快表，将该表项插入快表中。并计算物理地址.</li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-13-47-15.png" style="zoom:100%;"><h4 id="访问内存有效时间-EAT"><a href="#访问内存有效时间-EAT" class="headerlink" title="访问内存有效时间 EAT"></a>访问内存有效时间 EAT</h4><p>**访问内存有效时间 EAT(Effective Access Time)**：从进程发出指定逻辑地址的访问请求，经过地址变换，再到内存中找到对应的物理单元并取出数据，所花费的总时间。</p><p>如检索快表时间为 20 ns，访问内存为 100 ns。<br>若能在快表中检索到 CPU 给出的页号，则 CPU 存取一个数据共需 120 ns；否则，需要 220 ns 的时间。<br>如果不设置快表，CPU 存取一个数据需要 200 ns。快表(TLB)命中时效率会很高，未命中效率会降低，但平均后仍表现良好</p><p>$$<br>EAT_{average} &#x3D; HitR \times (TLB_{time} + Memory_{time}) + (1-HitR) \times (TLB_{time} + 2 \times Memory_{time})<br>$$</p><blockquote><p>$EAT_{average}$ 为平均有效访问时间<br>$HitR$ 为命中率<br>$TLB_{time}$ 为快表访问时间，$Memory_{time}$ 为内存访问时间</p></blockquote><h4 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h4><p><strong>问题引入</strong><br>32 位逻辑地址空间，假设页面大小为 4KB（212），则 4GB（232）的逻辑地址空间将被划分成 220 个页面。<br>若采用一级页表，则该表将包含 1M（220）个页表项。若按字节寻址，一个页表项占 4B，则一级页表需要占用 4MB（222）内存空间。不可能将 4MB 的页表保存在一个连续区中。<br>那么，如何处理大页表的存储与检索呢？</p><p>可以采用这样两个方法来解决这一问题：<br>① 采用离散分配方式来解决难以找到一块连续的大内存空间的问题，（即引入两级页表）；<br>② 只将当前需要的部分页表项调入内存， 其余的页表项仍驻留在磁盘上，需要时再调入。</p><h5 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h5><p>对于要求连续的内存空间来存放页表的问题：</p><ul><li>可将页表进行分页，并离散地将各个页面分别存放在不同的物理块中，</li><li>同样也要为离散分配的页表再建立一张页表，称为外层页表(Outer Page Table)，在每个页表项中记录了页表分页的物理块号。</li></ul><p>对于 4GB($2^{32} Byte$)的进程，页面大小为 4KB($2^12 Byte$) ,若采用二级页表，则对应的二级页表结构设计如下(假定每个页表项 4B)：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-17-27-34.png" style="zoom:100%;"></p><ol><li>页面大小 4KB，故 32 位逻辑地址中要用 12 位表示页内偏移量。</li><li>4GB 的逻辑地址空间被分成$4GB \div 4KB&#x3D; 2^{20}$个页面，内层页表大小为$2^{20} \times 4B &#x3D; 4MB$。</li><li>外层页表的表项记录的是某页在内存中的物理块号。外层页表个数为$4MB \div 4KB &#x3D; 2^{10}$个，大小为$2^{10} \times 4B &#x3D; 4KB$。</li><li>前 10 位表示外层页表的页号，后 10 位表示内层页表的页号，最后 12 位表示页内偏移量。</li></ol><p>变换机构：先在外层页表寄存器中找到外层页表的起始地址，根据逻辑地址中的外层页号找到对应的内层页表的起始地址，再根据逻辑地址中的内层页号找到对应的物理块号。</p><p>利用离散分配方法实现的两级页表只是解决了大页表无需大片连续存储空间问题，但并未解决用较少内存去存放大页表问题，有关此类问题的成功解决方案放在虚拟存储器管理中。</p><h5 id="多级页表机构"><a href="#多级页表机构" class="headerlink" title="多级页表机构"></a>多级页表机构</h5><p><strong>Intro</strong><br>对于 64 位的机器，采用两级页表结构是否合适?</p><p>使用 4KB 的页面，剩 52 位。若按 4KB 来划分页表，还剩 42 位用于外层页表，因而外层页表有 4KG 个页表项,占 16KGB 的空间<br>使用 1MB 的页面(220)，剩 44 位。若按 1MB 来划分页表，还剩 26 位用于外层页表，外层页表有 64M 个页表项，占 256MB 空间<br>显然这是不现实的，外层页表过大无法装入一个物理块中</p><blockquote><p>64 位的机器，采用的是多级（4 级以上）页表结构。<br>电脑的位数通常指的是其 CPU 的位数，这是指 CPU 一次能处理的数据的位数，也就是其寄存器的宽度。例如，32 位的 CPU 一次可以处理 32 位（4 字节）的数据，而 64 位的 CPU 一次可以处理 64 位（8 字节）的数据。<br>这个位数也决定了 CPU 可以直接寻址的内存空间的大小。32 位的 CPU 可以直接寻址$2^{32}个位置，也就是4GB的内存空间。同样，64位的CPU可以直接寻址\2^{64}$个位置，这是一个非常大的空间，远远超过了现在的计算机所装配的实际物理内存。<br>然而，实际上，操作系统通常会使用虚拟内存系统，这允许每个进程都有自己的地址空间，并且这个地址空间的大小可以超过实际的物理内存。例如，每个进程在 64 位的 Linux 系统中都有一个$2^{48}$字节的虚拟地址空间，虽然实际的物理内存可能只有几 GB。<br>所以，电脑的位数决定了 CPU 的寄存器宽度，一次可以处理的数据的位数，以及可以直接寻址的内存空间的大小。但是实际可用的地址空间可能会因为虚拟内存系统和操作系统的设计而变化。</p></blockquote><p><strong>多级页表实现</strong><br>通过间接引用将页号分成 k 级，建立页表“树”，减少每级页表的长度<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-21-38-01.png" style="zoom:100%;"><br>CPU 得到逻辑地址后，先从最高级的页表开始，逐级查找，直到找到最低级的页表，再根据页表项找到物理块号。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-21-39-01.png" style="zoom:100%;"></p><h5 id="反置页表-IPT-Inverted-Page-Table"><a href="#反置页表-IPT-Inverted-Page-Table" class="headerlink" title="反置页表 IPT Inverted Page Table"></a>反置页表 IPT Inverted Page Table</h5><p><strong>Intro</strong></p><p>对于在 OS 中同时运行的多个进程，相当大的一部分内存仅被页表占用。若结合了多级分页方案，这会进一步增加存储页表所需的空间，页表占用的内存量可能会成为一个巨大的开销；此外，查找一个物理地址需要读取多个页表，导致查找时间增加。<br>为了有效地利用存储器，引入了反置页表,一个系统中一般只存在一个反向页表，这张页表中的 entry 的数量和内存中 pageframe 的数量是一样的</p><ul><li>IPT 思想：<br>IPT 是为主存中的每一个物理块建立一个页表项并按照块号排序；<br>该表每个表项 Entry 包含正在访问该物理块的进程标识 Pid、页面号 Page number 及特征位 Control bits,用来完成主存物理块到访问进程的页号的转换</li></ul><p>IPT Entry Struct</p><ul><li>页号 Page number: It specifies the page number range of the logical address.</li><li>进程标识 Process id: An inverted page table contains the address space information of all the processes in execution. Since two different processes can have a similar set of virtual addresses, it becomes necessary in the Inverted Page Table to store a process Id of each process to identify its address space uniquely. This is done by using the combination of PID and Page Number. So this Process Id acts as an address space identifier and ensures that a virtual page for a particular process is mapped correctly to the corresponding physical frame.</li><li>特征位 Control bits: These bits are used to store extra paging-related information. These include the valid bit, dirty bit, reference bits, protection, and locking information bits.</li><li>链接指针 Chained pointer: It may be possible sometimes that two or more processes share a part of the main memory. In this case, two or more logical pages map to the same Page Table Entry then a chaining pointer is used to map the details of these logical pages to the root page table.<br>Note: Number of Entries in Inverted page table &#x3D; Number of frames in Physical Address Space(PAS).</li></ul><p><strong>IPT 地址转换过程</strong></p><p>给出进程标识和页号,用它们去比较 IPT,若整个反置页表中未能找到匹配的页表项,说明该页不在主存,产生请求调页中断,请求操作系统调入;否则，该表项的序号便是物理块号,块号加上位移,便形成物理地址。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-10-20-50-53.png" style="zoom:100%;"></p><p>然而，反置页表也有其缺点，比如查找特定虚拟地址对应的物理地址可能会更复杂。为了解决这个问题，一些系统会使用额外的数据结构，如哈希表，基于 Hash 映射值查找对应页表项中的帧号</p><p>以下是倒排页表（IPT）在引入哈希表后如何转换逻辑地址的过程：</p><ol><li>当需要访问内存时，操作系统或硬件会使用逻辑地址中的页号和进程 ID 作为哈希函数的输入，计算出哈希值。</li><li>这个哈希值用于在哈希表中查找相应的页表项。如果存在冲突（即多个 VPN 哈希到同一位置），则使用链接（链表）的方式解决冲突。</li><li>一旦找到了对应的页表项，就可以得到物理页框号（Physical Frame Number，PFN）。这个 PFN 就是物理地址的一部分。</li><li>最后，物理地址由 PFN 和原始的页内偏移组成。</li></ol><p>通过这种方式，倒排页表结合哈希表可以有效地将逻辑地址转换为物理地址，同时保持查找时间的效率。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-10-21-00-23.png" style="zoom:100%;"></p><p><strong>Pros</strong></p><ul><li>Reduced Memory Overhead</li><li>Simplified Page Swapping: When a process needs to be swapped out of memory, the IPT can be used to quickly identify all the physical pages that are associated with the process. This can simplify the process of swapping pages and reduce the overall overhead of memory management.</li><li>Improved Cache Performance: Because the IPT is smaller than a Page Table, it can be more easily stored in the CPU cache, which can improve the performance of memory access operations.</li></ul><h2 id="基本分段存储管理方式-Segmented-Storage-Management"><a href="#基本分段存储管理方式-Segmented-Storage-Management" class="headerlink" title="基本分段存储管理方式 Segmented Storage Management"></a>基本分段存储管理方式 Segmented Storage Management</h2><h3 id="分段式存储管理方式的引入"><a href="#分段式存储管理方式的引入" class="headerlink" title="分段式存储管理方式的引入"></a>分段式存储管理方式的引入</h3><ol><li><strong>方便编程</strong><br>通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从 0 开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的<br>常见段有：主程序段、子程序段、数据段、堆栈段 etc</li><li><strong>分段共享。</strong><br>一般实现程序和数据共享时都是以信息的逻辑单位(过程、函数或文件)为基础的。<br>在分页系统中的每一页都只是存放信息的物理单位，其本身并无完整意义，因而不便于实现信息共享。<br>段是信息的逻辑单位，可以为共享过程建立一个独立的段，更便于实现程序和数据的共享。</li><li><strong>分段保护。</strong><br>信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便的实现信息保护功能。</li><li><strong>动态链接。</strong><br>程序运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段调入内存并进行链接,分段管理方式更适合实现动态链接。</li><li><strong>动态增长。</strong><br>在实际使用中，往往有些段，特别是数据段会随着程序的运行不断增大，而这种增长事先并不知道会增长到多大，采用其它存储管理方式是难以应付的，而分段存储管理却能较好的解决这一问题。</li></ol><h3 id="分段式存储管理的基本原理"><a href="#分段式存储管理的基本原理" class="headerlink" title="分段式存储管理的基本原理"></a>分段式存储管理的基本原理</h3><h4 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段 Segmentation"></a>分段 Segmentation</h4><ul><li>作业地址空间按逻辑信息的完整性被划分为若干个段；</li><li>每段有段名（或段号），每段从 0 开始编址；</li><li>段内的地址空间是连续的。</li><li>许多编译程序支持分段方式，自动根据源程序的情况产生若干个段。</li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-11-21-02-26.png" style="zoom:100%;"><p><strong>分段的基本原理</strong><br>在分段管理系统中，对所有地址空间的访问均要求两个成分： (1)段的名字；(2)段内地址。<br>例如，可按下述调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CALL  [X]|&lt;Y&gt;        转移到子程序X中的入口点Y</span><br><span class="line">LOAD  R1, [A]|&lt;D&gt;   将数组A的D单元的值读入寄存器<span class="number">1</span></span><br><span class="line">STORE  R1,[B]|&lt;C&gt;  将寄存器<span class="number">1</span>的内容存入分段B的C单元中</span><br></pre></td></tr></table></figure><p>这些符号程序经汇编和装配后，指令和数据的单元地址均由两部分构成：一是表示段名的段号 S；一是位移量 W，即段内地址。</p><p><strong>分段管理</strong><br>分段管理，就是管理由若干分段组成的作业，且按分段来进行存储分配。<br>实现分段管理的关键在于，如何保证分段(二维)地址空间中的一个作业在线性(一维)的存储空间中正确运行。也就是说，如何把分段地址结构变换成线性的地址结构。和分页管理一样，可采用动态重定位技术，即通过地址变换机构来实现。</p><p>优点：<br>没有内碎片，外碎片可以通过内存紧凑来消除。<br>便于改变进程占用空间的大小。</p><h4 id="段表-Segment-Table"><a href="#段表-Segment-Table" class="headerlink" title="段表 Segment Table"></a>段表 Segment Table</h4><p>为每个段分配一个连续的分区，而进程中的各个段可以离散地移入内存中不同的分区中<br><strong>段表</strong>：每个段在表中占有一个表项，其中记录了该段在内存中的起始地址(又称为“基址”,Base Address)和段长。通常将段表放在内存中，执行中的进程可通过查找段表找到每个段所对应的内存区。作用为实现从逻辑段到物理内存区的映射<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-11-21-42-59.png" style="zoom:100%;"></p><h4 id="地址变换机构-Address-Translation-1"><a href="#地址变换机构-Address-Translation-1" class="headerlink" title="地址变换机构 Address Translation"></a>地址变换机构 Address Translation</h4><p>段表寄存器（Segment Table Register，STR）</p><ol><li>根据段表寄存器的内容找到该作业的段表地址；</li><li>检索段表，得到该段在主存的起始地址；</li><li>将段的主存起始地址和位移量 W 相加，即得访问主存的物理地址<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-11-21-52-59.png" style="zoom:100%;"></li></ol><p>若段表放在内存中，每访问一个数据需要访问内存 2 次，可设置联想存储器（快表），以提高访问速度。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-12-14-02-19.png" style="zoom:100%;"></p><h3 id="段的共享和保护"><a href="#段的共享和保护" class="headerlink" title="段的共享和保护"></a>段的共享和保护</h3><h4 id="信息共享"><a href="#信息共享" class="headerlink" title="信息共享"></a>信息共享</h4><p>分页系统实现程序段的共享较为困难。分段易于实现段的共享和段的保护。<br><strong>可重入代码</strong>（Reentrant Code, 纯代码）是一种允许多个进程同时访问的代码（可共享），且是一种不允许任何进程对其进行修改的代码。</p><p>例如一个多用户系统可接纳 40 个用户，它们都执行一个文本编辑程序(ED)，ED 代码共 160K（ED 可共享），每个用户还有 40K 的数据区(DA)。</p><ul><li>不采用信息共享时需占用的内存空间 $(160K + 40K ) \times 40 &#x3D; 8000K$</li><li>采用信息共享后占用的内存空间 $160K + 40K \times 40 &#x3D; 1760K$</li></ul><h4 id="分页共享"><a href="#分页共享" class="headerlink" title="分页共享"></a>分页共享</h4><p>在分页存储管理中，进程被划分为固定大小的页。当两个或更多的进程需要访问相同的信息时，可以使用分页共享。例如，当多个进程运行相同的程序或访问相同的只读文件时，它们可以共享相同的代码页或数据页。这种方式的优点是可以节省内存空间，因为相同的信息只需要在内存中存储一次。此外，分页共享也可以用于实现进程间的通信。</p><p>对于数据页面，实现起来比较简单。因为这个数据页面可以安排在诸作业地址空间中的任何一页面上。<br>如果多个进程（或作业）要共享同一个代码页，那么这个代码页必须在所有共享它的进程的地址空间中处于相同的位置（即具有相同的页号）。这是因为代码页中的跳转或引用指令的目标地址通常在链接阶段就确定了。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-12-16-39-12.png" style="zoom:100%;"></p><h4 id="分段共享"><a href="#分段共享" class="headerlink" title="分段共享"></a>分段共享</h4><p>在分段存储管理中，进程被划分为多个具有不同长度和功能的段。分段共享允许多个进程共享一个或多个段。这在一些情况下是非常有用的。例如，当多个进程需要执行相同的函数或访问相同的数据结构时，它们可以共享相同的代码段或数据段。分段共享的优点是它可以更灵活地管理内存，因为每个段的大小可以根据需要进行调整。此外，分段共享也可以用于实现进程间的通信。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-12-16-41-38.png" style="zoom:100%;"></p><h3 id="段页式存储管理-Segment-Paging"><a href="#段页式存储管理-Segment-Paging" class="headerlink" title="段页式存储管理 Segment Paging"></a>段页式存储管理 Segment Paging</h3><h4 id="段页式存储管理的引入"><a href="#段页式存储管理的引入" class="headerlink" title="段页式存储管理的引入"></a>段页式存储管理的引入</h4><p>分页管理内存管理效率高</p><ul><li>没有外零头</li><li>内零头小<br>分段管理符合模块化思想</li><li>每个分段都具备完整的功能</li><li>方便代码共享、保护</li><li>没有内零头，存在外零头</li></ul><p>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势。两者结合，形成段页式存储管理方式。</p><p><strong>原理</strong>：分段和分页相结合。先将用户程序分段，每段内再划分成若干页，每段有段名（段号），每段内部的页有一连续的页号。</p><p>下图为段页式系统中一个作业的地址空间结构，页面尺寸为 4KB。由图可见，该作业有三个分段，第一段为 15KB，占 4 页，最后一页有 1KB 未用；第二段为 8KB，恰好占满 2 页；第三段为 10KB，占 3 页；而最后一页有 2KB 未用。和分页系统一样，这些未写满的页，在装入主存空间后，依然存在内零头问题。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-12-17-13-05.png" style="zoom:100%;"></p><ul><li>内存划分：按页式存储管理方案。</li><li>内存分配：以页为单位进行离散分配。</li><li>逻辑地址结构：由于段页式系统给作业地址空间增加了另一级结构现在地址空间如下所示<ul><li>段号 Segment numbers(S)</li><li>段内页号 Page number (P)</li><li>页内相对地址(位移量)The offset number (W)</li></ul></li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-12-17-20-19.png" style="zoom:100%;"><p>综合了分段和分页技术的优点，既能有效地利用存储空间，又能方便用户进行程序设计。但是，实现段页式存储管理系统需要增加硬件成本，系统的复杂度和管理开销也大大增加。因此，段页式存储管理技术适合于大、中型计算机系统，不太适合小型、微型计算机系统。</p><h4 id="地址变换机构-Address-Translation-2"><a href="#地址变换机构-Address-Translation-2" class="headerlink" title="地址变换机构 Address Translation"></a>地址变换机构 Address Translation</h4><ul><li>首先，从段表寄存器从获得进程段表的起始地址，根据该地址，查找进程的段表。</li><li>然后，根据逻辑地址指定的段号检索段表，找到对应段的页表起始地址。</li><li>再根据逻辑地址中指定的页号检索该页表，找到对应页所在的物理块号。</li><li>最后，用物理块号加上逻辑地址中指定的页内偏移量，形成物理地址。</li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-12-17-54-40.png" style="zoom:100%;"><h4 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h4><p>在段页式存储管理方式中，每访问一次数据，需访问 次内存。</p><ul><li>第一次访问内存中的段表</li><li>第二次访问内存中的页表</li><li>第三次访问相应数据。<br>可以设置快表，表项应包括段号、页号、物理块号<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-12-18-04-54.png" style="zoom:100%;"></li></ul><h2 id="Swap"><a href="#Swap" class="headerlink" title="Swap"></a>Swap</h2><h3 id="Intro-1"><a href="#Intro-1" class="headerlink" title="Intro"></a>Intro</h3><p><strong>对换</strong>指把内存中暂不能运行的进程或暂时不用和程序和数据，换到外存上，以腾出足够的内存空间，把已具备运行条件的进程，或进程所需要的程序和数据，换入内存。<br>对换是系统行为，是提高内存的利用率的有效措施。<br>常用于多道程序系统或小型分时系统中，与分区存储管理配合使用。<br>实现：可在系统中设一对换进程，以执行换进内存、换出至外存操作。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-12-18-11-20.png" style="zoom:100%;"><p>对换技术，最早用在分时系统 UNIX 中。<br>在任何时刻，在该系统的主存中只保存一个完整的用户作业，当其运行一段时间后，或由于分配给它的时间片已用完，或由于需要其它资源而等待，系统就把它交换到辅存，同时把另一个作业调入主存让其运行。这样，可以在存储容量不大的小型机上实现分时系统。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><strong>分类</strong></p><ul><li>整体对换（进程对换）<br>对换以整个进程为单位，用于分时系统，以解决内存紧张的问题；</li><li>页面对换&#x2F;分段对换<br>对换以“页”或“段”为单位进行“部分对换”，该方法是实现请求分页及请求分段存储器的基础，支持虚存系统。</li></ul><p><strong>功能</strong></p><p>为实现对换，系统需要三方面的功能：</p><ul><li>对换空间的管理</li><li>进程的换入</li><li>进程的换出</li></ul><h4 id="对换空间的管理"><a href="#对换空间的管理" class="headerlink" title="对换空间的管理"></a>对换空间的管理</h4><p>外存被分为两部分，文件区和对换区<br><strong>文件区</strong>用于存放文件，对它的管理应重在如何提高存储空间的利用率。所以对它采取离散分配方式。即一个文件可根据当前外存的使用情况，被分成多块，分别存储到不邻接的多个存储区域中，用指针相连。<br><strong>对换区</strong>存放从内存换出的进程，它们在外存的存放时间较短，换入、换出频繁。对对换区的管理应重在提高进程的换入换出速度。因此采用连续分配方式。即把一个换出的进程存放到一个连续的存储空间中。</p><p>为了能对对换区中的空闲盘块进行管理，在系统中应配置相应的数据结构，以记录外存的使用情况。<br>空闲分区表或空闲分区链。在空闲分区表中的每个表目应包含两项，即<strong>对换分区首址</strong>和<strong>对换区长度</strong>，它们的基本单位都是盘块。<br>对换区的分配，是采用连续分配方式。因而对对换区空间的分配与回收，与动态分区方式时内存的分配与回收方法雷同。<br>分配算法可以是首次适应算法、循环首次适应算法和最佳适应算法。<br>回收操作也可分为四种情况</p><blockquote><p>为了能对交换区中的空闲盘块进行管理，在系统中应配置相应的数据结构,盘块的大小和操作系统的具体文件系统有关系;比如 fat32 的盘块大小为 4KB,内存分配的单位是字节，外存（硬盘）分配的单位是盘块</p></blockquote><h4 id="进程的换进与换出"><a href="#进程的换进与换出" class="headerlink" title="进程的换进与换出"></a>进程的换进与换出</h4><p><strong>换出</strong>（swap out）<br>首先选择阻塞或睡眠状态的进程，若有多个，按优先级由低到高进行选择。若没有此状态进程，则选择就绪状态的，仍然按优先级由低到高进行选择。<br>为避免某进程被频繁的换入换出，还应考虑进程在内存中的驻留时间，优先选择驻留时间长的进程。<br><strong>换入</strong>（swap in）<br>① 从 PCB 集合中查找“就绪且换出”的进程，有多个，则选择换出时间最长的。<br>② 根据进程大小申请内存，成功则读入，否则要先执行换出，再换入。<br>③ 若还有可换入进程，则转向 ①。直至无“就绪且换出”进程或无法获得足够内存空间为止。</p><h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><table><thead><tr><th align="center">S.NO</th><th align="center">Paging</th><th align="center">Segmentation</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">In paging, the program is divided into fixed or mounted size pages.</td><td align="center">In segmentation, the program is divided into variable size sections.</td></tr><tr><td align="center">2</td><td align="center">For the paging operating system is accountable.</td><td align="center">For segmentation compiler is accountable.</td></tr><tr><td align="center">3</td><td align="center">Page size is determined by hardware.</td><td align="center">Here, the section size is given by the user.</td></tr><tr><td align="center">4</td><td align="center">It is faster in comparison to segmentation.</td><td align="center">Segmentation is slow.</td></tr><tr><td align="center">5</td><td align="center">Paging could result in internal fragmentation.</td><td align="center">Segmentation could result in external fragmentation.</td></tr><tr><td align="center">6</td><td align="center">In paging, the logical address is split into a page number and page offset.</td><td align="center">Here, the logical address is split into section number and section offset.</td></tr><tr><td align="center">7</td><td align="center">Paging comprises a page table that encloses the base address of every page.</td><td align="center">While segmentation also comprises the segment table which encloses segment number and segment offset.</td></tr><tr><td align="center">8</td><td align="center">The page table is employed to keep up the page data.</td><td align="center">Section Table maintains the section data.</td></tr><tr><td align="center">9</td><td align="center">In paging, the operating system must maintain a free frame list.</td><td align="center">In segmentation, the operating system maintains a list of holes in the main memory.</td></tr><tr><td align="center">10</td><td align="center">Paging is invisible to the user.</td><td align="center">Segmentation is visible to the user.</td></tr><tr><td align="center">11</td><td align="center">In paging, the processor needs the page number, and offset to calculate the absolute address.</td><td align="center">In segmentation, the processor uses segment number, and offset to calculate the full address.</td></tr><tr><td align="center">12</td><td align="center">It is hard to allow sharing of procedures between processes.</td><td align="center">Facilitates sharing of procedures between the processes.</td></tr><tr><td align="center">13</td><td align="center">In paging, a programmer cannot efficiently handle data structure.</td><td align="center">It can efficiently handle data structures.</td></tr><tr><td align="center">14</td><td align="center">This protection is hard to apply.</td><td align="center">Easy to apply for protection in segmentation.</td></tr><tr><td align="center">15</td><td align="center">The size of the page needs always be equal to the size of frames.</td><td align="center">There is no constraint on the size of segments.</td></tr><tr><td align="center">16</td><td align="center">A page is referred to as a physical unit of information.</td><td align="center">A segment is referred to as a logical unit of information.</td></tr><tr><td align="center">17</td><td align="center">Paging results in a less efficient system.</td><td align="center">Segmentation results in a more efficient system.</td></tr></tbody></table><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://data-flair.training/blogs/memory-management-in-computer/">data-flair memory-management-in-computer</a><br><a href="https://www.cs.cornell.edu/courses/cs4410/2017su/lectures/lec12-ipt.html">Inverted page tables</a><br><a href="https://www.geeksforgeeks.org/inverted-page-table-in-operating-system/">Inverted Page Table in Operating System</a><br><a href="https://www.cnblogs.com/Allen-rg/p/7185161.html">操作系统基本分段存储管理方式</a></p>]]></content>
    
    
    <summary type="html">基本分页存储管理方式，基本分段存储管理方式</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="操作系统" scheme="https://efterklang.github.io/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Understanding Git Reset and Revert</title>
    <link href="https://efterklang.github.io/Dev/Git/reset-and-revert/"/>
    <id>https://efterklang.github.io/Dev/Git/reset-and-revert/</id>
    <published>2024-05-05T13:04:42.000Z</published>
    <updated>2024-05-13T14:20:32.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>项目开发中遇到过意外提交或糟糕的修改需要撤销的情况如何解决？Git Reset它可以帮助我们在Git历史中回到过去，去除错误的提交或修改，为项目的进展铺平道路</p><h2 id="reset命令格式和参数-🛠️"><a href="#reset命令格式和参数-🛠️" class="headerlink" title="reset命令格式和参数 🛠️"></a>reset命令格式和参数 🛠️</h2><p>在开始介绍Git Reset的使用案例之前，我们先来了解一下Git Reset命令的格式和参数。Git Reset命令的一般格式如下</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">reset</span> [<span class="keyword">option</span>] &lt;<span class="keyword">commit</span>&gt;</span><br></pre></td></tr></table></figure><p>Git Reset命令有三个主要的选项参数，它们分别是：</p><ul><li>git reset –soft <commit>: 此命令将HEAD移动到指定的提交，但保留暂存区和工作目录不变。这意味着所有的更改仍然被暂存，你可以重新提交。这是撤销提交但保留更改以便重新提交的好方法。<br>只改变HEAD的位置，不改变暂存区和工作目录</li><li>git reset –mixed <commit>: 这是git reset的默认模式。此命令将HEAD移动到指定的提交，并且也会更新暂存区以匹配这个提交。但是，工作目录中的文件不会改变。这意味着你的更改仍然存在，但没有被暂存，你可以重新暂存和提交。<br>只改变HEAD和暂存区的位置，不改变工作目录</li><li>git reset –hard <commit>: 此命令将HEAD移动到指定的提交，并且也会更新暂存区和工作目录以匹配这个提交。这将永久删除自指定提交以来的所有更改。这是一个危险的命令，因为它会永久删除更改，所以在使用之前一定要确认你不需要这些更改。<br>改变HEAD、暂存区和工作目录的位置</li><li>git reset –merge&#x2F;keep 不常用，暂不做介绍</li></ul><blockquote><p>git reset也可以操作文件，通过<code>git reset &lt;file_name&gt;</code>撤销暂存区中相应的文件</p></blockquote><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>修复错误的提交</strong> 🐞</p><p>有时候，我们可能会在项目中不小心提交了一些错误的代码或文件，甚至可能是敏感信息。你可以使用git reset回到之前的提交，撤销这次错误，然后再次进行修改，确保密码等敏感信息不再提交到代码库中。</p><p><strong>回滚到稳定版本</strong> ⏪</p><p>另一个Git Reset的常见应用场景是回滚到项目的稳定版本。有时候，在进行新功能开发或进行一些实验性的修改时，我们可能会发现项目出现了一些难以解决的问题，导致项目无法正常工作。通过回到之前的稳定版本，你可以快速撤销引入问题的修改，并确保项目回到可用状态。</p><p>例如，你在开发一个网站时添加了一些新功能，但发现它们导致了严重的性能问题,你希望丢弃这些修改，回到一个已知稳定的版本。使用Git Reset，你可以轻松地回到之前的提交，撤销这些修改，确保项目恢复正常运行。</p><h2 id="Git-Revert"><a href="#Git-Revert" class="headerlink" title="Git Revert"></a>Git Revert</h2><p>git reset可以撤销提交，但是会删除提交历史，如果想保留提交历史，可以使用git revert</p><p><code>git revert &lt;commit&gt;</code>，其中<code>&lt;commit&gt;</code>是你希望撤销的提交的哈希值或引用。Git会自动创建一个新的提交，撤销指定的更改，并保留撤销的历史记录。此时，你的代码将回到撤销的提交之前的状态。</p>]]></content>
    
    
    <summary type="html">介绍git reset和revert的使用；通过git reset，撤销提交，回滚版本，使项目的进展更加顺利。</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Git" scheme="https://efterklang.github.io/categories/Dev/Git/"/>
    
    
    <category term="Git" scheme="https://efterklang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>ChⅥ 数据库应用编程</title>
    <link href="https://efterklang.github.io/UESTC/DataBase/Ch6-DbPrograming/"/>
    <id>https://efterklang.github.io/UESTC/DataBase/Ch6-DbPrograming/</id>
    <published>2024-04-28T12:07:31.000Z</published>
    <updated>2024-05-21T07:18:07.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库连接技术"><a href="#数据库连接技术" class="headerlink" title="数据库连接技术"></a>数据库连接技术</h2><h3 id="ODBC"><a href="#ODBC" class="headerlink" title="ODBC"></a>ODBC</h3><p><strong>ODBC</strong> 是由 Microsoft 在 1990 年代初开发的，用于访问各种数据库系统的标准 API。ODBC 使用 SQL 作为数据库访问语言，允许应用程序独立于任何特定 DBMS，从而使得应用程序能够与多种 DBMS 进行交互。ODBC 驱动程序是一种实现了 ODBC 接口的特定 DBMS 的库。应用程序通过 ODBC 驱动程序与 DBMS 进行通信。</p><ul><li>开放式数据库互连（Open DataBase Connectivity）实现了应用程序对多种不同 DBMS 的数据库的访问，实现了数据库连接方式的变革</li><li>是一套基于 SQL 的，公共的，与数据库无关的 API</li><li>使每个应用程序利用相同的源代码就可访问不同的数据库系统</li><li>存取多个数据库中的数据，从而使得应用程序与数据库管理系统之间在逻辑上独立，使应用程序与数据库无关性</li></ul><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p><strong>JDBC</strong> 是 Java 中用于数据库连接的 API，由 Sun Microsystems（现在是 Oracle Corporation 的一部分）在 1997 年发布。JDBC 提供了一种基准，使得 Java 程序可以与多种关系数据库进行交互。JDBC 提供了一组接口和类，使得开发人员可以发送 SQL 语句并处理结果。JDBC 驱动程序是实现了 JDBC 接口的特定 DBMS 的 Java 类库。Java 程序通过 JDBC 驱动程序与 DBMS 进行通信。</p><p>JDBC 程序访问数据库的步骤</p><ul><li>应用程序开始</li><li>导入 java.sql 包</li><li>加载并注册驱动程序</li><li>依次创建 Connection 对象、Statement 对象</li><li>执行 SQL 语句</li><li>使用 ResultSet 对象返回结果</li><li>依次关闭 ResultSet 对象、Statement 对象、Connection 对象</li><li>应用程序结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际开发中，密码不应该明文存储，应进行一定的数据脱敏处理。这也是为什么忘记密码时，只能重置密码，而不能查看密码的原因</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProcessAccountData</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ProcessAccountData.class.getClassLoader();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">sqlURL</span> <span class="operator">=</span></span><br><span class="line">            <span class="string">&quot;jdbc:mysql://localhost:3306/free_chat?serverTimezone=GMT&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;gjxMySQLPWD&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> 对数据库,进行读取，写入到validUsers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> validUsers 要写入账号数据的HashMap</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readAccountFile</span><span class="params">(ConcurrentHashMap&lt;String, User&gt; validUsers)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(sqlURL, user, password);</span><br><span class="line">                <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> conn.createStatement()) &#123;</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;select * from accounts&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(rs.getString(<span class="string">&quot;account&quot;</span>), rs.getString(<span class="string">&quot;pwd&quot;</span>));</span><br><span class="line">                validUsers.put(rs.getString(<span class="string">&quot;account&quot;</span>), user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@apiNote</span> 当进行注册时，将userId＆pwd写入到数据库中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pwd 用户密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeAccountFile</span><span class="params">(String userId, String pwd)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO accounts (account, pwd) VALUES (?, ?)&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(sqlURL, user, password);) &#123;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line">            pstmt.setString(<span class="number">1</span>, userId);</span><br><span class="line">            pstmt.setString(<span class="number">2</span>, pwd);</span><br><span class="line">            pstmt.executeUpdate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><p>Servlet 是 Java Web 技术的核心组成部分，它是在服务器端运行的 Java 程序，用于处理来自 Web 客户端（如浏览器）的请求，并生成动态的 Web 内容。Servlet 是 Java EE 规范的一部分，但在 Java EE 8 之后，Java EE 已经转交给 Eclipse 基金会，并更名为 Jakarta EE。因此，最新的 Servlet 规范是 Jakarta Servlet。</p><p>以下是关于 Servlet 的一些关键点：</p><ul><li><strong>生命周期</strong>：Servlet 的生命周期从 Web 容器加载和实例化 Servlet 开始，经过处理一系列的请求，直到最后 Web 容器卸载 Servlet。主要的方法有 init(), service(), 和 destroy()。</li><li><strong>处理请求</strong>：Servlet 可以处理来自客户端的 GET、POST 等 HTTP 请求，并根据请求生成相应的响应。请求和响应都被封装为 Java 对象，分别是 HttpServletRequest 和 HttpServletResponse。</li><li><strong>线程安全</strong>：对于每个新的请求，Servlet 容器会启动一个新的线程来处理。因此，Servlet 必须被设计为线程安全的。</li><li><strong>配置和上下文</strong>：Servlet 可以通过 ServletConfig 和 ServletContext 接口访问配置信息和应用程序级别的上下文。</li><li><strong>会话管理</strong>：Servlet 提供了 HttpSession 接口来管理与特定用户相关的会话。</li><li><strong>过滤器和监听器</strong>：Servlet API 还提供了过滤器（Filter）和监听器（Listener）等组件，可以用于拦截请求、响应，或者监听 Servlet 的生命周期事件等。</li></ul><p><strong>Servlet 工作流程</strong></p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-DbPrograming-2024-04-29-17-23-01.png" style="zoom:100%;"><h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><p>MyBatis 是一个优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码和参数的手动设置以及结果集的检索。MyBatis 可以使用简单的 XML 或注解进行配置，并将原生信息映射至 Java 对象。MyBatis 通常被视为介于全自动 ORM 框架（如 Hibernate）和手动处理所有事情的 JDBC 之间的一种解决方案。</p><p><strong>Mybatis 优点</strong>：</p><ol><li>支持自定义 SQL、存储过程、及高级映射</li><li>实现自动对 SQL 的参数设置</li><li>实现自动对结果集进行解析和封装</li><li>通过 XML 或者注解进行配置和映射，大大减少代码量</li><li>数据源的连接信息通过配置文件进行配置</li></ol><h3 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h3><p>JSP 全名为 Java Server Pages，java 服务器页面。JSP 是一种基于文本的程序，其特点就是 HTML 和 Java 代码共同存在<br>jsp 只是 servlet 的一种特殊形式，每一个 jsp 页面就是一个 servlet 实例，通俗一点的话来说：jsp 就是 servlet，只不过 servlet 把一些业务功能剥离开来交给了或者是形成了 jsp。在我们的项目编译的时候就是把 jsp 编译成了 servlet。<br>JSP 比 Servlet 更方便更简单的一个重要原因就是：内置了 9 个对象！内置对象有：out、session、response、request、config、page、application、pageContext、exception</p><h3 id="SSM-典型-Java-web-开发架构"><a href="#SSM-典型-Java-web-开发架构" class="headerlink" title="SSM 典型 Java web 开发架构"></a>SSM 典型 Java web 开发架构</h3><ul><li>JSP&#x2F;HTML 页面发送请求</li><li>Controller 层接收用户请求，进行响应的流程处理</li><li>Service 层完成具体的业务逻辑</li><li>DAO(Data Access Object)层对数据库进行操作</li><li>数据库</li></ul><h2 id="数据库存储过程"><a href="#数据库存储过程" class="headerlink" title="数据库存储过程"></a>数据库存储过程</h2><p><strong>存储过程</strong>（Stored Procedure）是一种数据库的对象。由一组能完成特定功能的 SQL 语句集构成，是把经常会被重复使用的 SQL 语句逻辑块封装起来，经编译后，存储在数据库服务器端；当被再次调用时，不需要再次编译； 当客户端连接到数据库时，用户通过指定存储过程的名字并给出参数，数据库就可以找到相应的存储过程予以调用。</p><blockquote><p>PostgreSQL 使用 CREATE FUNCTION 命令创建存储过程。(11 版本后可以用 CREATE PRECEDURE)</p></blockquote><p><strong>Pros</strong><br>(1) 减少网络通信量<br>(2) 执行速度更快<br>(3) 更强的适应性<br>(4) 降低了业务实现与应用程序的耦合<br>(5) 降低了开发的复杂性<br>(6) 保护数据库元信息<br>(7) 增强了数据库的安全性<br><strong>Cons</strong><br>(1) SQL 本身是一种结构化查询语言，而存储过程本质上是过程化的程序；面对复杂的业务逻辑，过程化处理逻辑相对比较复杂；而 SQL 语言的优势是面向数据查询而非业务逻辑的处理。<br>(2) 如果存储过程的参数或返回数据发生变化，一般需要修改存储过程的代码，同时还需要更新主程序调用存储过程的代码。<br>(3) 开发调试复杂，由于缺乏支持存储过程的集成开发环境，存储过程的开发调试要比一般程序困难。<br>(4) 可移植性差</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建存储过程</span></span><br><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> REPLACE ] <span class="keyword">FUNCTION</span><span class="operator">/</span><span class="keyword">PROCEDURE</span>  name</span><br><span class="line">([ [ argmode ] [ argname ] argtype [ &#123; <span class="keyword">DEFAULT</span> <span class="operator">|</span> <span class="operator">=</span> &#125; default_expr ] [, ...] ])</span><br><span class="line"> [ <span class="keyword">RETURNS</span> retype <span class="operator">|</span> <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span> ( column_name  column_type [, ...] ) ]</span><br><span class="line"> <span class="keyword">AS</span> $$         <span class="comment">-- $$用于声明存储过程的实际代码的开始</span></span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    <span class="comment">-- 声明段</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="comment">--函数体语句</span></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"> $$ <span class="keyword">LANGUAGE</span> lang_name;  <span class="comment">--$$ 表明代码的结束, LANGUAGE后面指明所用的编程语言</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">主要参数：</span></span><br><span class="line"><span class="string">（1）name：要创建的存储过程名；</span></span><br><span class="line"><span class="string">（2）OR REPLACE ：覆盖同名的存储过程；</span></span><br><span class="line"><span class="string">（3）argmode：存储过程参数的模式可以为IN、OUT或INOUT，缺省值是IN。</span></span><br><span class="line"><span class="string">（4）argname：形式参数的名字。</span></span><br><span class="line"><span class="string">（5）RETURNS：返回值；RETURNS TABLE：返回二维表</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment">--删除存储过程</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> [ IF <span class="keyword">EXISTS</span> ] name ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [</span><br><span class="line">CASCADE <span class="operator">|</span> RESTRICT ]</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">主要参数：</span></span><br><span class="line"><span class="string">（1）IF EXISTS：如果指定的存储过程不存在，那么发出提示信息。</span></span><br><span class="line"><span class="string">（2）name ：现存的存储过程名称。</span></span><br><span class="line"><span class="string">（3）argmode：参数的模式：IN(缺省), OUT, INOUT, VARIADIC。请注意，实际并不注明OUT参数，因为判断</span></span><br><span class="line"><span class="string">存储过程的身份只需要输入参数。</span></span><br><span class="line"><span class="string">（4）argname：参数的名字。请注意，实际上并不注明参数的名字，因为判断函数的身份只需要输入参数的数据类</span></span><br><span class="line"><span class="string">型。</span></span><br><span class="line"><span class="string">（5）argtype：如果有的话，是存储过程参数的类型。</span></span><br><span class="line"><span class="string">（6）CASCADE：级联删除依赖于存储过程的对象(如触发器)。</span></span><br><span class="line"><span class="string">（7）RESTRICT：如果有任何依赖对象存在，则拒绝删除该函数；这个是缺省值。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="PL-pgSQL-syntax"><a href="#PL-pgSQL-syntax" class="headerlink" title="PL\pgSQL syntax"></a>PL\pgSQL syntax</h3><ol><li>变量声明的语法如下：<br>declare<br>变量名 变量类型；<br>如果声明变量为记录类型，变量声明格式为： variable_name RECORD;<br>注：RECORD 不是真正的数据类型，只是一个占位符。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span></span><br><span class="line">  count intger;</span><br><span class="line">    rec RECORD;</span><br></pre></td></tr></table></figure><ol start="2"><li>condition statement</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">IF-THEN</span></span><br><span class="line"><span class="string">IF-THEN-ELSE</span></span><br><span class="line"><span class="string">IF-THEN-ELSEIF-ELSE</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">IF <span class="keyword">condition</span> <span class="keyword">THEN</span></span><br><span class="line">  statement;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">IF <span class="keyword">condition</span> <span class="keyword">THEN</span></span><br><span class="line">  statement;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">  statement;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">IF condition1 <span class="keyword">THEN</span></span><br><span class="line">  statement;</span><br><span class="line">ELSEIF condition2 <span class="keyword">THEN</span></span><br><span class="line">  statement;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line">  statement;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br></pre></td></tr></table></figure><ol start="3"><li>loop</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">LOOP</span><br><span class="line">  statement;</span><br><span class="line"><span class="keyword">END</span> LOOP [label];</span><br><span class="line"></span><br><span class="line">LOOP</span><br><span class="line">  i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">  EXIT <span class="keyword">WHEN</span> i <span class="operator">&gt;</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line">LOOP</span><br><span class="line">  i <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">  EXIT <span class="keyword">WHEN</span> i <span class="operator">&gt;</span> <span class="number">100</span>;</span><br><span class="line">  CONTINUE <span class="keyword">WHEN</span> i <span class="operator">&lt;</span> <span class="number">50</span>;</span><br><span class="line">  j <span class="operator">=</span> j <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line">WHILE <span class="keyword">condition</span> LOOP</span><br><span class="line">  statement;</span><br><span class="line"><span class="keyword">END</span> LOOP</span><br><span class="line"></span><br><span class="line"><span class="keyword">FOR</span> i <span class="keyword">IN</span> <span class="number">1.</span><span class="number">.10</span> LOOP</span><br><span class="line">  RAISE NOTICE <span class="string">&#x27;i = %&#x27;</span>, i;</span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> Out_Record() <span class="keyword">returns</span> RECORD <span class="keyword">as</span> $$</span><br><span class="line"><span class="keyword">declare</span> </span><br><span class="line">rec RECORD;</span><br><span class="line"><span class="keyword">FOR</span> rec <span class="keyword">IN</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student LOOP</span><br><span class="line">raise notice <span class="string">&#x27;学生数据: %,%&#x27;</span>,rec.studentID,rec.studentName; </span><br><span class="line"><span class="keyword">END</span> LOOP;</span><br><span class="line"><span class="keyword">return</span> rec;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">$$ <span class="keyword">language</span> plpgsql;</span><br></pre></td></tr></table></figure><h3 id="return-type"><a href="#return-type" class="headerlink" title="return type"></a>return type</h3><p>在 SQL 和 PL&#x2F;pgSQL 中，函数可以返回以下几种类型的值：</p><ol><li><p><strong>标量（Scalar）</strong>：这是最简单的返回类型，可以是任何基本数据类型，如 INTEGER，VARCHAR，BOOLEAN 等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> add_one(<span class="type">INTEGER</span>) <span class="keyword">RETURNS</span> <span class="type">INTEGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">RETURN</span> $<span class="number">1</span> <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure></li><li><p><strong>记录（Record）</strong>：函数可以返回一个完整的记录，这个记录的结构通常与一个已存在的表相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> get_employee(<span class="type">INTEGER</span>) <span class="keyword">RETURNS</span> employee <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">DECLARE</span></span><br><span class="line">    rec employee<span class="operator">%</span>ROWTYPE;</span><br><span class="line">  <span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">INTO</span> rec <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> id <span class="operator">=</span> $<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">RETURN</span> rec;</span><br><span class="line">  <span class="keyword">END</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure></li><li><p><strong>表（Table）</strong>：函数还可以返回一个表，即多个记录。这个表可以有自定义的结构，也可以与一个已存在的表相同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> get_employees() <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span>(id <span class="type">INTEGER</span>, name <span class="type">VARCHAR</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">RETURN</span> QUERY <span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure></li><li><p><strong>触发器（Trigger）</strong>：在 PostgreSQL 中，触发器函数必须声明为返回 TRIGGER。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> check_update() <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  IF NEW.updated_at <span class="operator">&lt;</span> OLD.updated_at <span class="keyword">THEN</span></span><br><span class="line">    RAISE EXCEPTION <span class="string">&#x27;Update timestamp must be newer&#x27;</span>;</span><br><span class="line">  <span class="keyword">END</span> IF;</span><br><span class="line">  <span class="keyword">RETURN</span> <span class="keyword">NEW</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure></li><li><p><strong>复杂类型（Composite Types）</strong>：函数可以返回一个自定义的复合类型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> TYPE my_type <span class="keyword">AS</span> (f1 <span class="type">integer</span>, f2 text);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> return_compound() <span class="keyword">RETURNS</span> my_type <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">RETURN</span> <span class="type">ROW</span>(<span class="number">1</span>,<span class="string">&#x27;test&#x27;</span>)::my_type;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure></li><li><p><strong>Void</strong>：如果函数不需要返回任何值，可以使用 VOID 类型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> log_message(text) <span class="keyword">RETURNS</span> VOID <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  RAISE NOTICE <span class="string">&#x27;%&#x27;</span>, $<span class="number">1</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><ol><li>统计学生表中有多少 records</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> countRecords ()</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">integer</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">declare</span></span><br><span class="line">    count <span class="type">integer</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">INTO</span> count <span class="keyword">FROM</span> STUDENT;  <span class="comment">-- INTO 用于将查询结果赋值给变量</span></span><br><span class="line">   <span class="keyword">RETURN</span> count;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"><span class="comment">-- 执行存储过程</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> countRecords();</span><br></pre></td></tr></table></figure><ol start="2"><li>如果 grade 大于等于 60 分视为该学生取得相应学分，编写 sql 代码统计每个 学生取得的总学分，包含学号、姓名、总学分；<br><code>Course（courseid，coursename，credit）</code><br><code>Grade（gradeid，studentid，courseid，grade）</code><br><code>Student（studentid，studentname，sex，age）</code></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> getcredit0()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span>(</span><br><span class="line">    vsid <span class="type">CHAR</span>,</span><br><span class="line">vsname <span class="type">VARCHAR</span>,</span><br><span class="line">vscredit <span class="type">BIGINT</span></span><br><span class="line">  )</span><br><span class="line"><span class="keyword">AS</span> $vscredit$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   <span class="comment">-- 这是主查询，它将从course，grade和student表中获取信息，</span></span><br><span class="line">   <span class="comment">-- 并计算每个学生的总学分（只包括成绩大于或等于60的课程）。</span></span><br><span class="line">   <span class="keyword">RETURN</span> QUERY</span><br><span class="line">   <span class="keyword">SELECT</span></span><br><span class="line">     C.studentid <span class="keyword">AS</span> &quot;vsid&quot;,</span><br><span class="line">     C.studentname <span class="keyword">AS</span> &quot;vsname&quot;,</span><br><span class="line">     <span class="built_in">SUM</span>(A.credit) <span class="keyword">AS</span> &quot;vscredit&quot;</span><br><span class="line">   <span class="keyword">FROM</span></span><br><span class="line">     COURSE <span class="keyword">AS</span> A,</span><br><span class="line">     GRADE <span class="keyword">AS</span> B,</span><br><span class="line">     STUDENT <span class="keyword">AS</span> C</span><br><span class="line">   <span class="keyword">WHERE</span></span><br><span class="line">     B.studentid <span class="operator">=</span> C.studentid <span class="keyword">AND</span></span><br><span class="line">     A.courseid <span class="operator">=</span> B.courseid <span class="keyword">AND</span></span><br><span class="line">     B.grade <span class="operator">&gt;=</span> <span class="number">60</span></span><br><span class="line">   <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">     C.studentid;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$vscredit$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 调用函数</span></span><br><span class="line"><span class="keyword">SELECT</span> getcredit0();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="3"><li>创建一个名为 add_data(a, b，c)的存储过程实现 a+b 相加运算，并将结果放入 c</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">PROCEDURE</span> add_data(a <span class="type">integer</span>,b <span class="type">integer</span>,<span class="keyword">inout</span> c <span class="type">integer</span>)<span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">Begin</span></span><br><span class="line">c<span class="operator">=</span>a<span class="operator">+</span>b;</span><br><span class="line"><span class="keyword">End</span>;</span><br><span class="line">$$<span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure><h2 id="数据库触发器"><a href="#数据库触发器" class="headerlink" title="数据库触发器"></a>数据库触发器</h2><p>触发器是一个定义在表或视图上的特殊类型的存储过程（不传递接受参数）、一个特殊的事务单位，由操作事件触发自动执行，可以实现比约束更复杂的数据完整性，用于加强数据完整性约束和业务规则</p><p>语句级触发器只执行一次（默认触发器）；行级触发器每有数据变化一行就执行一次</p><ul><li>INSTEAD OF触发器：事件发生时只执行触发器不执行原本的sql语句，一个表或视图只能有一个INSTEAD OF触发器</li><li>NEW：RECORD类型，对于行级触发器其存有INSERT或UPDATE操作产生的新数据行。对于语句级触发器其值为NULL</li><li>OLD：RECORD类型，对于行级触发器其存有DELETE或UPDATE操作修改或删除的旧数据行。对于语句级触发器其值为NULL</li><li>TG_OP:text类型，值为INSERT&#x2F;UPDATE&#x2F;DELETE，说明引发触发器的操作</li></ul><p>创建触发器步骤：</p><ul><li>检查所依附的表或视图是否存在</li><li>创建触发器执行的触发器函数，返回类型为TRIGGER</li><li>创建触发器</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu_score</span><br><span class="line">( </span><br><span class="line">    sid <span class="type">character</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    cid <span class="type">character</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    score <span class="type">numeric</span>(<span class="number">5</span>,<span class="number">1</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> stu_score_pkey <span class="keyword">PRIMARY</span> KEY (sid, cid)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> audit_score</span><br><span class="line">(    username <span class="type">character</span>(<span class="number">20</span>) ,  <span class="comment">--用户名</span></span><br><span class="line">    sid <span class="type">character</span>(<span class="number">10</span>) ,</span><br><span class="line">    cid <span class="type">character</span>(<span class="number">10</span>) ,</span><br><span class="line">    updatetime text ,            <span class="comment">--修改的时间</span></span><br><span class="line">    oldscore <span class="type">numeric</span>(<span class="number">5</span>,<span class="number">1</span>),   <span class="comment">--修改前的成绩</span></span><br><span class="line">    newscore <span class="type">numeric</span>(<span class="number">5</span>,<span class="number">1</span>)  <span class="comment">--修改后的成绩</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 创建函数</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> REPLACE <span class="keyword">FUNCTION</span> score_audit <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> </span><br><span class="line"><span class="keyword">AS</span> $score_sudits$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">IF (TG_OP <span class="operator">=</span> <span class="string">&#x27;DELETE&#x27;</span>) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> audit_score <span class="keyword">SELECT</span> <span class="keyword">user</span>,old.sid,old.cid,OLD.score ;</span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">OLD</span>;</span><br><span class="line">ELSIF (TG_OP <span class="operator">=</span> <span class="string">&#x27;UPDATE&#x27;</span>) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> audit_score</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span>,old.sid,old.cid,now(),OLD.score,new.score</span><br><span class="line"><span class="keyword">WHERE</span> old.sid<span class="operator">=</span>new.sid <span class="keyword">and</span> old.cid<span class="operator">=</span>new.cid;</span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">NEW</span></span><br><span class="line">ELSIF (TG_OP <span class="operator">=</span> <span class="string">&#x27;INSERT&#x27;</span>) <span class="keyword">THEN</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> audit_score <span class="keyword">SELECT</span> <span class="keyword">user</span>,new.sid,new.cid,now(),<span class="keyword">null</span>,new.score;</span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">NEW</span>;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">RETURN</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$score_audits$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"><span class="comment">-- 创建触发器</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> score_audit_triger</span><br><span class="line">AFTER <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">OR</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> stu_score</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> score_audit();</span><br><span class="line"><span class="comment">-- 修改触发器</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TRIGGER</span> score_audit_trigger <span class="keyword">ON</span> stu_score  RENAME <span class="keyword">TO</span> score_audit_trig;</span><br><span class="line"><span class="comment">-- 删除触发器</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> [ IF <span class="keyword">EXISTS</span> ] name <span class="keyword">ON</span> table_name [ CASCADE <span class="operator">|</span> RESTRICT ]</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> score_audit_trig <span class="keyword">ON</span> stu_score CASCADE;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数据库游标"><a href="#数据库游标" class="headerlink" title="数据库游标"></a>数据库游标</h2><p>游标是一种存放了查询数据库表返回的数据记录的临时的数据库对象，包含查询结果和指针，提供了处理结果集中每一条记录的机制，它总是与一条查询SQL语句相关联</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 声明游标</span></span><br><span class="line">curStudent <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student;</span><br><span class="line">curStudentOne <span class="keyword">CURSOR</span> (key <span class="type">integer</span>)<span class="number">7</span>y <span class="keyword">IS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> SID <span class="operator">=</span> key;</span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line"><span class="keyword">OPEN</span> curVars1 <span class="keyword">FOR</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student <span class="keyword">WHERE</span> SID <span class="operator">=</span> mykey;</span><br><span class="line"><span class="keyword">OPEN</span> curVars1 <span class="keyword">FOR</span> <span class="keyword">EXECUTE</span> <span class="string">&#x27;SELECT * FROM &#x27;</span> <span class="operator">||</span> quote_ident($<span class="number">1</span>);</span><br><span class="line"><span class="keyword">OPEN</span> curStudent;</span><br><span class="line"><span class="keyword">OPEN</span> curStudentOne (<span class="string">&#x27;20160230302001&#x27;</span>); </span><br><span class="line"><span class="comment">-- 使用游标提取值</span></span><br><span class="line"><span class="keyword">FETCH</span> curVars1 <span class="keyword">INTO</span> rowvar;  <span class="comment">--rowvar为行变量</span></span><br><span class="line"><span class="keyword">FETCH</span> curStudent <span class="keyword">INTO</span> SID, Sname, sex;</span><br><span class="line"><span class="comment">-- 关闭游标</span></span><br><span class="line"> <span class="keyword">CLOSE</span> cursorName; </span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/whgk/p/6399262.html">Java Web Servlet 详解 cnblog</a></p>]]></content>
    
    
    <summary type="html">PL/pgSQL过程语言，函数编程，游标编程；存储过程创建，存储过程修改，存储过程删除，存储过程调用；触发器创建，触发器修改，触发器应用；数据库JDBC连接技术，Java+嵌入式SQL编程。</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="数据库原理及应用" scheme="https://efterklang.github.io/categories/UESTC/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>网络层控制平面 Network Layer:Control Plane</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-2NetworkLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-2NetworkLayer/</id>
    <published>2024-04-27T12:34:19.000Z</published>
    <updated>2024-06-12T09:23:35.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>路由算法确定了通过网络的端到端路径，转发表确定了在路由器上的本地转发，转发表是链接数据平面与控制平面的主要元素，本篇将介绍其是如何计算、维护的</p><ul><li><strong>每个路由器控制 Per-router control</strong>：每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-11-17-28.png" style="zoom:50%;"></li><li><strong>逻辑集中式控制 Logically centralized control</strong>：逻辑集中式控制器计算并分发转发表以供每台路由器使用，如下图所示：<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-11-17-38.png" style="zoom:50%;"></li></ul><h2 id="Routing-Algorithms"><a href="#Routing-Algorithms" class="headerlink" title="Routing Algorithms"></a>Routing Algorithms</h2><p><strong>路由的基本概念</strong></p><ul><li>默认路由器：与主机直接相连的路由器，又叫第一跳路由器。每当主机发送一个分组时，都先传送给它的默认路由器。<ul><li>源路由器：源主机的默认路由器。</li><li>目的路由器：目的主机的默认路由器。</li><li>从源主机到目的主机的选路归结为从源路由器到目的路由器的选路。</li></ul></li><li>路由算法：是确定一个分组从源路由器到目的路由器所经路径的算法</li><li>路由算法的关键：在给定的一组路由器以及连接路由器的链路中，找到一条从源路由器到目的路由器的“好”路径。</li></ul><p><strong>网络的抽象图模型</strong></p><p>图$G &#x3D; (N，E)$表示 N 个节点和 E 条边的集合，每条边是来自 N 的一对节点。<br>Node 节点：表示路由器(做出分组转发判决的点)。如 $u，v，w，x，y，z$<br>Edge 边：连接节点的线段，表示路由器之间的物理链路。如$(u，v)、 (u，x) 、(u，w)、…$<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-13-50-15.png" style="zoom:70%;"></p><p>Cost 可以表示对应链路的物理长度、或链路速度、或与链路相关的费用。<br>定义：$c(x，y)$ 表示从节点 x 到节点 y 的链路费用,规定若节点 x 与节点 y 不直接相连则$c(x,y)&#x3D;\infty$</p><h3 id="Routing-Algorithms-Classification"><a href="#Routing-Algorithms-Classification" class="headerlink" title="Routing Algorithms Classification"></a>Routing Algorithms Classification</h3><ul><li><strong>集中式路由选择算法 Centralized Routing Algorithm</strong>：用完整、全局性的网络知识计算出从源到目的地之间的最低开销路径。具有全局状态信息的算法常被称作<strong>链路状态(Link State，LS)算法</strong>，因为该算法必须知道网络中每条链路的开销。</li><li><strong>分布式路由算法 Decentralized Routing Algorithm</strong>：路由器以迭代、分布式计算的方式计算出最低开销路径。没有节点拥有关于网络链路开销的完整信息。一个分散式路由选择算法为<strong>距离向量(Distance-Vector，DV)算法</strong>，每个节点维护到网络中所有其他节点的开销估计的向量。</li></ul><hr><ul><li><strong>静态路由算法</strong>：路由确定后基本不再变化。只有人工干预调整时，可能有一些变化。</li><li><strong>动态路由算法</strong>：当网络的流量负载或拓扑发生变化时，路径可能发生改变。可以周期性地或直接地响应拓扑或链路费用的变化。易受选路循环、路由振荡之类问题的影响。</li></ul><h3 id="Link-State-Routing-Algorithms"><a href="#Link-State-Routing-Algorithms" class="headerlink" title="Link State Routing Algorithms"></a>Link State Routing Algorithms</h3><p><strong>链路状态选路算法</strong></p><p>在实践中，这经常由链路状态广播（link state broadcast）算法完成。下面给出的链路状态路由选择算法是 Dijkstra’s algorithm</p><p><strong>Dijkstra’s Alogorithm</strong></p><ul><li>所有节点知道网络拓扑，以及每条链路的费用信息<ul><li>通过链路状态广播来实现</li><li>所有节点拥有相同的信息</li></ul></li><li>计算任意一个节点（源节点）到所有其他节点的最低费用路径<ul><li>给出该节点的转发表</li></ul></li><li>迭代：通过 k 次迭代后可以知道到达 k 个目的节点的最低费用路径</li><li>基本思想：以源节点为起点，每次找出一个到源节点的费用最低的节点，直到把所有的目的节点都找到为止。</li></ul><p>定义以下符号</p><ul><li><code>c(x,y)</code>: 表示从节点 x 到节点 y 的链路费用,规定若节点 x 与节点 y 不直接相连则<code>c(x,y)=∞</code></li><li><code>D(v)</code>：到算法的本次迭代，从源节点到目的节点 v 的最低开销；</li><li><code>p(v)</code>：从源到 v 沿着当前最小开销路径的前一个节点（v 的邻居）；</li><li><code>N&#39;</code>：节点子集；如果从源到 v 的最低开销路径已经确定，v 在<code>N&#39;</code>中</li><li><code>u</code> 源节点</li></ul><h4 id="Link-State-LS-Algorithm-for-Source-Node-u"><a href="#Link-State-LS-Algorithm-for-Source-Node-u" class="headerlink" title="Link-State (LS) Algorithm for Source Node u"></a>Link-State (LS) Algorithm for Source Node u</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Initialization:</span><br><span class="line">  N&#x27; = &#123;u&#125;</span><br><span class="line">  for all nodes v</span><br><span class="line">    if v is a neighbor of u:</span><br><span class="line">      then D(v) = c(u,v)</span><br><span class="line">    else  D(v) = ∞</span><br><span class="line"></span><br><span class="line">while N&#x27; != N:</span><br><span class="line">  # 从N&#x27;的补集中找一个到源节点费用最低的节点</span><br><span class="line">  find w not in N&#x27; such that D(w) is a minimum</span><br><span class="line">    add w to N&#x27;</span><br><span class="line">    update D(v) for each neighbor v of w and not in N&#x27;:</span><br><span class="line">      D(v) = min(D(v),D(w)+c(w,v))</span><br></pre></td></tr></table></figure><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-13-50-15.png" style="zoom:70%;">以上图为例,计算从u到所有可能目的节点的最低费用路径。算法迭代如下<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-15-30-57.png" style="zoom:70%;"><br><article class="message is-info">        <div class="message-header"><p>LS</p></div>        <div class="message-body">            <p>Dijkstra 例题 2 基于 Dijkstra 算法计算路由器 A 的算法表<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-10-20-04-16.png" style="zoom:100%;"></p><table><thead><tr><th>Step</th><th>N’</th><th>D(B),p(B)</th><th>D(C),p(C)</th><th>D(D),p(D)</th><th>D(E),p(E)</th><th>D(F),p(F)</th><th>D(G),p(G)</th><th>D(H),p(H)</th></tr></thead><tbody><tr><td>1</td><td>A</td><td>4,A</td><td>$\infty$</td><td>$\infty$</td><td>1,A</td><td>3,A</td><td>$\infty$</td><td>$\infty$</td></tr><tr><td>2</td><td>AE</td><td>4,A</td><td>$\infty$</td><td>$\infty$</td><td></td><td>3,A</td><td>$\infty$</td><td>$\infty$</td></tr><tr><td>3</td><td>AEF</td><td>4,A</td><td>$\infty$</td><td>8,F</td><td></td><td></td><td>6,F</td><td>$\infty$</td></tr><tr><td>4</td><td>AEFB</td><td></td><td>7,B</td><td>8,F</td><td></td><td></td><td>5,B</td><td>$\infty$</td></tr><tr><td>5</td><td>AEFBG</td><td></td><td>6,G</td><td>8,F</td><td></td><td></td><td></td><td>7,G</td></tr><tr><td>6</td><td>AEFBGC</td><td></td><td></td><td>8,F</td><td></td><td></td><td></td><td>7,G</td></tr><tr><td>7</td><td>AEFBGCH</td><td></td><td></td><td>8,F</td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td>AEFBGCHD</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>        </div>    </article><p>构建从源节点到所有目的节点的路径</p><ul><li>对于每个节点，都得到从源节点沿着它的最低费用路径的前驱节点；</li><li>每个前驱节点，又可得到它的前驱节点；以此继续，可以得到到所有目的节点的完整路径。<br>如节点 z 的前驱节点依次为：<code>p(z)=y,z-&gt;y;p(y)=x,z-&gt;y-&gt;x;p(x)=u,z-&gt;y-&gt;x-&gt;u</code></li><li>得出从源节点 u 到节点 z 的最低费用路径为：uxyz，费用为 4。</li><li>根据目的节点找出顺序和其费用以及前驱节点，可以画出源节点 u 到所有目的节点的最低费用路径树。<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-15-44-55.png" style="zoom:70%;"></li><li>根据得到的所有目的节点的完整路径，或最低费用路径树，可以生成源节点的转发表。<strong>转发表</strong>存放从源节点到每个目的节点的最低费用路径上的下一跳节点。即指出对于发往某个目的节点的分组，从该节点发出后的下一个节点。</li></ul><blockquote><p>默认路由 <code>*</code> ：表示所有具有相同“下一跳”的表项。即将“下一跳”相同的项合并为一项，目的节点用<code>*</code>表示。优先级最低，转发分组时，当找不到对应表项时，才使用默认路由。</p></blockquote><p><strong>Dijkstra’s Algorithm 复杂度</strong><br>设 n 个节点(除源节点)，最坏情况下要经多少次计算才能找到从源节点到所有目的节点的最低费用路径?<br>第一次迭代：搜索所有的 n 个节点以确定最低费用节点<br>第二次迭代：检查 n-1 个节点；<br>第三次：检查 n-2 个节点；<br>依次类推。<br>所有迭代中需要搜寻的节点总数为 $\frac{n(n+1)}{2}$<br>算法复杂性为 $O(n^2)$</p><p>且路线上的流量变化和拥塞会使 LS 算法产生<strong>路由震荡 Routing Oscillations</strong></p><h3 id="The-Distance-Vector（DV）Routing-Algorithm"><a href="#The-Distance-Vector（DV）Routing-Algorithm" class="headerlink" title="The Distance-Vector（DV）Routing Algorithm"></a>The Distance-Vector（DV）Routing Algorithm</h3><p>距离向量路由算法有以下特征</p><ul><li><strong>迭代 Iterative</strong>：计算过程一直持续到邻居之间无更多信息交换为止。</li><li><strong>分布式 Distributed</strong>：每个节点都从其直接相连邻居接收信息，进行计算，再将计算结果分发给邻居。</li><li><strong>异步 Asynchronous</strong>：不要求所有节点相互之间步伐一致地操作。</li><li><strong>自我终结 Self-termination</strong>：算法能自行停止。</li></ul><p><strong>Bellman-Ford 方程</strong></p><p>$$d_x(y)&#x3D;min_v{c(x,v)+d_v(y)}$$</p><ul><li>$d_x(y)$：节点 x 到节点 y 的最低开销路径的 cost。</li><li>$v$: 节点 x 的邻居节点。</li><li>$c(x,v)+ d_v(y)$：x 与某个邻居 v 之间的直接链路费用 c(x,v)加上邻居 v 到 y 的最小费用。即 x 经 v 到节点 y 的最小的路径费用。</li><li>$min_v$ ：从所有经直接相连邻居节点到节点 y 的费用中选取的最小路径费用。</li></ul><h4 id="Distance-Vector-DV-Algorithm"><a href="#Distance-Vector-DV-Algorithm" class="headerlink" title="Distance-Vector (DV) Algorithm"></a>Distance-Vector (DV) Algorithm</h4><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-19-17-16.png" style="zoom:50%;"><br><p>对每个节点 x:</p><ol><li>初始化</li><li>等待 (收到本地链路代价变化或邻居来距离矢量更新)</li><li>重新计算距离矢量,更新距离向量</li><li>如果到任何目的节点的距离矢量发生变化, 通知邻居</li><li>goto2</li></ol><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-13-50-15.png" style="zoom:70%;">仍以该图为例,计算源节点u到目的节点z的最低费用路径。<ul><li>邻居 v：$d_v(z) &#x3D; 5、c(u,v) &#x3D; 2$</li><li>邻居 w：$d_w(z) &#x3D; 3、c(u,w) &#x3D; 5$</li><li>邻居 x：$d_x(z) &#x3D; 3、c(u,x) &#x3D; 1$</li></ul><div>$$d_u(z) = min \{ c(u,v) + d_v(z), c(u,w) + d_w(z) , c(u,x) + d_x(z)\} \\= min\{2+5,5+3,1+3\} = 4$$</div><p>即源节点 u 经相邻节点 x 到目的节点 z 的路径费用最低，为 4</p><p><strong>节点的距离向量表</strong></p><ul><li>行：该节点的距离向量 Dx 和其邻居的距离向量 Dv</li><li>列：所有目的节点。</li></ul><p>节点 x 的距离向量 $D_x$ ，即节点 x 到每个目的节点 y 的估计费用； $Dx &#x3D; [D_x(y) | y \in N ]$<br>节点 x 每个邻居的距离向量 $D_v$ ，即 x 的邻居 v 到每个目的节点 y 的估计费用，$Dv &#x3D; [D_v(y)：y \in N]$</p><p>如何更新距离向量?</p><ul><li>每个节点不断向邻居发送其距离向量的 copy；</li><li>当节点 x 收到一个邻居 v 的新距离向量，先保存，并用 B-F 公式更新自己的距离向量：<br>$D_x(y)&#x3D;min_v{c(x,v)+D_v(y)}$<br>从所有经邻居 v 到节点 y 的费用中选取最小路径费用</li><li>若距离向量发生改变，将新的距离向量通知给邻居。</li><li>当距离向量不再变化，算法终止，此时$D_x(y)$收敛到$d_x(y)$，即得到节点 x 到节点 y 的最低费用路径。</li><li>多次重复从邻居接收更新距离向量、重新计算选路表项、并向邻居发送更新通知的过程，直到没有更新报文</li><li>算法进入静止状态，直到某个链路费用发生改变为止。</li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-19-35-25.png" style="zoom:100%;"><article class="message is-info">        <div class="message-header"><p>DV</p></div>        <div class="message-body">            <p><strong>练习</strong><br>考虑如图所示的子网，该子网使用了距离-向量算法，下面的向量刚刚到达路由器 C：<br>来自 B 的向量为（5，0， 8，12，6，2）；<br>来自 D 的向量为（16，12，6，0，9，10）；<br>来自 E 的向量为（7，6，3，9，0，4）；<br>经过测量，C 到 B、D 和 E 的延迟分别为 6，3 和 5，那么 C 到达所有结点的最短路径是？<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-10-16-10-53.png" style="zoom:100%;"></p><p>各个向量对应元素的意思是(A,B,C,D,E,F)，路由节点 X 到其他节点 X’所需要的延迟。（注：这里是 C 经 B、C 经 D、C 经 E，再到目标节点的延迟）<br>如图写出过后，从这些向量中的所有元素中选出各对应点里面的延迟最小值的，组成一个新向量，即（11，6，0，3，5，8）</p>        </div>    </article><hr><h4 id="Distance-Vector-Algorithm-Link-Cost-Changes-and-Link-Failure"><a href="#Distance-Vector-Algorithm-Link-Cost-Changes-and-Link-Failure" class="headerlink" title="Distance-Vector Algorithm: Link-Cost Changes and Link Failure"></a>Distance-Vector Algorithm: Link-Cost Changes and Link Failure</h4><p>当一个节点检测到从它到邻居的链路费用发生变化时，就更新其距离向量，如果最低费用路径的费用发生变化，通知其邻居。</p><ul><li><p><strong>某链路费用减少时情况</strong><br>如图所示，当 y 到 x 的链路费用从 4 变为 1 的情况。</p><ul><li><p><code>t0</code>：y 检测到 x 的链路费用从 4 变为 1，更新其距离向量，并通知其邻居 z；</p></li><li><p><code>t1</code>：z 收到来自 y 的更新报文，并更新自己的距离表，此时到节点 x 的最低费用减为 2，并通知其邻居 y；</p></li><li><p><code>t2</code>：y 收到来自 z 的更新报文，并更新自己的距离表，此时到节点 x 的最低费用不变仍为 1。不发送更新报文，算法静止。<br>当 x 与 y 之间费用减少，DV 算法只需两次迭代到达静止状态。节点之间链路费用减少的“好消息”在网络中能迅速传播,即 <em>good news travels fast</em></p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-08-19-44-30.png" style="zoom:50%;"></li></ul></li><li><p><strong>某链路费用增加时情况</strong><br>假设 x 与 y 之间的链路费用从 4 增加到 60<br><strong>链路费用变化前</strong><br>$D_y(x)&#x3D;4 ，D_y(z)&#x3D;1， D_z(y)&#x3D;1，D_z(x)&#x3D;5$</p><ul><li><code>t0</code> ：y 检测到链路费用从 4 变为 60。更新到 x 的最低路径费用<br>$D_y(x)&#x3D;min{c(y,x)+ D_x(x), c(y,z)+ D_z(x)}&#x3D;min{60+0,1+5}&#x3D;6$<br>此时 $D_y(x)&#x3D;6 ，D_y(z)&#x3D;1， D_z(y)&#x3D;1，D_z(x)&#x3D;5$<br>经节点 z 到 x 费用最低，此新费用错误，发给节点 z。</li><li><code>t1</code> ：z 收到新费用，更新其到 x 的最低路径费用<br>$D_z(x )&#x3D;min{ c(z,x)+ D_x(x), c(z,y)+ D_y(x)}&#x3D;min{50+0,1+6}&#x3D;7$<br>此时 $D_y(x)&#x3D;6 ，D_y(z)&#x3D;1， D_z(y)&#x3D;1，D_z(x)&#x3D;7$<br>经节点 y 到 x 费用最低，发给节点 y。</li><li><code>t2</code>：y 收到新费用，更新到 x 的最低路径费用<br>$D_y(x )&#x3D;min{c(y,x)+ D_x(x), c(y,z)+ D_z(x)}&#x3D;min{60+0,1+7}&#x3D;8$<br>经节点 z 到 x 费用最低，发给节点 z。<br>……<br>节点 y 或 z 的最低费用不断更新。<br>产生<strong>选路回环</strong>(routing loop)：为到达 x， y 通过 z 选路，z 又通过 y 选路。即目的地为 x 的分组到达 y 或 z 后，将在这两个节点之间不停地来回反复，直到转发表发生改变为止。上述循环将持续 44 次迭代 (y 与 z 之间的报文交换)，直到 z 最终算出它经由 y 的路径费用大于 50 为止。并确定：z 到 x 的最低费用路径：zxy 到 x 的最低费用路径：yzx<br>说明：链路费用增加的“坏消息”传播很慢,即 <em>bad news travels slow</em><br>当链路费用增加很大，会出现<strong>无穷计数</strong>(count-to-infinity)问题。如链路费用 c(y，x)变为 10000，c(z，x)变为 9999 时。</li></ul></li></ul><h4 id="Distance-Vector-Algorithm-Adding-Poisoned-Reverse"><a href="#Distance-Vector-Algorithm-Adding-Poisoned-Reverse" class="headerlink" title="Distance-Vector Algorithm: Adding Poisoned Reverse"></a>Distance-Vector Algorithm: Adding Poisoned Reverse</h4><p>针对上面的问题，引出<strong>毒性逆转（poisoned reverse）</strong>思想：如果 z 通过 y 路由选择目的地 x，则 z 将通告 y，它到 x 的距离是无穷大，也就是 z 将通告$D_z(x)&#x3D;\infty$。毒性逆转可以完全解决计数到无穷的问题吗？不能，如果三个以上节点的环路，则不能被毒性逆转技术检测</p><h3 id="A-Comparison-of-LS-and-DV-Routing-Algorithms"><a href="#A-Comparison-of-LS-and-DV-Routing-Algorithms" class="headerlink" title="A Comparison of LS and DV Routing Algorithms"></a>A Comparison of LS and DV Routing Algorithms</h3><p><strong>消息复杂度</strong><br>LS 算法：知道网络每条链路的费用，需发送 $O(nE)$个报文；当一条链路的费用变化时，必须通知所有节点<br>DV 算法：迭代时，仅在两个直接相连邻居之间交换报文；当链路费用改变时，只有该链路相连的节点的最低费用路径发生改变时，才传播已改变的链路费用<br><strong>收敛速度</strong><br>LS 算法：需要 $O(nE)$个报文和 $O(n^2)$的搜寻，可能会振荡<br>DV 算法：收敛较慢。可能会遇到选路回环，或计数到无穷的问题。<br><strong>健壮性</strong><br>当一台路由器发生故障、操作错误或受到破坏时，会发生什么情况?<br>LS 算法：路由器向其连接的一条链路广播不正确费用，路由计算基本独立（仅计算自己的转发表），有一定健壮性。<br>DV 算法：一个节点可向任意或所有目的节点发布其不正确的最低费用路径，一个节点的计算值会传递给它的邻居，并间接地传递给邻居的邻居。一个不正确的计算值会扩散到整个网络。</p><h2 id="Intra-AS-Routing-in-the-Internet-OSPF"><a href="#Intra-AS-Routing-in-the-Internet-OSPF" class="headerlink" title="Intra-AS Routing in the Internet: OSPF"></a>Intra-AS Routing in the Internet: OSPF</h2><p>迄今为止，我们的路由研究都是理想化的： 所有路由器一样的 网络是 “平面的” 实际中并不是这样的。互联网在规模上具有 20 亿个节点，路由表中不可能存储所有的节点而路由表的信息交换也将淹没数据链路</p><p>随着路由器规模增大和管理自治的要求，可以通过将路由器组织进<strong>自治系统（Autonomous System，AS）</strong>来解决。在一个自治系统内运行的路由算法叫做<strong>自治系统内部路由选择协议（intra-autonomous system routing protocol）</strong>，不同自治系统内的路由器可以运行不同的区域内路由协议</p><p><strong>网关路由器</strong>（gateway router）</p><ul><li>和其他自治系统内的路由器直接相连的路由器。运行域间路由协议，与其他网关路由器交互</li><li>同自治系统内的所有其他路由器一样也运行域内路由协议</li></ul><p>域（自治系统）内路由选择</p><ul><li>使用域内路由协议，也被称作内部网关协议 (IGP)</li><li>标准的域内路由协议:<ul><li>RIP: 路由信息协议</li><li>OSPF: 开放式最短路径优先</li><li>IGRP: 内部网关路由协议 (Cisco 所有)</li></ul></li></ul><h3 id="RIP-Routing-Information-Protocol"><a href="#RIP-Routing-Information-Protocol" class="headerlink" title="RIP ( Routing Information Protocol)"></a>RIP ( Routing Information Protocol)</h3><ul><li>属于距离向量算法，包含在 1982 年发布的 BSD-UNIX 版本中。</li><li>距离衡量: 跳数 (max &#x3D; 15 hops)</li><li>RIP 通告<ul><li>每隔 30 秒,通过响应报文在邻居间交换距离向量 (也被称为 RIP 通告, advertisement)</li><li>每个通告包含了多达 25 个 AS 内的目的子网的列表</li></ul></li><li>RIP 链路失败及恢复<br>若 180 秒后没有收到通告，则认为邻居死机或链路中断：<ul><li>通过故障邻居的路由失败</li><li>新的公告发送给其他邻居</li><li>邻居然后再发送新的公告 (如果转发表发生变化)</li><li>链路故障信息快速传播到整个网络</li><li>毒性逆转用于防止乒乓循环 (无限距离 &#x3D; 16 跳)</li></ul></li></ul><h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF (Open Shortest Path First)"></a>OSPF (Open Shortest Path First)</h3><p>OSPF 是一种链路状态协议，它使用洪泛链路状态信息和 Dijkstra 最低开销路径算法。使用 OSPF，一台路由器构建了一幅关于整个自治系统的完整拓扑图。于是，每台路由器在本地运行 Dijkstra 的最短路径算法，以确定一个自身为根节点到所有子网的最短路径树。</p><p>使用 OSPF 时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时，路由器就会广播链路状态信息。</p><ul><li>属于链路状态算法<ul><li>分发 LS 分组</li><li>每个节点具有拓扑图</li><li>路由计算使用 Dijkstra 算法</li></ul></li><li>每个 router 都广播 OSPF 通告，OSPF 通告里为每个邻居路由器设一个表项（记录每个邻居的链路特征和费用）</li><li>通告会散布到 整个 自治系统 (通过洪泛法)<ul><li>OSPF 信息直接通过 IP 传输 （不是 TCP 或 UDP）</li></ul></li></ul><p><strong>OSPF 相比 RIP 的优点</strong></p><ul><li>安全: 所有 OSPF 消息需要认证 (防止恶意入侵)</li><li>允许多个相同开销的路径 (在 RIP 中只有一条路径)</li><li>对于每个链路, 有多个消费尺度用于不同的服务类型 TOS (例如在尽力转发时卫星链路代价设置为 “低” ，而对实时应用设置为高)</li><li>对单播与多播路由选择的综合支持（Integrated support for unicast and multicast routing）；</li><li>在大的区域中使用层次 OSPF</li></ul><p><strong>层次 OSPF</strong></p><ul><li>两级层次: 本地区域, 主干区域（这些区域都是在一个自治系统内）<ul><li>只在区域内发送链路状态通告</li><li>每个节点有详细的区域拓扑; 仅知道到达其他区域内网络的方向（即最短路径）</li></ul></li><li>区域边界路由器（同时属于本地区域和主干区域）:“汇总”了到本区域内部网络的路径, 并通告给其他区域边界路由器.</li><li>主干路由器：限于在主干区域内运行 OSPF 路由协议（本身不是区域边界路由器）</li><li>边界路由器: 连接到其他自治系统</li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-10-17-41-40.png" style="zoom:50%;"><h2 id="Routing-Among-the-ISPs-BGP"><a href="#Routing-Among-the-ISPs-BGP" class="headerlink" title="Routing Among the ISPs:BGP"></a>Routing Among the ISPs:BGP</h2><p>当分组跨越多个 AS 进行路由时，我们需要一个<strong>自治系统间路由协议（inter-autonomous system routing protocol）</strong>。在因特网中，所有的 AS 运行相同的 AS 间路由选择协议，称为<strong>边界网关协议（Broder Gateway Protocol，BGP）</strong>。</p><h3 id="The-Role-of-BGP"><a href="#The-Role-of-BGP" class="headerlink" title="The Role of BGP"></a>The Role of BGP</h3><p>BGP 是事实上的标准，它为每个 AS 提供了一种手段</p><ul><li>从相邻 AS 获取子网的可达性信息 Obtain prefix reachability information from neighboring ASs，向该 AS 内部的所有路由器传播这些可达性信息 Advertising BGP Route Information。</li><li>基于该可达信息和 AS 策略，决定到达子网的“最好”路由 Determine the “best” routes to the prefixes.</li></ul><blockquote><p>In BGP, packets are not routed to a specific destination address, but instead to CIDRized prefixes, with each prefix representing a subnet or a collection of subnets.</p></blockquote><p>BGP 是一种 AS(自治区域)外部路由协议，主要负责本自治区域和外部的自治区域间的路由<strong>可达信息的交换</strong>。因此，它所关心的拓扑结构是 AS(自治区域)的拓扑结构。转发表根据 AS 内和 AS 间选路算法而配置；AS 域内和 AS 域间的选路项用于目的端在域外的选路，AS 域内的选路项用于目的端在域内的选路。</p><p>假设 AS1 中的路由器接收到了目的端是 AS1 外的分组。路由器将把这个分组转发到网关路由器，但是是哪个网关路由器呢？<br>AS1 需要知道:</p><ul><li>通过 AS2 和 AS3 可以到达哪些目的端</li><li>将这些可达信息传播给 AS1 内的所有路由器</li></ul><p>这就是<strong>域间选路</strong>的任务</p><h3 id="Advertising-BGP-Route-Information"><a href="#Advertising-BGP-Route-Information" class="headerlink" title="Advertising BGP Route Information"></a>Advertising BGP Route Information</h3><p>对于每个 AS，路由器可分为<strong>网关路由器 gateway router</strong>及<strong>内部路由器 internal router</strong>。在 BGP 中，每对路由器通过使用<code>179</code>端口的半永久 TCP 连接(semi-permanent TCP connections)交换路由选择信息,TCP 连接携带着 BGP message，因此其也称作<strong>BGP Connection</strong>。其中跨越两个 AS 的 BGP 连接称为<strong>eBGP</strong> connection，而在相同 AS 中的两台路由器之间的 BGP 会话称为<strong>iBGP</strong> connection。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-10-18-44-42.png" style="zoom:80%;"><p>以上图为例，具体传播过程如下：当需要将前缀 x 的可达性信息传播至 AS1 和 AS2 的所有路由器时，首先，AS3 的网关路由器 3a 通过 eBGP 发送消息<code>AS3 x</code>给 AS2 的网关路由器 2c。接着，路由器 2c 利用 iBGP 将此消息<code>AS3 x</code>转发给 AS2 内的所有其他路由器，包括路由器 2a。然后，路由器 2a 通过 eBGP 发出更新的消息<code>AS2 AS3 x</code>至 AS1 的网关路由器 1c。最后，路由器 1c 使用 iBGP 将这条包含路径信息的消息<code>AS2 AS3 x</code>广播给 AS1 内的所有路由器。完成这一过程后，AS1 和 AS2 中的每一台路由器都知晓了前缀 x 的存在及其可达的 AS 路径。</p><p>可达性信息通过 iBGP 和 eBGP 的协作，在自治系统内外进行传播，确保网络中的每个关键节点都能够了解到目标前缀的存在及其可达路径。</p><h3 id="Determining-the-Best-Routes"><a href="#Determining-the-Best-Routes" class="headerlink" title="Determining the Best Routes"></a>Determining the Best Routes</h3><p>当通告前缀时，通告包含了 BGP 属性(BGP attribute),<code>前缀+属性</code>称为路由 route<br>两个重要的属性:1</p><ul><li>AS-PATH: 包含了前缀的通告已经通告过的那些 AS,如 <code>AS 67 AS 17</code>,BGP 也会根据 AS-PATH 属性来检测并避免循环通告</li><li>NEXT-HOP: 指出到达下一个 AS 的具体 AS 间边界路由器（可能存在多条从当前 AS 到达下一个 AS 的链路）</li></ul><p>当网关路由器接收到路由通告时，使用输入策略来决定接收&#x2F;舍弃该通告。</p><h4 id="Hot-potato-routing"><a href="#Hot-potato-routing" class="headerlink" title="Hot potato routing"></a>Hot potato routing</h4><p>热土豆(烫手山芋)路由选择的基本思想是：在多个 NEXT-HOP 路由器中，选择到 NEXT-HOP 开销最低的路径。<br>热土豆的思想：尽可能块地将分组送出其 AS（最低开销），而不担心其 AS 外部到目的地的余下部分的开销(贪心策略)</p><p>在路由器转发表中增加 AS 外部目的地的步骤：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-11-19-26-10.png" style="zoom:50%;"></p><h4 id="Route-Selection-Algorithm"><a href="#Route-Selection-Algorithm" class="headerlink" title="Route-Selection Algorithm"></a>Route-Selection Algorithm</h4><p>路由器可能知道到相同前缀的多条路由，路由器必须从中选择。该种情况下会顺序地匹配下列消除规则</p><ol><li>路由被指派一个本地偏好（local preference）值作为其属性值之一，具有最高本地偏好值的将被选择；</li><li>如果本地偏好值相同，则选择具有最短 AS-PATH 属性值的路由；</li><li>如果 AS-PATH 属性值相同，则选择具有最短 NEXT-HOP 属性值的路由；(Hot potato routing)</li><li>根据 BGP identifiers， 匹配其它标准</li></ol><h4 id="IP-Anycast"><a href="#IP-Anycast" class="headerlink" title="IP-Anycast"></a>IP-Anycast</h4><p>除了作为 Internet 的 AS 间路由协议外，BGP 还经常用于实现 IP 任播服务，该服务通常用于 DNS。</p><p>常见的应用场景可抽象为：在许多不同的分散地理位置的不同服务器上复制相同的内容，并让每个用户从最近的服务器访问内容。<br>具体的例子包括： CDN 可以在不同国家&#x2F;地区的服务器上复制视频和其他对象。DNS 系统可以在世界各地的 DNS 服务器上复制 DNS 记录。</p><article class="message is-info">                <div class="message-body">            <p><strong>How does Anycast work?</strong><br>Anycast network routing is able to route incoming connection requests across multiple data centers. When requests come into a single IP address associated with the Anycast network, the network distributes the data based on some prioritization methodology. The selection process behind choosing a particular data center will typically be optimized to reduce latency by selecting the data center with the shortest distance from the requester. Anycast is characterized by a 1-to-1 of many association, and is one of the 5 main network protocol methods used in the Internet protocol.<br><strong>What is the difference between Anycast and Unicast?</strong><br>Most of the Internet works via a routing scheme called Unicast. Under Unicast, every node on the network gets a unique IP address. Home and office networks use Unicast; when a computer is connected to a wireless network and gets a message saying the IP address is already in use, an IP address conflict has occurred because another computer on the same Unicast network is already using the same IP. In most cases, that isn’t allowed.<br>Using Anycast means the network can be extremely resilient. Because traffic will find the best path, an entire data center can be taken offline and traffic will automatically flow to a proximal data center.</p><p><a href="https://www.cloudflare.com/learning/cdn/glossary/anycast-network/">What is Anycast? | How does Anycast work?</a></p>        </div>    </article><h4 id="Routing-Policy"><a href="#Routing-Policy" class="headerlink" title="Routing Policy"></a>Routing Policy</h4><p>X 是一个<strong>多宿主接入 ISP（multi-homed access ISP）</strong>,它经由两个不同提供商连接到两个网络</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-11-20-01-40.png" style="zoom:100%;" alt="ABCXYW 均表示 AS 而非 routers"> <ul><li>B 向X通告路由BAW </li><li>A 向B通告路径 AW <ul><li>B 会向C通告路由BAW吗?</li><li>W和C都不是B的customer，B希望C通过A路由到W（CAW），自己只负责路由自己的客户<blockquote><p>ISP遵循的法则：任何穿越某ISP主干网的流量必须是其源或者目的位于该ISP的某个客户网络中</p></blockquote></li></ul></li></ul><p><strong>为什么 AS 内选路和 AS 间选路采用不同的协议?</strong></p><ul><li><strong>策略 Policy</strong>:<ul><li>AS 间: 管理员想控制本 AS 内产生的通信流怎样选路，以及什么通信流穿过自己的网络</li><li>AS 内:单个管理者, 因此不需要策略</li></ul></li><li><strong>规模 Scale</strong>:<ul><li>层次路由节省了转发表的大小空间，减少了路由更新的流量</li></ul></li><li><strong>性能 Performance</strong>:<ul><li>AS 内: 集中在性能上</li><li>AS 间: 策略可能比性能更加重要</li></ul></li></ul><h2 id="The-SDN-Control-Plane"><a href="#The-SDN-Control-Plane" class="headerlink" title="The SDN Control Plane"></a>The SDN Control Plane</h2><p>软件定义网络（SDN，SoftwareDefinedNetwork）源自美国斯坦福大学 CLeanState 研究组提出的一种新型网络创新架构，可通过软件编程的形式定义和控制网络，具有控制平面和转发平面分离及开放性可编程的特点。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-11-20-47-27.png" style="zoom:70%;"><br>SDN 的核心理念是，希望应用软件可以参与对网络的控制管理，满足上层业务需求，通过自动化业务部署，简化网络运维。如果把现有的网络看成手机，那 SDN 的目标就是做出一个网络界的 Android 系统，可以在手机上安装升级，同时还能安装更多更强大的手机 APP。</p><p>SDN 并不是一个具体的技术，它是一种网络设计理念，规划了网络的各个组成部分（软件、硬件、转发面和控制面）及相互之间的互动关系。</p><article class="message is-info">                <div class="message-body">            <p>过去几十年里，IP 网络一直是全分布式的，战功卓著，解决了各种客户需求。今天 SDN 是为了未来更好更快的实现用户需求。并不是有什么需求通过传统方法不能做到，只是 SDN 做得更快、更好、更简单。</p><p>IP 网络的生存能力很强，得益于其分布式架构。当年美国军方希望在遭受核打击后，整个网络能够自主恢复，这样就不能允许网络集中控制，不能存在中心结点，否则在这个中心节点丢一颗核弹，整个网络就瘫痪了，由此才导致了互联网的研究和诞生。</p><p>但正是这种全分布式架构导致了许多问题：看看现在的 IP 网络管理多复杂，举个运营商部署 VPN 的例子：要配置 MPLS、BFD、IGP、BGP、VPNV4、要绑定接口…且需要在每个 PE 上配置；当新增加一个 PE 时，还需要回去修改每个涉及到的 PE。现在各厂家的网络设备都太复杂了。如果您准备成为某个厂商设备的百事通，你需要掌握的命令行超过 10000 条，而其数量还在增加。 如果你准备成为 IP 骨灰级专家，你需要阅读网络设备相关 RFC 2500 篇，如果一天阅读一篇，你知道要看多久能看完？6 年多！而这只是整个 RFC 的 1&#x2F;3，其数量还在增加。此外，这些协议标准都是在解决各种各样的控制面需求，而这些需求都是需要经过需求提出、定义标准、互通测试、现网设备升级来完成部署，一般要个 3~5 年才能完成部署。这样的速度，已经 Hold 不住网络上运营业务的 OTT 们的各种快速网络调整需求，必须想办法解决这个问题。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-11-20-46-59.png" style="zoom:80%;"><br>Google 的网络分为数据中心内部网络（IDC Network）及骨干网（Backbone Network，也可以称为 WAN 网）。其中 WAN 网按照流量方向由两张骨干网构成，分别为：第一，数据中心之间互联的网络（Inter-DC WAN，即 G-scale Network），用来连接 Google 位于世界各地之间的数据中心，属于内部网络 Google 选择使用 SDN 来改造数据中心之间互联的 WAN 网（即 G-scale Network）<br>促使 Google 使用 SDN 改造 WAN 网的最大原因是 当前连接 WAN 网的链路带宽利用率很低。GoogleWAN 网的出口设备有上百条对外链路，分成很多的 ECMP 负载均衡组，在这些均衡组内的多条链路之间 用的是基于静态 Hash 的负载均衡方式, ，最主要的应用是流量工程，最主要的控制手段是软件应用程序。</p>        </div>    </article><p><strong>SDN 的发展驱动力和优势</strong><br>驱动力：</p><ul><li>计算虚拟化驱动：静态到动态的网络变化。虚拟机迁移改变了原有静态的网络部署模式，需要网络开放出来，能与虚拟化业务互通起来随需而动，动态调整网络的策略的扩展性</li><li>云计算对资源的垂直整合：独立演进到协同。网络作为一种资源被云计算整合到基础架构中，提供快速连接的服务</li><li>云计算时代 IT 业务的发展，驱动由固定到可编程网络的快速变化</li><li>数据中心资源：需要随业务跨地域整合，并使数据中心间广域流量增大。而现状是数据中心资源分散，广域成本高且利用率低</li></ul><p>优势：</p><ul><li>统一便捷的管理，解决网络中设备越来越多样化问题</li><li>无缝的版本升级，解决设备版本升级对业务的影响</li><li>网络数据可视化</li><li>整体的流量调度</li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-11-20-51-15.png" style="zoom:100%;"><p>SDN 体系结构具有四个关键特征：</p><ul><li>基于流的转发（Flow-based forwarding）；</li><li>数据平面与控制平面分离（Separation of data plane and control plane）；</li><li>网络控制功能位于数据平面交换机外部（Network control functions: external to data-plane switches）；</li><li>可编程网络（A programmable network）；</li></ul><p>SDN 的核心思想是建立一个通用转发体系。每个交换设备包含一个流表(flow table). 流表由一个逻辑上中心化的控制器（远程控制器）来计算和分发</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2NetworkLayer-2024-06-11-20-56-23.png" style="zoom:50%;"><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cloudflare.com/learning/cdn/glossary/anycast-network/">What is Anycast? | How does Anycast work?</a></p>]]></content>
    
    
    <summary type="html">介绍网络层的控制平面，包括路由算法，较为详细介绍了Dijkstra算法(链路状态选路算法)Distance-Vector Routing Algorithms(距离向量算法)以及层次选路三种选路算法。并介绍因特网中的选路协议（内部网关协议：RIP、OSPF、IGRP；外部网关协议：BGP），介绍SDN的概念，用途，架构</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="计算机网络" scheme="https://efterklang.github.io/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://efterklang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Using Git Rebase to Manage Commit History</title>
    <link href="https://efterklang.github.io/Dev/Git/rebase-and-quash/"/>
    <id>https://efterklang.github.io/Dev/Git/rebase-and-quash/</id>
    <published>2024-04-27T11:10:13.000Z</published>
    <updated>2024-06-11T09:43:37.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在开发过程中，可能会有这样的情况：你在开发一个功能时，提交了多次commit，但是这些commit并不是一个完整的功能，或者是一个bug修复，这时候你可能会想要将这些commit合并成一个commit，以便于更好的管理提交历史。这时候，git rebase就派上用场了。通过这个命令，对git提交历史进行整理，可以使提交历史更加清晰。需要注意的是，如果你已经将这些commit推送到了远程仓库，那么你需要使用<code>git push --force</code>来推送你的更改。</p><article class="message is-danger">        <div class="message-header"><p>Warning</p></div>        <div class="message-body">            <p>⚠️️ 在多人协作的项目中使用git rebase 需要注意尽量不要对已经推送到远程仓库的commit进行rebase操作，因为这样会改变提交历史，可能会导致其他人在合并你的提交时出现问题。推荐的使用场景是在本地开发过程中使用rebase整理提交历史。</p>        </div>    </article><h2 id="如何合并多个commit"><a href="#如何合并多个commit" class="headerlink" title="如何合并多个commit"></a>如何合并多个commit</h2><p>如何确定你想要合并的commits的范围呢?</p><p>例如，如果你想要合并最近的三个 commit，你可以使用 <code>HEAD~3</code>。这将打开一个编辑器(core.editor)，列出最近的三个 commit。<br>你也可以使用<code>git rebase -i &lt;commit&gt;</code>指定commit的hash值。例如<code>git rebase -i 8c0a3c</code>,这将打开一个编辑器，列出从 <commit> 到 HEAD 的所有 commit。<br>运行<code>git rebase -i HEAD~3</code>。</p><blockquote><p>注意:git rebase只能合并连续的commit，如果你想要合并不连续的commit，你需要多次运行rebase命令<br>你可以通过设置环境变量来指定使用的编辑器，例如：<code>git config --global core.editor &quot;nvim&quot; </code>将使用nvim编辑器。<br>这里推荐<a href="https://www.lazyvim.org/installation">lazyvim</a>以及lunarvim，这两个vim配置都是基于neovim的，功能强大，配置简单，推荐使用。且对于在终端中运行支持良好。</p></blockquote><p>在编辑器中，将第二行和第三行的 pick 改为 squash 或 s;然后保存修改并退出，这将打开另一个编辑器，让你编辑新的 commit 信息。更多命令见下表Commands内容</p><blockquote><p>vim使用命令<code>2,3s/pick/s</code>可替换2-3行的<code>pick</code>为<code>squash</code>，2，3指定行;<code>s/pick/s/</code>表示 Substitute a with b;</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GitRebase-2024-04-27-19-26-02.png" style="zoom:80%;"><br><blockquote><p><strong>Commands</strong>:</p><ul><li>p, pick &#x3D; use commit</li><li>r, reword &#x3D; use commit, but edit the commit message</li><li>e, edit &#x3D; use commit, but stop for amending</li><li>s, squash &#x3D; use commit, but meld into previous commit</li><li>f, fixup &#x3D; like “squash”, but discard this commit’s log message</li><li>x, exec &#x3D; run command (the rest of the line) using shell</li><li>d, drop &#x3D; remove commit</li></ul></blockquote><p>编辑 commit 信息，然后保存并关闭编辑器。如果一切顺利，你的三个 commit 现在应该已经被合并成一个了。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GitRebase-2024-04-27-19-27-45.png" style="zoom:80%;"><p>这将改变你的 Git 历史。如果你已经将这些 commit 推送到了远程仓库，你将需要使用<code>git push --force</code> 来推送你的更改</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GitRebase-2024-04-27-19-30-26.png" style="zoom:80%;"><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://git-scm.com/docs/git-rebase">https://git-scm.com/docs/git-rebase</a></p>]]></content>
    
    
    <summary type="html">介绍git rebase的使用；通过git rebase,git squash等命令，对git提交历史进行整理，使提交历史更加清晰。</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Git" scheme="https://efterklang.github.io/categories/Dev/Git/"/>
    
    
    <category term="Git" scheme="https://efterklang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Hexo添加Live2d模型</title>
    <link href="https://efterklang.github.io/Dev/FrontEnd/Live2d/"/>
    <id>https://efterklang.github.io/Dev/FrontEnd/Live2d/</id>
    <published>2024-04-26T10:58:52.000Z</published>
    <updated>2024-06-11T09:41:34.991Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Installations"><a href="#Installations" class="headerlink" title="Installations"></a>Installations</h2><ol><li>首先在网站根目录下执行<code>npm install --save hexo-helper-live2d</code>，下载 Live2d 插件</li><li>下载模型，在网站根目录下新建<code>live2d_models</code>文件夹，将模型文件放入其中,模型文件可在以下链接下载<br><a href="https://github.com/xiazeyu/live2d-widget-models">https://github.com/xiazeyu/live2d-widget-models</a></li><li>修改<code>_config.yml</code>文件，添加如下配置<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">nipsilon</span> <span class="comment"># 相对于/live2d_models/的路径</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">175</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">350</span></span><br><span class="line">  <span class="attr">log:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>文件的存放位置参考下图<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Live2d-2024-04-26-19-17-08.png" style="zoom:70%;"></li><li>效果图<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Live2d-2024-04-26-19-20-25.png" style="zoom:80%;"></li></ol><h2 id="Configurations"><a href="#Configurations" class="headerlink" title="Configurations"></a>Configurations</h2><h3 id="helper-特有"><a href="#helper-特有" class="headerlink" title="helper 特有"></a>helper 特有</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/EYHN/hexo-helper-live2d</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># enable: false</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">local</span> <span class="comment"># 默认</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="comment"># scriptFrom: jsdelivr # jsdelivr CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: unpkg # unpkg CDN</span></span><br><span class="line">  <span class="comment"># scriptFrom: https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-wanko</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="comment"># use: wanko # 博客根目录/live2d_models/ 下的目录名</span></span><br><span class="line">    <span class="comment"># use: ./wives/wanko # 相对于博客根目录的路径</span></span><br><span class="line">    <span class="comment"># use: https://cdn.jsdelivr.net/npm/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url</span></span><br></pre></td></tr></table></figure><h3 id="General-Settings"><a href="#General-Settings" class="headerlink" title="General Settings"></a>General Settings</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Live2D</span></span><br><span class="line"><span class="comment">## https://github.com/xiazeyu/live2d-widget.js</span></span><br><span class="line"><span class="comment">## https://l2dwidget.js.org/docs/class/src/index.js~L2Dwidget.html#instance-method-init</span></span><br><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">superSample:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">right</span></span><br><span class="line">    <span class="attr">hOffset:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">vOffset:</span> <span class="number">-20</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">0.5</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacityDefault:</span> <span class="number">0.7</span></span><br><span class="line">    <span class="attr">opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.npmjs.com/package/hexo-helper-live2d">hexo-helper-live2d</a><br><a href="https://blog.csdn.net/wang_123_zy/article/details/87181892">Hexo 添加 Live2D 看板娘+模型预览</a></p>]]></content>
    
    
    <summary type="html">本文介绍如何给Hexo博客添加Live2d模型</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="FrontEnd" scheme="https://efterklang.github.io/categories/Dev/FrontEnd/"/>
    
    
    <category term="Others" scheme="https://efterklang.github.io/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Storage Management Part Ⅰ</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch4-1StorageManagement/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch4-1StorageManagement/</id>
    <published>2024-04-18T13:19:38.000Z</published>
    <updated>2024-06-12T09:26:01.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="存储器层次结构概述"><a href="#存储器层次结构概述" class="headerlink" title="存储器层次结构概述"></a>存储器层次结构概述</h3><p>为能更多的存放并更快地处理用户信息，目前许多计算机把存储器分为三级。</p><ul><li><strong>高速缓存</strong> Cache：K 字节、高速、昂贵、易变的</li><li><strong>内存</strong> RAM： M 或 G 字节、中速、中等价格、易变的</li><li><strong>磁盘</strong>：G 或 T 字节、低速、价廉、不易变的</li></ul><blockquote><p>寄存器、高速缓存、主存储器和磁盘缓存均属于操作系统存储管理的管辖范畴，掉电后它们存储的信息不再存在。<br>磁盘和可移动存储介质属于设备管理的管辖范畴，它们存储的信息将被长期保存。</p></blockquote><h4 id="主存储器与寄存器"><a href="#主存储器与寄存器" class="headerlink" title="主存储器与寄存器"></a>主存储器与寄存器</h4><ol><li><p><strong>主存储器</strong>（内存，主存，可执行存储器）<br>用于保存进程运行时的程序和数据。CPU 的控制部件只能从主存中取得指令和数据到 CPU 寄存器，同样，CPU 寄存器中的数据可存入主存。<br>CPU 与外设交换数据必须依托于主存。</p></li><li><p><strong>寄存器</strong><br>寄存器访问速度最快，与 CPU 协调工作。<br>高速缓存与磁盘缓存<br>CPU 对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。<br>根据程序执行的<strong>局部性原理</strong>，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。<br>有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。</p><blockquote><p>局部性原理（Locality Principle）指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。<br>在分页机制中，页表的作用是将虚拟地址转换为物理地址，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：<br>时间局部性：由于程序中存在一定的循环或者重复操作，因此会反复访问同一个页或一些特定的页，这就体现了时间局部性的特点。为了利用时间局部性，分页机制中通常采用缓存机制来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。<br>空间局部性：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此当访问某个页时，往往会顺带访问其相邻的一些页。为了利用空间局部性，分页机制中通常采用预取技术来预先将相邻的一些页读入内存缓存中，以便在未来访问时能够直接使用，从而提高访问速度。总之，局部性原理是计算机体系结构设计的重要原则之一，也是许多优化算法的基础。在分页机制中，利用时间局部性和空间局部性，采用缓存和预取技术，可以提高页面的命中率，从而提高内存访问效率</p></blockquote></li></ol><h4 id="高速缓存与磁盘缓存"><a href="#高速缓存与磁盘缓存" class="headerlink" title="高速缓存与磁盘缓存"></a>高速缓存与磁盘缓存</h4><ol><li><strong>高速缓存</strong><br>CPU 对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。<br>根据程序执行的局部性原理，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。<br>有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。</li><li><strong>磁盘缓存</strong><br>内存中一块存储区，对应于某固定磁盘，临时存储磁盘数据（如，数据预取）</li></ol><h3 id="存储器管理的目的和功能"><a href="#存储器管理的目的和功能" class="headerlink" title="存储器管理的目的和功能"></a>存储器管理的目的和功能</h3><p>操作系统负责协调这些存储器的使用<br>三级存储器，从缓存到内存到外存，其容量愈来愈大，而访问数据的速度则愈来愈慢，价格也愈来愈便宜。<br>用户的程序在运行时应存放在主存中，以便处理机访问。<br>为尽可能利用 CPU，要求直接存取内存的速度尽量快到与 CPU 取指速度相匹配，容量大到能装下当前运行的程序与数据<br>由于主存容量和速度有限。所以把那些不马上使用的程序、数据放在外部存储器(又称辅存)中。当用到时再把它们读入主存。</p><ol><li><strong>主存储器的分配和管理</strong>：按用户要求把适当的存储空间分配给相应的作业。一个有效的存储分配机制，应在用户请求时能作出快速的响应，分配相应的存储空间；在用户不再使用它时，应立即回收，以供其他用户使用。为此，这个存储分配机制应具有如下功能：<br>(1)记住每个存储区域的状态：哪些是已分配的，哪些是可以用作分配的。<br>(2)实施分配：在系统程序或用户提出申请时，按所需的量给予分配；修改相应的分配记录表。<br>(3)接受系统或用户释放的存储区域：并相应地修改分配记录表。</li><li><strong>提高主存储器的利用率</strong>：使多道程序能动态地共享主存，最好能共享主存中的信息</li><li><strong>“扩充”主存容量</strong>：这是借助于提供虚拟存储器或其它自动覆盖技术来达到的。即为用户提供比主存的存储空间还大的地址空间</li><li><strong>存储保护</strong>：确保各道用户作业都在所分配的存储区内操作，互不干扰。即要防止一道作业由于发生错误而损害其它作业，特别需要防止破坏其中的系统程序。这个问题不能用特权指令来加以解决，而必须由硬件提供保护功能，并由软件配合实现</li></ol><h3 id="存储分配的三种方式"><a href="#存储分配的三种方式" class="headerlink" title="存储分配的三种方式"></a>存储分配的三种方式</h3><p>存储分配，解决多道作业之间共享主存的问题。确定什么时候，以什么方式，把一个作业的全部信息或作业运行时首先需要的信息分配到主存中，并使这些问题对用户来说尽可能是<strong>透明</strong>的。</p><blockquote><p>“对用户透明”（User Transparency）是一种计算术语，它指的是用户在使用系统或服务时，不需要关心或理解其背后的复杂实现细节。换句话说，系统或服务的复杂性对用户是”透明”的。</p></blockquote><p>解决存储分配问题的三种方式：</p><blockquote><p>目前，绝大多数计算机系统都采用静态或动态存储分配方式</p></blockquote><ol><li><strong>直接指定方式</strong>：程序员在编程序时，或编译程序(汇编程序)对源程序进行编译(汇编)时，使用实际存储地址。<ul><li>在多道程序环境下，应保证各作业所用的地址互不重叠。在多道程序发展的初期，通常把存储空间划分成若干个固定的不同大小分区，并对不同的作业指定相应的分区。因此，对编程人员或对编译程序而言，存储器的可用空间是可知的</li><li>采用直接指定方式分配的前提是：存储器的可用容量(空间)已经给定或者可以指定，这对单用户计算机系统是不成问题的</li><li>这种分配方式的实质是：由编程人员在编写程序时，或由编译程序编译源程序时，对一个作业的所有信息确定在主存存储空间中的位置。因此，这种直接指定方式的存储分配方案，不仅用户感到不便，而且存储空间的利用也不那么有效</li></ul></li><li><strong>静态分配方式</strong>(Static Allocation)<br>用户在编程时，或由编译程序产生的目的程序，均可从其地址空间的零地址开始；当<strong>装配程序</strong>对其进行连接装入时才确定它们在主存中的相应位置，从而生成可执行程序。也就是说，存储分配是在装入时实现的。静态分配策略的存储管理很简单，但在多道程序系统中不能有效地共享存储器资源<br>这种静态存储分配方式的特点是：<ul><li>在一个作业装入时必须分配其要求的全部存储量；</li><li>如果没有足够的存储空间，就不能装入该作业；</li><li>一旦一个作业进入内存后，在其退出系统之前，它一直占用着分配给它的全部存储空间；</li><li>作业在整个运行过程中不能在内存中“搬家”、也不能再申请存储量。</li></ul></li><li><strong>动态分配方式</strong>(Dynamic Allocation)：<br>动态分配是一种更加有效的使用主存储器的方法。这种动态存储分配方式的特点是：<ul><li>作业在存储空间中的位置，也是在其装入时确定的；</li><li>在其执行过程中可根据需要申请附加的存储空间；</li><li>一个作业已占用的部分存储区域不再需要时，可以要求归还给系统。即：这种存储分配机制能接受不可预测的分配和释放存储区域的请求，实现个别存储区域的分配和回收；</li><li>存储区域的大小是可变的；</li><li>允许作业在内存中“搬家”。</li></ul></li></ol><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>逻辑地址</strong>（相对地址，虚地址） Logical Address<br>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为 0，其余指令中的地址都相对于首地址而编址。不能用逻辑地址在内存中读取信息<br><strong>物理地址</strong>（绝对地址，实地址）Physical Address<br>内存中存储单元的地址，可直接寻址<br><strong>名空间</strong> namespace<br>是一种封装或组织代码的方式，它可以将一组标识符（如变量、函数、类、模块等）包含在一个名为命名空间的范围内<br><strong>地址空间</strong> Address Space<br>程序用来访问信息所用地址单元的集合，是逻辑（相对）地址的集合，由编译程序生成。<br><strong>存储空间</strong> Storage Space<br>主存中物理单元的集合。这些单元的编号称物理地址或绝对地址。存储空间的大小是由主存的实际容量决定的。</p><blockquote><p>地址空间是逻辑地址的集合；存储空间是物理地址的集合。一个是“虚”的概念，一个是“实”的物体。<br>一个编译好的目标程序存在于它自己的地址空间中，当要它在计算机上运行时，才把它装入存储空间。<br>一个作业在编译、装入前后存在于不同的空间。</p></blockquote><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>将一个用户源程序变为一个可在内存中执行的程序，通常要经过下列几步：</p><ul><li><strong>预处理</strong>（Preprocessing）：这是编译过程的第一步，主要处理源代码中的预处理器指令。例如，C 和 C++语言中的<code>#include</code>和<code>#define</code>等。预处理器将处理这些指令，如扩展包含文件，替换宏定义等，生成一个预处理后的源代码文件。</li><li><strong>编译</strong>（Compilation）：在这个阶段，编译器将预处理后的源代码转换为汇编语言。编译器在这个过程中会进行词法分析、语法分析、语义分析和优化等操作。编译器还会检查源代码中的错误，并生成对应的错误和警告信息。</li><li><strong>汇编</strong>（Assembly）：汇编阶段将编译阶段生成的汇编代码转换为机器语言代码，也就是目标代码。这个过程是由汇编器完成的。每一条汇编语言指令通常会被转换为一条机器语言指令。</li><li><strong>链接</strong>（Linking）：链接阶段是将所有的目标代码和必要的库函数链接在一起，生成一个可执行文件。链接器会处理源代码中的外部符号引用，将它们与正确的地址或者符号绑定在一起。</li><li><strong>装入</strong>（Loading）：当程序运行时，加载器（Loader）的任务是将可执行文件从硬盘加载到内存中，然后开始执行。加载器还负责解析程序对动态库的依赖，并将这些库加载到内存中。</li></ul><h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><p>根据存储空间的分配方式，将一个装入模块装入内存时，可采用三种方式：</p><ol><li><strong>绝对装入方式</strong>Absolute Loading Mode：<br>在编译时，如果知道程序将驻留在内存的具体位置，那么编译程序将产生**实际存储地址(绝对地址)**的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<ul><li>装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。</li><li>通常在程序中采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址。</li></ul></li><li><strong>静态重定位装入方式</strong>Static Relocation Loading Mode：<br>地址变换是在装入内存时一次完成的，且以后不能移动。<br>一般情况下,物理地址&#x3D;相对地址+内存中的起始地址<br>适用于多道程序环境，可以将装入模块装入到内存中任何允许的位置。<ul><li>优点：不需硬件支持，可以装入有限多道程序。</li><li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动，不易实现共享。</li></ul></li><li><strong>动态重定位装入方式&#x2F;动态运行时装入方式</strong>Dynamic Run-time Loading<br>装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是<strong>把地址转换推迟到程序执行时进行</strong>。在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换，故称为<strong>动态重定位</strong><br>最简单的办法是利用一个重定位寄存器(RR)。该寄存器的值是由进程调度程序根据作业分配到的存储空间起始地址来设定的。<br>在具有这种地址变换机构的计算机系统中，当执行作业时，不是根据 CPU 给出的有效地址去访问主存，而是将有效地址与重定位寄存器中的内容相加后得到的地址作为访问主存的地址<br>采用动态重定位技术后，程序中所有指令和数据的实际地址是在运行过程中最后访问的时刻确定的。也就是说，在作业运行过程中临时申请分配附加的存储区域或释放已占用的部分存储空间是允许的。<ul><li><strong>主要优点</strong><br>① 主存的使用更加灵活有效。这里，一个用户的作业不一定要分配在一个连续的存储区，因而可以使用较小的分配单位。而且，在作业开始之前也不一定把它的地址空间全部装入主存，而可以在作业执行期间响应请求动态地进行分配。<br>② 几个作业共享一程序段的单个副本比较容易。<br>③ 有可能向用户提供一个比主存的存储空间大得多的地址空间。因而无需用户来考虑覆盖结构，而由系统来负责全部的存储管理。</li><li><strong>主要缺点</strong><br>① 需要附加硬件支持；<br>② 实现存储器管理的软件比较复杂。</li></ul></li></ol><h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>链接程序的功能，是将经过编译后所得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。<br>连接程序按各个模块的相对地址依次构成统一的从 0 号单元开始编址的逻辑地址空间<br>根据链接时间的不同，可把链接分成如下三种：</p><ol><li><p><strong>静态链接</strong> Static Linking<br>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开。<br>将几个目标链接装配成一个装入模块时，需解决以下两个问题：</p><ul><li>将相对地址进行修改。即将除第一个模块外的相对地址修改成装入模块中的相应的相对地址</li><li>变换外部调用符号。即将每个模块中所用的外部调用符号，都变换为相对地址。<br>这种先进行链接所形成的一个完整的装入模块，又称为可执行文件<br>Pros：适用范围广，不必担心用户机器缺少某个库函数<br>Cons：修改或更新某个目标模块时，需要重新打开装入模块，效率低且很多时候不可行；静态链接的每个模块都要有目标模块的副本，无法实现共享，浪费空间</li></ul></li><li><p><strong>装入时动态链接</strong>Load-Time Dynamic Linking<br>用户源程序经编译后所得到的目标模块，是在装入内存时，边装入边链接的。即在装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将其装入内存。<br>Pros：便于软件版本的修改和更新,只需修改各个目标模块，不必将装入模块拆开，非常方便;便于实现目标模块共享。即可以将一个目标模块链接到几个应用模块中，从而实现多个应用程序对该模块的共享。</p></li><li><p><strong>运行时动态链接</strong>(Run-Time Dynamic Linking)<br>目前最常使用的链接方式,采用装入时动态链接方式，虽然可将一个装入模块装入到内存的任何地方，但装入模块的结构是静态的，表现在：</p><ul><li>进程（程序）在整个执行期间，装入模块是不改变的；</li><li>每次运行时的装入模块是相同的。并且事先无法知道本次要运行哪些模块，只能将所有可能要运行的模块在装入时全部链接在一起，而实际上往往有些目标模块根本不会运行。<br>采用运行时动态链接可<strong>将某些目标模块的链接推迟到执行时才进行</strong>，即在执行过程中，若发现一个被调用模块尚未装入内存时，由 OS 去找到该模块，将它装入内存，并链接到调用模块上。<blockquote><p>运行时动态链接的工作原理如下：</p><ol><li><strong>加载阶段</strong>：当程序启动时，动态链接器（在 Unix-like 系统中通常是 ld.so 或 ld-linux.so，在 Windows 系统中是 kernel32.dll）会加载程序需要的动态链接库（DLL）或共享对象（SO）文件。这些库文件包含程序需要的函数和数据。</li><li><strong>链接阶段</strong>：在程序运行时，当程序第一次调用某个库函数时，动态链接器会查找这个函数在内存中的实际地址，并将这个地址写入程序的全局偏移表（GOT）或程序查找表（PLT）。这个过程被称为“解析”。</li><li><strong>运行阶段</strong>：一旦函数地址被解析，程序就可以直接调用这个函数，而不需要再次通过动态链接器。如果程序再次调用这个函数，它会直接从 GOT 或 PLT 中获取函数的地址。</li></ol><p>运行时动态链接的优点包括：</p><ul><li><strong>主要优点</strong>:凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</li><li><strong>节省内存</strong>：因为多个程序可以共享同一个库的单个副本。</li><li><strong>模块化</strong>：程序可以在运行时加载和卸载模块，这使得程序更加灵活和可扩展。</li><li><strong>版本控制</strong>：可以在不重新编译程序的情况下更新库。</li></ul><p>运行时动态链接的缺点包括：</p><ul><li><strong>性能开销</strong>：动态链接和解析需要时间，尤其是在程序第一次调用库函数时。</li><li><strong>兼容性问题</strong>：如果库的新版本和旧版本不兼容，那么使用这个库的程序可能会出错。</li></ul></blockquote></li></ul></li></ol><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>连续分配指为用户程序分配一个连续的内存空间。<br>程序空间本来就是连续的,用连续的内存装入连续的程序，减少管理工作的难度<br>连续分配有三种方式：</p><ol><li><strong>单一连续分配方式</strong><br>单用户系统在一段时间内，只有一个进程在内存，故内存分配管理十分简单，内存利用率低。内存分为两个区域，一个供操作系统使用，一个供用户使用.</li><li><strong>分区式分配方式</strong><br>系统把内存用户区划分为若干分区，分区大小可以相等，也可以不等。一个进程占据一个分区。这是早期用于多道程序的一种较简单的存储管理方式。它又可以分为：<ul><li>固定分区</li><li>动态（可变）分区</li></ul></li><li><strong>可重定位分区分配</strong>(汤子瀛)</li></ol><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>内存中仅驻留一道用户程序，整个用户区为一个用户独占。<br>内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间。<br>最简单，适用于单用户、单任务的 OS。</p><ul><li>优点：易于管理。</li><li>缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存。<br>例如：DOS 2.0 以下的 DOS 操作系统采用单一连续区域主存管理方法。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-10-51-38.png"></li></ul><blockquote><p><strong>🌟 内存碎片</strong><br>内部碎片 Internal Fragment：分配给用户但用户没有使用的空间，即多分配的空间。分配给进程的内存空间比进程所需的内存空间大，但未使用的部分不能再分配给其他进程，造成内部碎片。<br>外部碎片 External Fragment：没有分配但无法分配的空间，即太小而无法分配的空间。相邻已分配内存空间的空闲区域太小，不能分配给需要的进程，造成外部碎片。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-05-05-11-34-52.png" style="zoom:50%;"></p></blockquote><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p><strong>固定分区分配思想</strong>：将内存用户空间划分为若干个固定大小的区域，每个区域称为一个分区（region），在每个分区中只装入一道作业 ，从而支持多道程序并发设计。<br>由于这些存储区域是在系统启动时划定的，在用户作业装入及运行过程中，其区域的大小和边界是不能改变的。<br>固定式分区的划分方法有两种：<br>(1)分区大小相等<br>(2)分区大小不等<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-10-54-48.png"><br>为了实现这种固定分区的分配，系统需要建立一张<strong>分区说明表</strong>。这个分区说明表指出可用于分配的分区数以及每个区的大小、起始地址及状态(是否已被分配)<br><strong>内存分配过程</strong><br>当有作业要装入内存时，内存分配程序检索分区说明表，从中找出一个尚未使用的满足大小要求的分区分配给该作业，然后修改分区的状态；如果找不到合适的分区就拒绝为该作业分配内存。</p><blockquote><p>内存中已分配给用户但未被利用的区域称为 “内零头”（内部碎片，内碎片）;固定分区分配有内零头产生</p></blockquote><ul><li>优点：易于实现，开销小</li><li>缺点：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目；存储空间的利用率太低。现在的操作系统几乎不用它了。</li></ul><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>动态分区分配是指根据进程的实际需要，动态地为之分配连续的内存空间。即分区的边界可以移动，分区的大小是可变的。<br>动态分区又有两种不同选择，一种是分区的<strong>数目固定大小可变</strong>，而另一种则允许分区的<strong>数目和大小都可变</strong>。 为了说明它们之间的重要差异，我们考虑一个具有 256K 字节存储器的系统。</p><p><strong>第一种方案</strong>(分区数目固定)：假定系统初始化时规定把存储空间划分为 8 个分区;在下图(a)中用问号(?)来表示它们。在系统运行一段时间后，已有 192K 存储空间分配给 7 个作业，剩下 64K 还未分配，如下图(b)所示。<br>现在，又有两个作业 P 和 Q 准备调入，它们每个需要 32K 存储空间。显然，我们有足够的存储空间。却没有足够数的存储区域(目前只有一个可用)。因此，只能允许一个作业(如 P)被调入，如下图(c)所示。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-11-20-19.png"><br><strong>第二种方案</strong>(分区数目可变)：最初，没有建立任何分区，整个可用的存储空间用一个问号来表示；之后，发生上述所说在系统运行一段时间后，已有 192K 存储空间分配给 7 个作业，剩下 64K 还未分配的情况，如图(b)；<br>现在，我们在剩下的 64K 存储空间中，可以创建两个分区，分别装入作业 P 和 Q，如图(c)。显然，此方案比第一个方案更灵活，内存利用率更高。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-11-21-13.png"></p><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p>实现动态分区分配，通常有两种数据结构：空闲分区表和空闲分区链。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-11-45-01.png"></p><p><strong>算法</strong></p><p>系统运行一段时间后，在整个存储空间内将出现许多大小不等的区域，有的仍被作业进程占用，有的则因作业已退出系统而成为可用于再分配的区域。现在假设有一个新的作业需调入主存，如何为其选择一个合适的区域？</p><ul><li><strong>基于顺序搜索</strong><ul><li>最佳适应算法(Best Fit)</li><li>最坏适应算法(Worst Fit)</li><li>首次适应算法(First Fit)</li><li>循环首次适应算法(Next Fit)</li></ul></li><li><strong>基于索引搜索</strong><ul><li>快速适应算法(Quick Fit)</li><li>伙伴系统</li></ul></li></ul><hr><h5 id="最佳适应算法-Best-fit-BF"><a href="#最佳适应算法-Best-fit-BF" class="headerlink" title="最佳适应算法 Best fit: BF"></a>最佳适应算法 Best fit: BF</h5><p>就是为一作业选择分区时总是寻找其大小最接近作业所要求的存储区域。即：把作业放入这样的分区后剩下的内部碎片最小。为了加快查找速度，应将存储空间中所有的空白区按其大小递增的顺序链接起来，组成一空白区链(Free List)。<br><strong>优点</strong>：</p><ul><li>如果存储空间中具有正好是所要求大小的存储空白区，则必然被选中；</li><li>如果不存在这样的空白区，也只对比要求稍大的空白区进行划分，而绝不会去划分一个更大的空白区。因此，其后遇到大作业到来时，作业要求的存储区域就比较容易得到满足。</li></ul><p><strong>缺点</strong>：</p><ul><li>采用最佳适应算法，在每次分配时，总是产生最小的空白区。因此，经过一段时期后，存储空间中可能留许多这样的空白区，由于其太小而无法使用。为了改善这种情况，在该算法中设置一参数 G，用它来确定最小分区的大小。当选择一个分区时，如果选中的空白区与要求的大小之差小于 G，则不再对它划分，而把整个这个空白区分配给申请的作业。</li><li>在回收一个分区时，为了把它插入到空白区链中合适的位置上也颇为费时。所以，这种算法乍看起来是最佳的，其实则不然。</li></ul><hr><h5 id="最坏适应算法-Worst-fit-WF"><a href="#最坏适应算法-Worst-fit-WF" class="headerlink" title="最坏适应算法 Worst fit: WF"></a>最坏适应算法 Worst fit: WF</h5><p>与最佳适应算法相反，它在为作业选择存储区域时，总是寻找最大的空白区。在划分后剩下的空白区也是最大的，因而对以后的分配很可能仍然是有用的，这是该算法的一个优点。但是，由于最大的空白块总是首先被分配而进行划分，当有大的作业时，其存储空间的申请往往得不到满足，这是该算法的一个缺点。<br>为了支持这个算法的实现，空白块应以大小递减的顺序链接起来。</p><hr><h5 id="首次适应算法-First-fit-FF"><a href="#首次适应算法-First-fit-FF" class="headerlink" title="首次适应算法 First fit: FF"></a>首次适应算法 First fit: FF</h5><p>BF 和 WF 各有其利弊。首次适应算法是对它们进行折衷考虑后设计出来的。<br>每个空白区按其在存储空间中地址递增的顺序链在一起，即每个后继空白区的起始地址总是比前者的大。在为作业分配存储区域时，从这个空白区链的始端开始查找，选择第一个足以满足请求的空白块，而不管它究竟有多大。<br>和上述算法一样，这个选择的空白区被分成两部分。一部分与请求的大小相等，分配给作业；剩下的部分留在空白区链中。显然，这个算法倾向于优先利用存储空间中低址部分的空白区。</p><p><strong>主要优点</strong><br>算法简单，查找速度快；留在高址部分的大的空白区被划分的机会较少，因而在大作业到来时也比较容易得到满足。<br><strong>主要缺点</strong>：<br>这种算法常常利用一个大的空白区适应小作业的请求，从而留下一些较小的无法用的空白区(外部碎片)，存储空间利用率不高；而且，由于所有的请求都是从空白区链的始端开始查找，因而这些小而无用的空白区集中在这个链的前端，相应地，一些较大空白区在链的尾端才能发现，这种情况将使找到合适空白区的速度降低。</p><hr><h5 id="下次-循环首次-适应算法-Next-fit-NF"><a href="#下次-循环首次-适应算法-Next-fit-NF" class="headerlink" title="下次(循环首次)适应算法 Next fit: NF"></a>下次(循环首次)适应算法 Next fit: NF</h5><p>为了克服上述缺点，又设计了一种称为“下次”适应的算法，它实际上是首次适应算法的一种变形，故也被称为<strong>带旋转指针的首次适应算法(Next Fit with Roving Pointer)</strong><br>为此，我们把存储空间中空白区构成一个循环链。每次为存储请求查找合适的分区时，总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将它划分后分配出去。显然，采用这一策略后，存储空间的利用更加均衡，而不至于使小的空白区集中于存储器的一端。但是，在存储器的另一端也不可能保留大的空白块，因此，当需要获得相当大的空白区时，能满足的可能性减少了。</p><hr><h5 id="快速适应算法-Quik-fit-QF"><a href="#快速适应算法-Quik-fit-QF" class="headerlink" title="快速适应算法 Quik fit:QF"></a>快速适应算法 Quik fit:QF</h5><p>将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。<br>这样，系统中存在多个空闲分区链表；<br>同时，在内存中设立一张管理分区类型，并记录了该类型空闲分区链表表头的索引表，该表的每一个表项记录了对应类型空闲分区链表表头的指针。<br>分配过程：根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可<br><strong>优点</strong></p><ul><li>查找效率高。</li><li>该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。</li></ul><p><strong>缺点</strong></p><ul><li>在分区归还主存时算法复杂，系统开销较大。</li><li>该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，</li></ul><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-17-11-39-39.png" style="zoom:100%;"><hr><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-17-11-39-20.png" style="zoom:100%;"><h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><p>涉及动态分区的主要操作有<strong>分配内存</strong>和<strong>回收内存</strong>。这些操作是在程序接口中通过系统调用发出的。</p><ol><li><p><strong>分配内存</strong>：<br>向操作系统提出一特定存储量的请求。通常，它并不要求这个分配的存储区域限于特定的位置，但是，这个区域必须是连续的。OS 利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。</p><ul><li>请求的分区大小为 u.size</li><li>表中每个空闲分区的大小为 m.size</li><li>size 是事先规定的不再切割的剩余分区的大小<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-17-11-47-18.png" style="zoom:100%;"></li></ul></li><li><p><strong>回收内存</strong><br>进程用于归还一个不再需用的存储区域。</p><ul><li>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链(表)中找到相应的插入点。</li><li>在回收一个分区时，一个回收的分区与空白区邻接的情况有四种，对这四种情况分别作如下处理：<ul><li>回收区与插入点的前一个空闲分区 F1 相邻接。此时应将回收区与插入点的前一分区合并(通过修改其前一分区 F1 的大小，不必为回收区分配新表现)</li><li>回收区仅与下面的空白区邻接，合并后仍为空白区 F2，但其起始地址和大小均需改变。用回收区的首址作为新空闲区的首址，大小为两者之和</li><li>回收区与上、下面的空白区邻接此时将三个分区合并，使用 F1 的表项和 F1 的首址，取消 F2 的表项，大小为三者之和。</li><li>回收区与上、下面的空白区均不邻接，在这种情况下，应为回收区单独建立一新表项，填写回收区的首址和大小，并根据首地址插入到空闲链中的适当位置。</li></ul></li></ul></li></ol><h3 id="伙伴系统-Buddy-System"><a href="#伙伴系统-Buddy-System" class="headerlink" title="伙伴系统 Buddy System"></a>伙伴系统 Buddy System</h3><p>固定分区和动态分区都存在内部碎片和外部碎片的问题。伙伴系统是一种解决内部碎片问题的方法。</p><p>在伙伴系统中，可用内存块的大小为$2^k (1\le k\le m)$<br>其中$2^1$表示分配的最小块尺寸，$2^m$表示分配的最大块尺寸，通常是可供分配的整个内存空间大小。<br>对空闲区按照大小分类，相同大小的分区链接为一个双向空闲链表；最多可形成 k 个链表。</p><p>进程请求大小为 n 的存储空间：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-18-21-01-37.png" style="zoom:100%;"></p><ol><li>找到 i，使得$2^{i-1}\lq n &lt; 2^i$</li><li>在空闲分区大小为$2^i$的链表中查找，若找到，则分配；</li><li>如果没找到，从$2^{i+1}$的链表中查找，找到后，将其分裂为两个大小相等的伙伴，其中一个分配给进程，另一个插入到$2^i$相应的链表中。</li><li>如果仍然没找到，则继续查找更大的链表，直到找到或者查找完所有链表。</li></ol><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-18-21-02-46.png" style="zoom:100%;">> 分割及回收合并分区需要时间开销，多用于多处理机系统中。<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>利用哈希快速查找的优点，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一张哈希表，以空闲分区大小为关键字，每一个表项记录了一个对应的空闲分区链表表头指针。<br>当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p><h4 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h4><h5 id="紧凑-Compaction"><a href="#紧凑-Compaction" class="headerlink" title="紧凑 Compaction"></a>紧凑 Compaction</h5><p>可变式分区分配策略是在装入作业时根据其要求量为其划定相应的区域。这种分配策略，消除了固定式分区分配造成的“内零头”，但不可避免地在存储空间中造成“外零头”，为了进一步提高存储器的利用率，必须设法减少由于外零头造成的浪费。</p><p>一个最简单而直观的解决零头问题的办法是，定时地或者在内存紧张时，把存储空间中的空白区合并为一个大的连续区。<br>实现方法将内存中的所有作业进行移动，使它们全都相邻接，这样，可把原来分散的多个小分区合成一个大分区。这种技术称为存储器的<strong>紧凑</strong>Compaction。<br>把一个作业从一个存储区域移动到另一个存储区域，需要对作业中的某些地址部分和地址常数等进行调整。一个较实用且可行的办法是采用动态重定位技术。一个作业在主存中移动后，只要改变重定位寄存器中的内容即可。</p><hr><h5 id="动态重定位-Dynamic-Relocation"><a href="#动态重定位-Dynamic-Relocation" class="headerlink" title="动态重定位 Dynamic Relocation"></a>动态重定位 Dynamic Relocation</h5><p>在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。<br>程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-18-21-09-58.png" style="zoom:100%;"></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://data-flair.training/blogs/memory-management-in-computer/">data-flair memory-management-in-computer</a></p>]]></content>
    
    
    <summary type="html">介绍存储管理第一部分。包括存储器的层次结构、程序的装入和链接、连续分配存储管理方式三大部分。</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="操作系统" scheme="https://efterklang.github.io/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>ChⅤ 数据库系统管理</title>
    <link href="https://efterklang.github.io/UESTC/DataBase/Ch5-DbManagement/"/>
    <id>https://efterklang.github.io/UESTC/DataBase/Ch5-DbManagement/</id>
    <published>2024-04-11T03:35:50.000Z</published>
    <updated>2024-05-21T01:23:37.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h2><p>数据库管理(Database Management)是指为保证数据库系统的正常运行和服务质量必须进行的系统管理工作。</p><p><strong>为什么需要数据库管理</strong></p><ul><li>数据库系统随规模增大,系统会变得异常复杂</li><li>多用户数据库应用带来数据库访问复杂性</li><li>数据安全和数据隐私对机构和用户都非常重要</li><li>数据库系统随数据量增加和使用时间增长其性能会降低系统遭遇意外事件，数据库损坏或数据丢失</li></ul><p><strong>数据库管理目标</strong></p><ul><li>保障数据库系统正常稳定运行</li><li>充分发挥数据库系统的软硬件处理能力</li><li>确保数据库系统安全和用户数据隐私性</li><li>有效管理数据库用户及其角色权限</li><li>解决数据库系统性能优化、系统故障与数据损坏等问题</li><li>最大程度地发挥数据库对其所属机构的作用</li></ul><p><strong>DBMS 功能</strong></p><ul><li>数据库定义<ul><li>数据库结构创建，结构修改，完整性约束定义，索引结构定义</li></ul></li><li>数据库运行管理<ul><li>系统启停控制，并发控制，事务管理，安全性控制，完整性控制，日志管理，性能监控</li></ul></li><li>数据库组织与存储<ul><li>缓冲区管理，数据组织，数据存取</li></ul></li><li>数据库维护<ul><li>数据载入，数据转换，数据库备份＆恢复，数据库重构，性能优化</li></ul></li><li>数据库通信<ul><li>数据的同步、复制、传输</li></ul></li></ul><h2 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h2><p><strong>为什么需要事务管理</strong></p><p>在数据库应用系统中，完成一个业务处理通常需要多个操作步骤才能完成处理。在每个操作步骤中，都可能遭遇失败，若没有一个处理机制，就可能造成操作数据混乱，从而破坏数据一致性。</p><p><strong>事务的概念</strong><br>[<a href="../../Tech/DataBase/DataBase03.md" title="DataBase Base 多表查询&amp;事务">DataBase03#事务 Transaction</a>]<br>在数据库中，事务（Transaction）是指由构成单个业务处理单元的一组数据库访问操作，要求它们要么都成功执行，要么都不执行。</p><ul><li>最小的 DBMS 执行任务单元</li><li>最小的故障恢复任务单元</li><li>最小的并发控制任务单元</li></ul><h3 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h3><ul><li><strong>原子性</strong>（Atomicity）：事务中的所有操作要么全部完成，要么全部不完成。如果事务中的某个操作失败，那么整个事务将被回滚，数据库状态不会改变。</li><li><strong>一致性</strong>（Consistency）：事务确保数据库从一个一致的状态转换到另一个一致的状态。事务开始和结束时，所有的业务规则都必须保持一致。</li><li><strong>隔离性</strong>（Isolation）：每个事务都在一个独立的工作区中执行，事务之间不会互相影响。这意味着并发事务的修改必须被隔离，直到事务提交，其他事务才能看到这些修改。</li><li><strong>持久性</strong>（Durability）：一旦事务被提交，它对数据库的更改就是永久性的。即使发生系统故障，更改也不会丢失。<blockquote><p>事务并发执行是指多个事务程序在数据库系统中同一时段运行，从而改善系统的资源利用率、减少事务运行的平均等待时间</p></blockquote></li></ul><p>事务 SQL 程序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>  或 <span class="keyword">START</span> TRANSACTION ；<span class="comment">--事务开始语句</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>； <span class="comment">--事务回滚语句</span></span><br><span class="line"><span class="keyword">COMMIT</span>；<span class="comment">--事务提交语句</span></span><br><span class="line"><span class="keyword">SAVEPOINT</span>；<span class="comment">--事务保存点语句</span></span><br></pre></td></tr></table></figure><h3 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h3><p><strong>为什么需要并发控制</strong>？</p><p>当多个事务程序在 DBMS 系统中同时运行时，可能会出现对一些共享数据同时进行访问操作，如一些事务修改数据，另一些事务读取数据。这些并发的共享数据操作，如果在 DBMS 中没有一定的约束控制情况下，可能会带来数据不一致性或事务程序死锁问题。因此，在多个事务并发运行时必须进行并发控制处理</p><p><strong>并发控制目的</strong></p><ul><li>支持并发事务处理，使更多用户并行操作，提高系统的并发访问能力。</li><li>保证一个事务工作不会对另一个事务工作产生不合理的影响。</li></ul><h3 id="并发控制需解决的问题"><a href="#并发控制需解决的问题" class="headerlink" title="并发控制需解决的问题"></a>并发控制需解决的问题</h3><ul><li><p><strong>丢失更新 lost update</strong><br>两个事务同时读取同一数据，其中一个事务修改数据后，另一个事务也修改了同一数据，导致其中一个事务的修改被覆盖。</p></li><li><p><strong>脏读 dirty read</strong><br>事务 T1 更新了数据，但没有 Commit,T2 读取了 T1 更新的数据，但 T1 通过 ROLLBACK 撤销事务，即 T2 读取到脏数据。</p></li><li><p><strong>不可重复读 nonrepeatable read</strong><br>事务 T1 读取 a，T2 修改 a 并提交，T1 再次读取 a，发现 a 的值发生了变化。即一个事务的两次读取相同的资源但得到不同的值</p></li><li><p><strong>幻读 phantom read</strong><br>事务T1按一定条件从数据库中读取某些数据记录后，事务T2在其中插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。称为幻读。与不可重复读类似。<br>A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</p></li><li><p><strong>serialization anomaly</strong><br>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</p></li></ul><h3 id="加锁协议"><a href="#加锁协议" class="headerlink" title="加锁协议"></a>加锁协议</h3><p><strong>一级加锁协议</strong>：任何事务在修改共享数据对象之前，必须对该数据执行排它锁定指令，直到该事务处理完成，才进行解锁指令执行。<br>特点：使用一级加锁协议，可避免出现<strong>更新丢失</strong>问题。但不能解决“不可重复读取”、“脏读”等数据不一致问题<br><strong>二级加锁协议</strong>：在一级加锁协议基础上，针对并发事务的共享数据读操作，必须对该数据执行共享锁定指令，读完数据后即刻释放共享锁定。<br>特点：该加锁协议不但可以防止<strong>丢失更新,脏读</strong>问题。但有可能会出现“不可重复读取”的数据不一致问题。<br><strong>三级加锁协议</strong>：在一级加锁协议基础上，针对并发事务对共享数据进行读操作，必须对该数据执行共享锁定指令，直到该事务处理结束才释放共享锁定。<br>特点：该加锁协议可以防止<strong>丢失更新、脏读、不可重复读取</strong></p><p>两阶段锁定协议<br>并发事务的正确调度准则：<br>一个给定的并发事务调度，当且仅当它是可串行化时，才能保证正确调度。<br>保证可串行化的一个协议是：二阶段锁定协议<br>二阶段锁定协议规定每个事务必须分两个阶段提出加锁和解锁申请:<br>增长阶段，事务只能获得锁，但不能释放锁。<br>缩减阶段，事务只能释放锁，但不能获得新锁。</p><p>结论:若并发事务执行的所有事务都遵从两阶段锁定协议，则这些事务的任何并发调度都是可串行化调度，即这些并发调度执行结果可以保证数据库一致性。</p><h2 id="数据库备份与恢复"><a href="#数据库备份与恢复" class="headerlink" title="数据库备份与恢复"></a>数据库备份与恢复</h2><p>数据库备份——是指将数据库当前数据和状态进行副本复制，以便当数据库受到破坏或丢失数据时可以进行修复。<br>数据库恢复——是指数据库中数据丢失或被破坏时，从备份副本将数据库从错误状态恢复到某一正确状态。</p><p>备份方法：<br>完全数据库备份<br>差异数据库备份<br>事务日志备份<br>文件备份</p><p><strong>备份方式</strong></p><ul><li><p>热备份 Hot Backup，也被称为在线备份，是在数据库仍在运行和处理事务的同时进行的备份。这种备份方式的主要优点是它不会中断数据库服务，但可能会稍微影响数据库的性能。</p></li><li><p>冷备份 Cold Backup：也被称为离线备份，是在数据库完全关闭的情况下进行的备份。这种备份方式可以确保备份的数据一致性，但在备份期间，数据库无法提供服务。</p></li></ul><p>备份时机:当系统数据库重要数据被修改、日志被清理、用户数据库创建、用户数据库加载等事件出现时。</p><p>数据库备份实现</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--实例操作： 备份SAMPLE数据库到一个G磁盘的根目录文件Sample.bak中。</span></span><br><span class="line">BACKUP DATABASE SAMPLE</span><br><span class="line"><span class="keyword">TO</span> DISK <span class="operator">=</span> <span class="string">&#x27;G:\Sample.bak&#x27;</span>; <span class="comment">--实例操作： 从存储备份文件中恢复SAMPLE数据库。</span></span><br><span class="line">RESTORE DATABASE SAMPLE</span><br><span class="line"><span class="keyword">FROM</span> DISK <span class="operator">=</span> <span class="string">&#x27;G:\Sample.bak&#x27;</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">UESTC数据库系统原理与开发，Chapter5 - Database Management;涉及数据库管理、事务管理、数据库备份与恢复等内容</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="数据库原理及应用" scheme="https://efterklang.github.io/categories/UESTC/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>ARM伪指令及编程基础</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch4-1ARM%E4%BC%AA%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch4-1ARM%E4%BC%AA%E6%8C%87%E4%BB%A4%E5%8F%8A%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2024-04-07T11:28:39.000Z</published>
    <updated>2024-06-06T05:13:47.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="伪指令概述"><a href="#伪指令概述" class="headerlink" title="伪指令概述"></a>伪指令概述</h2><p><strong>伪指令</strong>:人们设计了一些专门用于指导汇编器进行汇编工作的指令，由于这些指令不形成机器码指令，它们只是在汇编器进行汇编工作的过程中起作用，所以被叫做伪指令<br>伪指令具有的两个特征:伪指令是一条指令;伪指令没有指令代码。</p><p><strong>伪指令的作用</strong></p><ul><li>程序定位的作用;</li><li>为非指令代码进行定义;</li><li>为程序完整性做标注;</li><li>有条件的引导程序段。</li></ul><h2 id="通用伪指令"><a href="#通用伪指令" class="headerlink" title="通用伪指令"></a>通用伪指令</h2><p>在 ARM 汇编程序语言中，有如下几种伪指令：</p><ul><li>符号定义（Symbol Definition）伪指令</li><li>数据定义（Data Definition）伪指令</li><li>汇编控制（Assembly Control）伪指令</li><li>其它（Miscellaneous）伪指令</li></ul><h3 id="为变量定义或赋值的伪指令"><a href="#为变量定义或赋值的伪指令" class="headerlink" title="为变量定义或赋值的伪指令"></a>为变量定义或赋值的伪指令</h3><p>符号的命名由编程者决定，但必须遵循以下约定：</p><ul><li>符号区分大小写，同名的大、小写符号会被编译器认为是两个不同的符号;</li><li>符号在其作用范围内必须唯一;</li><li>自定义的符号不能与系统保留字相同;</li><li>符号不应与指令或伪指令同名。</li></ul><h4 id="声明全局变量伪指令-GBLA、GBLL-和-GBLS"><a href="#声明全局变量伪指令-GBLA、GBLL-和-GBLS" class="headerlink" title="声明全局变量伪指令 GBLA、GBLL 和 GBLS"></a>声明全局变量伪指令 GBLA、GBLL 和 GBLS</h4><p>GBLA、GBLL 和 GBLS 伪指令用于定义一个 ARM 程序中的全局变量，并将其初始化。全局变量的变量名在整个程序范围内必须具有唯一性<br>指令格式：<code>GBLA(GBLL和GBLS)  &lt;variable_name&gt;</code><br>GBLA 定义一个 全局数字变量，其默认初值为 0 ;<br>GBLL 定义一个 全局逻辑变量 ，其默认初值为 FALSE;<br>GBLS 定义一个 全局字符串变量，其默认初值为 空 ;</p><h4 id="声明局部变量伪指令-LCLA、LCLL-和-LCLS"><a href="#声明局部变量伪指令-LCLA、LCLL-和-LCLS" class="headerlink" title="声明局部变量伪指令 LCLA、LCLL 和 LCLS"></a>声明局部变量伪指令 LCLA、LCLL 和 LCLS</h4><p>LCLA、LCLL 和 LCLS 伪指令用于定义一个 ARM 程序中的局部变量，并将其初始化。<br>格式：<code>LCLA(LCLL 和 LCLS) &lt;variable_name&gt;</code><br>LCLA 定义一个局部数字变量，其默认初值为 0;<br>LCLL 定义一个局部逻辑变量，其默认初值为 FALSE;<br>LCLS 定义一个局部字符串变量，其默认初值为 空。</p><h4 id="变量赋值伪指令-SETA、SETL-和-SETS"><a href="#变量赋值伪指令-SETA、SETL-和-SETS" class="headerlink" title="变量赋值伪指令 SETA、SETL 和 SETS"></a>变量赋值伪指令 SETA、SETL 和 SETS</h4><p>伪指令 SETA、SETL 和 SETS 用于给一个已经定义的全局变量或局部变量进行赋值。 注：要顶格写</p><p>指令格式：<code>变量名 SETA（SETL 或 SETS）表达式</code><br>SETA 伪指令用于给一个数字变量赋值;<br>SETL 伪指令用于给一个逻辑变量赋值;<br>SETS 伪指令用于给一个字符串变量赋值;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Test1  SETA  <span class="number">0xAA</span> ;将Test1变量赋值为<span class="number">0xAA</span>。</span><br><span class="line">Test2  SETL  &#123;TRUE&#125;  ;将Test2 变量赋值为真;</span><br><span class="line">Test3 SETS <span class="string">&quot;Testing&quot;</span>    ;将Test3变量赋值为Testing</span><br></pre></td></tr></table></figure><h4 id="定义寄存器列表伪指令"><a href="#定义寄存器列表伪指令" class="headerlink" title="定义寄存器列表伪指令"></a>定义寄存器列表伪指令</h4><p>指令 LDM&#x2F;STM 需要使用一个比较长的寄存器列表，使用伪指令 RLIST 可对一个列表定义一个统一的名称。<br>格式：<code>&lt;name&gt; RLIST &lt;&#123;list&#125;&gt;</code><br>例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoReg RLIST &#123;R0-R7&#125; ;定义寄存器列表&#123;R0-R7&#125;的名称为 LoReg</span><br><span class="line">STMFD SP!, LoReg ;堆栈操作使用寄存器列表</span><br><span class="line">RegList RLIST &#123;R0-R5,R8,R10&#125; ;将寄存器列表名称定义为 RegList，可在 ARM 指令 LDM/STM 中通过该名称访问寄存器列表</span><br></pre></td></tr></table></figure><h3 id="数据定义伪指令"><a href="#数据定义伪指令" class="headerlink" title="数据定义伪指令"></a>数据定义伪指令</h3><h4 id="LTORG"><a href="#LTORG" class="headerlink" title="LTORG"></a>LTORG</h4><p>用于声明一个数据缓冲池（文字池）的开始。<br>格式：<code>LTORG</code><br>伪指令 LTORG 用来说明某个存储区域为一个用来暂存数据的数据缓冲区，也叫文字池或数据缓冲池。大的代码段也可以使用多个数据缓冲池。<br>其目的是，防止在程序中使用 LDR 之类的指令访问时，可能产生的越界。<br>通常把数据缓冲池放在代码段的最后面，或放在无条件转移指令或子程序返回指令之后，这样处理器就不会错误地将数据缓冲池中的数据当作指令来执行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">         AREA example, CODE, READONLY</span><br><span class="line">Start   BL  Func1</span><br><span class="line">             …</span><br><span class="line">Func1    LDR R1,=<span class="number">0x800</span></span><br><span class="line">         MOV PC,LR</span><br><span class="line">         LTORG  ;定义数据缓冲池的开始位置，</span><br><span class="line">             ;系统会自动设置数据缓冲池的大小</span><br><span class="line">         …</span><br><span class="line">         END</span><br></pre></td></tr></table></figure><h4 id="MAP-和-FIELD"><a href="#MAP-和-FIELD" class="headerlink" title="MAP 和 FIELD"></a>MAP 和 FIELD</h4><p>MAP 用于定义一个结构化的内存表的首地址。MAP 可以用<code>^</code> 代替。<br>格式：<code>MAP &lt;expr&gt; &#123;,&lt;base_register&gt;&#125;</code></p><p>expr 是数字表达式或程序中的标号。当指令中没有 base_register 时，expr 即为结构化内存表的首地址，可以为 标号 或 数字表达式;<br>base_register 为基址寄存器（可选项）。当指令中包含这一项时，结构化内存表的首地址为 expr 与 base_register 寄存器值的和;<br><code>MAP fun ;</code> fun 就是内存表的首地址<br><code>MAP 0x100,R9</code> ;内存表的首地址为 R9+0X100</p><p>MAP 通常和 FIELD 伪指令相配合来定义一个结构化的内存表。<br>FIELD 伪指令用于定义一个结构化内存表中的数据域。<br>格式：<code>&#123;label&#125; FIELD expr</code></p><p>Label 为域标号，要顶格写;<br>Expr 表示本数据域在内存表中所占用的字节数;<br>功能：FIELD 用于定义一个结构化内存表中的数据域，<code>#</code>与 FIELD 同义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    MAP <span class="number">0X100</span> ;定义结构化内存表首地址为 <span class="number">0X100</span></span><br><span class="line">A FIELD <span class="number">16</span> ;定义A的长度为<span class="number">16</span>字节，位置为 <span class="number">0X100</span></span><br><span class="line">B FIELD <span class="number">32</span> ;定义B的长度为<span class="number">32</span>字节，位置为 <span class="number">0X110</span></span><br><span class="line">S FIELD <span class="number">256</span> ;定义S的长度为<span class="number">256</span>字节，位置为 <span class="number">0X130</span></span><br><span class="line">注意：MAP 和 FIELD 伪指令仅用于定义数据结构，并不实际分配存储单元。 FIELD 也可用“#” 代替。</span><br></pre></td></tr></table></figure><h4 id="SPACE-和-DCB"><a href="#SPACE-和-DCB" class="headerlink" title="SPACE 和 DCB"></a>SPACE 和 DCB</h4><p>SPACE 伪指令用于分配一片连续的存储区域并初始化为 0。<br>格式： <code>&#123;label&#125; SPACE expr</code><br>label 为内存块起始地址标号;<br>Expr 为所要分配的内存字节数;<br>SPACE 也可用“%” 代替。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    AREA DataRAM,DATA,READWRITE;声明一数据段，名为 DataRAM</span><br><span class="line">DataSpace SPACE <span class="number">100</span> ;分配连续的 <span class="number">100</span> 字节的存储单元,并初始化为 <span class="number">0</span>。</span><br></pre></td></tr></table></figure><p>DCB 伪指令用于分配内存单元并初始化<br>格式：<code>&#123;label&#125;  DCB  expr&#123;，expr &#125;&#123;，expr &#125;…</code></p><p>label 是存块起始地址标号;<br>expr 可以为 0 至 255 的数值或字符串，内存分配的字节数由 expr 个数决定;<br>功能：DCB 用于分配一段字节内存单元，并用伪指令中的 expr 初始化，一般可用来定义数据表格，或文字符串，<code>=</code>与 DCB 同义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DISPTAB DCB <span class="number">0x43</span>,<span class="number">0x33</span>,<span class="number">0x76</span>,<span class="number">0x12</span></span><br><span class="line">            DCB <span class="number">120</span>,<span class="number">20</span>,<span class="number">32</span>,<span class="number">44</span></span><br><span class="line">String  DCB “send,data is error!”,<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LDR R1, =DISPTAB   ;把DISPTAB的地址值送入R1</span><br><span class="line">        LDRB R2, [R1,#<span class="number">2</span>];获取地址为[R1+#<span class="number">2</span>]字节单元的值,R2=<span class="number">0x76</span></span><br></pre></td></tr></table></figure><h4 id="DCD-和-DCDU"><a href="#DCD-和-DCDU" class="headerlink" title="DCD 和 DCDU"></a>DCD 和 DCDU</h4><p>用于分配存储单元并初始化<br>格式：<br><code>&#123;label&#125; DCD expr&#123;，expr &#125;&#123;，expr &#125;…</code><br><code>&#123;label&#125; DCDU expr&#123;，expr &#125;&#123;，expr &#125;…</code><br>label 是内存块起始地址标号<br>expr 为常数表达式或程序中标号，内存分配字节数由 expr 个数决定<br>功能：<br>DCD 用于分配一段字内存单元，并用伪指令中的 expr 初始化，字对齐，可定义数据表格或其它常数。<code>&amp;</code>与 DCD 同义。<br>DCDU 用于分配一段字内存单元，并用伪指令中的 expr 初始化。DCDU 伪指令分配的内存不需要字对齐，可定义数据表格或其它常数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        AREA blockcopy,CODE,READONLY</span><br><span class="line">        ……</span><br><span class="line">        LDR R1,=ftt</span><br><span class="line">        LDR R2,=ftt2</span><br><span class="line">        LDR R3,[R1] ; R3 = <span class="number">1</span></span><br><span class="line">        LDR R4,[R2] ; R4 = <span class="number">3</span></span><br><span class="line">        LDR R5,[R1, #<span class="number">4</span>]; R5 = <span class="number">2</span></span><br><span class="line">        LDR R6,[R2, #<span class="number">4</span>]; R6 = <span class="number">4</span></span><br><span class="line">        ……</span><br><span class="line">Src    DCD <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,</span><br><span class="line"></span><br><span class="line">        MAP Src</span><br><span class="line">ftt    FIELD <span class="number">8</span>; <span class="number">8</span> Byte = <span class="number">64</span> Bit = <span class="number">2</span> words, 即ftt为src数组的前两个元素</span><br><span class="line">ftt2FIELD <span class="number">8</span></span><br><span class="line">        END</span><br></pre></td></tr></table></figure><p>该例说明了,MAP 和 FIELD 伪指令不分配存储空间，只是给相关存储单元取个名称（标号）。便于程序以结构的方式访问对应的内存单元。</p><h4 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h4><p>了解</p><ul><li>DCFD 和 DCFDU</li><li>DCFS 和 DCFSU</li><li>DCQ 和 DCQU</li><li>DCW 和 DCWU</li></ul><h3 id="控制程序流向伪指令"><a href="#控制程序流向伪指令" class="headerlink" title="控制程序流向伪指令"></a>控制程序流向伪指令</h3><p>IF、ELSE 和 ENDIF 伪指令能根据条件的成立与否决定是否编译某个程序段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF condition</span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line">ELSE</span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line">ENDIF</span><br></pre></td></tr></table></figure><p>WHILE 和 WEND 伪指令根据条件的成立与否决定是否重复汇编一个程序段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WHILE condition</span><br><span class="line">    程序段</span><br><span class="line">WEND</span><br></pre></td></tr></table></figure><p>若 WHILE 后面的逻辑表达式为真，则重复汇编该程序段，直到逻辑表达式为假。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    GBLA  NUM</span><br><span class="line">NUMSETA  <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    AREA blockcopy,CODE,READONLY</span><br><span class="line">    ENTRY</span><br><span class="line">    WHILE NUM &lt; <span class="number">3</span></span><br><span class="line">    ...</span><br><span class="line">NUMSETA  NUM+<span class="number">1</span></span><br><span class="line">    WEND</span><br><span class="line">    .........</span><br><span class="line">    END</span><br></pre></td></tr></table></figure><h3 id="其它伪指令"><a href="#其它伪指令" class="headerlink" title="其它伪指令"></a>其它伪指令</h3><h4 id="定义对齐方式伪指令-ALIGN"><a href="#定义对齐方式伪指令-ALIGN" class="headerlink" title="定义对齐方式伪指令 ALIGN"></a>定义对齐方式伪指令 ALIGN</h4><p>格式：<code>ALIGN &#123;表达式，&#123;偏移量&#125;&#125;</code><br>ALIGN 是边界对齐伪指令，它可以通过添加填充字节的方式，使当前位置满足一定的对齐方式。其中表达式用于指定对齐方式在不同场合有不同的定义<br>例如 ALIGN 4 ;4 字节字对齐，ALIGN 后面不能有等号</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">        AREA    OffsetExample, CODE</span><br><span class="line">        .........</span><br><span class="line">ss1  DCB     <span class="number">1</span>    ;假设ss1在<span class="number">0x01000</span>字节</span><br><span class="line">        ALIGN   <span class="number">4</span>,<span class="number">3</span>  ; <span class="number">4</span>字节对齐+<span class="number">3</span>偏移量.</span><br><span class="line">ss2    DCB     <span class="number">1</span></span><br><span class="line">                ;使用“ALIGN <span class="number">4</span>，<span class="number">3</span>”以后，</span><br><span class="line">                ;当前位置会转到<span class="number">0x01003</span>(<span class="number">0x01000</span>+<span class="number">3</span>)。</span><br><span class="line">                ;ss1和ss2之间会空<span class="number">2</span>个字节。</span><br></pre></td></tr></table></figure><h4 id="段定义伪指令-AREA"><a href="#段定义伪指令-AREA" class="headerlink" title="段定义伪指令 AREA"></a>段定义伪指令 AREA</h4><p>AREA 用于定义一个代码段或数据段。一个汇编语言程序至少要有一个段。<br>格式：<code>AREA  sectionname &#123;,attr&#125; &#123;,attr&#125;…</code></p><p>sectionname 是定义的代码段或数据段的名称。若该名称是以数据开头的，则该名称必须用“｜”括起来，如｜ 2_datasec ｜。还有一些代码段的名称是专有名称。<br>Attr 表示代码或数据段的属性，多个属性用短号分隔，常用的属性如下</p><table><thead><tr><th>属性</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>CODE</td><td>代码段</td><td>默认读&#x2F;写属性为 READONLY</td></tr><tr><td>DATA</td><td>数据段</td><td>默认读&#x2F;写属性为 READWRITE</td></tr><tr><td>NOINIT</td><td>数据段</td><td>指定此数据段仅仅保留了内存单元，而没有将各初始值写入内存单元。</td></tr><tr><td>READONLY</td><td>本段为只读</td><td></td></tr><tr><td>READWRITE</td><td>本段为可读可写</td><td></td></tr><tr><td>ALIGN 表达式</td><td></td><td>ELF 的代码段和数据段为字对齐</td></tr><tr><td>COMMON</td><td>多源文件共享段</td><td></td></tr></tbody></table><h4 id="CODE16-和-CODE32"><a href="#CODE16-和-CODE32" class="headerlink" title="CODE16 和 CODE32"></a>CODE16 和 CODE32</h4><p>CODE16 告诉汇编编译器后面的指令序列为 16 位的 Thumb 指令。<br>CODE32 告诉汇编编译器后面的指令序列为 32 位的 ARM 指令。<br>注意：CODE16 和 CODE32 只是告诉编译器后面指令的类型，该伪操作本身不进行程序状态的切换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">AREA     ChangeState, CODE, READONLY</span><br><span class="line">         ENTRY</span><br><span class="line">         CODE32                   ;下面为<span class="number">32</span>位ARM指令</span><br><span class="line">         LDR   R0,=start+<span class="number">1</span>   ;将跳转地址放入寄存器R0</span><br><span class="line">         BX      R0;程序跳转到新的位置执行</span><br><span class="line">             …… ;并将处理器切换到Thumb工作状态</span><br><span class="line">         CODE16                 ;下面为<span class="number">16</span>位Thumb指令</span><br><span class="line">start  MOV   R1,#<span class="number">10</span></span><br><span class="line">           …….</span><br><span class="line">          END</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="ENTRY-END"><a href="#ENTRY-END" class="headerlink" title="ENTRY &amp; END"></a>ENTRY &amp; END</h4><p>ENTRY 定义程序入口点伪指令 ,指定程序的入口点。</p><p>注意：一个程序（可包含多个源文件）中至少要有一个 ENTRY（可以有多个 ENTRY，当有多个 ENTRY 入口时，程序的真正入口点由链接器指定），但一个源文件中最多只能有一个 ENTRY（可以没有 ENTRY）</p><p>END 伪指令用于通知编译器汇编工作到此结束，不再往下汇编了。每一个汇编源程序都必须包含 END 伪操作，以表明本源程序的结束。</p><h4 id="EXPORT-IMPORT-EXTERN"><a href="#EXPORT-IMPORT-EXTERN" class="headerlink" title="EXPORT &amp; IMPORT &amp; EXTERN"></a>EXPORT &amp; IMPORT &amp; EXTERN</h4><p><strong>EXPORT</strong><br>外部可引用符号声明伪指令 EXPORT（或 GLOBAL）<br>声明一个源文件中的符号，使此符号可以被其他源文件引用。<br>格式：<code>EXPORT/GLOBAL symbol &#123;[weak]&#125;</code><br>symbol：声明的符号的名称。（区分大小写）<br>[weak]：声明其他同名符号优先于本符号被引用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        AREA example，CODE，READONLY</span><br><span class="line">        EXPORT  DoAdd;申明一个全局引用的标号 DoAdd</span><br><span class="line">DoAdd   ADD R0，R0，R1</span><br></pre></td></tr></table></figure><p><strong>IMPORT</strong><br>当在一个源文件中需要使用另外一个源文件的外部可引用符号时，在被引用的符号前面，必须使用伪指令 IMPORT 对其进行声明：声明一个符号是在其他源文件中定义的。<br>格式：<code>IMPORT symbol&#123;[weak]&#125;</code><br>如果源文件声明了一个引用符号，则无论当前源文件中程序是否真正地使用了该符号，该符号均会被加入到当前源文件的符号表中。<br>symbol：声明的符号的名称。<br>[weak]：当没有指定此项时，如果 symbol 在所有的源文件中都没有被定义，则连接器会报告错误。<br>当指定此项时，如果 symbol 在所有的源文件中都没有被定义，则连接器不会报告错误，而是进行下面的操作。<br>如果该符号被 B 或者 BL 指令引用，则该符号被设置成下一条指令的地址，该 B 或 BL 指令相当于一条 NOP 指令。<br>其他情况下此符号被设置成 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AREA Init, CODE, READONLY</span><br><span class="line">IMPORT  main</span><br><span class="line">  …</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p><strong>EXTERN</strong><br>EXTERN 伪指令与 IMPORT 伪指令的功能基本相同，但如果当前源文件中的程序实际并未使用该符号，则该符号不会加入到当前源文件的符号表中。<br>其它与 IMPORT 相同。</p><h4 id="GET-INCLUDE"><a href="#GET-INCLUDE" class="headerlink" title="GET &amp; INCLUDE"></a>GET &amp; INCLUDE</h4><p>GET（或 INCLUDE）<br>GET 伪指令用于将一个源文件包含到当前的源文件中，并将被包含的源文件在当前位置进行汇编。<br>语法格式：GET 文件名<br>可以使用 INCLUDE 代替 GET。<br>GET 伪指令只能用于包含源文件，包含目标文件则需要使用 INCBIN 伪指令。</p><h2 id="与-ARM-指令相关的宏指令"><a href="#与-ARM-指令相关的宏指令" class="headerlink" title="与 ARM 指令相关的宏指令"></a>与 ARM 指令相关的宏指令</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>MACRO 和 MEND 伪指令可以为一个程序段定义一个名称。这样，在汇编语言应用程序中，就可以通过这个名称来使用它所代表的程序段，即当程序做汇编时，该名称将被替换为其所代表的程序段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MACRO</span><br><span class="line">  $标号   宏名 $参数<span class="number">1</span>， $参数<span class="number">2</span>，…..</span><br><span class="line">  程序段（宏定义体）</span><br><span class="line">MEND</span><br></pre></td></tr></table></figure><p>$标号：为主标号，宏内的所有其它标号必须由主标号组成;<br>宏名：宏名称，为宏在程序中的引用名;<br>$参数 1，$参数2：宏中可以使用的参数。宏中的所有标号必须在前面冠以符号“$”。<br>MACRO、 MEND 伪指令可以嵌套使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">            MACRO    ;宏定义指令</span><br><span class="line">$MDATA      MAXNUM $NUM1,$NUM2 ;主标号，宏名，参数</span><br><span class="line">            语句段</span><br><span class="line">$MDATA.WAY1  ;   宏内标号，必须写为“主标号.宏内标号”</span><br><span class="line">            语句段</span><br><span class="line">$MDATA.WAY2   ;  宏内标号</span><br><span class="line">            语句段</span><br><span class="line">    MEND  ; 宏结束指令</span><br></pre></td></tr></table></figure><p>MEXIT 用于从宏定义中跳转出去</p><h3 id="宏指令"><a href="#宏指令" class="headerlink" title="宏指令"></a>宏指令</h3><p>在 ARM 中，还有一种汇编器内置的无参数和标号的宏——宏指令。<br>在汇编时，这些宏指令被替换成一条或两条真正的 ARM 或 Thumb 指令。ARM 宏指令有四条，分别是：</p><ul><li>ADR：小范围的地址读取宏指令；</li><li>ADRL：中等范围的地址读取宏指令；</li><li>LDR：大范围的地址读取宏指令；</li><li>NOP：空操作宏指令。</li></ul><p>ADR 指令用于将一个 近地址值 传递到一个寄存器中。<br>格式：<code>ADR&#123;cond&#125;  &lt;reg&gt;, &lt;expr&gt;</code><br>reg 为目标寄存器名称；<br>expr 为表达式。该表达式通常是程序中一个表示存储位置的 地址标号。<br>该宏指令的功能是把标号所表示的地址传递到目标寄存器中。<br>汇编器在汇编时，将把 ADR 宏指令替换成一条真正的 ADD 或 SUB 指令，以当前的 PC 值减去或加上 expr 与 PC 之间的偏移量得到标号的地址，并将其传递到目标寄存器。若不能用一条指令实现，则产生错误，编译失败。</p><p>中等范围的地址读取宏指令 ADRL 类似于 ADR，但可以把更远的地址赋给目标寄存器。该指令只能在 ARM 状态下使用，在 Thumb 状态下不能使用。汇编时，ADRL 宏指令由汇编器替换成两条合适的指令。<br>大范围的地址读取宏指令LDR</p><p>大范围的地址读取宏指令LDR<br>格式：<code>LDR&#123;cond&#125; reg,=&#123;expr | label - expr&#125;</code><br> reg：目标寄存器名称；<br> expr：32位常数；<br> label – expr：为地址表达式。<br>       程序经常用这条指令把一个地址传递到寄存器reg中。汇编器在对这种指令进行汇编时，会根据指令中expr的值的大小来把这条指令替换为合适的指令。<br>       与ARM指令的LDR的区别：伪指令LDR的参数有“&#x3D;”</p><!-- ## ARM 工程## ARM 程序框架## ARM 汇编语言程序设计## C/C++语言和汇编语言的混合编程 --><p>TODO…<br>Maybe never <em>(:з)∠)</em></p>]]></content>
    
    
    <summary type="html">ARM四类伪指令的概述,以及与C的混合编程</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM处理器体系结构及应用" scheme="https://efterklang.github.io/categories/UESTC/ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>ChⅣ-数据库设计与实现</title>
    <link href="https://efterklang.github.io/UESTC/DataBase/Ch4-DbDesign/"/>
    <id>https://efterklang.github.io/UESTC/DataBase/Ch4-DbDesign/</id>
    <published>2024-04-06T08:06:27.000Z</published>
    <updated>2024-05-20T13:56:23.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据集设计方案"><a href="#数据集设计方案" class="headerlink" title="数据集设计方案"></a>数据集设计方案</h2><p>包括:</p><ol><li><strong>数据库应用架构设计</strong><ul><li>在不同应用需求场景中，数据库的应用架构方式是不同的。数据库应用架构可分为<strong>单用户结构、集中式结构、C&#x2F;S 结构和分布式结构</strong></li></ul></li><li><strong>数据库结构模型设计</strong><ul><li>数据库结构模型设计一般分为概念层、逻辑层、物理层设计，它们的设计模型分别为<strong>概念数据模型 CDM、逻辑数据模型 LDM 和物理数据模型 PDM</strong></li></ul></li><li><strong>数据库应用访问方式设计</strong><ul><li>数据库应用对数据库访问可以有多种方式，如<strong>直接本地接口连接访问</strong>、<strong>基于标准接口连接访问</strong>、<strong>基于数据访问层框架连接访问</strong></li></ul></li></ol><h2 id="数据库结构模型"><a href="#数据库结构模型" class="headerlink" title="数据库结构模型"></a>数据库结构模型</h2><ul><li><strong>概念数据模型</strong>（Concept Data Model，CDM）是一种面向用户的系统数据模型，它用来描述现实世界的系统概念化数据结构。使数据库设计人员在系统设计的初始阶段，摆脱计算机系统及 DBMS 的具体技术问题，集中精力分析业务数据以及数据之间的联系等，描述系统的数据对象及其组成关系。</li><li><strong>逻辑数据模型</strong> (Logic Data Model，LDM)是在概念数据模型基础上，从系统设计角度描述系统的数据对象组成及其关联结构，并考虑这些数据对象符合数据库对象的逻辑表示。</li><li><strong>物理数据模型</strong>（Physical Data Model，PDM）是在逻辑数据模型基础上，针对具体 DBMS 所设计的数据模型。它用于描述系统数据模型在具体 DBMS 中的数据对象组织、存储方式、索引方式、访问路径等实现信息。</li></ul><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-17-30-46.png" alt="数据库开发过程"></p></center><ol><li><strong>数据需求分析阶段</strong>:从现实业务中获取数据表单、报表、查询、业务规则、数据更新的说明;分析系统的数据特征、数据类型、数据取值约束;描述系统的数据关系、数据处理要求;建立系统的数据字典</li><li><strong>数据库设计阶段</strong>:数据库内部结构设计（概念数据模型、逻辑数据模型、物理数据模型）;数据库索引、视图、查询设计;数据库表约束设计;数据库触发器、存储过程设计;文件组织方式</li><li><strong>数据库实现阶段</strong>:数据库创建;数据模型的 SQL 程序创建、数据库对象物理实现</li><li><strong>数据库测试阶段</strong>:数据库数据上线;数据库系统测试<table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>CDM</td><td>从用户角度所建模的系统数据对象及其关系，它帮助用户分析信息系统的数据结构关系</td></tr><tr><td>LDM</td><td>从系统分析员角度所建模的系统数据对象逻辑结构关系，它帮助开发人员分析信息系统的逻辑数据结构</td></tr><tr><td>PDM</td><td>从系统设计人员角度所建模的系统数据物理存储及结构关系，它针对设计者具体定义信息系统的数据库表结构</td></tr></tbody></table></li></ol><h2 id="E-R-模型方法"><a href="#E-R-模型方法" class="headerlink" title="E-R 模型方法"></a>E-R 模型方法</h2><h3 id="E-R-模型基本元素"><a href="#E-R-模型基本元素" class="headerlink" title="E-R 模型基本元素"></a>E-R 模型基本元素</h3><p><strong>E-R 模型</strong>是“实体-联系模型”（Entity-Relationship Model）的简称。它是一种描述现实世界概念数据模型、逻辑数据模型的有效方法。</p><p>在 E-R 模型中，基本元素包括实体、属性、标识符和联系:</p><ul><li><strong>实体</strong>Entity 是指问题域中存在的人、事、物、地点等客观事物在逻辑层面的数据抽象。它用于描述事物的数据对象，如客户、交易、产品、订单等</li><li><strong>属性</strong>Attribute 是指描述实体特征的数据项。每个实体都具有 1 个或多个属性</li><li><strong>标识符</strong>Identifier 是指标识不同实体实例的属性。标识符可以是 1 个或多个属性<br>标识符与主键的区别是标识符是一个逻辑概念，主键是物理概念</li><li><strong>联系</strong>Relationship 是指实体之间的联系，如“学生”与“成绩”的联系、“孩子”与“父亲”、“母亲”的联系等。<br>联系中关联的实体数目称为联系度数</li></ul><h3 id="实体-联系类型"><a href="#实体-联系类型" class="headerlink" title="实体-联系类型"></a>实体-联系类型</h3><h4 id="二元实体联系类型"><a href="#二元实体联系类型" class="headerlink" title="二元实体联系类型"></a>二元实体联系类型</h4><ul><li>一对一联系 1:1</li><li>一对多联系 1:N</li><li>多对多联系 M:N<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-17-42-55.png"></li></ul><p>上述实体之间的联系反映了一个给定实体有多少实例与另一实体实例存在的数量对应关系。术语<strong>基数</strong>Cardinality 表示实体联系的实例数量。在实体之间除了需要反映了数量对应关系，有时还需要反映实体参与关系的必要性，即<strong>可选</strong>optional 或<strong>强制</strong>mandatory</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-18-32-27.png"></p><h4 id="继承联系"><a href="#继承联系" class="headerlink" title="继承联系"></a>继承联系</h4><p>在 E-R 模型中，实体之间除了基本联系外，还存在继承联系。继承联系用于表示实体之间的相似性关系。在实体继承联系中，一端是具有公共属性的实体，称为父实体；另一端是与父实体具有相似属性，同时也具有特殊性的一个或多个实体，称为子实体。</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-18-33-31.png"></p></center><p>在继承联系中，还可以分为:</p><ul><li><strong>互斥性继承联系</strong>Mutual Exclusive Inheritance Relationship：在这种类型的继承中，子类只能从一个父类继承，不能同时从多个父类继承</li><li><strong>非互斥性继承联系</strong>Non-Mutual Exclusive Inheritance Relationship：这种类型的继承中，子类可以从多个父类继承，即一个子类可以属于多个父类</li></ul><hr><ul><li><strong>完整继承联系</strong> Total Inheritance Relationship：在这种继承中，父实体的每一个实例都必须是一个或多个子实体的实例。换句话说，父实体中的每个 instance 都必须在子实体中有对应。例如，如果我们有一个“人”实体，它有两个子实体：“学生”和“教师”，那么在完整继承关系中，每个“人”都必须是“学生”或“教师”。</li><li><strong>不完整继承联系</strong> Partial Inheritance Relationship：在这种类型的继承中，子类的 instance 可以不属于父类的任何子类；在上述的例子中，非完整继承允许存在一些“人”，他们既不是“学生”也不是“教师”。</li></ul><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-19-54-38.png"></p></center><h4 id="强弱实体联系"><a href="#强弱实体联系" class="headerlink" title="强弱实体联系"></a>强弱实体联系</h4><p>在 E-R 模型中，按照实体之间的语义关系，可以将实体分为<strong>弱实体 Weak Entity 和强实体 Strong Entity</strong>; 弱实体是指那些对于另外实体有依赖关系的实体，即一个实体的存在必须以另一实体的存在为前提。而被依赖的实体称为强实体; 例如在学校与学生之间的联系中，学生是弱实体，学校是强实体。</p><ul><li><strong>强实体</strong>Strong Entity</li><li><strong>弱实体</strong>Weak Entity<ul><li><strong>标识符依赖弱实体</strong> Identifier Dependent Weak Entity<br>如果弱实体的标识符中，包含了强实体的标识符，那么这种弱实体称为标识符依赖弱实体</li><li><strong>非标识符依赖弱实体</strong> Non-Identifier Dependent Weak Entity<br>如果弱实体的标识符中，不包含强实体的标识符，那么这种弱实体称为非标识符依赖弱实体</li></ul></li></ul><h2 id="数据库建模设计"><a href="#数据库建模设计" class="headerlink" title="数据库建模设计"></a>数据库建模设计</h2><p>概念数据模型设计是通过对现实世界中数据实体进行抽取、分类、聚集和概括等处理，建立反映系统业务数据组成结构的过程。<br><strong>步骤</strong></p><ul><li>业务数据分析，抽取数据实体</li><li>定义实体属性及其标识</li><li>建立实体联系，构建局部 E-R 模型图</li><li>分类、聚集和概括各个部分 E-R 模型图</li><li>完善全局 E-R 模型图，建立系统业务数据组成结构</li></ul><p><strong>数据模型 DM 元素对应关系表</strong></p><table><thead><tr><th>CDM</th><th>LDM</th><th>PDM</th></tr></thead><tbody><tr><td>Entity</td><td>Entity</td><td>Table</td></tr><tr><td>Attribute</td><td>Attribute</td><td>Column</td></tr><tr><td>Identifier</td><td>Primary Identifier&#x2F;Foreign Identifer</td><td>Primary Key&#x2F;Foreign Key</td></tr><tr><td>Relationship</td><td>Relationship</td><td>Reference(参照完整性约束)</td></tr></tbody></table><p><strong>1:1</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-20-16-28.png"><br><strong>1:N</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-20-17-38.png"><br><strong>M:N</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-20-38-36.png"></p><h2 id="规范化设计"><a href="#规范化设计" class="headerlink" title="规范化设计"></a>规范化设计</h2><p>为什么需要规范化数据库设计？</p><ul><li>减少数据库中的冗余数据，尽量使同一数据在数据库中仅保存一份，有效降低维护数据一致性的工作量。</li><li>设计合理的表间依赖关系和约束关系，便于实现数据完整性和一致性。</li><li>设计合理的数据库结构，便于系统对数据高效访问处理。</li></ul><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>定义：设有一关系模式<code>R(U)</code>，<code>U</code> 为关系 R 的属性集合，<code>X</code>和<code>Y</code>为属性<code>U</code>的子集。设 t，s 是关系 R 中的任意两个元组，如果 t<code>[X] = s[X]</code>，则<code>t[Y] = s[Y]</code>。那么称 Y 函数依赖于 X，表示为<code>X→Y</code>。<br>函数依赖的左部称为决定因子，右部称为依赖函数。决定因子和依赖函数都是属性的集合。</p><blockquote><p>假设我们有一个关系模式<code>R</code>，代表一个学生注册系统，其中<code>U</code>是关系<code>R</code>的属性集合，包括 <code>&#123;学生ID, 姓名, 课程ID, 课程名, 教师&#125;</code><br>任意给定两个元组<code>t</code>和<code>s</code>，例如<br>元组<code>t:&#123;学生ID: 001, 姓名: &quot;小明&quot;, 课程ID: C101, 课程名: &quot;数学&quot;, 教师: &quot;李老师&quot;&#125;</code><br>元组<code>s:&#123;学生ID: 001, 姓名: &quot;小明&quot;, 课程ID: C102, 课程名: &quot;英语&quot;, 教师: &quot;王老师&quot;&#125;</code><br>都有<code>t[学生ID] = s[学生ID] 则 t[姓名] = s[姓名]</code><br>可以得出学生 ID 决定姓名，即<code>学生ID→姓名</code></p></blockquote><p><strong>函数依赖的类型</strong>:</p><ul><li>完全函数依赖 Total Functional Dependency<br>若<code>X→Y</code>，对于<code>X</code>的任何一个真子集<code>X&#39;</code>，<code>X&#39;→Y</code>都不成立，则称<code>X→Y</code>是完全函数依赖</li><li>部分函数依赖 Partial Functional Dependency<br>若<code>X→Y</code>，<code>X</code>存在一个真子集<code>X&#39;</code>，使得<code>X&#39;→Y</code>，则称<code>X→Y</code>是部分函数依赖</li><li>属性传递依赖 Transitive Dependenc<br>若满足<code>X→Y</code>，<code>Y→Z</code>，则有<code>X→Z</code>，则称为属性传递依赖</li><li>多值函数依赖 Multivalued Dependency<br>设 U 是关系模式 R 的属性集，X 和 Y 是 U 的子集，<code>Z=U-X-Y</code>，<code>xyz</code>表示属性集 XYZ 的值。对于 R 的关系 r，在 r 中存在元组<code>（x, y1, z1）</code>和<code>（x, y2, z2）</code>时，也存在元组<code>（x, y1, z2）</code>和<code>（x, y2, z1）</code>，那么在模式 R 上存在多值函数依赖。<blockquote><p>(数据结构，李老师，《数据结构与算法-初级》)<br>(数据结构，王老师，《数据结构与算法-高级》)</p><hr><p>(数据结构，李老师，《数据结构与算法-高级》)<br>(数据结构，王老师，《数据结构与算法-初级》)</p></blockquote></li></ul><h2 id="关系规范化范式"><a href="#关系规范化范式" class="headerlink" title="关系规范化范式"></a>关系规范化范式</h2><p>关系规范化是把一个有访问异常的关系分解成结构良好的关系的过程，使得这些关系有最小的冗余或没有冗余。<br><strong>规范化范式</strong>（Normal Form，NF）是指关系表符合特定规范化程度的模式。</p><ol><li>第 1 范式（1NF）<br>如果关系表中的属性不可再细分，该关系满足第 1 范式。反之，该表就不是关系表。<blockquote><p>如果联系方式是一个关系表的属性，那么联系方式还可细分为电话号码、邮箱等属性；消除联系方式这类属性，将联系方式细分为电话号码、邮箱等属性，就满足了第 1 范式。</p></blockquote></li><li>第 2 范式（2NF）<br>如果关系满足第 1 范式，并消除了关系中的属性部分函数依赖，该关系满足第 2 范式。有一个关系<code>(A,B,N, 0,P)</code>其复合主键为<code>(A,B)</code>那么 <code>N,O,P</code> 这三个非键属性都不存在只依赖 A 或只依赖 B 情况，则该关系满足第 2 范式，反之，不满足第 2 范式。<blockquote><p>我们有一个关系模式 R，它的属性集 U 包括 {学生 ID, 课程 ID, 学生姓名, 课程名, 教师}，复合主键为(学生 ID,课程 ID)，然而学生姓名只依赖于学生 ID，课程名和教师只依赖于课程 ID，那么学生姓名和课程名、教师之间存在部分函数依赖，不满足第 2 范式。</p></blockquote></li><li>第 3 范式（3NF）<br>如果关系满足第 2 范式，并切断了关系中的属性传递函数依赖，该关系满足第 3 范式。<blockquote><p>{学号，姓名，系名，住址(宿舍地址)，电话，电子邮件}，其中学号决定系名，系名决定宿舍地址，故学号决定宿舍地址，存在传递依赖，不满足第 3 范式;可以对学生关系表再次分解为学生和系信息关系表<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DatabaseDesignAndImplementation-2024-04-06-21-44-39.png"></p></blockquote></li><li>Boyce-Codd 范式（BCNF）<br>在关系中，所有函数依赖的决定因子都是候选键，该关系满足 BCNF 范式</li><li>第 4 范式（4NF）<br>如果关系满足 BCNF 范式，并消除了多值函数依赖，该关系满足第 4 范式。</li></ol><h3 id="逆规范化处理"><a href="#逆规范化处理" class="headerlink" title="逆规范化处理"></a>逆规范化处理</h3><p>所谓逆规范化，就是适当降低规范化范式约束，不再要求一个关系表必须达到很高的规范化程度，而是允许适当的数据冗余性，以获取数据访问性能。<br>逆规范化处理的基本方法：<br>（1）增加冗余列或派生列<br>（2）多个关系表合并为一个关系表</p>]]></content>
    
    
    <summary type="html">数据库设计方案，数据库设计过程，数据库设计策略，设计模型类型，设计工具；E-R模型要素，实体联系类型，强弱实体，标识符依赖弱实体，非标识符依赖弱实体，E-R模型图；概念数据模型设计，逻辑数据模型设计，物理数据模型设计，数据模型转换方案；非规范数据库设计问题，函数依赖理论，规范化设计范式，逆规范化设计处理；数据库设计模型SQL实现；Power Designer项目实践，CDM/LDM/PDM设计，设计模型检查，数据库SQL实现。</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="数据库原理及应用" scheme="https://efterklang.github.io/categories/UESTC/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>The Dead Lock</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch3-2TheDeadLock/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch3-2TheDeadLock/</id>
    <published>2024-04-05T13:52:59.000Z</published>
    <updated>2024-06-12T09:26:00.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="产生死锁的原因和必要条件"><a href="#产生死锁的原因和必要条件" class="headerlink" title="产生死锁的原因和必要条件"></a>产生死锁的原因和必要条件</h2><h3 id="死锁相关定义"><a href="#死锁相关定义" class="headerlink" title="死锁相关定义"></a>死锁相关定义</h3><p><strong>永久（可重用）性资源</strong></p><ul><li>可抢占性资源: 是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺</li><li>不可抢占性资源: 当系统把这类资源分配给某进程后，就不能强行收回，只能在进程用完后自行释放。<strong>临时性（消耗性）资源</strong></li><li>只可使用一次的资源</li></ul><p><strong>死锁 Dead Lock</strong>：如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。</p><ul><li>死锁会造成进程无法执行</li><li>死锁会造成系统资源的极大浪费(资源没法释放)</li></ul><p><strong>产生死锁的原因</strong></p><ul><li>竞争资源</li><li>进程间推进顺序不当</li></ul><p><strong>产生死锁的必要条件</strong></p><ol><li><strong>互斥条件</strong>:进程对分配到的资源进行排它性使用</li><li><strong>请求和保持条件</strong>:进程已经保持了至少一个资源，但又提出了新的资源要求，而该资源又被其他进程占有，请求进程阻塞，但对已经获得的资源不释放</li><li><strong>不剥夺条件</strong>:进程已获得的资源在未使用完之前，不能被剥夺，只能在使用完时自己释放</li><li><strong>环路等待条件</strong>:发生死锁时，必然存在进程—资源的环形链</li></ol><h3 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h3><p>资源分配图 Resource Allocation Graph(RAG)：用来描述进程和资源之间的关系，以及资源之间的竞争关系。它是有向图，说明了系统资源、进程状态，其中每个资源、进程用节点表示，圆点表示资源的一个示例，一个资源可拥有多个实例</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-07-11-53-28.png" style="zoom:50%;" /></center><p><strong>1.竞争不可抢占性资源引起死锁</strong></p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-07-11-54-14.png" style="zoom:50%;" /></center><p><strong>2.竞争临时性资源引起进行死锁</strong><br>临时性资源，可以创造（生产）和撤消（消耗）的资源，也称之为消耗性资源，如信号量、消息、buffer 中的数据等资源<br>例如：S1、S2 和 S3 是临时性资源，是由进程 P1、P2 和 P3 产生的消息。如果消息通信处理顺序不当也会发生死锁。</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-07-15-15-18.png" style="zoom:50%;" /></center><p><strong>3. 进程推进顺序不当引起死锁</strong><br>联合进程图(Joint Progress Diagram)记录共享资源的多个进程的执行进展</p><blockquote><p>竞争资源，未必产生死锁。是否产生死锁，还取决于动态执行和应用程序细节</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P: 申请A，申请B，释放A，释放B</span><br><span class="line">Q: 申请B，申请A，释放B，释放A</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-07-16-00-03.png"></p><h2 id="预防死锁的方法"><a href="#预防死锁的方法" class="headerlink" title="预防死锁的方法"></a>预防死锁的方法</h2><ol><li><strong>预防死锁 Deadlock Prevention</strong>：设置某些限制条件，破坏四个必要条件中的一个或几个。<br>优点：容易实现<br>缺点:系统资源利用率和吞吐量降低</li><li><strong>避免死锁 Deadlock Avoidance</strong>：在资源的动态分配过程用某种方法防止系统进入不安全状态。<br>优点：较弱限制条件可获得较高系统资源利用率和吞吐量。<br>缺点：有一定实现难度。<br>死锁避免的两种方法：<ul><li>若一个进程的请求会导致死锁，则不启动进程</li><li>若一个进程增加的资源请求会导致死锁，则不允许这一资源分配</li></ul></li><li><strong>检测死锁 Deadlock Detection</strong>：预先不采取任何限制，也不检查系统是否已进入不安全区，通过设置检测机构，检测出死锁后解除。</li><li><strong>解除死锁 Unlocking deadlock</strong>：常用撤消或挂起一些进程，回收一些资源。</li></ol><blockquote><p>预防死锁和避免死锁是两种不同的概念，两者都是事先防范死锁的发生，但是方法不同。<br>预防死锁是在系统设计时就考虑到死锁的可能性，采取措施避免死锁的发生，而避免死锁是在系统运行时，根据系统的状态，采取措施避免死锁的发生。</p><p>预防死锁：破坏死锁的必要条件，施加的条件比较严格，可能会影响到进程的并发执行。<br>避免死锁：资源动态分配，施加的限制条件较弱一些，有利于进程的并发执行。</p></blockquote><h3 id="摒弃请求和保持条件"><a href="#摒弃请求和保持条件" class="headerlink" title="摒弃请求和保持条件"></a>摒弃请求和保持条件</h3><p><strong>第一种协议</strong>：系统要求所有进程一次性申请所需的全部资源，只要有一种资源要求不能满足，即使是已有的其它各资源，也全部不分配给该进程，而让其等待</p><ul><li>优点：简单、易于实现且很安全。</li><li>缺点：资源严重浪费；进程延迟运行。</li></ul><p><strong>第二种协议</strong>：允许一个进程只获得运行初期所需的资源后便开始运行。进程运行过程中再逐步释放已分配给自己的、且已使用完毕的全部资源，然后再请求新的所需资源<br>优点：使进程更快地完成任务，提高设备的利用率，减少进程发生饥饿的概率</p><h3 id="摒弃不剥夺条件"><a href="#摒弃不剥夺条件" class="headerlink" title="摒弃不剥夺条件"></a>摒弃不剥夺条件</h3><p>进程在需要资源时才提出请求，一个已经保持了某些资源的进程，再提出新的资源要求而不能立即得到满足时，必须释放已经保持的所有资源，待以后需要时再重新申请。<br>Cons:实现复杂，代价大；延长了进程的周转时间，增加系统开销，降低系统吞吐量。</p><h3 id="摒弃环路等待条件"><a href="#摒弃环路等待条件" class="headerlink" title="摒弃环路等待条件"></a>摒弃环路等待条件</h3><p>系统将所有资源按类型进行线性排队（常用-不常用），并赋予不同的序号。所有进程对资源的请求必须严格按资源序号递增的次序提出，按序号递减的次序释放</p><blockquote><p>假设我们的系统有三种资源：A、B、C，我们将它们按照使用频率进行排序，得到的序列是 A（最常用）-&gt; B -&gt; C（最不常用）。然后，我们给每种资源分配一个序号：A&#x3D;1，B&#x3D;2，C&#x3D;3。<br>在这种策略下，所有的进程必须按照资源序号递增的顺序请求资源,按照资源序号递减的顺序释放资源。</p></blockquote><h2 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h2><p><strong>安全状态</strong>:是指系统能按某种进程顺序 <code>〈P1, P2, …, Pn〉</code>，来为每个进程 Pi 分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成,则称这是一个安全序列。安全序列的实质是:序列中的每一个进程 Pi 到运行完成尚需的资源量不超过系统当前剩余的资源量与所有在它之前的进程 P1, P2, …, Pi-1 所占用的资源量之和。<br>如果系统无法找到这样一个安全序列，则称系统处于不安全状态。</p><ul><li>并非所有不安全状态都是死锁状态，但当系统进入不安全状态后，便可能有进入死锁状态。</li><li>系统处于安全状态时，不会进入死锁状态。</li></ul><p>死锁避免策略并不能确切的预测死锁，仅仅是预料死锁的可能性并确保永远不会出现这种可能性。<br>死锁避免比死锁预防限制少，但使用中也有许多限制：</p><ul><li>必须事先声明每个进程请求的最大资源。</li><li>考虑的进程必须是无关的，执行的顺序必须没有任何同步的要求。</li><li>分配的资源数目必须是固定的。</li><li>在占有资源时，进程不能退出。</li></ul><h3 id="🌟-银行家算法思想-死锁避免策略"><a href="#🌟-银行家算法思想-死锁避免策略" class="headerlink" title="🌟 银行家算法思想 死锁避免策略"></a>🌟 银行家算法思想 死锁避免策略</h3><p><a href="https://www.cnblogs.com/wkfvawl/p/11929508.html">Banker’s Alogorithm</a></p><h4 id="银行家算法的基本思想"><a href="#银行家算法的基本思想" class="headerlink" title="银行家算法的基本思想"></a>银行家算法的基本思想</h4><p>避免死锁的关键在于如何准确的预测是否会出现死锁，从而避免死锁。最有代表性的避免死锁的算法是 Dijkstra 在 1965 年提出的银行家算法。该算法可用于银行发放一笔贷款前，预测该笔贷款是否会引起银行资金周转问题。<br>银行的资金就类似于计算机系统的资源，贷款业务类似于计算机的资源分配。银行家算法能预测一笔贷款业务对银行是否是安全的，该算法也能预测一次资源分配对计算机系统是否是安全的。</p><ol><li>当前状态下，某进程申请资源；</li><li>系统假设将资源分给该进程，满足它的需求；</li><li>检查分配后的系统状态是否是安全的，如果是安全，就确认本次分配；如果系统是不安全的，就取消本次分配并阻塞该进程(这一步也被称为安全性算法)</li></ol><h4 id="银行家算法的数据结构"><a href="#银行家算法的数据结构" class="headerlink" title="银行家算法的数据结构"></a>银行家算法的数据结构</h4><p>为实现银行家算法，系统中必须设置若干数据结构</p><ol><li><p><strong>可利用资源向量 Available</strong>这是一个含有 m 个元素的数组，其中的每一个元素代表一类可利用的资源数目，其初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。如果 <code>Available[j]= K</code>，则表示系统中现有 Rj 类资源 K 个。</p></li><li><p><strong>最大需求矩阵 Max</strong>这是一个 n×m 的矩阵，它定义了系统中 n 个进程中的每一个进程对 m 类资源的最大需求。如果 <code>Max[i,j]=K</code>，则表示进程 i 需要 Rj 类资源的最大数目为 K。</p></li><li><p><strong>分配矩阵 Allocation</strong>这也是一个 n×m 的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果 <code>Allocation[i,j]</code>&#x3D;K，则表示进程 i 当前已分得 Rj 类资源的数目为 K。</p></li><li><p><strong>需求矩阵 Need</strong>这也是一个 n×m 的矩阵，用以表示每一个进程尚需的各类资源数。如果 <code>Need[i,j]=K</code>，则表示进程 i 还需要 Rj 类资源 K 个，方能完成其任务。</p><p>设 $Request_i$ 是进程 $P_i$ 的请求向量，如果 $Request_i[j] &#x3D; K$，表示进程 $P_i$ 需要 K 个 $R_j$ 类型的资源。当 Pi 发出资源请求后，系统按下述步骤进行检查：<br>(1) 如果 $Request_i[j] \leq Need[i,j]$，便转向步骤 2；否则认为出错，因为它所申请的资源数已超过它所宣布的需要的资源数。<br>(2) 如果 $Request_i[j] \leq Available[j]$，便转向步骤(3)；否则， 表示尚无足够资源，Pi 须等待。<br>(3) 系统试探着把资源分配给进程 Pi，并修改下面数据结构中的数值：<br>$Available[j]&#x3D;Available[j]-Requesti[j];$<br>$Allocation[i,j]&#x3D;Allocation[i,j]+Requesti[j];$<br>$Need[i,j]&#x3D;Need[i,j]-Requesti[j];$<br>(4) 系统执行<a href = #安全性算法>安全性算法</a>，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程 Pi，以完成本次分配；否则， 将本次的试探分配作废，恢复原来的资源分配状态，让进程 Pi 等待。</p><center> <p> <img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-08-15-42-12.png"></p></li></ol>  </center><h4 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h4><p>(1) 设置两个向量：<br><strong>工作向量 Work</strong>: 它表示系统可提供给进程继续运行所需的各类资源数目，它含有 m 个元素，在执行安全算法开始时，Work 初始化为 Available;<br><strong>Finish</strong>: 它表示系统是否有足够的资源分配给进程，使之运行完成。开始时先初始化 Finish[i]&#x3D;false; 当有足够资源分配给进程时， 再令 Finish[i]&#x3D;true。<br>(2) 从进程集合中找到一个能满足下述条件的进程：<br>$Finish[i] &#x3D; false$<br>$Need[i,j] \leq Work[j]$<br>若找到， 执行步骤(3)，否则，执行步骤(4)。<br>(3) 当进程 Pi 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：<br>$Work[j]&#x3D;Work[j]+Allocation[i,j];$<br>$Finish[i]&#x3D;true;$<br>go to step 2;<br>(4) 如果所有进程的$Finish[i]&#x3D;true$都满足， 则表示系统处于安全状态；否则，系统处于不安全状态。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-08-15-52-12.png"></p><h2 id="死锁的检测与解除"><a href="#死锁的检测与解除" class="headerlink" title="死锁的检测与解除"></a>死锁的检测与解除</h2><p>如果系统不愿意附加太多约束条件预防死锁，也不希望系统额外开销预测并避免死锁，那么，只能允许死锁出现，然后，再解除它。因此，系统需要利用某种方法来检测死锁。</p><h3 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h3><h4 id="化简资源分配图—检测死锁"><a href="#化简资源分配图—检测死锁" class="headerlink" title="化简资源分配图—检测死锁"></a>化简资源分配图—检测死锁</h4><p><strong>资源分配图(Resource Allocation Graph)</strong><br>该图是由一组结点 N 和一组边 E 所组成的一个对偶<code>G＝（N,E）</code>，其中：</p><ol><li>把 N 分为两个互斥的子集，即一组进程结点<code>P=&#123;P1,P2，…，Pn&#125;</code>和一组资源结点<code>R=&#123;R1, R2 ，…， Rn&#125;</code>，<code>N＝PUR</code></li><li>凡属于 E 中的一个边 e∈E 都连接着 P 中的一个结点和 R 中的一个结点<br><code>e=&#123;Pi,Rj&#125;</code>表示进程 Pi 请求一个单位的 Rj 资源<br><code>e=&#123;Rj,Pi&#125;</code>表示把一个单位的资源 Rj 分配给进程 Pi</li></ol><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-08-15-58-04.png"></p></center><p>Steps:<br>第一步:先看系统还剩下多少资源没分配，再看有哪些进程是不阻塞的（即系统有足够的空闲资源分配给它）<br>第二步:把不阻塞的进程的所有边都去掉，形成一个孤立的点，再把系统分配给这个进程的资源回收回来<br>第三步:重复一二步<br>第四步:最后，若所有的资源和进程都可以变成孤立的点。这样的图就叫做“可完全简化”</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2TheDeadLock-2024-04-08-18-40-23.png"></p></center>**死锁定理**：S 为死锁状态当且仅当 S 状态的资源分配图是不可完全简化的。<p><strong>死锁检测中的数据结构</strong><br>(1) 可利用资源向量 Available，它表示了 m 类资源中每一类资源的可用数目。<br>(2) 把不再占用资源的进程(即向量 Allocation 和 Request 为 0 的进程)记入 L 表中， 即<code>L = Li∪L</code><br>(3) 从进程集合中找到一个 <code>Requesti≤Work</code> 的进程，做如下处理：① 将其资源分配图简化，释放出资源，增加工作向量 $Work&#x3D;Work+Allocation_i$。 ② 将它记入 L 表中。<br>(4) 若不能把所有进程都记入 L 表中， 便表明系统状态 S 的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Work = Available;</span><br><span class="line">L = &#123;Li| Allocation_i = <span class="number">0</span> ∩ Request_i = <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; Pi not in L; i++)&#123;</span><br><span class="line">   <span class="keyword">if</span> Requesti≤Work&#123;</span><br><span class="line">      Work=Work+Allocation_i;</span><br><span class="line">      Li=Pi；</span><br><span class="line">      L=Li∪L;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">deadlock= !(L=&#123;p1, p2, …, pn&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>例题<br>p 个进程共享 m 个同类资源，每一资源在任一时刻只能供一个进程使用，每一进程对任一资源都只能使用一有限时间，使用完便立即释放，并且每个进程对该类资源的最大需求量小于该类资源的数目。设所有进程对资源的最大需要之和小于 p+m。试证：在系统中不会发生死锁。<br>证明：假设系统发生死锁。<br>设 Max(i)为进程 i 的最大资源需求量，Need(i)为进程 i 尚需资源量，Allocation(i)为已分配资源量，则系统在任意时刻有：<br>$\sum_{i&#x3D;1}^{p}Max(i) &#x3D; \sum_{i&#x3D;1}^{p} Need(i) + \sum_{i&#x3D;1}^{p}Allocation(i) \lt p+ m①$<br>系统发生死锁，则一方面说明所有 m 个资源都应该已经分配出去：$\sum_{i&#x3D;1}^{p} Allocation(i)&#x3D;m②$<br>另一方面，进程将处于无限等待状态之中。<br>由 ① ② 可以得到：$\sum_{i&#x3D;1}^{p} Need(i) \lt p③$<br>即死锁后 p 个进程还需要的资源量之和少于 p，这就意味着此刻至少有一个进程譬如 j，已经获得了所需要的全部资源数，即$Need（j）&#x3D;0$。但是系统发生死锁时，每个进程至少还需要一个资源单位，即$\sum_{i&#x3D;1}^{p} Need(i) \geq p$，与等式 ③ 矛盾。此外，既然该进程已经获得了所需要的全部资源数，那么就能完成其任务并释放占有的资源，以保证系统能进一步前进，这与前面的假定死锁矛盾。</p></blockquote><h3 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h3><p>当发现有进程死锁时，常采用的两种方法是解除死锁：</p><ol><li><strong>剥夺资源</strong>。从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态。</li><li><strong>撤消进程</strong>。最简单的撤消进程的方法，是使全部死锁进程都夭折掉；或者按照某种顺序逐个地撤消进程，直至有足够的资源可用，使死锁状态消除为止。</li></ol><p>按照解除死锁复杂度递增的顺序列出解除死锁的方法：</p><ol><li>撤消死锁进程 -该方法是目前操作系统中解除死锁的常用方法。</li><li>把死锁进程恢复到前一个检查点，重新执行每个进程。</li><li>按照某种原则逐个选择死锁进程进行撤消，直到解除系统死锁。</li><li>按照某种原则逐个剥夺进程资源，直到解除死锁。</li></ol><p>第三种和第四种方法需要选择系统付出代价最小的进程，最小代价原则：</p><ul><li>到目前为止，花费处理机的时间最少的进程；</li><li>到目前为止，产生输出最少的进程；</li><li>估计未执行部分最多的进程；</li><li>到目前为止，已获得资源量最少的进程；</li><li>优先级最低的进程。<br>为把系统从死锁状态中解脱出来，所花费的代价(最小)可表示为：<div>$R(S)_{min} = \sum_{1\lt i\lt j\lt n} min{C_{ij}}$</div></li><li>$R(S)_{min}$ 表示从死锁状态中解脱出来的最小代价。</li><li>$C_{ui}$, $C_{uj}$, $C_{uk}$, … 表示各个死锁参与者（例如线程、进程或事务）需要付出的代价。这些代价可能是不同的，因为每个参与者可能在不同的状态，需要执行的操作也可能不同。</li><li>$min{C_{ui}}$, $min{C_{uj}}$, $min{C_{uk}}$, … 表示选择每个死锁参与者需要付出的最小代价。这是因为在解决死锁时，通常会选择使得总代价最小的策略。</li></ul>]]></content>
    
    
    <summary type="html">死锁的产生原因、必要条件、预防、避免、检测与解除</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="操作系统" scheme="https://efterklang.github.io/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>The Processor Scheduling</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch3-1TheProcessorScheduling/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch3-1TheProcessorScheduling/</id>
    <published>2024-03-29T02:56:11.000Z</published>
    <updated>2024-06-12T09:26:02.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理机调度的层次-Process-Scheduling-Levels"><a href="#处理机调度的层次-Process-Scheduling-Levels" class="headerlink" title="处理机调度的层次 Process Scheduling Levels"></a>处理机调度的层次 Process Scheduling Levels</h2><h3 id="概述-Overview"><a href="#概述-Overview" class="headerlink" title="概述 Overview"></a>概述 Overview</h3><p>处理机是计算机系统中的重要资源,在<strong>多道程序环境</strong>下[<a href="Ch1-1OSIntroduction.md" title="操作系统概论">Ch1-1OSIntroduction#操作系统的发展过程</a>]，进程数目通常多于处理机的数目,系统必须按一定方法动态地把处理机分配给就绪队列中的一个进程;处理机利用率和系统性能（吞吐量、响应时间）在很大程度上取决于处理机调度</p><ul><li>WHAT：按什么原则分配 CPU 调度算法</li><li>WHEN：何时分配 CPU 调度的时机</li><li>HOW：如何分配 CPU 调度过程及进程的上下文切换</li></ul><h3 id="作业-JOB"><a href="#作业-JOB" class="headerlink" title="作业 JOB"></a>作业 JOB</h3><p>作业是用户在一次算题过程中或一次事务处理中，要求计算机系统所做的工作的集合<br>作业是一个比程序更广泛的概念，可以包含多个程序和数据，还配有一份作业说明书，系统根据作业说明书来对作业中的程序进行控制。在批处理系统中，以作业为单位从外存调入内存<br>用户为了让计算机完成某个特定任务，首先编写成源程序，然后提交给计算机通过编译或汇编、连接、装配、运行等步骤，最终由计算机输出用户所需要的运行结果。从计算机管理的角度看，上述一系列的由计算机执行的任务的集合就是作业。</p><blockquote><p>Job and task are today vague, ambiguous terms, especially task. A “job” often means a set of processes, while a “task” may mean a process, a thread, a process or thread, or, distinctly, a unit of work done by a process or thread.<br><a href="https://stackoverflow.com/questions/3073948/job-task-and-process-whats-the-difference">job, task and process, what’s the difference</a></p></blockquote><h4 id="作业步-Job-Step"><a href="#作业步-Job-Step" class="headerlink" title="作业步 Job Step"></a>作业步 Job Step</h4><p>计算机完成作业是通过执行一系列有序的工作步骤进行的，每个步骤完成作业的一部分特定工作;把计算机系统完成一个作业所需的一系列有序的相对独立的工作步骤称为<strong>作业步</strong><br>作业的各个作业步虽然功能相对独立，但它们之间相互关联，往往是一个作业步的执行需要使用上一个作业步的执行结果。</p><blockquote><p>从用户把源程序提交给计算机系统到得出运算结果要经过若干个工作步骤，首先计算机系统要对用户的源程序进行编辑工作来进行语法检查，再由编译或汇编工作生成目标代码。由连接工作形成装入模块，然后通过装入工作将装入模块装入内存。最后由运行工作得出运行结果。5 个步骤，每步都完成一项相对独立的工作</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-29-15-12-12.png"></p></blockquote><h4 id="作业状态转换-Job-State-Transition"><a href="#作业状态转换-Job-State-Transition" class="headerlink" title="作业状态转换 Job State Transition"></a>作业状态转换 Job State Transition</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-29-15-26-26.png" alt="Ch3-1TheProcessorScheduling-2024-03-29-15-26-26"></p><h4 id="JCB"><a href="#JCB" class="headerlink" title="JCB"></a>JCB</h4><p>作业提交给系统进入后备状态后，系统将为每个作业建立一个作业控制块 JCB。<br>JCB 在作业的整个运行过程中始终存在，并且其内容与作业的状态同步地动态变化。只有当作业完成并退出系统时，JCB 才被撤消。可以说，<strong>JCB 是一个作业在系统中存在的唯一标志</strong>，系统根据 JCB 才感知到作业的存在<br>作业控制块 JCB 中包含了对作业进行管理的必要信息，JCB 中的信息一部分是从用户提供的作业控制卡或作业说明书中得到，另一部分是记录作业运行过程中的动态信息<br>JCB 的具体内容因系统不同而异</p><table><thead><tr><th><strong>作业名</strong></th><th></th></tr></thead><tbody><tr><td>资源要求</td><td>预估的运行时间 最迟完成时间 要求的内存量 要求外设类型、台数 要求的文件量和输出量</td></tr><tr><td>资源使用情况</td><td>进入系统时间 开始运行时间 已运行时间 内存地址 外设台号</td></tr><tr><td>类型级别</td><td>控制方式 作业类型 优先级</td></tr><tr><td>状态</td><td></td></tr><tr><td>用户账户……</td><td></td></tr></tbody></table><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ul><li>在多道程序系统中，一个作业从提交到执行，通常都要经历多级调度,如高级调度、低级调度、中级调度以及 I&#x2F;O 调度等</li><li>系统的运行性能在很大程度上取决于调度,如吞吐量的大小、周转时间的长短、响应的及时性等</li><li>调度是多道系统的关键</li></ul><table><thead><tr><th align="center">类型</th><th align="center">运行频率</th><th align="center">运行时间</th><th align="center">算法复杂性</th><th>存储</th><th>OS</th></tr></thead><tbody><tr><td align="center">进程调度</td><td align="center">高</td><td align="center">短</td><td align="center">低</td><td>内存中</td><td>批处理,实时,分时</td></tr><tr><td align="center">中程调度</td><td align="center">中</td><td align="center">较短</td><td align="center">中</td><td>内外存互换</td><td>批处理,实时,分时</td></tr><tr><td align="center">作业调度</td><td align="center">低</td><td align="center">长</td><td align="center">高</td><td>外存到内存</td><td>批处理</td></tr></tbody></table><p>引起进程调度的事件：</p><ol><li>正在执行的进程正常终止或异常终止</li><li>正在执行的进程因某事件而阻塞(如提出 IO 请求后阻塞,调用<code>wait()</code>后阻塞,在进程通信或同步过程中执行了某种原语操作，如 P、V 操作原语，Block 原语， Wakeup 原语等后阻塞)</li><li>在引入时间片的系统中，时间片用完，进程被抢占</li><li>在抢占式系统中，就绪队列中的某进程优先级高于当前进程,或有更高优先级的进程进入就绪队列</li></ol><h4 id="高级调度-High-Scheduling"><a href="#高级调度-High-Scheduling" class="headerlink" title="高级调度 High Scheduling"></a>高级调度 High Scheduling</h4><p><strong>高级调度 High Scheduling</strong>：又称<strong>作业调度、准入调度、长程调度或接纳调度</strong>，其主要功能是根据某种算法，把外存上处于后备队列中的那些作业调入内存;它发生在一批作业完成，重新调入一批作业到内存的时候，执行频率低。批处理系统需要有作业调度，<strong>分时和实时系统无需此调度</strong>。主要用于批处理系统。其设计目标是最大限度地发挥各种资源的利用率和保持系统内各种活动的充分并行;</p><blockquote><p>例：对资源需求不同的作业进行合理搭配<br>科学计算往往需要占用大量的 CPU 时间，属于 CPU 繁忙型作业，对于 I&#x2F;O 设备的使用少；<br>数据处理要求占用较少的 CPU 时间，但要求大量 I&#x2F;O 时间，属于 I&#x2F;O 繁忙型作业；<br>有些递归计算，产生大量中间结果，需要很多内存单元存放它们，这属于内存繁忙型作业。<br>如果能把它们搭配在一起，程序 A 在使用处理机，程序 B 在利用通道 l，而程序 C 恰好利用通道 2 等，这样一来，A、B 和 C 从来不在同一时间使用同一资源，每个程序就好像单独在一个机器上运行</p></blockquote><p>在每次执行作业调度时，都须做出以下两个决定：</p><ol><li>接纳多少个作业（取决于多道程序度）<ul><li>作业太多 服务质量下降</li><li>作业太少 资源利用率低</li></ul></li><li>接纳哪些作业 （取决于采用的调度算法）</li></ol><h5 id="调度评价指标"><a href="#调度评价指标" class="headerlink" title="调度评价指标"></a>调度评价指标</h5><blockquote><p>多道程序度 Degree Of Multiprogramming：即允许多少个作业同时在内存中运行。<br>周转时间 Turnaround Time：指从作业被提交给系统开始，到作业完成为止的这段时间间隔,也称为作业周转时间<br>带权周转时间 Weighted Turnaround Time：作业的周转时间 T 与系统为它提供服务的时间 TS 之比,称为带权周转世界,$WTT&#x3D;\frac{T_{周转时间}}{T_{预计运行时间}}$<br>吞吐量 Throughput：是指在单位时间内系统所完成的作业数<br>服务时间 Service Time：作业的预计运行时间<br>响应比 Response Ratio：$RR&#x3D;\frac{T_{等待时间} + T_{预计运行时间}}{T_{预计运行时间}}&#x3D;\frac{T_{响应时间}}{T_{预计运行时间}}$,注意 <code>RR&gt;=1</code></p></blockquote><h4 id="低级调度-Low-Scheduling"><a href="#低级调度-Low-Scheduling" class="headerlink" title="低级调度 Low Scheduling"></a>低级调度 Low Scheduling</h4><p><strong>低级调度又称为进程调度或短程调度</strong>，它所调度的对象是进程。三种类型 OS 都必须配置这级调度(最基本调度);低级调度用于决定就绪队列中的哪个进程应获得处理机，然后由<strong>分派进程 Dispatcher</strong>执行把分配处理机给相应进程的具体操作。其时间尺度通常是毫秒级的,且是系统中最频繁的调度,要求在实现时做到高效</p><p><strong>低级调度基本机制</strong></p><ol><li><strong>排队器</strong>为了提高进程调度的效率，应事先将系统中所有的就绪进程按照一定的方式排成一个或多个队列。</li><li><strong>分派器(调度程序)</strong> 分派器把由进程调度程序所选定的进程从就绪队列中取出，然后进行上下文切换，将处理机分配给它。</li><li><strong>上下文切换机制</strong>当对处理机进行切换时，会发生两对上下文切换操作。</li></ol><p><strong>低级调度功能</strong></p><ol><li>按某种算法选取进程（调度）。</li><li>保存处理机的现场信息（上下文切换第一步骤）</li><li>恢复新进程的 CPU 现场,从而把处理器分配给新进程（上下文切换第二步骤）。</li></ol><p><strong>进程调度方式</strong></p><p><strong>非抢占方式 Non-preemptive Mode</strong>：进程占用处理机直至自愿放弃或发生某事件被阻塞时，在把处理机分配给其他进程。</p><p>进程正在处理机上执行时，新就绪的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻塞状态时，才转让处理机。</p><p>优点：算法简单，系统开销小<br>缺点：紧急任务不能及时响应；短进程到达要等待长进程运行结束</p><p><strong>抢占方式 Preemptive Mode</strong>：允许暂停某个正在执行的进程，将处理机重新分配给另一个进程。</p><p>进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程</p><p>优点：可以防止一个长进程长时间占用处理机，能为大多数进程提供更公平的服务，特别是能满足对响应时间有着较严格要求的实时任务的需求。<br>缺点：抢占方式比非抢占方式调度所需付出的开销较大，且调度算法复杂。</p><p>抢占方式 Preemptive Mode</p><ul><li>时间片原则:适用于分时、大多数实时以及要求较高的批处理系统</li><li>优先权原则:重要紧急作业优先权高</li><li>短作业(进程)优先原则。</li></ul><h4 id="中级调度-Intermediate-Level-Scheduling"><a href="#中级调度-Intermediate-Level-Scheduling" class="headerlink" title="中级调度 Intermediate-Level Scheduling"></a>中级调度 Intermediate-Level Scheduling</h4><p>中级调度 Intermediate-Level Scheduling,又称中程调度(Medium-Term Scheduling);<br>主要目的：为了提高内存利用率和系统吞吐量。<br>具体实现：</p><ul><li>使那些暂时不能运行的进程不再占用宝贵的内存资源，而将其调至外存的交换区(swap space)去等待，把此时的进程状态称为就绪驻外存状态或挂起状态。</li><li>当这些进程重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把外存上的那些又具备运行条件的就绪进程，重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。</li></ul><h2 id="调度队列模型和调度准则"><a href="#调度队列模型和调度准则" class="headerlink" title="调度队列模型和调度准则"></a>调度队列模型和调度准则</h2><h3 id="调度模型-Scheduling-Model"><a href="#调度模型-Scheduling-Model" class="headerlink" title="调度模型 Scheduling Model"></a>调度模型 Scheduling Model</h3><p>三级调度都涉及进程的队列。可以形成以下三种调度队列模型</p><ul><li>仅有进程调度(低级调度)</li><li>具有高级和低级调度</li><li>具有三级调度</li></ul><h4 id="仅有进程调度"><a href="#仅有进程调度" class="headerlink" title="仅有进程调度"></a>仅有进程调度</h4><p>在分时系统中，通常仅设有进程调度,系统把这些进程组织成一个就绪队列,每个进程在执行时，可能有以下几种情况</p><ul><li>进程获得 CPU 正在执行；</li><li>任务在给定时间片内已完成，释放处理机后为完成状态；</li><li>任务在时间片内未完成，进入就绪队列末尾；</li><li>在执行期间因某事件而阻塞。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-31-18-02-37.png" alt="仅有进程调度的调度队列模型(分时系统)"><blockquote><p>就绪队列时间片轮转，常采用 FCFS(FIFO)算法， FCFS(FIFO)队列。<br>进程执行时三种情况：完成、时间片到、阻塞</p></blockquote></li></ul><h4 id="具有高级和低级调度"><a href="#具有高级和低级调度" class="headerlink" title="具有高级和低级调度"></a>具有高级和低级调度</h4><p>在批处理系统中，不仅需要进程调度，而且还要有作业调度<br>就绪队列的形式:在批处理系统中，常用高优先权队列。进程进入就绪队列时，按优先权高低插入相应位置，调度程序总是把处理机分配给就绪队列首进程<br>设置多个阻塞队列:根据事件的不同设置多个队列提高效率<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-31-18-04-45.png" alt="具有高级和低级调度的调度队列模型"></p><blockquote><p>常采用高优先权优先调度算法<br>可采用优先队列，进程来时按优先权插队，从队首调度 （效率高）<br>可采用无序列表，每次调度时，先比较优先权<br>多个阻塞队列</p></blockquote><h4 id="同时具有三级调度的调度队列模型"><a href="#同时具有三级调度的调度队列模型" class="headerlink" title="同时具有三级调度的调度队列模型"></a>同时具有三级调度的调度队列模型</h4><p>在 OS 中引入中级调度后，进程的就绪状态分为内存就绪(表示进程在内存中就绪)和外存就绪(进程在外存中就绪)。同样，阻塞状态进一步分成内存阻塞和外存阻塞两种状态。<br>在调出操作的作用下，可使进程状态由内存就绪转为外存就绪，由内存阻塞转为外存阻塞；<br>在中级调度的作用下，又可使外存就绪转为内存就绪。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-31-18-11-01.png" alt="同时具有三级调度的调度队列模型"></p><h3 id="选择调度方式和调度算法的若干准则"><a href="#选择调度方式和调度算法的若干准则" class="headerlink" title="选择调度方式和调度算法的若干准则"></a>选择调度方式和调度算法的若干准则</h3><p>在不同的系统中通常采用不同的调度方式和算法。</p><p><strong>调度的目标</strong></p><ul><li>提高处理机的利用率</li><li>提高系统吞吐量</li><li>尽量减少进程的响应时间</li><li>防止进程长期得不到运行</li></ul><h4 id="系统选择调度方式和算法的准则"><a href="#系统选择调度方式和算法的准则" class="headerlink" title="系统选择调度方式和算法的准则"></a>系统选择调度方式和算法的准则</h4><p><a href="#调度评价指标">调度评价指标术语</a></p><ol><li>面向用户的准则<ul><li><strong>周转时间短</strong>:用来评价批处理系统的性能、选择作业调度方式与算法的重要准则之一<ul><li>作业在外存后备队列上等待调度的时间。</li><li>进程在就绪队列等待调度的时间。</li><li>进程在 CPU 上的执行时间。</li><li>等待 I&#x2F;O 操作完成的时间。</li></ul></li><li><strong>响应时间快</strong>:用来评价分时系统的性能、选择进程调度算法的重要准则之一<br>这里的响应时间，是指从用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间。<ul><li>从键盘输入的请求信息传送到处理机的时间。</li><li>处理机对请求信息进行处理的时间。</li><li>将所形成的响应回送到终端显示器的时间。</li></ul></li><li><strong>截止时间的保证</strong>:用来评价实时系统的性能、选择实时调度算法的重要准则之一<br>截止时间，是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。（也叫做时限，即 deadline）<ul><li>开始截止时间。</li><li>终止&#x2F;完成截止时间。</li></ul></li><li><strong>优先权准则</strong>:适合批处理、分时和实时系统<ul><li>让某些紧急的作业能得到及时处理。</li><li>往往还需选择抢占式调度方式，才能保证紧急作业得到及时处理。</li></ul></li></ul></li><li>面向系统的准则<ul><li><strong>系统吞吐量高</strong>:评价批处理系统<ul><li>吞吐量是指在单位时间内，系统所完成的作业数</li><li>与批处理作业的平均长度有关</li></ul></li><li><strong>处理机利用率高</strong>。主要对大、中型多用户系统，对单用户或实时系统不重要。<br>$CPU利用率 &#x3D; \frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$</li><li><strong>各类资源的平衡利用</strong>:如内存、外存、I&#x2F;O 设备等;主要对大、中型系统，对微型机或实时系统不重要。</li></ul></li></ol><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p><strong>进程切换</strong>:当一个进程占用处理机执行完(或不能继续执行)，则切换另一个进程占用处理机执行，称为进程切换。<br><strong>进程调度</strong>:把处理机分配给不同的进程占用执行，称为进程调度。实现分配处理机的程序称为<strong>调度程序</strong><br>在进程切换时，要保护执行现场。执行现场称为进程的<strong>上下文 context</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-01-14-10-26.png" alt="Process Switch"></p><p><strong>进程切换基本步骤</strong></p><ol><li>保存当前进程的上下文</li><li>更新当前运行进程的 PCB，将其状态改为就绪 Ready 或阻塞 Blocked</li><li>将 PCB 插入就绪队列或阻塞队列</li><li>改变需要投入运行的进程的 PCB，将其状态改为运行 Running</li><li>恢复新进程的上下文</li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-01-20-52-59.png"></p><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><p><strong>先到先服务调度算法</strong>(FCFS，First Come First Served) 按照作业&#x2F;进程进入系统的<strong>先后次序</strong>进行调度，先进入系统者先调度；适合于作业调度和进程调度;用于批处理系统，不适于分时系统</p><ul><li>优点：<ul><li>有利于长作业（进程）</li><li>有利于 CPU 繁忙型作业（进程）</li></ul></li><li>缺点：<ul><li>不利用短作业（进程），特别是来的较晚的短作业（进程）。</li><li>不利于 I&#x2F;O 繁忙型作业（进程）</li></ul></li></ul><h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p><strong>短作业优先的调度算法</strong>(SJF，Shortest Job First) 以要求运行时间长短进行调度，即启动要求运行时间最短的作业;可以分别用于作业调度和进程调度</p><ul><li>短作业优先(SJF)的调度算法，是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行；</li><li>短进程优先(SPF)调度算法，则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。</li><li>优点<ul><li>能有效降低作业&#x2F;进程的平均等待时间</li><li>提高系统的吞吐量。</li></ul></li><li>缺点<ul><li>该算法对长作业不利，更严重的是可能将导致长作业(进程)长期不被调度</li><li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li><li>由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度</li><li>无法实现人机交互</li></ul></li></ul><h3 id="SRT"><a href="#SRT" class="headerlink" title="SRT"></a>SRT</h3><p><strong>最短剩余时间优先调度算法</strong>(SRT,Shortest Remaining Time) 调度时选择预期剩余时间最短的进程。当一个新进程加入到就绪队列时，它可能比当前运行的进程具有更短的剩余时间。因此，只要新进程就绪，调度器可能抢占当前正在运行的进程。可能存在长进程被饿死的危险。</p><h3 id="PSA"><a href="#PSA" class="headerlink" title="PSA"></a>PSA</h3><p><strong>优先权调度算法</strong>(PSA,Priority) 适合于作业调度和进程调度</p><ul><li><strong>优先权类型</strong><ul><li><strong>静态优先权</strong>:静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。优点是简单易行、系统开销小。缺点：不够精确，可能出现优先权低的作业或进程长期得不到调度的情况。</li><li><strong>动态优先权</strong>:动态优先权随进程的推进或随其等待时间的增加而改变，以获得更好的调度性能</li></ul></li><li><strong>确定进程优先权的依据有</strong><ul><li>进程类型: 系统进程高，一般用户进程低。</li><li>进程对资源的需求:进程的估计执行时间、内存需求量等。要求少的进程赋予较高的优先权。</li><li>用户要求:紧迫程度、所付费用。</li></ul></li><li><strong>非抢占式优先权算法</strong>（用于批处理、要求不严的实时 OS）系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。</li><li><strong>抢占式优先权调度算法</strong>（用于要求严格的实时、性能要求较高的批处理和分时 OS）系统把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。这种抢占式的优先权调度算法，能更好地满足<strong>紧迫作业</strong>的要求<br><strong>Note: 只要新的进程到达并加入到就绪队列中，就进行优先权比较</strong><ul><li><strong>高响应比优先调度算法</strong>(HRRN,High Response Ratio Next),优先权的变化规律可描述为：$优先权 &#x3D; \frac{等待时间+预计运行时间}{预计运行时间}$ 由于等待时间与预计运行时间之和，就是系统对该作业的响应时间，故该优先权又相当于响应比 RP。据此，又可表示为$R_p &#x3D; \frac{等待时间+预计运行时间}{预计运行时间} &#x3D; \frac{响应时间}{预计运行时间}$<blockquote><p>HRRN 是介于 FCFS 和 SJ(P)F 之间的一种折中算法,HRRN 调度算法的优点是能够较好地平衡服务时间短和等待时间长的进程，避免了“饥饿”现象。由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于 SJ(P)F 算法，从而采用 HRRN 方式时其吞吐量将小于采用 SJF 算法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。</p></blockquote></li></ul></li></ul><h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round-Robin"></a>Round-Robin</h3><p><strong>时间片轮转调度算法</strong>(RR，Round-Robin):时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法,适合于进程调度。</p><ul><li><strong>基本原理</strong><br>系统将所有就绪进程按 FCFS 原则，排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个<strong>时间片</strong>(Time Slice)。当时间片用完时，由一个计时器发出时钟中断请求，调度程序便根据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-02-21-04-08.png"></li><li><strong>Time Slice 大小确定</strong><br>需考虑系统对响应时间的要求,就绪队列中进程的数量,系统的处理能力(保证用户键入的命令能在一个时间片内处理完毕)<ul><li>时间片太短，会增加进程切换的开销，降低系统吞吐量</li><li>时间片太长，退化成 FCFS</li></ul></li><li><strong>优缺点</strong><br>时间片的大小对计算机性能的影响。<br>存在的问题：未有效利用系统资源。<br>对于短的、计算密集型任务(CPU-bound)比较有利，因为该进程充分利用时间片，而 I&#x2F;O 密集型(I&#x2F;O-bound)任务却不利(虽然进程大部分时间都在等待 I&#x2F;O，它仍然会被分配到 CPU 时间片。这可能导致 CPU 资源的浪费)<br>常用于分时系统及事务处理系统。</li></ul><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p><strong>多级队列调度算法</strong> (MQ,Multilevel Queue):就绪队列被分解为多个独立的队列，每个队列具有自己的调度算法。前台的就绪队列是交互性作业(Interactive Job)的进程，采用时间片轮转。后台的就绪队列是批处理作业(Batch Job)的进程，采用优先权或短作业优先算法。<br>调度方式有两种：① 优先调度前台，若前台无可运行进程，才调度后台 ② 分配占用 CPU 的时间比例，如：前台 80%，后台 20%</p><blockquote><p>什么是交互性作业(Interactive Job)和批处理作业(Batch Job)？<br>Interact Job: 与用户交互的作业,在执行这类作业时，用户可以输入命令，系统立即响应并返回结果;例如 UNIX shell 的<code>ls</code><br>Batch Job:批处理作业是在没有用户交互的情况下自动执行的一组命令或程序;些作业通常被组织成批次，一次性提交给系统，然后按照预定的顺序或优先级执行</p></blockquote><h3 id="MFQ"><a href="#MFQ" class="headerlink" title="MFQ"></a>MFQ</h3><p><strong>多级反馈队列调度算法</strong>(MFQ，Multilevel Feedback Queue):最通用的调度算法，多数 OS 都使用该方法或其变形，如 UNIX、Windows 等。它可以看作是更成熟的多级队列调度,其任务可以在队列之间移动,从而更细致的区分任务</p><blockquote><p>Note:MFQ 均为为抢占式;高优先级队列中有进程进入时，会抢占低优先级队列中进程的 CPU。被抢占的进程不降级，回到原级队列中，下次仍然执行该级队列的时间片。</p></blockquote><p><strong>MFQ 调度算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-02-21-45-44.png"></p><ul><li>设置多个就绪队列,记作 RQ0，RQ1 … RQn，并为各个队列赋予不同的优先级队列。 第一个队列的优先级最高，第二个次之，其余各队列的优先级逐个降低。规定高优先级队列时间片小</li><li>一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统；进程一次时间片没执行完，就降至下一级队列，以此类推，降至最低优先级队列后，一直在此队列中不再下降。</li><li>系统优先调度高优先级队列中的进程，仅当 RQ0 空闲时才调度 RQ1 队列进程，以此类推</li></ul><p><strong>MFQ 性能</strong></p><ul><li>对于终端型作业用户，其所提交的作业大都属于较小的交互型作业，系统只要使这些作业在箫 1 队列规定的时间片内完成，终端型作业用户就会感到满足。</li><li>对于短批处理作业用户，如果其作业在第 1 队列中执行一个时间片即可完成，便可获得与终端作业一样的响应时间。对于稍长批处理作业用户，其作业通常只须在第 2 队列和第 3 队列各执行 1 个时间片即可完成，周转时间仍然较短。</li><li>对于长批处理作业用户，其将依次在第 1,2…n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。因此，多级反馈队列调度算法能满足多用户需求。</li></ul><h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><ol><li><p>保证调度算法<br>保证的是绝对运行时间，即启动后在某个时间段内必须获得多少运行时间。<br>例如 N 个进程平均分配时间。</p></li><li><p>公平分享调度算法<br>按照用户数量平均分配时间，而不是进程间平均分配。</p></li></ol><blockquote><p>例：公平分享调度算法<br>用户 1 有 4 个进程 ABCD<br>用户 2 有 1 个进程 E</p><ol><li>时间片轮转法:<code>ABCDEABCDEABCDEABCDE……</code></li><li>所有用户获得相同的处理机时间:<code>AEBECEDEAEBECEDEAEBECEDE……</code></li><li>用户 1 获得的处理机时间是用户 2 的两倍:<code>ABECDEABECDEABECDEABECDE……</code></li></ol></blockquote><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>实时任务</strong>：任务的结束时间有严格约束(Deadline),即任务执行必须在 Deadline 之前完成;具有紧迫性。<br>前述算法不能很好地满足实时系统对调度的特殊要求，所以引入实时调度。<br><strong>实时操作系统 RTOS Real-Time Operating System</strong> 对外部输入的信息，实时操作系统能够在规定的时间内处理完毕并做出反应正确性:不仅要求计算逻辑的正确，而且要求在规定的时间内得到该结果通常给定一个开始时间或者结束时间的最后期限;多用于工业、军事等控制领域或实时信息处理方面<br><strong>硬实时系统</strong>有一个刚性的、不可改变的时间限制，它不允许任何超出时限的错误。超时错误会带来损害甚至导致系统失败、或者导致系统不能实现它的预期目标<br><strong>软实时系统</strong>的时限是柔性灵活的，它可以容忍偶然的超时错误。失败后造成的后果并不严重，例如在网络中仅仅轻微地降低了系统的吞吐量<br><strong>硬实时 HRT 与软实时 SRT</strong>之间最关键的差别在于：软实时只能提供统计意义上的实时。例如，有的应用要求系统在 95%的情况下都会确保在规定的时间内完成某个动作，而不一定要求 100%<br><strong>优先级倒置</strong>: 即高优先级进程(或线程)被低优先级进程(或线程)延迟或阻塞。</p><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ol><li>提供必要的调度信息</li></ol><ul><li>任务的到达时间,开始截止时间,执行时间,完成截止时间</li><li>资源要求</li><li>优先级(若错过开始截止时间则赋予“绝对”优先级)</li></ul><ol start="2"><li>系统处理能力强<br>若处理机的处理能力不够强，则有可能因处理机忙不过来而使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。<br>假定系统中有 m 个周期性的硬实时任务，它们的处理时间可表示为 Ci ，周期时间表示为 Pi，则在单处理机情况下，必须满足$\sum_{i&#x3D;1}^{m} \frac{C_i}{P_i} \leq 1$;若为多处理机系统,假设有 n 个处理机，则需满足$\sum_{i&#x3D;1}^{m} \frac{C_i}{P_i} \leq n$</li><li>采用抢占式调度机制:调度程序先调度开始截止时间即将到达的任务。</li><li>具有快速切换机制</li></ol><ul><li>具有快速响应外部中断的能力:及时响应紧迫的外部事件的中断请求</li><li>快速的任务分派能力:使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。</li></ul><h3 id="实时调度算法分类"><a href="#实时调度算法分类" class="headerlink" title="实时调度算法分类"></a>实时调度算法分类</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-05-20-46-52.png"></p><p><strong>非抢占式调度算法</strong></p><ol><li>非抢占式轮转调度算法（如工业生产群控系统）<br>调度程序每次选择队列中的第一个任务投入运行。该任务完成后，便把它挂在轮转队列的末尾，等待下次调度运行，而调度程序再选择下一个(队首)任务运行。<br>常用于要求不太严格的实时控制系统。</li><li>非抢占优先权调度算法<br>如果在实时系统中存在着要求较为严格(响应时间为数百毫秒)的任务，则可采用非抢占式优先调度算法为这些任务赋予较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后才能被调度执行。常用于有一定要求的实时控制系统。</li></ol><p><strong>抢占式调度算法</strong></p><ol><li>基于时钟中断的抢占式优先权调度算法</li><li>立即抢占(Immediate Preemption)的优先权调度算法</li></ol><h3 id="常见的实时调度算法"><a href="#常见的实时调度算法" class="headerlink" title="常见的实时调度算法"></a>常见的实时调度算法</h3><h4 id="最早截止时间优先即-EDF-Earliest-Deadline-First-算法"><a href="#最早截止时间优先即-EDF-Earliest-Deadline-First-算法" class="headerlink" title="最早截止时间优先即 EDF(Earliest Deadline First) 算法"></a>最早截止时间优先即 EDF(Earliest Deadline First) 算法</h4><p>优先级确定：根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。<br>实时任务就绪队列：按各任务截止时间的早晚排序；具有最早截止时间的任务排在队列的最前面。<br>调度顺序：总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。<br>适用范围：既可用于抢占式调度，也可用于非抢占式调度方式中。</p><h4 id="最低松弛度优先即-LLF-Least-Laxity-First-算法"><a href="#最低松弛度优先即-LLF-Least-Laxity-First-算法" class="headerlink" title="最低松弛度优先即 LLF(Least Laxity First)算法"></a>最低松弛度优先即 LLF(Least Laxity First)算法</h4><p>$Laxity &#x3D; Deadline - RemainingServiceTime - CurrentTime$<br>松弛度&#x3D;完成截止时间–剩余运行时间–当前时间 (假设从现在执行任务, 完成的时间为 t1, 则松弛度为截止时间-t1)</p><p>该算法按松弛度排序实时任务的就绪队列，松弛度值最小的任务排在队列最前面，调度程序总是选择就绪队列中的队首任务执行。<br>该算法主要用于可抢占调度方式中。</p><p><strong>抢占方式和时机</strong></p><ul><li>当等待任务的松弛度值为 0 时才进行抢占</li><li>当有任务执行时，只有等待任务的松弛度值为 0 才会发生任务的调度，其他情况不发生调度。</li><li>任务执行结束后或无任务执行时，再比较等待任务的松弛度值，较小的先执行。</li></ul>]]></content>
    
    
    <summary type="html">介绍处理机调度的层次 调度队列模型和调度准则调度算法 实时调度</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="操作系统" scheme="https://efterklang.github.io/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>ChⅢ-数据库操作SQL语言</title>
    <link href="https://efterklang.github.io/UESTC/DataBase/Ch3-DbSQL/"/>
    <id>https://efterklang.github.io/UESTC/DataBase/Ch3-DbSQL/</id>
    <published>2024-03-27T08:26:37.000Z</published>
    <updated>2024-05-20T13:02:46.452Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h2><ul><li>数据定义语言（DDL）：创建修改删除数据库对象；create&#x2F;drop&#x2F;alter database&#x2F;table&#x2F;index</li><li>数据操纵语言（DML）：增删改数据；insert&#x2F;update&#x2F;delete</li><li>数据查询语言（DQL）：数据查询；</li><li>数据控制语言（DCL）：数据库对象访问控制；grant&#x2F;deny&#x2F;revoke</li><li>事物处理语言（TPL）：事物处理；begin transaction&#x2F;commit&#x2F;rollback</li><li>游标控制语言（CCL）：游标操作；declare cursor&#x2F;fetch into&#x2F;close curso</li></ul><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>数据定义语言（Data Definition Language，DDL）是 SQL 语言中用于创建、修改或删除数据库对象的语句。</p><h4 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- database</span></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE db_name;</span><br><span class="line"><span class="keyword">ALTER</span> DATABASE db_name RENAME <span class="keyword">TO</span> new_db_name;</span><br><span class="line"><span class="keyword">DROP</span> DATABASE db_name;</span><br></pre></td></tr></table></figure><h4 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    Sname <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Age <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    Sid <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">完整性约束包括：</span></span><br><span class="line"><span class="string">PRIMARY KEY 主键</span></span><br><span class="line"><span class="string">NOT NULL 非空</span></span><br><span class="line"><span class="string">NULL 空值</span></span><br><span class="line"><span class="string">UNIQUE 值唯一</span></span><br><span class="line"><span class="string">CHECK 有效性检查</span></span><br><span class="line"><span class="string">DEFAULT 缺省</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;假定创建一个表，City字段只能取值上海、北京，age 默认为 10&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEST(</span><br><span class="line">    City <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">CHECK</span>(City <span class="keyword">IN</span>(<span class="string">&#x27;上海&#x27;</span>,<span class="string">&#x27;北京&#x27;</span>)),</span><br><span class="line">    Age <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">10</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ADD</span> <span class="operator">&lt;</span>新列名称<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span><span class="operator">|</span>[完整性约束]</span><br><span class="line"> <span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span>  <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span>；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span><span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">DROP</span>  <span class="keyword">CONSTRAINT</span><span class="operator">&lt;</span>完整性约束名<span class="operator">&gt;</span>；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> RENAME <span class="keyword">TO</span> <span class="operator">&lt;</span>新表名<span class="operator">&gt;</span>；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> RENAME <span class="operator">&lt;</span>原列名<span class="operator">&gt;</span> <span class="keyword">TO</span> <span class="operator">&lt;</span>新列名<span class="operator">&gt;</span>；</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">ALTER</span>  <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> TYPE<span class="operator">&lt;</span>新的数据类型<span class="operator">&gt;</span>；</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h4 id="Primary-Foreign-Key-Constraint"><a href="#Primary-Foreign-Key-Constraint" class="headerlink" title="Primary&#x2F;Foreign Key Constraint"></a>Primary&#x2F;Foreign Key Constraint</h4><p><strong>Primary Key Constraint syntax</strong></p><ul><li>定义单列主键<br><code>Age int PRIMARY KEY</code></li><li>定义多列主键<br><code>CONSTRAINT &lt;constraint_name&gt; PRIMARY KEY &lt;col1,col2...&gt;</code></li><li>定义代理键时，注意主键应为 serial 类型</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEST(</span><br><span class="line">    City <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Age <span class="type">int</span> <span class="keyword">PRIMARY</span> KEY</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEST(</span><br><span class="line">    Name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    Age <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> PK_TEST <span class="keyword">PRIMARY</span> KEY(Name,Age)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TEST(</span><br><span class="line">    Idx serial <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    Name <span class="type">varchar</span>(<span class="number">10</span>),</span><br><span class="line">    Age <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>Foreign Key Constraint</strong><br>为了成功创建外键，以下条件必须满足：</p><ul><li>引用的表（在 REFERENCES 后面指定的表）必须已经存在。</li><li>被引用的字段必须是父表的主键或具有唯一性约束。</li><li>数据类型必须兼容，即外键字段和被引用字段的类型必须相同或可转换。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> parent_table (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> child_table (</span><br><span class="line">    id SERIAL <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">    parent_id <span class="type">INTEGER</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (parent_id) <span class="keyword">REFERENCES</span> parent_table(id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- ON DELETE CASCADE</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line">    child_table</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span></span><br><span class="line">    fk_parent_id <span class="keyword">FOREIGN</span> KEY (parent_id)</span><br><span class="line"><span class="keyword">REFERENCES</span> parent_table(id)</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br></pre></td></tr></table></figure><p>在 SQL 中，特别是像 MySQL 和 PostgreSQL 这样的关系型数据库管理系统中，外键不仅提供了数据完整性，还可以配置不同的行为，例如 ON DELETE 和 ON UPDATE 规则，来决定当父表中的记录被删除或更新时，子表中的关联记录应该如何处理，常见的 ON DELETE 和 ON UPDATE 规则包括：</p><ul><li>RESTRICT 或 NO ACTION<br>这是默认行为。如果尝试删除或更新主表中的记录，而子表中存在依赖这个记录的外键，那么操作会被阻止。这确保了参照完整性，防止了意外的数据丢失。</li><li>CASCADE:<br>当主表中的记录被删除或更新时，所有关联的子表记录也将被相应地删除或更新。这样，两个表之间的数据保持一致。</li><li>SET NULL:<br>如果主表中的记录被删除或更新，子表中对应的外键字段将被设置为 NULL。这要求外键字段在定义时允许为 NULL。</li><li>SET DEFAULT:<br>设置外键在主键被删除或更新时，将子表中的外键字段设为其默认值。<br>请注意，SET DEFAULT 在 MySQL 中不支持，</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">管理约束</span></span><br><span class="line"><span class="string">constraint_type指明了约束的类型，比如FOREIGN KEY、UNIQUE、PRIMARY KEY等。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line">    table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span></span><br><span class="line">    constraint_name constraint_type(column_name, ...);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span></span><br><span class="line">    child_table</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">CONSTRAINT</span> IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    fk_parent_id <span class="keyword">FOREIGN</span> KEY (parent_id)</span><br><span class="line"><span class="keyword">REFERENCES</span></span><br><span class="line">    parent_table(id)</span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">DELETE</span> CASCADE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> child_table <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span> fk_parent_id;</span><br></pre></td></tr></table></figure><h4 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h4><p>索引（index）：将关系表按照指定列的取值顺序组织元组数据的数据结构，加快查询，占用额外存储空间、开销较大</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX Birthday_Idx <span class="keyword">ON</span> STUDENT(Birthday);</span><br><span class="line"><span class="keyword">ALTER</span> INDEX Birthday_Idx RENAME <span class="keyword">TO</span> Bday_Idx;</span><br><span class="line"><span class="keyword">DROP</span> INDEX bday_idx;</span><br></pre></td></tr></table></figure><h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><p>DML：数据操作语言，用于对数据进行 CRUD(Create, Retrieve, Update, Delete)</p><p>Ref: [[DataBase01#DML]]</p><h4 id="INSERT-UPDATE-DELETE"><a href="#INSERT-UPDATE-DELETE" class="headerlink" title="INSERT, UPDATE, DELETE"></a>INSERT, UPDATE, DELETE</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- insert</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span>  <span class="operator">&lt;</span>表名<span class="operator">|</span>视图名<span class="operator">&gt;</span>[<span class="operator">&lt;</span>列名表<span class="operator">&gt;</span>]  <span class="keyword">VALUES</span> （列值表）;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student <span class="keyword">VALUES</span>(<span class="string">&#x27;2017220101105&#x27;</span>,<span class="string">&#x27;柳因&#x27;</span>,<span class="string">&#x27;女&#x27;</span>,<span class="string">&#x27;1999-04-23&#x27;</span>,<span class="string">&#x27;软件工程&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;liuyin@163.com&#x27;</span>)</span><br><span class="line"><span class="comment">-- update</span></span><br><span class="line"><span class="keyword">UPDATE</span></span><br><span class="line">    <span class="operator">&lt;</span>表名<span class="operator">|</span>视图名<span class="operator">&gt;</span></span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">    <span class="operator">&lt;</span>列名<span class="number">1</span><span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="number">1</span><span class="operator">&gt;</span> [，<span class="operator">&lt;</span>列名<span class="number">2</span><span class="operator">&gt;=</span><span class="operator">&lt;</span>表达式<span class="number">2</span><span class="operator">&gt;</span>...]</span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]；</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span></span><br><span class="line">    Student</span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">    Email<span class="operator">=</span><span class="string">&#x27;zhaodong@163.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    StudentName<span class="operator">=</span><span class="string">&#x27;赵东&#x27;</span>;</span><br><span class="line"><span class="comment">-- delete</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span></span><br><span class="line">    <span class="operator">&lt;</span>表名<span class="operator">|</span>视图名<span class="operator">&gt;</span></span><br><span class="line">[<span class="keyword">WHERE</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span></span><br><span class="line">    Student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">    StudentName<span class="operator">=</span><span class="string">&#x27;赵东&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  [<span class="keyword">ALL</span><span class="operator">|</span><span class="keyword">DISTINCT</span>]  <span class="operator">&lt;</span>目标列<span class="operator">&gt;</span>[，<span class="operator">&lt;</span>目标列<span class="operator">&gt;</span>…]</span><br><span class="line">[ <span class="keyword">INTO</span> <span class="operator">&lt;</span>新表<span class="operator">&gt;</span> ]</span><br><span class="line"><span class="keyword">FROM</span>  <span class="operator">&lt;</span>表名<span class="operator">|</span>视图名<span class="operator">&gt;</span>[，<span class="operator">&lt;</span>表名<span class="operator">|</span>视图名<span class="operator">&gt;</span>…]</span><br><span class="line">[ <span class="keyword">WHERE</span>  <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ]</span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span>  <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">HAVING</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span> ]]</span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span>  <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [ <span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span> ] ];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- BETWEEN AND 限制列值范围</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  STUDENT</span><br><span class="line"><span class="keyword">WHERE</span> BirthDay <span class="keyword">BETWEEN</span> ‘<span class="number">2000</span><span class="number">-01</span><span class="number">-01</span>’ <span class="keyword">AND</span> ‘<span class="number">2000</span><span class="number">-12</span><span class="number">-30</span>’;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LIKE 通配符&#x27;_&#x27;代表一个字符&#x27;%&#x27;代表一个或多个字符</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  STUDENT</span><br><span class="line"><span class="keyword">WHERE</span>  Email  <span class="keyword">LIKE</span>  <span class="string">&#x27;%@163.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- AND\OR\NOT 逻辑运算符</span></span><br><span class="line"><span class="keyword">SELECT</span>  StudentID, StudentName, StudentGender, Major</span><br><span class="line"><span class="keyword">FROM</span>  STUDENT</span><br><span class="line"><span class="keyword">WHERE</span>  Major<span class="operator">=</span><span class="string">&#x27;软件工程&#x27;</span>  <span class="keyword">AND</span>  StudentGender<span class="operator">=</span><span class="string">&#x27;男&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- IN 限定范围</span></span><br><span class="line"><span class="keyword">SELECT</span>  StudentID, StudentName, StudentGender, Major</span><br><span class="line"><span class="keyword">FROM</span>  STUDENT</span><br><span class="line"><span class="keyword">WHERE</span>  Major <span class="keyword">IN</span>  (<span class="string">&#x27;CS&#x27;</span>,<span class="string">&#x27;SE&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ORDER BY &lt;&gt; ASC/DESC 默认升序ASC</span></span><br><span class="line"><span class="comment">-- 多个列排序时，只有当前列相同时才会比较下一列</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  STUDENT</span><br><span class="line"><span class="keyword">ORDER</span>  <span class="keyword">BY</span>  Birthday <span class="keyword">DESC</span> ,  StudentName  <span class="keyword">ASC</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 内置函数</span></span><br><span class="line"><span class="keyword">SELECT</span>  COUNT（<span class="operator">*</span>） <span class="keyword">AS</span>  学生人数</span><br><span class="line"><span class="keyword">FROM</span>  Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span>  Min（Birthday） <span class="keyword">AS</span> 最大年龄，Max（Birthday） <span class="keyword">AS</span> 最小年龄</span><br><span class="line"><span class="keyword">FROM</span>  Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- GROUP BY &lt;&gt; HAVING</span></span><br><span class="line"><span class="comment">-- 专业统计STUDENT表中男生人数，但限定只显示人数大于2的人数</span></span><br><span class="line"><span class="keyword">SELECT</span>  Major  <span class="keyword">AS</span> 专业,  COUNT（StudentID） <span class="keyword">AS</span> 学生人数</span><br><span class="line"><span class="keyword">FROM</span>  Student</span><br><span class="line"><span class="keyword">WHERE</span>  StudentGender<span class="operator">=</span>’男’</span><br><span class="line"><span class="keyword">GROUP</span>  <span class="keyword">BY</span>  Major</span><br><span class="line"><span class="keyword">HAVING</span>  <span class="built_in">COUNT</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="多表关联查询"><a href="#多表关联查询" class="headerlink" title="多表关联查询"></a>多表关联查询</h4><h5 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  TeacherID, TeacherName, TeacherTitle</span><br><span class="line"><span class="keyword">FROM</span>  Teacher</span><br><span class="line"><span class="keyword">WHERE</span>  CollegeID  <span class="keyword">IN</span></span><br><span class="line">        (<span class="keyword">SELECT</span>  CollegeID</span><br><span class="line">         <span class="keyword">FROM</span>  College</span><br><span class="line">         <span class="keyword">WHERE</span>  CollegeName<span class="operator">=</span><span class="string">&#x27;计算机学院&#x27;</span>);</span><br></pre></td></tr></table></figure><h5 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  </span><br><span class="line">    B.CollegeName <span class="keyword">AS</span> 学院名称,  A.TeacherID  <span class="keyword">AS</span> 编号, A.TeacherName  <span class="keyword">AS</span> 姓名,  A.TeacherGender  <span class="keyword">AS</span> 性别,  A. TeacherTitle  <span class="keyword">AS</span> 职称</span><br><span class="line"><span class="keyword">FROM</span>  </span><br><span class="line">    Teacher  <span class="keyword">AS</span>  A，College  <span class="keyword">AS</span>  B</span><br><span class="line"><span class="keyword">WHERE</span>  </span><br><span class="line">    A.CollegeID<span class="operator">=</span>B.CollegeID</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span>  </span><br><span class="line">    B.CollegeName, A.TeacherID;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- JOIN ON 内连接</span></span><br><span class="line"><span class="keyword">SELECT</span>  </span><br><span class="line">    B.CollegeName <span class="keyword">AS</span> 学院名称,  A.TeacherID  <span class="keyword">AS</span> 编号, A.TeacherName  <span class="keyword">AS</span> 姓名,  A.TeacherGender  <span class="keyword">AS</span> 性别,  A. TeacherTitle  <span class="keyword">AS</span> 职称</span><br><span class="line"><span class="keyword">FROM</span>  </span><br><span class="line">    TEACHER  <span class="keyword">AS</span>  A  <span class="keyword">JOIN</span>  COLLEGE  <span class="keyword">AS</span>  B</span><br><span class="line"><span class="keyword">ON</span>  </span><br><span class="line">    A.CollegeID<span class="operator">=</span>B.CollegeID</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    B.CollegeName, A.TeacherID;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- LEFT JOIN/RIGHT JOIN/FULL JOIN 外连接</span></span><br><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">    C.CourseName <span class="keyword">AS</span> 课程名称, T.TeacherName <span class="keyword">AS</span> 教师,<span class="built_in">COUNT</span> (R.CoursePlanID)  <span class="keyword">AS</span> 选课人数</span><br><span class="line"><span class="keyword">FROM</span>  </span><br><span class="line">    COURSE  <span class="keyword">AS</span>  C  </span><br><span class="line"><span class="keyword">JOIN</span>  </span><br><span class="line">    PLAN  <span class="keyword">AS</span>  P</span><br><span class="line">    <span class="keyword">ON</span> C.CourseID<span class="operator">=</span>P.CourseID</span><br><span class="line"><span class="keyword">JOIN</span>  </span><br><span class="line">    TEACHER  <span class="keyword">AS</span>  T  </span><br><span class="line">    <span class="keyword">ON</span> P.TeacherID<span class="operator">=</span>T.TeacherID</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span>  </span><br><span class="line">    REGISTER  <span class="keyword">AS</span>  R  </span><br><span class="line">    <span class="keyword">ON</span>  P.CoursePlanID<span class="operator">=</span>R.CoursePlanID</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line">    C.CourseName, T.TeacherName;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">SQL语言特点，SQL语句类型，SQL数据类型；DDL语句操作，数据库对象定义SQL语句，数据库表定义SQL语句，数据索引对象定义SQL语句；DML语句操作，数据插入SQL语句，数据更新SQL语句，数据删除SQL语句；DQL语句操作，单表指定行列查询，查询结果排序，内置函数应用，查询结果分组，子查询应用，多表关联查询，外连接查询；视图SQL语句，视图创建，视图应用。</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="数据库原理及应用" scheme="https://efterklang.github.io/categories/UESTC/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>网络层数据平面 Network Layer:Data Plane</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-1NetworkLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-1NetworkLayer/</id>
    <published>2024-03-27T05:33:20.000Z</published>
    <updated>2024-06-12T09:23:37.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview-of-Network-Layer"><a href="#Overview-of-Network-Layer" class="headerlink" title="Overview of Network Layer"></a>Overview of Network Layer</h2><p><strong>网络层提供的功能</strong><br>从发送方主机传输报文段到接收方主机<br>发送方主机封装报文段(segments)为数据报(datagrams)给链路层<br>接收方主机递交报文段给传输层<br>在每个主机、路由器上都需要运行网络层协议<br>路由器会检查通过它的所有 IP 数据报的头部字段，然后根据目的 IP 地址对数据报进行转发</p><h3 id="Forwarding-and-Routing-The-Data-Plane-and-Control-Plane"><a href="#Forwarding-and-Routing-The-Data-Plane-and-Control-Plane" class="headerlink" title="Forwarding and Routing: The Data Plane and Control Plane"></a>Forwarding and Routing: The Data Plane and Control Plane</h3><ul><li><strong>转发</strong>(forwarding): 当数据包到达路由器的输入链路时，路由器必须将数据包移动到适当的输出链路。例如，从主机 H1 到路由器 R1 的数据包必须被转发到通往 H2 的路径上的下一个路由器。将分组从路由器的输入端口转移到正确的路由器输出端口(主要利用硬件)</li><li><strong>路由</strong>(routing): 网络层必须确定数据包从发送者流向接收者时所走的路由 route 或路径 path,计算这些路径的算法被称为路由算法。例如，路由算法会确定数据包从 Host1 流向 Host2 的路径。路由在网络层的控制平面 Control Plane 中实现(主要利用软件)</li></ul><blockquote><p>转发指的是路由器在本地将数据包从输入链路接口转移到适当的输出链路接口的动作。转发在非常短的时间范围内发生（通常是几纳秒），因此通常在硬件中实现。路由指的是确定数据包从源到目的地的端到端路径的网络范围内的过程。路由在更长的时间范围内发生（通常是几秒钟），通常在软件中实现。</p></blockquote><h4 id="Control-Plane-The-Traditional-Approach"><a href="#Control-Plane-The-Traditional-Approach" class="headerlink" title="Control Plane: The Traditional Approach"></a>Control Plane: The Traditional Approach</h4><p>每个路由器都有单独的路由算法组件，路由器之间通过交互来实现控制平面<br>由路由算法决定了路由器转发表的内容<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-05-14-15-19-16.png" style="zoom:100%;"></p><h4 id="Control-Plane-The-SDN-Approach"><a href="#Control-Plane-The-SDN-Approach" class="headerlink" title="Control Plane: The SDN Approach"></a>Control Plane: The SDN Approach</h4><p>一个分离的（通常是远程的）控制器和路由器本地的控制代理 (local control agents，CAs) 交互，由 remote controller 计算并分发每个路由器要使用的转发表<br>远程控制器可能在具有高可靠性和冗余的远程数据中心中实现，并可能由 ISP 或某第三方管理，因为计算转发表并与路由器交互的控制器是在软件中实现的，故被称为软件定义网络(Software Defined Networking, SDN)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-05-14-15-51-29.png" style="zoom:100%;"></p><h3 id="Network-Service-Model"><a href="#Network-Service-Model" class="headerlink" title="Network Service Model"></a>Network Service Model</h3><p><strong>网络服务模型（network service model）</strong>定义了分组在发送与接收端系统之间的端到端运输特性。</p><p>某些分组交换机称为<strong>链路层交换机</strong>（link-layer switch），基于链路层帧中的字段值做出转发决定，这些交换机因此被称为链路层设备；其他分组交换机称为<strong>路由器</strong>（router），基于网络层数据报中的首部字段值做出转发决定，路由器因此是网络层设备。</p><p><strong>网络层可能提供的服务</strong></p><p>针对单个的数据报 datagram，可提供以下服务</p><ul><li>Guaranteed delivery 确保交付：确保分组到达目的地。</li><li>Guaranteed delivery with bounded delay：最大时延的保证，例如确保主机到主机的时延不超过 40ms</li></ul><p>针对数据包流(flow of datagrams)，可提供的服务有</p><ul><li>In-order packet delivery 有序分组交付：按发送顺序到达。</li><li>Guaranteed minimal bandwidth 确保最小带宽：当发送主机以低于特定比特率的速率发送比特，分组不会丢失，在一定时延到达。</li><li>Security 安全性：网络层可以在源端对所有数据报进行加密，并在目的端进行解密，从而为所有传输层的段提供保密性。</li></ul><p>互联网的网络层提供了一种单一的服务，称为<strong>尽力而为服务</strong>(best-effort service)。在尽力而为服务中，数据包既不能保证按照发送的顺序被接收，也不能保证最终被送达。没有对端到端延迟的保证，也没有最小带宽的保证。</p><article class="message is-info">        <div class="message-header"><p>QOS</p></div>        <div class="message-body">            <table><thead><tr><th>QoS 模型</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>Best Effort</td><td>1. 简单，不需要复杂的网络策略或协议。<br>2. 允许数据包在网络中自由流动，无需预设路径。<br>3. 在无拥塞的情况下，可以提供可靠的服务。<br>4. 允许最大的网络效率和成本效益。</td><td>1. 不允许资源预留或任何其他与网络特殊处理相关的机制。<br>2. 对于实时（RT）流量需求的新兴应用，表现不佳。<br>3. 当网络资源不足以满足 QoS 应用程序的需求时，不应使用此模型。</td></tr><tr><td>Integrated Services (IntServ)</td><td>1. 允许网络流量的个性化处理。<br>2. 使用服务特定的预留协议为特定的数据流预留资源。<br>3. 可以准确预测并保证定义的性能水平。</td><td>1. 不可扩展，需要比其他 QoS 模型（如 DiffServ）更多的管理控制。<br>2. 实施此模型需要网络中存在 IntServ 能力的路由器，并使用 RSVP 进行端到端的资源预留。<br>3. 由于 RSVP 是一个软状态协议，持续的信令负载只会加剧可扩展性问题。</td></tr><tr><td>Differentiated Services (DiffServ)</td><td>1. 提供一种基于类别的服务，某些类别的流量可以优先于其他流量类别得到处理。<br>2. 适用于大型网络，因为它不需要为每个流量保留网络资源。</td><td>1. 不能为每个流量提供精确的 QoS 保证。<br>2. 对于需要高精度 QoS 保证的应用，可能不是最佳选择。</td></tr></tbody></table>        </div>    </article><article class="message is-info">        <div class="message-header"><p>虚电路</p></div>        <div class="message-body">            <ul><li>数据报 网络提供网络层的无连接 服务</li><li>虚电路 网络提供网络层的 连接 服务</li><li>类比于 TCP&#x2F;UDP 的面向连接&#x2F; 无连接的传输层服务：<ul><li>任何网络中的网络层只提供两种服务之一，不会同时提供。</li><li>虚电路网络：提供连接服务。</li><li>数据报网络：提供无连接服务。</li><li>传输层：面向连接服务在网络边缘的端系统中实现。</li><li>网络层：面向连接服务在端系统及网络核心的路由器中实现。</li></ul></li></ul><p><strong>定义</strong><br><strong>虚电路</strong>(Virtual Circuits)“源主机-目的主机路径的行为类似于电话网络的行为”,性能上类似,沿着源-目的路径的网络行为类似。</p><ul><li>在数据传输之前，需要为每个呼叫建立连接</li><li>每个分组携带 VC 标识符(不是目的主机地址)</li><li>位于“源-目的路径”上的每个路由器会维护经过它的每条连接的“状态”</li><li>链路和路由器的资源(带宽、缓存)可以被分配给 VC(专用资源)</li></ul><p><strong>特点</strong><br>虚电路网络源于电话产业界（采用“真正”电路）。<br>呼叫建立及每次呼叫的状态要在网络中的路由器上维持，比面向数据报的网络要复杂。<br>网络功能复杂，端系统设备简单</p>        </div>    </article><h2 id="What’s-Inside-a-Router"><a href="#What’s-Inside-a-Router" class="headerlink" title="What’s Inside a Router?"></a>What’s Inside a Router?</h2><p>对于一般的路由器来说，它主要包含四个部分<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-06-18-12-09.png" style="zoom:100%;"></p><ul><li><p><strong>输入端口</strong> (Input Ports)</p><ul><li>执行物理层功能，终止路由器上的入站物理链接。</li><li>执行链路层功能，与入站链接另一侧的链路层进行互操作。</li><li>在输入端口执行查找功能，这将在输入端口的最右侧的框中发生。在这里，将查询转发表以确定将通过交换结构转发到哪个路由器输出端口的到达数据包。</li><li>控制数据包（例如，携带路由协议信息的数据包）从输入端口转发到路由处理器。</li></ul></li><li><p><strong>交换结构</strong> (Switching Fabric)</p><ul><li>连接路由器的输入端口和输出端口。</li></ul></li><li><p><strong>输出端口</strong> (Output Ports)</p><ul><li>存储从交换结构接收的数据包，并执行必要的链路层和物理层功能在出站链接上传输这些数据包。</li><li>当链接是双向的时，输出端口通常会与同一线卡上的该链接的输入端口配对。</li></ul></li><li><p><strong>路由处理器</strong> (Routing Processor)</p><ul><li>执行控制平面 Data Plane 功能</li><li>在传统路由器中，它执行路由协议，维护路由表和附加的链路状态信息，并为路由器计算转发表。</li><li>在 SDN 路由器中，路由处理器负责与远程控制器通信，以便（在其他活动中）接收由远程控制器计算的转发表条目，并将这些条目安装在路由器的输入端口中。</li><li>执行网络管理功能。</li></ul></li></ul><h3 id="Input-Port-Processing-and-Destination-Based-Forwarding"><a href="#Input-Port-Processing-and-Destination-Based-Forwarding" class="headerlink" title="Input Port Processing and Destination-Based Forwarding"></a>Input Port Processing and Destination-Based Forwarding</h3><p>路由器输入端口处理的工作流程可以概括如下：</p><ol><li><p><strong>输入端口处理</strong> 终止路由器上的入站物理链接。路由器根据 forwarding table 来查找输出端口，到达的数据包将通过交换结构转发到该端口。</p></li><li><p><strong>转发表的更新</strong>：通过路由处理器计算和更新转发表，或者从远程 SDN 控制器接收。</p><blockquote><p>转发表是通过一个单独的总线（例如，PCI 总线）从路由处理器复制到线卡(line card)上的，每个线卡都有一个转发表的副本，可以在每个输入端口本地做出转发决策，无需在每个数据包都要调用路由处理器，从而避免了集中处理的瓶颈。</p></blockquote></li><li><p><strong>基于目标地址的转发</strong>：在最简单的情况下，即将到达的数据包将被转发到的输出端口是基于数据包的目标地址的。在 32 位 IP 地址的情况下，转发表的暴力实现将为每个可能的目标地址有一个条目。由于可能的地址超过 40 亿个，这个选项完全不可能。</p></li></ol><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-06-18-25-58.png" style="zoom:50%;" alt="Input port processing"><p>实际上路由器中使用分组目的地址的<strong>前缀</strong>（prefix）与该表中的表项进行匹配，如下图所示：</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-06-18-28-54.png" style="zoom:80%;"><p>当有多个匹配项目时，该路由器使用<strong>最长前缀匹配规则</strong>（longest prefix matching rule），即在该表中寻找最长的匹配项，并向与最长的前缀匹配先关联的链路接口转发分组。</p><table><thead><tr><th align="center">prefix</th><th align="center">Link Interface</th></tr></thead><tbody><tr><td align="center"><code>11001000 00010111 00010</code></td><td align="center">0</td></tr><tr><td align="center"><code>11001000 00010111 00011000</code></td><td align="center">1</td></tr><tr><td align="center"><code>11001000 00010111 00011</code></td><td align="center">2</td></tr><tr><td align="center">Otherwise</td><td align="center">3</td></tr></tbody></table><blockquote><p>一个端系统发送给另一个端系统的一批分组可能在网络中选择不同的路径，到达的顺序可能不一致</p></blockquote><p>鉴于转发表的存在，查找在概念上很简单 - 硬件逻辑只是在转发表中搜索最长的前缀匹配。在千兆传输速率下，这种查找必须在纳秒内执行,因此，不仅必须在硬件中执行查找，而且需要对大表进行快速查找的算法;还必须特别注意内存访问时间，从而在设计中嵌入式片上 DRAM 和更快的 SRAM（用作 DRAM 缓存）存储器。实践中经常使用<strong>三态内容可寻址存储器</strong>（Tenary Content Address Memory，TCAM）来查找</p><h3 id="Switching"><a href="#Switching" class="headerlink" title="Switching"></a>Switching</h3><p>Switch fabric 负责转发功能，完成交换的方式有很多，主要包括下面几种</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-06-21-07-17.png" style="zoom:100%;"><ul><li>Memory<ul><li>在 CPU 直接控制下交换的传统计算机,数据交换的执行与传统 IO 设备一致；</li><li>数据包复制到 processor memory，processor 从 header 中提取目标地址；</li><li>速度受内存带宽限制，交换速度受总线带宽的速度限制 (每个分组穿过两次总线:<code>Input&gt;Memory&gt;Output</code>),故若总线带宽为每秒写入或读出 B 个分组，则总的转发吞吐量 (分组从输入端口被传送到输出端口的总速率)小于 B&#x2F;2</li></ul></li><li>Bus<ul><li>输入端口通过一条共享总线将分组直接传送到输出端口，不需要选路处理器的干预。</li><li>每次只能有一个分组通过总线传送。<br>分组到达一个输入端口时，若总线正忙，会被暂时阻塞，在输入端口排队</li><li>路由器交换带宽受总线速率限制。</li></ul></li><li>Interconnection network<ul><li>数据报分割成固定长度信元, 通过交换矩阵来交换信元。到达输入端口的分组沿水平总线穿行，直至与所希望的输出端口的垂直总线交叉点：<ul><li>若该条垂直总线空闲，则分组被传送到输出端口；</li><li>否则，该到达的分组被阻塞，必须在输入端口排队。</li></ul></li></ul></li></ul><h3 id="Output-port-processing"><a href="#Output-port-processing" class="headerlink" title="Output port processing"></a>Output port processing</h3><p>取出存放在输出端口内存中的分组，并将其传输到输出链路上。<br>当交换结构将分组交付给输出端口的速率超过输出链路速率，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-06-21-25-01.png" style="zoom:100%;"><h3 id="When-Does-Queuing-Occur"><a href="#When-Does-Queuing-Occur" class="headerlink" title="When Does Queuing Occur"></a>When Does Queuing Occur</h3><p>在输入端口和输出端口都可以形成分组队列，随着这些队列的增长，路由器的缓存空间最终将会耗尽，并且当无内存可用于存储到达的分组时将会出现丢包（packet loss）</p><h4 id="Input-Queueing"><a href="#Input-Queueing" class="headerlink" title="Input Queueing"></a>Input Queueing</h4><p>当交换结构的速度慢于输入端口的速度，就会在输入端口的缓冲区发生排队,会导致排队延时和由于输入缓冲区溢出导致的丢包<br>线头阻塞（Head-of-the-Line (HOL) blocking）: 在队列前面的被阻塞的数据报会阻止队列中的其他数据报被转发</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-13-26-52.png" style="zoom:100%;"><h4 id="Output-Queueing"><a href="#Output-Queueing" class="headerlink" title="Output Queueing"></a>Output Queueing</h4><p>当经过交换结构到达的速度超过了输出端口的处理线速就会发生排队,当输出端口的缓冲区溢出时就会发生丢包</p><h4 id="Packet-Scheduling"><a href="#Packet-Scheduling" class="headerlink" title="Packet Scheduling"></a>Packet Scheduling</h4><p><strong>FCFS</strong>(FIFO)<br>维护一个 Queue，按照到达顺序依次处理分组</p><p><strong>Priority Queuing</strong><br>通常每个 Packet 都有一个优先级，不同优先级的 Packet 被分配到不同的队列中，然后按照优先级顺序处理<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-15-08-43.png" style="zoom:100%;"></p><p><strong>Round Robin</strong> and <strong>Weighted Fari Queuing</strong>(WFQ)</p><p>Round Robin 轮流服务将需要路由发送的资源进行分类，为每种类别生成自有的一个队列，发送时轮流从队列中选取队首的文件包进行发送。如果轮到某个队列时，该队列为空，则跳过该队列。</p><p>这样的服务能保障在各不同类型的网络服务中合理分配资源，不会让某一网络服务占用过大的带宽以至于影响其他的网络服务。比如某个下载程序占用过多网速，致使视频浏览出现卡顿或打开网页速度过慢。</p><p>WFQ 是基于 Round Robin 方法改进后而成的。对于某些网络服务，如网络电话或视频直播，为了保障能流畅进行，总是需要保留一定的优先带宽。这样情况下就可以使用 Round Robin 轮流服务的升级版本 Weighted Fair Quequing(WFQ)加权公平队列。其中的思想很简单，轮流服务中已经有了各个公平队列，需要做的就是对一些带宽敏感型服务进行标记并附以相应权重 $w_i$，服务时进行侧重就可以。</p><p>WFQ 在发送时仍然轮流从队列中选取队首文件包，但选取的数量根据权重 $w_i$ 确定，权重大的服务在一次发送循环中就能多发送文件包，从而确保相应的服务带宽，保证网络的服务质量。</p><h2 id="The-Internet-Protocol-IP-IPv4-Addressing-IPv6-and-More"><a href="#The-Internet-Protocol-IP-IPv4-Addressing-IPv6-and-More" class="headerlink" title="The Internet Protocol (IP): IPv4, Addressing, IPv6, and More"></a>The Internet Protocol (IP): IPv4, Addressing, IPv6, and More</h2><h3 id="IPV4-Datagram-Format"><a href="#IPV4-Datagram-Format" class="headerlink" title="IPV4 Datagram Format"></a>IPV4 Datagram Format</h3><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-15-17-12.png" style="zoom:100%;"><ul><li><strong>版本号</strong>（Version）：4bit。指定了数据报的 IP 协议版本。通过查看版本号，路由器可以确定如何解释 IP 数据报的其余部分。不同版本的 IP 使用不同的数据报格式。</li><li><strong>首部长度</strong>（Header length）：确定 IP 数据报中有效载荷,在无选项（Options）首部时，IP 具有 20Byte 的首部；</li><li><strong>服务类型</strong>（Type of service）：不同类型的数据报可以相互区分；</li><li><strong>数据报长度</strong>（Datagram length）：IP 数据报的总长度（首部加上数据），以字节计数；</li><li><strong>标识</strong>（Identifier）、<strong>标志</strong>（Flags）、<strong>分片偏移</strong>（Fragmentation offset）：一个链路层帧能承载的最大数据量叫作最大传送单元（Maximum Transmission Unit，MTU）。每个数据链路有自己的 MTU，链路类型不同，MTU 的值也不同，用于 IP 分片；在因特网中一个大的分组可能在路由器中被分割为几个分片，然后独立转发到目的地，在目的地将它们重新组装，然后将其有效载荷数据。IPV6 不允许分片</li><li><strong>生存时间</strong>（Time-to-live，TTL）：确保数据段不会永远在网络中循环；每次数据报被路由器处理时，这个字段就会减 1。如果 TTL 字段达到 0，路由器必须丢弃该数据报。</li><li><strong>上层协议</strong>（Upper-layer protocol）：IP 数据报到达最终目的地时使用。这个字段的值指示应该将该 IP 数据报的数据部分传递给特定的传输层协议。例如，值 6 表示数据部分传递给 TCP，而值 17 表示数据传递给 UDP。</li><li><strong>首部检验和</strong>（Header checksum）：帮助路由器检测收到的 IP 数据报中的比特错误；</li><li><strong>源和目的 IP 地址</strong>（Source and Destination IP address）；</li><li><strong>选项</strong>（Options）：允许 IP 首部被扩展；</li><li><strong>数据</strong>（Data）：一般为运输层报文段；</li></ul><h3 id="IPV4-Addressing"><a href="#IPV4-Addressing" class="headerlink" title="IPV4 Addressing"></a>IPV4 Addressing</h3><ul><li><strong>IP</strong> 地址: 分配给主机或路由器接口的标识符</li><li><strong>接口</strong>: 主机&#x2F;路由器与物理链路之间的边界<ul><li>路由器有多个接口</li><li>主机可以有多个接口</li><li>每个接口有一个 IP 地址</li></ul></li><li><strong>IPV4 和 IPV6</strong><ul><li>IPV4：32 bits(4 Bytes)常用点分十进制(dotted-decimal notation)表示；</li><li>IPV6：128 bits(16 Bytes)常用冒号分隔表示</li></ul></li></ul><p>32 比特的二进制表示和点分十进制表示法<br>将 4 个字节中的每一个字节分别用十进制数来表示，4 个十进制数之间用 <code>.</code> 分隔。<br>例如<code>223.1.1.1 = 11011111 00000001 00000001 00000001</code><br>根据不同的取值范围，早期将 IP 地址分为五类。IP 地址中前 5 位用于标识 IP 地址的类别，A 类地址的第一位为“0”，B 类地址的前两位为“10”，C 类地址的前三位为“110”，D 类地址的前四位为“1110”，E 类地址的前五位为“11110”。其中，A 类、B 类与 C 类地址为基本的 IP 地址。</p><ul><li>A 类地址：地址范围为 <code>1. 0. 0. 1－127.255.255.254</code>全 0 表示本地地址，全 1 表示在本地网络中向所有机广播</li><li>B 类地址：地址范围为 <code>128.0.0.1－191.255.255.254</code></li><li>C 类地址：地址范围为 <code>192.0.0.1－223.255.255.254</code></li></ul><hr><p>特殊 IP 地址段</p><ul><li>本地回环地址<br><code>127.0.0.1-127.255.255.254</code>是预留的一组 IP 地址，主要是用来识别主机本身的地址。也叫做“localhost”，一般用来测试。</li><li>私有地址（Private address）<br><code>10.x.x.x,  172.16.x.x-172.31.x.x,  192.168.x.x</code>三个地址段被称为私有 IP 地址段，也就是局域网所使用的地址段，在公网上不能被路由</li><li><code>0.0.0.0</code><br>这个地址严格上来说都不是真正意义上的 IP 地址。主要是用来标识不清楚的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到这个地址</li><li><code>255.255.255.255</code><br>这个地址是受限的广播地址。主要指一个网段内的所有主机</li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-16-18-59.png" style="zoom:80%;"><p>IP 地址:<br>网络号 (高位 bits):指明主机所在网络的编号<br>主机号 (低位 bits):作为主机在网络中的编号。</p><p>网络号相同的 IP 地址属于同一个网络。而网络还可以划分为若干子网（subnet），划分子网的方法是从主机号借用若干个比特作为子网号，剩下的主机位为主机号。</p><p>子网 Subnet: 设备接口的 IP 地址具有同样的网络部分;没有路由器的介入，物理上能够相互到达<br>子网掩码 Subnet Mask,子网掩码用来确定网络地址（包括网络号和子网号）和主机地址的长度。子网掩码长为 32 位比特，其中的 1 对应于 IP 地址中的网络号和子网号，而子网掩码中的 0 对应于主机号。有公式</p><p>$$ip_address &amp; subnet_mask &#x3D; network_address$$</p><p>下图中，一台路由器（具有三个接口）用于互联 7 台主机。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-17-38-17.png" style="zoom:80%;"><p>图中左侧的 3 个主机和它们连接的路由器接口，都有一个形如<code>233.1.1.xxx</code>的 IP 地址。用 IP 的术语说，互联这 3 个主机接口与 1 个互联网接口的网络形成一个<strong>子网</strong>（subnet）。IP 编址为这个子网分配一个地址<code>233.1.1.0/24</code>，其中<code>/24</code>记法，指示 32 比特中的最左侧 24 比特定义了子网地址。</p><p><strong>使用子网掩码的分组转发</strong><br>不划分子网时，路由表只有两项：目的网络地址和下一跳地址。使用子网划分后，路由表中将包括三项：目的网络地址、子网掩码和下一跳地址。</p><p>一个 A 类的 IP 地址，可以有 24bit 用于分配主机地址，因此可以支持$2^24$个主机(注意，实际上可接入主机要-2，因为有 2 个要留给 localhost 和广播地址)，但是一个家庭或者组织往往不需要这么多的地址空间，造成浪费。<br>一个 C 类的 IP 地址，只有 8bit 用于分配主机地址，因此只能支持 256 个主机，又不太够用。因此，按传统 IP 地址分类方式分配 IP 被 CIDR 技术取代</p><p>CIDR，也被称为<strong>无类别域间路由选择</strong>（Classless Interdomain Routing，CIDR）, 消除了传统的 A 类、B 类和 C 类地址的概念。使用斜线记法，又称为 CIDR 记法来区分网络前缀和主机号，即在 IP 地址后面加上一个斜线<code>/</code>，斜线后面用一个数字指定网络前缀的长度。CIDR 将网络前缀都相同的连续的 IP 地址组成 CIDR 地址块。<br>一个 CIDR 地址块可以表示分类 IP 的多个分类地址，这种地址的聚合称为路由聚合，又称为<strong>构造超网</strong>(superneting)。</p><p>下图为一个示例，</p><ul><li>ISP 获得地址块的方法——从 <a href="http://www.icann.org/">ICANN（Internet Corporation for Assigned Names and Numbers）</a><ul><li>分配 IP 地址</li><li>管理 DNS</li><li>分配域名，解决纠纷</li></ul></li><li>组织机构如何获取 IP 地址? 从 ISP 的地址空间中划分一块给申请者</li></ul><blockquote><p>所有的 IP 地址都由 ICANN 规划，然后主要由国际组织 NIC（Network Information Center）具体负责统一分配。<br>目前全世界共有五个这样的网络信息中心(ARIN,LACNIC,RIPE NCC,AFRINIC,APNIC)<br>我国申请 IP 地址要通过 APNIC，APNIC 的总部设在日本东京大学。申请时要考虑申请哪一类的 IP 地址，然后向国内的代理机构提出。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-18-04-57.png" style="zoom:50%;"><br><article class="message is-info">        <div class="message-header"><p>隋唐小练</p></div>        <div class="message-body">            <p>现有一公司已获得网络号为 202.1.1.0&#x2F;24,如果该公司有 3 个部门,<br>（1）如果第 1 个部门有 60 台计算机，第二个部门有 20 台计算机，第三个部门有 16 台计算机，问如何分配地址?<br>（2）如果第 1 个部门有 120 台计算机，第 2 个部门有 60 台计算机，第 3 个部门有 60 台计算机，使用上述方法可以分配地址吗？使用 CIDR 方法如何分配地址?</p><p>（1）以最多台数的部门（60 台）为准，需要的最接近数为 2^6&#x3D;64，故要从最后个字节借 8-6&#x3D;2 位，<br>子网分别为 <code>202.1.1.0, 202.1.1.64, 202.1.1.128, 202.1.1.192</code>，在这 4 个其中任选 3 个即可。掩码均为 <code>255.255.255.192</code>。<br>（2）若以最多台数的部门（120 台）为准，仅能分两个子网，无法满足。故应采用 CIDR 法：<br>首先以最小需求台数部门为准（60 台），此时主机号位数需要 6 位（因为 60&#x3D;&lt;2^6-2），则子网号位数为 8-6&#x3D;2 位，然后将子网划分出来，子网分别为 <code>202.1.1.0, 202.1.1.64, 202.1.1.128, 202.1.1.192</code><br>接下来，部门 2、3 可以直接在 4 个子网中任选两个，部门 1 选剩下 2 个以满足 120 台的要求（但这两个子网要连续，以便用 CIDR 法合并之，做超网）。比如 <code>202.1.1.128、202.1.1.192</code> 分别给部门 2、3，部门 1 用 <code>202.1.1.0、202.1.1.64</code><br>（3）最后将各部门 IP 段用 CIDR 超网形式描述，以便对外发布：<br>部门 1：202.1.1.0&#x2F;25; (注意含义：表示前 25 位是网络号，且最后一个字节最高位为 0，后面 7 位是主机号)<br>部门 2：202.1.1.128&#x2F;26; (最后一个字节最高两位为 10，后面 6 位是主机号)<br>部门 3：202.1.1.192&#x2F;26; (最后一个字节最高两位为 11，后面 6 位是主机号)</p><p>将 202.1.1.128、202.1.1.192 给部门 1，202.1.1.0、202.1.1.64 分别给部门 2、3 亦可。此时答案为：<br>部门 1：202.1.1.0&#x2F;26;<br>部门 2：202.1.1.64&#x2F;26;<br>部门 3：202.1.1.128&#x2F;25</p>        </div>    </article><h3 id="Obtaining-a-Host-Address-The-Dynamic-Host-Configuration-Protocol"><a href="#Obtaining-a-Host-Address-The-Dynamic-Host-Configuration-Protocol" class="headerlink" title="Obtaining a Host Address: The Dynamic Host Configuration Protocol"></a>Obtaining a Host Address: The Dynamic Host Configuration Protocol</h3><p>主机如何得到 IP 地址?</p><ul><li>手工指定（保存在系统配置中）<ul><li>Windows: 控制面板-&gt;网络</li><li>UNIX&#x2F;LINUX: 在&#x2F;etc&#x2F;rc.config 中，可使用 ifconfig 命令配置</li></ul></li><li>DHCP: Dynamic Host Configuration Protocol,自动从一个 DHCP 服务器得到 IP 地址,方便灵活</li></ul><p><strong>DHCP</strong></p><p>DHCP 是应用层协议。其分配的不仅仅是 IP 地址，还可分配：</p><ul><li>客户的第一跳路由器的地址（网关）</li><li>DNS 服务器的 IP 地址或域名</li><li>子网掩码</li></ul><p><strong>报文格式</strong></p><ul><li><code>OP</code> 若是 client 送给 server 的封包，设为 1，反向为 2；</li><li><code>Htype</code> 硬件类别，ethernet 为 1；</li><li><code>Hlen</code> 硬件长度，ethernet 为 6；</li><li><code>Hops</code> 若数据包需经过 router 传送，每站加 1，若在同一网内，为 0；</li><li><code>Transaction</code> ID：事务 ID，是个随机数，用于客户和服务器之间匹配请求和相应消息；</li><li><code>Seconds</code> 由用户指定的时间，指开始地址获取和更新进行后的时间；</li><li><code>Flags</code> 从 0-15bits，最左一 bit 为 1 时表示 server 将以广播方式传送封包给 client，其余尚未使用；</li><li><code>Ciaddr</code> 用户 IP 地址；</li><li><code>Yiaddr</code> 客户 IP 地址；</li><li><code>Siaddr</code> 用于 bootstrap 过程中的 IP 地址；</li><li><code>Giaddr</code> 转发代理（网关）IP 地址；</li><li><code>Chaddr</code> client 的硬件地址；</li><li><code>Sname</code> 可选 server 的名称，以 0x00 结尾；</li><li><code>File</code> 启动文件名；</li><li><code>Options</code> ，厂商标识，可选的参数字段</li></ul><p><strong>Steps</strong></p><ol><li><p>DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。DHCP 客户端启动时,由于其还未配置 IP 地址,因此只能使用广播方式发送 Dhcpdiscover 包,即该数据包的源地址为 0.0.0.0,目标地址为 255.255.255.255</p></li><li><p>DHCP 客户从 UDP 端口 68 发送 DHCP Discover 报文。</p></li><li><p>凡收到 DHCP discover 报文的 DHCP 服务器 都发出 DHCP offer 报文，因此 DHCP 客户 可能收到多个 DHCP offer 报文</p></li><li><p>DHCP 客户从几个 DHCP 服务器中选择 其中的一个，并向所选择的 DHCP 服务 器发送 DHCP request 报文</p></li><li><p>被选择的 DHCP 服务器发送确认报文 DHCPACK，客户进入已绑定状态，并可 开始使用得到的临时 IP 地址了<br>DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。</p></li><li><p>租用期过了一半（T1 时间到），DHCP 发送 request 报文 DHCPREQUEST 要求更新租用期。</p></li><li><p>DHCP 服务器若不同意，则发回否认报文 DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤 2）</p></li><li><p>DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。若 DHCP 服务器不响应步骤 6 的 request 报文 DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤 6），然后又继续后面的步骤。</p></li><li><p>DHCP 客户可随时提前终止服务器所提供的 租用期，这时只需向 DHCP 服务器发送释 放报文 DHCPRELEASE 即可。</p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-18-50-12.png" style="zoom:50%;"></li></ol><h3 id="Network-Address-Translation-NAT"><a href="#Network-Address-Translation-NAT" class="headerlink" title="Network Address Translation (NAT)"></a>Network Address Translation (NAT)</h3><p>对于外部网络而言，本地网络中的所有设备只共享一个 IPv4 地址。这样做有以下几点好处：</p><ul><li>不需要从 ISP 分配一系列地址—— 只要一个 IP 地址用于所有设备</li><li>在本地网络，改变设备的 IP 地址不用通知外部世界</li><li>可以变更 ISP ，不用改变本地网络的设备的地址</li><li>本地网络内部设备不能被外部世界明确寻址，或是不可见 (增加了安全性)</li></ul><p>但同时，为与外部网络交互，需进行网络地址转换(NAT)，执行 NAT，路由器</p><ul><li>外出的分组: 把每个外出的分组的 (源 IP 地址, 端口号) 替换为 (NAT IP 地址, 新端口号)</li><li>在 NAT 转换表(NAT Translation Table)中记录每个(源 IP 地址, 端口号)到 (NAT IP 地址, 新端口号) 转换配对</li><li>进来的分组: 对每个进来的分组，用保存在 NAT 表中的对应的(源 IP 地址, 端口号) 替换分组中的目的域 （NAT IP 地址, 新端口号）</li></ul><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-19-21-55.png" style="zoom:100%;"><p>Nat 的一些局限——16bit 端口号使得一个局域网地址可以同时支持 60,000 个并发连接!</p><p>NAT 存在争议</p><ul><li>路由器只应该处理到第三层</li><li>违反了端到端主张</li><li>应用程序设计者在设计时不得不将 NAT 加以考虑</li><li>如 P2P 应用程序</li><li>应使用 IPv6 来解决地址短缺问题</li></ul><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>Internet Control Message Protocol（ICMP，互联网控制消息协议），负责在网络设备间传递控制与错误信息，确保数据包能够顺利抵达目的地。互联网中丢包、路由错误、网络拥塞等状况时有发生。这时，ICMP 便如同一位经验丰富的“诊断医生”，通过发送特定的消息类型，帮助识别并报告这些网络问题。</p><p><strong>ICMP 的基本运作原理</strong><br>ICMP 位于 Internet 协议（IP）之上，属于 TCP&#x2F;IP 协议栈的网络层。它并不直接参与数据的传输，而是作为 IP 协议的一个辅助工具，通过差错报告和询问机制来实现其功能。ICMP 报文通常封装在 IP 数据包内，包含类型、代码和校验和等字段，用以区分不同的消息类型和提供完整性检查。</p><p>差错报告：当数据包无法到达目标或遇到其他传输问题时，路由器或主机可以通过发送 ICMP 错误消息（如“目标不可达”、“超时”等）给源主机，告知发生了什么问题。</p><table><thead><tr><th>ICMP type</th><th>Code</th><th>Description</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>echo reply (ping)</td></tr><tr><td>3</td><td>0</td><td>destination network unreachable</td></tr><tr><td>3</td><td>1</td><td>destination host unreachable</td></tr><tr><td>3</td><td>2</td><td>destination protocol unreachable</td></tr><tr><td>3</td><td>3</td><td>destination port unreachable</td></tr><tr><td>3</td><td>6</td><td>destination network unknown</td></tr><tr><td>3</td><td>7</td><td>destination host unknown</td></tr><tr><td>4</td><td>0</td><td>源端抑制 source quench(congestion control)</td></tr><tr><td>8</td><td>0</td><td>echo request (ping)</td></tr><tr><td>9</td><td>0</td><td>router advertisement</td></tr><tr><td>10</td><td>0</td><td>router discovery</td></tr><tr><td>11</td><td>0</td><td>TTL expired</td></tr><tr><td>12</td><td>0</td><td>IP header bad</td></tr></tbody></table><p><strong>ICMP 的实用价值</strong><br>网络故障排除：对于网络管理员而言，通过分析 ICMP 反馈的信息，可以迅速定位网络故障，比如判断是网络拥塞还是链路故障导致的数据包丢失。</p><p>路径监测与测量：“Traceroute”利用 ICMP 的 TTL（Time to Live）字段递减特性，逐跳追踪数据包的传输路径，帮助理解网络拓扑结构及延迟情况。</p><p>可用性检查：“Ping”命令简单有效，成为检测远程主机是否可达的日常工具，广泛应用于网络维护和服务器监控中。</p><p>安全考量与限制<br>尽管 ICMP 对网络运维至关重要，但它也存在被滥用的风险，例如用于 DDoS 攻击中的 Smurf 攻击或放大攻击。因此，合理配置防火墙策略，对 ICMP 流量进行适当限制和监控，是保障网络安全的必要措施。</p><h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><ul><li>初始动机：<ul><li>32-bit IPv4 地址空间即将用尽</li></ul></li><li>其他动机：<ul><li>首部格式可帮助加速处理&#x2F;转发</li><li>改变首部利于 QoS 要求</li></ul></li><li>IPv6 数据报格式<ul><li>固定长度的 40 字节首部</li><li>不允许分片</li></ul></li></ul><p><strong>IPV6 报文格式</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-20-22-25.png" style="zoom:80%;"></p><p>Priority: 表示流中分组的优先级<br>Flowlabel: 表示分组在同一个“stream”中 (“流”的概念尚未完全定义)<br>next hdr(header): 表示数据的上层协议</p><p><strong>与 IPv4 区别</strong></p><ul><li>删掉分片&#x2F;重新组装；</li><li>校验和: 全部去掉，减少每一跳的处理时间</li><li>虽允许 Option 字段, 但是不是标准首部的一部分，而是用下一个首部域指出</li><li>ICMPv6:新版本的 ICMP<br>增加消息类型, 例如“分组太大”<br>多播组管理功能</li></ul><article class="message is-info">                <div class="message-body">            <p><strong>IPv4</strong></p><p>Pros<br>广泛兼容性：目前互联网上的大多数系统和设备都支持 IPv4，具有极高的兼容性。<br>NAT（网络地址转换）：通过 NAT 技术，多个设备可以共享一个公共 IPv4 地址，缓解了地址不足的问题。<br>成熟度：作为长期使用的标准，IPv4 的技术支持、文档和工具都非常成熟。<br>Cons<br>地址空间有限：只有大约 43 亿个地址，随着互联网设备的激增，地址资源已接近枯竭。<br>复杂的 NAT 使用：虽然 NAT 有助于缓解地址短缺，但它增加了网络的复杂性，可能影响某些应用的端到端通信。<br>安全性：IPv4 本身并未内置强大的安全机制，依赖于外部解决方案如防火墙和 IPsec 来增强安全性。</p><hr><p><strong>IPv6</strong></p><p>Pros<br>巨大的地址空间：拥有 2^128 个地址，几乎解决了地址耗尽的问题，可以为每一台设备分配一个全球唯一的 IP 地址。<br>内置安全：IPv6 集成了 IPsec，提供了端到端的安全性和数据隐私保护，增强了网络通信的安全性。<br>简化网络：减少了对 NAT 的依赖，简化了路由和网络配置，提高了网络的透明度和效率。<br>改进的报头和性能：IPv6 的报头设计更简洁，提高了数据包处理效率；同时，它支持更高效的路由和自动配置功能。<br>Cons<br>普及率：尽管 IPv6 已经存在多年，其在全球范围内的普及和部署速度较慢，部分原因是设备升级和兼容性问题。<br>过渡成本：从 IPv4 向 IPv6 迁移需要投入成本，包括硬件升级、软件改造和人员培训。<br>兼容性问题：早期的设备和一些老旧应用可能不支持 IPv6，需要额外的努力来确保兼容性。</p>        </div>    </article><p><strong>IPV6 地址表示</strong></p><p>在 IPv6 中，地址分为 8 个段来表示，每段共 4 个字符</p><ul><li><strong>冒号十六进制表示法</strong><br><code>104.220.136.100.255.255.255.255.0.0.18.128.140.10.255.255</code>用冒号十六进制表示为：<br><code>69DC:8864:FFFF:FFFF:0:1280:8C0A:FFFF</code></li><li><strong>零压缩表示法</strong><br>多个连续的<code>0</code>可用<code>::</code>替换;当计算机拿到这个压缩后的地址，发现比正常的 128 位少了 n 位，计算机就会试图在::的地方补上 n 个 0，从结果中可以发现，当一个 IPv6 地址被压缩后，如果计算机出现两个或多个::的时候，计算机在将地址还原时，就可能出现多种情况。这将导致计算机还原后的地址不是压缩之前的地址，将导致地址错误，最终通信失败。所以在压缩 IPv6 地址时，<strong>一个地址中只能出现一个</strong><code>::</code><br><code>FF0C:0:0:0:0:0:B1</code>零压缩表示为：<br><code>FF0C::B1</code></li></ul><p><strong>从 IPV4 到 IPV6 过渡</strong><br>两种推荐方法:<br>双栈：一些路由器具有双重栈 (v6, v4) 能够在两种格式中转换<br>隧道: 在穿过 IPv4 路由器时，IPv6 分组作为 IPv4 分组的负载<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1NetworkLayer-2024-06-07-20-33-49.png" style="zoom:50%;"></p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.cnblogs.com/lzr5350109/p/15265403.html">流量控制的相关算法与数据结构——Round Robin 轮流服务，Weighted Fair Quequing(WFQ)加权公平队列与 Leaky Bucket 漏桶限流</a></p>]]></content>
    
    
    <summary type="html">介绍网络层的主要功能——转发与路由，这两大核心方面分别由数据平面和控制平面负责，该篇主要介绍Data Plane,对比了传统的路由管理方式与SDN（软件定义网络）方法。阐述了网络服务模型的基本概念及路由器内部工作原理，包括输入输出端口处理、交换机制、排队策略及包调度等关键流程。此外，介绍互联网协议(IP)，涉及IPv4的数据报结构、地址分配，动态主机配置协议(DHCP)、网络地址转换(NAT)、ICMP协议以及IPv6的。</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="计算机网络" scheme="https://efterklang.github.io/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="https://efterklang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java Reflection</title>
    <link href="https://efterklang.github.io/Dev/Java/Java%20Reflection/"/>
    <id>https://efterklang.github.io/Dev/Java/Java%20Reflection/</id>
    <published>2024-03-25T04:31:26.000Z</published>
    <updated>2024-06-11T09:41:34.992Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Class&lt;?&gt; clazz = user.getClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java Reflection</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Java" scheme="https://efterklang.github.io/categories/Dev/Java/"/>
    
    
    <category term="Java" scheme="https://efterklang.github.io/tags/Java/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Efterklang</title>
  
  
  <link href="https://efterklang.github.io/atom.xml" rel="self"/>
  
  <link href="https://efterklang.github.io/"/>
  <updated>2024-04-03T05:24:41.617Z</updated>
  <id>https://efterklang.github.io/</id>
  
  <author>
    <name>Efterklang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ch4-1</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch4-1/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch4-1/</id>
    <published>2024-04-03T02:20:03.000Z</published>
    <updated>2024-04-03T05:24:41.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><pre><code>    为能更多的存放并更快地处理用户信息，目前许多计算机把存储器分为三级。</code></pre><p>寄存器、高速缓存、主存储器和磁盘缓存均属于操作系统存储管理的管辖范畴，掉电后它们存储的信息不再存在。<br>磁盘和可移动存储介质属于设备管理的管辖范畴，它们存储的信息将被长期保存。<br>高速缓存 Cache：K 字节、高速、昂贵、易变的<br>内存 RAM： M 或 G 字节、中速、中等价格、易变的<br>磁盘：G 或 T 字节、低速、价廉、不易变的<br>主存储器与寄存器 1.主存储器（内存，主存，可执行存储器）<br>用于保存进程运行时的程序和数据。CPU 的控制部件只能从主存中取得指令和数据到 CPU 寄存器，同样，CPU 寄存器中的数据可存入主存。<br>CPU 与外设交换数据必须依托于主存。 2.寄存器<br>寄存器访问速度最快，与 CPU 协调工作。<br>高速缓存与磁盘缓存<br>CPU 对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。<br>根据程序执行的<strong>局部性原理</strong>，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。<br>有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。</p><blockquote><p>要想更好地理解虚拟内存技术，必须要知道计算机中著名的 局部性原理（Locality Principle）。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。局部性原理是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。在分页机制中，页表的作用是将虚拟地址转换为物理地址，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：时间局部性：由于程序中存在一定的循环或者重复操作，因此会反复访问同一个页或一些特定的页，这就体现了时间局部性的特点。为了利用时间局部性，分页机制中通常采用缓存机制来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。空间局部性：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此当访问某个页时，往往会顺带访问其相邻的一些页。为了利用空间局部性，分页机制中通常采用预取技术来预先将相邻的一些页读入内存缓存中，以便在未来访问时能够直接使用，从而提高访问速度。总之，局部性原理是计算机体系结构设计的重要原则之一，也是许多优化算法的基础。在分页机制中，利用时间局部性和空间局部性，采用缓存和预取技术，可以提高页面的命中率，从而提高内存访问效率</p></blockquote><hr><p>著作权归 JavaGuide(javaguide.cn)所有<br>基于 MIT 协议<br>原文链接：<a href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-02.html">https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-02.html</a><br>磁盘缓存<br>内存中一块存储区，对应于某固定磁盘，临时存储磁盘数据（如，数据预取）</p><p>三级存储器，从缓存到内存到外存，其容量愈来愈大，而访问数据的速度则愈来愈慢，价格也愈来愈便宜。<br>如缓存的最大传输速度为几十分之一至几百分之一 ns，主存的传输速度为几 ns 级。<br>用户的程序在运行时应存放在主存中，以便处理机访问。<br>其中直接存取要求内存速度尽量快到与 CPU 取指速度相匹配，大到能装下当前运行的程序与数据，否则 CPU 执行速度就会受到内存速度和容量的影响而得不到充分发挥。<br>由于主存容量和速度有限。所以把那些不马上使用的程序、数据放在外部存储器(又称辅存)中。当用到时再把它们读入主存。<br>由操作系统协调这些存储器的使用</p><h3 id="存储器管理的目的和功能"><a href="#存储器管理的目的和功能" class="headerlink" title="存储器管理的目的和功能"></a>存储器管理的目的和功能</h3><pre><code>   1.主存储器的分配和管理：按用户要求把适当的存储空间分配给相应的作业。一个有效的存储分配机制，应在用户请求时能作出快速的响应，分配相应的存储空间；在用户不再使用它时，应立即回收，以供其他用户使用。为此，这个存储分配机制应具有如下功能（3个）：   (1)记住每个存储区域的状态：哪些是已分配的，哪些是可以用作分配的。   (2)实施分配：在系统程序或用户提出申请时，按所需的量给予分配；修改相应的分配记录表。   (3)接受系统或用户释放的存储区域：并相应地修改分配记录表。   2.提高主存储器的利用率：使多道程序能动态地共享主存，最好能共享主存中的信息。   3.“扩充”主存容量：这是借助于提供虚拟存储器或其它自动覆盖技术来达到的。即为用户提供比主存的存储空间还大的地址空间。   4.存储保护：确保各道用户作业都在所分配的存储区内操作，互不干扰。即要防止一道作业由于发生错误而损害其它作业，特别需要防止破坏其中的系统程序。这个问题不能用特权指令来加以解决，而必须由硬件提供保护功能，并由软件配合实现。</code></pre><h3 id="存储分配的三种方式"><a href="#存储分配的三种方式" class="headerlink" title="存储分配的三种方式"></a>存储分配的三种方式</h3><p>存储分配，解决多道作业之间共享主存的问题。<br>解决的问题：确定什么时候，以什么方式，把一个作业的全部信息或作业运行时首先需要的信息分配到主存中，并使这些问题对用户来说尽可能是“透明”的。</p><blockquote><p>“对用户透明”（User Transparency）是一种计算术语，它指的是用户在使用系统或服务时，不需要关心或理解其背后的复杂实现细节。换句话说，系统或服务的复杂性对用户是”透明”的。</p></blockquote><p>解决存储分配问题的三种方式：</p><ol><li><p>直接指定方式：程序员在编程序时，或编译程序(汇编程序)对源程序进行编译(汇编)时，使用实际存储地址。<br>在多道程序环境下，应保证各作业所用的地址互不重叠。<br>采用直接指定方式分配的前提是：存储器的可用容量(空间)已经给定或者可以指定，这对单用户计算机系统是不成问题的。<br> 在多道程序发展的初期，通常把存储空间划分成若干个固定的不同大小分区，并对不同的作业指定相应的分区。因此，对编程人员或对编译程序而言，存储器的可用空间是可知的。<br>这种分配方式的实质是：由编程人员在编写程序时，或由编译程序编译源程序时，对一个作业的所有信息确定在主存存储空间中的位置。因此，这种直接指定方式的存储分配方案，不仅用户感到不便，而且存储空间的利用也不那么有效。（缺点）</p></li><li><p>静态分配方式(Static Allocation)<br>用户在编程时，或由编译程序产生的目的程序，均可从其地址空间的零地址开始；当装配程序对其进行连接装入时才确定它们在主存中的相应位置，从而生成可执行程序。也就是说，存储分配是在装入时实现的。<br>这种静态存储分配方式的特点是：<br>(1)在一个作业装入时必须分配其要求的全部存储量；<br>(2)如果没有足够的存储空间，就不能装入该作业；<br>(3)一旦一个作业进入内存后，在其退出系统之前，它一直占用着分配给它的全部存储空间；<br>(4) 作业在整个运行过程中不能在内存中“搬家”、也不能再申请存储量。<br>静态分配策略的存储管理很简单，但在多道程序系统中不能有效地共享存储器资源。</p></li><li><p>动态分配方式(Dynamic Allocation)：<br>动态分配是一种更加有效的使用主存储器的方法。<br>这种动态存储分配方式的特点是：<br>(1)作业在存储空间中的位置，也是在其装入时确定的；<br>(2)在其执行过程中可根据需要申请附加的存储空间；<br>(3)一个作业已占用的部分存储区域不再需要时，可以要求归还给系统。<br>即：这种存储分配机制能接受不可预测的分配和释放存储区域的请求，实现个别存储区域的分配和回收；<br>(4)存储区域的大小是可变的；<br>(5)允许作业在内存中“搬家”。</p><pre><code>目前，绝大多数计算机系统都采用静态或动态存储分配方式，所以，在本章只讨论这两种存储分配的实现技术，重点放在各种动态存储分配技术的实现上。</code></pre></li></ol><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>逻辑地址（相对地址，虚地址） logical address<br>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为 0，其余指令中的地址都相对于首地址而编址。不能用逻辑地址在内存中读取信息<br>物理地址（绝对地址，实地址）physical address<br>内存中存储单元的地址，可直接寻址<br>名空间 namespace<br>一个用高级语言编制的源程序，我们说它存在于由程序员建立的符号名字空间（简称名空间）。<br>地址空间<br>程序用来访问信息所用地址单元的集合，是逻辑（相对）地址的集合，由编译程序生成。<br>存储空间：主存中物理单元的集合。这些单元的编号称物理地址或绝对地址。存储空间的大小是由主存的实际容量决定的。<br>地址空间是逻辑地址的集合；存储空间是物理地址的集合。一个是“虚”的概念，一个是“实”的物体。<br>一个编译好的目标程序存在于它自己的地址空间中，当要它在计算机上运行时，才把它装入存储空间。<br>一个作业在编译、装入前后存在于不同的空间。</p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>将一个用户源程序变为一个可在内存中执行的程序，通常要经过下列几步：</p><ul><li>预处理（Preprocessing）：这是编译过程的第一步，主要处理源代码中的预处理器指令。例如，C和C++语言中的<code>#include</code>和<code>#define</code>等。预处理器将处理这些指令，如扩展包含文件，替换宏定义等，生成一个预处理后的源代码文件。</li><li>编译（Compilation）：在这个阶段，编译器将预处理后的源代码转换为汇编语言。编译器在这个过程中会进行词法分析、语法分析、语义分析和优化等操作。编译器还会检查源代码中的错误，并生成对应的错误和警告信息。</li><li>汇编（Assembly）：汇编阶段将编译阶段生成的汇编代码转换为机器语言代码，也就是目标代码。这个过程是由汇编器完成的。每一条汇编语言指令通常会被转换为一条机器语言指令。</li><li>链接（Linking）：链接阶段是将所有的目标代码和必要的库函数链接在一起，生成一个可执行文件。链接器会处理源代码中的外部符号引用，将它们与正确的地址或者符号绑定在一起。</li><li>加载（Loading）：当程序运行时，加载器（Loader）的任务是将可执行文件从硬盘加载到内存中，然后开始执行。加载器还负责解析程序对动态库的依赖，并将这些库加载到内存中。</li></ul><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><h2 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="headerlink" title="基本分页存储管理方式"></a>基本分页存储管理方式</h2><h2 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="headerlink" title="基本分段存储管理方式"></a>基本分段存储管理方式</h2><h2 id="虚拟存储器的基本概念"><a href="#虚拟存储器的基本概念" class="headerlink" title="虚拟存储器的基本概念"></a>虚拟存储器的基本概念</h2><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;存储器的层次结构&quot;&gt;&lt;a href=&quot;#存储器的层次结构&quot; class=&quot;headerlink&quot; title=&quot;存储器的层次结构&quot;&gt;&lt;/a&gt;存储器的层次结构&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;    为能更多的存放并更快地处理用户信息，目前许多计算机把存储器分为三级。</summary>
      
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>运输层 TransportLayer Part Ⅰ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-1TransportLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch5-1TransportLayer/</id>
    <published>2024-04-02T12:41:49.000Z</published>
    <updated>2024-04-02T09:05:52.676Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Introduction-and-Transport-Layer-Services"><a href="#Introduction-and-Transport-Layer-Services" class="headerlink" title="Introduction and Transport-Layer Services"></a>Introduction and Transport-Layer Services</h2><h3 id="Relationship-Between-Transport-and-Network-Layers"><a href="#Relationship-Between-Transport-and-Network-Layers" class="headerlink" title="Relationship Between Transport and Network Layers"></a>Relationship Between Transport and Network Layers</h3><p>运输层协议为运行在不同的主机上的应用进程之间提供了<strong>逻辑通信（logic communication）</strong>功能<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-14-43-16.png"><br>传输层协议运行在端系统而非路由器</p><ul><li>发送方: 将从发送应用程序接收到的报文转换成传输层分组(segment)传递给网络层 </li><li>接受方: 将数据段重新组装成报文传递到应用层</li></ul><p>传输层: <strong>进程之间</strong>的逻辑通信;传输层建立在网络层之上，负责端到端的通信会话和数据的可靠传输。传输层使用端口号来区分主机上的不同应用程序，并确保数据被正确地发送到接收应用程序。<br>网络层: <strong>主机之间</strong>的逻辑通信; 网络层负责处理数据包的发送和路由，包括 IP 地址处理和路由选择。网络层的主要目标是确定如何将数据从源主机传输到目标主机，即使这两台主机在物理上可能相隔很远，并且在它们之间可能存在多个中间节点（路由器）。网络层的一个关键协议是互联网协议（IP），它定义了数据包的格式和地址。</p><h3 id="Overview-of-the-Transport-Layer-in-the-Internet"><a href="#Overview-of-the-Transport-Layer-in-the-Internet" class="headerlink" title="Overview of the Transport Layer in the Internet"></a>Overview of the Transport Layer in the Internet</h3><p>Internet的传输层协议有两个:<br><strong>传输控制协议TCP,Transmission COntrol Protocol</strong>: 提供了一种可靠的、面向连接的服务。<br><strong>用户数据报协议UDP,User Datagram Protocol</strong>:提供不可靠、无连接的服务</p><blockquote><p>网络层的IP协议(Internet Protocol)提供了一种不可靠的、无连接的服务;IP 的服务模型是尽力而为交付服务（best-effort delivery service）</p></blockquote><p>UDP 和 TCP 最基本的责任是，将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong>。</p><h2 id="Multiplexing-and-Demultiplexing"><a href="#Multiplexing-and-Demultiplexing" class="headerlink" title="Multiplexing and Demultiplexing"></a>Multiplexing and Demultiplexing</h2><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-15-57-37.png"></p><p>运输层的多路复用与多路分解，也就是将由网络层提供的主机到主机的交付服务延伸到为运行在主机上的应用程序提供进程到进程的服务。一个进程（作为网络应用的一部分）有一个或多个<strong>套接字（socket）</strong>，它相当于从网络向进程传递数据和从进程向网络传递数据的门户。下图为进程交付过程：</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-15-48-45.png"></p><ul><li><strong>多路复用</strong>（Multiplexing）：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文传递到网络层；</li><li><strong>多路分解</strong>（Demultiplexing）：在接收端，运输层检查这些字段，标识出接收套接字，进而将报文段定向到该套接字，即将运输层报文段的数据交付到正确的套接字的工作；</li></ul><hr><p>主机收到IP数据报(IP Datagram),每个IP数据报中有源IP地址和目的IP地址,每个数据报搬运一个数据段,数据段中有源端口号和目的端口号,这样就可以将数据段交付给正确的Socket。</p><ol><li>套接字由唯一标识符；</li><li>每个报文段通过<strong>源端口号字段</strong>（source port number field）和<strong>目的端口号字段</strong>（destination port number field）来指示该报文段所要交付的套接字；<blockquote><p>端口号是一个 16 比特的数，其大小在 <code>0~65535</code>之间。<code>0~1023</code>范围的端口号称为<strong>周知端口号（well-know port number）</strong>，是受限制的。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch5-1TransportLayer-2024-04-02-16-00-52.png" alt="Ch5-1TransportLayer-2024-04-02-16-00-52"></p></blockquote></li></ol><h2 id="Connectionless-Transport-UDP"><a href="#Connectionless-Transport-UDP" class="headerlink" title="Connectionless Transport: UDP"></a>Connectionless Transport: UDP</h2><h2 id="Principles-of-Reliable-Data-Transfer"><a href="#Principles-of-Reliable-Data-Transfer" class="headerlink" title="Principles of Reliable Data Transfer"></a>Principles of Reliable Data Transfer</h2><h2 id="Connection-Oriented-Transport-TCP"><a href="#Connection-Oriented-Transport-TCP" class="headerlink" title="Connection-Oriented Transport: TCP"></a>Connection-Oriented Transport: TCP</h2><h2 id="Principles-of-Congestion-Control"><a href="#Principles-of-Congestion-Control" class="headerlink" title="Principles of Congestion Control"></a>Principles of Congestion Control</h2><h2 id="TCP-Congestion-Control"><a href="#TCP-Congestion-Control" class="headerlink" title="TCP Congestion Control"></a>TCP Congestion Control</h2>]]></content>
    
    
    <summary type="html">Transport Layer Part Ⅰ</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>The Processor Scheduling</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch3-1TheProcessorScheduling/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch3-1TheProcessorScheduling/</id>
    <published>2024-03-29T02:56:11.000Z</published>
    <updated>2024-04-05T13:15:23.142Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理机调度的层次-Process-Scheduling-Levels"><a href="#处理机调度的层次-Process-Scheduling-Levels" class="headerlink" title="处理机调度的层次 Process Scheduling Levels"></a>处理机调度的层次 Process Scheduling Levels</h2><h3 id="概述-Overview"><a href="#概述-Overview" class="headerlink" title="概述 Overview"></a>概述 Overview</h3><p>处理机是计算机系统中的重要资源,在<strong>多道程序环境</strong>下[<a href="Ch1-1OSIntroduction.md" title="操作系统概论">Ch1-1OSIntroduction#操作系统的发展过程</a>]，进程数目通常多于处理机的数目,系统必须按一定方法动态地把处理机分配给就绪队列中的一个进程;处理机利用率和系统性能（吞吐量、响应时间）在很大程度上取决于处理机调度</p><ul><li>WHAT：按什么原则分配 CPU 调度算法</li><li>WHEN：何时分配 CPU 调度的时机</li><li>HOW：如何分配 CPU 调度过程及进程的上下文切换</li></ul><h3 id="作业-JOB"><a href="#作业-JOB" class="headerlink" title="作业 JOB"></a>作业 JOB</h3><p>作业是用户在一次算题过程中或一次事务处理中，要求计算机系统所做的工作的集合<br>作业是一个比程序更广泛的概念，可以包含多个程序和数据，还配有一份作业说明书，系统根据作业说明书来对作业中的程序进行控制。在批处理系统中，以作业为单位从外存调入内存<br>用户为了让计算机完成某个特定任务，首先编写成源程序，然后提交给计算机通过编译或汇编、连接、装配、运行等步骤，最终由计算机输出用户所需要的运行结果。从计算机管理的角度看，上述一系列的由计算机执行的任务的集合就是作业。</p><blockquote><p>Job and task are today vague, ambiguous terms, especially task. A “job” often means a set of processes, while a “task” may mean a process, a thread, a process or thread, or, distinctly, a unit of work done by a process or thread.<br><a href="https://stackoverflow.com/questions/3073948/job-task-and-process-whats-the-difference">job, task and process, what’s the difference</a></p></blockquote><h4 id="作业步-Job-Step"><a href="#作业步-Job-Step" class="headerlink" title="作业步 Job Step"></a>作业步 Job Step</h4><p>计算机完成作业是通过执行一系列有序的工作步骤进行的，每个步骤完成作业的一部分特定工作;把计算机系统完成一个作业所需的一系列有序的相对独立的工作步骤称为<strong>作业步</strong><br>作业的各个作业步虽然功能相对独立，但它们之间相互关联，往往是一个作业步的执行需要使用上一个作业步的执行结果。</p><blockquote><p>从用户把源程序提交给计算机系统到得出运算结果要经过若干个工作步骤，首先计算机系统要对用户的源程序进行编辑工作来进行语法检查，再由编译或汇编工作生成目标代码。由连接工作形成装入模块，然后通过装入工作将装入模块装入内存。最后由运行工作得出运行结果。5 个步骤，每步都完成一项相对独立的工作</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-29-15-12-12.png"></p></center></blockquote><h4 id="作业状态转换-Job-State-Transition"><a href="#作业状态转换-Job-State-Transition" class="headerlink" title="作业状态转换 Job State Transition"></a>作业状态转换 Job State Transition</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-29-15-26-26.png" alt="Ch3-1TheProcessorScheduling-2024-03-29-15-26-26"></p><h4 id="JCB"><a href="#JCB" class="headerlink" title="JCB"></a>JCB</h4><p>作业提交给系统进入后备状态后，系统将为每个作业建立一个作业控制块 JCB。<br>JCB 在作业的整个运行过程中始终存在，并且其内容与作业的状态同步地动态变化。只有当作业完成并退出系统时，JCB 才被撤消。可以说，<strong>JCB 是一个作业在系统中存在的唯一标志</strong>，系统根据 JCB 才感知到作业的存在<br>作业控制块 JCB 中包含了对作业进行管理的必要信息，JCB 中的信息一部分是从用户提供的作业控制卡或作业说明书中得到，另一部分是记录作业运行过程中的动态信息<br>JCB 的具体内容因系统不同而异</p><table><thead><tr><th><strong>作业名</strong></th><th></th></tr></thead><tbody><tr><td>资源要求</td><td>预估的运行时间 最迟完成时间 要求的内存量 要求外设类型、台数 要求的文件量和输出量</td></tr><tr><td>资源使用情况</td><td>进入系统时间 开始运行时间 已运行时间 内存地址 外设台号</td></tr><tr><td>类型级别</td><td>控制方式 作业类型 优先级</td></tr><tr><td>状态</td><td></td></tr><tr><td>用户账户……</td><td></td></tr></tbody></table><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ul><li>在多道程序系统中，一个作业从提交到执行，通常都要经历多级调度,如高级调度、低级调度、中级调度以及 I&#x2F;O 调度等</li><li>系统的运行性能在很大程度上取决于调度,如吞吐量的大小、周转时间的长短、响应的及时性等</li><li>调度是多道系统的关键</li></ul><table><thead><tr><th align="center">类型</th><th align="center">运行频率</th><th align="center">运行时间</th><th align="center">算法复杂性</th><th>存储</th><th>OS</th></tr></thead><tbody><tr><td align="center">进程调度</td><td align="center">高</td><td align="center">短</td><td align="center">低</td><td>内存中</td><td>批处理,实时,分时</td></tr><tr><td align="center">中程调度</td><td align="center">中</td><td align="center">较短</td><td align="center">中</td><td>内外存互换</td><td>批处理,实时,分时</td></tr><tr><td align="center">作业调度</td><td align="center">低</td><td align="center">长</td><td align="center">高</td><td>外存到内存</td><td>批处理</td></tr></tbody></table><p>引起进程调度的事件：</p><ol><li>正在执行的进程正常终止或异常终止</li><li>正在执行的进程因某事件而阻塞(如提出 IO 请求后阻塞,调用<code>wait()</code>后阻塞,在进程通信或同步过程中执行了某种原语操作，如 P、V 操作原语，Block 原语， Wakeup 原语等后阻塞)</li><li>在引入时间片的系统中，时间片用完，进程被抢占</li><li>在抢占式系统中，就绪队列中的某进程优先级高于当前进程,或有更高优先级的进程进入就绪队列</li></ol><h4 id="高级调度-High-Scheduling"><a href="#高级调度-High-Scheduling" class="headerlink" title="高级调度 High Scheduling"></a>高级调度 High Scheduling</h4><p><strong>高级调度 High Scheduling</strong>：又称<strong>作业调度、准入调度、长程调度或接纳调度</strong>，其主要功能是根据某种算法，把外存上处于后备队列中的那些作业调入内存;它发生在一批作业完成，重新调入一批作业到内存的时候，执行频率低。批处理系统需要有作业调度，<strong>分时和实时系统无需此调度</strong>。主要用于批处理系统。其设计目标是最大限度地发挥各种资源的利用率和保持系统内各种活动的充分并行;</p><blockquote><p>例：对资源需求不同的作业进行合理搭配<br>科学计算往往需要占用大量的 CPU 时间，属于 CPU 繁忙型作业，对于 I&#x2F;O 设备的使用少；<br>数据处理要求占用较少的 CPU 时间，但要求大量 I&#x2F;O 时间，属于 I&#x2F;O 繁忙型作业；<br>有些递归计算，产生大量中间结果，需要很多内存单元存放它们，这属于内存繁忙型作业。<br>如果能把它们搭配在一起，程序 A 在使用处理机，程序 B 在利用通道 l，而程序 C 恰好利用通道 2 等，这样一来，A、B 和 C 从来不在同一时间使用同一资源，每个程序就好像单独在一个机器上运行</p></blockquote><p>在每次执行作业调度时，都须做出以下两个决定：</p><ol><li>接纳多少个作业（取决于多道程序度）<ul><li>作业太多 服务质量下降</li><li>作业太少 资源利用率低</li></ul></li><li>接纳哪些作业 （取决于采用的调度算法）</li></ol><h5 id="调度评价指标"><a href="#调度评价指标" class="headerlink" title="调度评价指标"></a>调度评价指标</h5><blockquote><p>多道程序度 Degree Of Multiprogramming：即允许多少个作业同时在内存中运行。<br>周转时间 Turnaround Time：指从作业被提交给系统开始，到作业完成为止的这段时间间隔,也称为作业周转时间<br>带权周转时间 Weighted Turnaround Time：作业的周转时间 T 与系统为它提供服务的时间 TS 之比,称为带权周转世界,$WTT&#x3D;\frac{T_{周转时间}}{T_{预计运行时间}}$<br>吞吐量 Throughput：是指在单位时间内系统所完成的作业数<br>服务时间 Service Time：作业的预计运行时间<br>响应比 Response Ratio：$RR&#x3D;\frac{T_{等待时间} + T_{预计运行时间}}{T_{预计运行时间}}&#x3D;\frac{T_{响应时间}}{T_{预计运行时间}}$,注意 <code>RR&gt;=1</code></p></blockquote><h4 id="低级调度-Low-Scheduling"><a href="#低级调度-Low-Scheduling" class="headerlink" title="低级调度 Low Scheduling"></a>低级调度 Low Scheduling</h4><p><strong>低级调度又称为进程调度或短程调度</strong>，它所调度的对象是进程。三种类型 OS 都必须配置这级调度(最基本调度);低级调度用于决定就绪队列中的哪个进程应获得处理机，然后由**分派进程(Dispatcher)**执行把分配处理机给相应进程的具体操作。其时间尺度通常是毫秒级的,且是系统中最频繁的调度,要求在实现时做到高效</p><p><strong>低级调度基本机制</strong></p><ol><li><strong>排队器</strong>为了提高进程调度的效率，应事先将系统中所有的就绪进程按照一定的方式排成一个或多个队列。</li><li><strong>分派器(调度程序)</strong> 分派器把由进程调度程序所选定的进程从就绪队列中取出，然后进行上下文切换，将处理机分配给它。</li><li><strong>上下文切换机制</strong>当对处理机进行切换时，会发生两对上下文切换操作。</li></ol><p><strong>低级调度功能</strong></p><ol><li>按某种算法选取进程（调度）。</li><li>保存处理机的现场信息（上下文切换第一步骤）</li><li>恢复新进程的 CPU 现场,从而把处理器分配给新进程（上下文切换第二步骤）。</li></ol><p><strong>进程调度方式</strong></p><p><strong>非抢占方式 Non-preemptive Mode</strong>：进程占用处理机直至自愿放弃或发生某事件被阻塞时，在把处理机分配给其他进程。</p><p>进程正在处理机上执行时，新就绪的进程进入就绪队列，该进程仍继续执行，直到其完成或发生某种事件而进入完成或阻塞状态时，才转让处理机。</p><p>优点：算法简单，系统开销小<br>缺点：紧急任务不能及时响应；短进程到达要等待长进程运行结束</p><p><strong>抢占方式 Preemptive Mode</strong>：允许暂停某个正在执行的进程，将处理机重新分配给另一个进程。</p><p>进程正在处理机上执行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程</p><p>优点：可以防止一个长进程长时间占用处理机，能为大多数进程提供更公平的服务，特别是能满足对响应时间有着较严格要求的实时任务的需求。<br>缺点：抢占方式比非抢占方式调度所需付出的开销较大，且调度算法复杂。</p><p>抢占方式 Preemptive Mode</p><ul><li>时间片原则:适用于分时、大多数实时以及要求较高的批处理系统</li><li>优先权原则:重要紧急作业优先权高</li><li>短作业(进程)优先原则。</li></ul><h4 id="中级调度-Intermediate-Level-Scheduling"><a href="#中级调度-Intermediate-Level-Scheduling" class="headerlink" title="中级调度 Intermediate-Level Scheduling"></a>中级调度 Intermediate-Level Scheduling</h4><p>中级调度 Intermediate-Level Scheduling,又称中程调度(Medium-Term Scheduling);<br>主要目的：为了提高内存利用率和系统吞吐量。<br>具体实现：</p><ul><li>使那些暂时不能运行的进程不再占用宝贵的内存资源，而将其调至外存的交换区(swap space)去等待，把此时的进程状态称为就绪驻外存状态或挂起状态。</li><li>当这些进程重又具备运行条件、且内存又稍有空闲时，由中级调度来决定把外存上的那些又具备运行条件的就绪进程，重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。</li></ul><h2 id="调度队列模型和调度准则"><a href="#调度队列模型和调度准则" class="headerlink" title="调度队列模型和调度准则"></a>调度队列模型和调度准则</h2><h3 id="调度模型-Scheduling-Model"><a href="#调度模型-Scheduling-Model" class="headerlink" title="调度模型 Scheduling Model"></a>调度模型 Scheduling Model</h3><p>三级调度都涉及进程的队列。可以形成以下三种调度队列模型</p><ul><li>仅有进程调度(低级调度)</li><li>具有高级和低级调度</li><li>具有三级调度</li></ul><h4 id="仅有进程调度"><a href="#仅有进程调度" class="headerlink" title="仅有进程调度"></a>仅有进程调度</h4><p>在分时系统中，通常仅设有进程调度,系统把这些进程组织成一个就绪队列,每个进程在执行时，可能有以下几种情况</p><ul><li>进程获得 CPU 正在执行；</li><li>任务在给定时间片内已完成，释放处理机后为完成状态；</li><li>任务在时间片内未完成，进入就绪队列末尾；</li><li>在执行期间因某事件而阻塞。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-31-18-02-37.png" alt="仅有进程调度的调度队列模型(分时系统)"><blockquote><p>就绪队列时间片轮转，常采用 FCFS(FIFO)算法， FCFS(FIFO)队列。<br>进程执行时三种情况：完成、时间片到、阻塞</p></blockquote></li></ul><h4 id="具有高级和低级调度"><a href="#具有高级和低级调度" class="headerlink" title="具有高级和低级调度"></a>具有高级和低级调度</h4><p>在批处理系统中，不仅需要进程调度，而且还要有作业调度<br>就绪队列的形式:在批处理系统中，常用高优先权队列。进程进入就绪队列时，按优先权高低插入相应位置，调度程序总是把处理机分配给就绪队列首进程<br>设置多个阻塞队列:根据事件的不同设置多个队列提高效率<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-31-18-04-45.png" alt="具有高级和低级调度的调度队列模型"></p><blockquote><p>常采用高优先权优先调度算法<br>可采用优先队列，进程来时按优先权插队，从队首调度 （效率高）<br>可采用无序列表，每次调度时，先比较优先权<br>多个阻塞队列</p></blockquote><h4 id="同时具有三级调度的调度队列模型"><a href="#同时具有三级调度的调度队列模型" class="headerlink" title="同时具有三级调度的调度队列模型"></a>同时具有三级调度的调度队列模型</h4><p>在 OS 中引入中级调度后，进程的就绪状态分为内存就绪(表示进程在内存中就绪)和外存就绪(进程在外存中就绪)。同样，阻塞状态进一步分成内存阻塞和外存阻塞两种状态。<br>在调出操作的作用下，可使进程状态由内存就绪转为外存就绪，由内存阻塞转为外存阻塞；<br>在中级调度的作用下，又可使外存就绪转为内存就绪。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-03-31-18-11-01.png" alt="同时具有三级调度的调度队列模型"></p><h3 id="选择调度方式和调度算法的若干准则"><a href="#选择调度方式和调度算法的若干准则" class="headerlink" title="选择调度方式和调度算法的若干准则"></a>选择调度方式和调度算法的若干准则</h3><p>在不同的系统中通常采用不同的调度方式和算法。</p><p><strong>调度的目标</strong></p><ul><li>提高处理机的利用率</li><li>提高系统吞吐量</li><li>尽量减少进程的响应时间</li><li>防止进程长期得不到运行</li></ul><h4 id="系统选择调度方式和算法的准则"><a href="#系统选择调度方式和算法的准则" class="headerlink" title="系统选择调度方式和算法的准则"></a>系统选择调度方式和算法的准则</h4><p><a href="#调度评价指标">调度评价指标术语</a></p><ol><li>面向用户的准则<ul><li><strong>周转时间短</strong>:用来评价批处理系统的性能、选择作业调度方式与算法的重要准则之一<ul><li>作业在外存后备队列上等待调度的时间。</li><li>进程在就绪队列等待调度的时间。</li><li>进程在 CPU 上的执行时间。</li><li>等待 I&#x2F;O 操作完成的时间。</li></ul></li><li><strong>响应时间快</strong>:用来评价分时系统的性能、选择进程调度算法的重要准则之一<br>这里的响应时间，是指从用户通过键盘提交一个请求开始，直至系统首次产生响应为止的时间。<ul><li>从键盘输入的请求信息传送到处理机的时间。</li><li>处理机对请求信息进行处理的时间。</li><li>将所形成的响应回送到终端显示器的时间。</li></ul></li><li><strong>截止时间的保证</strong>:用来评价实时系统的性能、选择实时调度算法的重要准则之一<br>截止时间，是指某任务必须开始执行的最迟时间，或必须完成的最迟时间。（也叫做时限，即 deadline）<ul><li>开始截止时间。</li><li>终止&#x2F;完成截止时间。</li></ul></li><li><strong>优先权准则</strong>:适合批处理、分时和实时系统<ul><li>让某些紧急的作业能得到及时处理。</li><li>往往还需选择抢占式调度方式，才能保证紧急作业得到及时处理。</li></ul></li></ul></li><li>面向系统的准则<ul><li><strong>系统吞吐量高</strong>:评价批处理系统<ul><li>吞吐量是指在单位时间内，系统所完成的作业数</li><li>与批处理作业的平均长度有关</li></ul></li><li><strong>处理机利用率高</strong>。主要对大、中型多用户系统，对单用户或实时系统不重要。<br>$CPU利用率 &#x3D; \frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$</li><li><strong>各类资源的平衡利用</strong>:如内存、外存、I&#x2F;O 设备等;主要对大、中型系统，对微型机或实时系统不重要。</li></ul></li></ol><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p><strong>进程切换</strong>:当一个进程占用处理机执行完(或不能继续执行)，则切换另一个进程占用处理机执行，称为进程切换。<br><strong>进程调度</strong>:把处理机分配给不同的进程占用执行，称为进程调度。实现分配处理机的程序称为<strong>调度程序</strong><br>在进程切换时，要保护执行现场。执行现场称为进程的<strong>上下文 context</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-01-14-10-26.png" alt="Process Switch"></p><p><strong>进程切换基本步骤</strong></p><ol><li>保存当前进程的上下文</li><li>更新当前运行进程的 PCB，将其状态改为就绪 Ready 或阻塞 Blocked</li><li>将 PCB 插入就绪队列或阻塞队列</li><li>改变需要投入运行的进程的 PCB，将其状态改为运行 Running</li><li>恢复新进程的上下文</li></ol><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-01-20-52-59.png"></p><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><p><strong>先到先服务调度算法</strong>(FCFS，First Come First Served) 按照作业&#x2F;进程进入系统的<strong>先后次序</strong>进行调度，先进入系统者先调度；适合于作业调度和进程调度;用于批处理系统，不适于分时系统</p><ul><li>优点：<ul><li>有利于长作业（进程）</li><li>有利于 CPU 繁忙型作业（进程）</li></ul></li><li>缺点：<ul><li>不利用短作业（进程），特别是来的较晚的短作业（进程）。</li><li>不利于 I&#x2F;O 繁忙型作业（进程）</li></ul></li></ul><h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p><strong>短作业优先的调度算法</strong>(SJF，Shortest Job First) 以要求运行时间长短进行调度，即启动要求运行时间最短的作业;可以分别用于作业调度和进程调度</p><ul><li>短作业优先(SJF)的调度算法，是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行；</li><li>短进程优先(SPF)调度算法，则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时，再重新调度。</li><li>优点<ul><li>能有效降低作业&#x2F;进程的平均等待时间</li><li>提高系统的吞吐量。</li></ul></li><li>缺点<ul><li>该算法对长作业不利，更严重的是可能将导致长作业(进程)长期不被调度</li><li>该算法完全未考虑作业的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理</li><li>由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度</li><li>无法实现人机交互</li></ul></li></ul><h3 id="SRT"><a href="#SRT" class="headerlink" title="SRT"></a>SRT</h3><p><strong>最短剩余时间优先调度算法</strong>(SRT,Shortest Remaining Time) 调度时选择预期剩余时间最短的进程。当一个新进程加入到就绪队列时，它可能比当前运行的进程具有更短的剩余时间。因此，只要新进程就绪，调度器可能抢占当前正在运行的进程。可能存在长进程被饿死的危险。</p><h3 id="PSA"><a href="#PSA" class="headerlink" title="PSA"></a>PSA</h3><p><strong>优先权调度算法</strong>(PSA,Priority) 适合于作业调度和进程调度</p><ul><li><strong>优先权类型</strong><ul><li><strong>静态优先权</strong>:静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。优点是简单易行、系统开销小。缺点：不够精确，可能出现优先权低的作业或进程长期得不到调度的情况。</li><li><strong>动态优先权</strong>:动态优先权随进程的推进或随其等待时间的增加而改变，以获得更好的调度性能</li></ul></li><li><strong>确定进程优先权的依据有</strong><ul><li>进程类型: 系统进程高，一般用户进程低。</li><li>进程对资源的需求:进程的估计执行时间、内存需求量等。要求少的进程赋予较高的优先权。</li><li>用户要求:紧迫程度、所付费用。</li></ul></li><li><strong>非抢占式优先权算法</strong>（用于批处理、要求不严的实时 OS）系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。</li><li><strong>抢占式优先权调度算法</strong>（用于要求严格的实时、性能要求较高的批处理和分时 OS）系统把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。这种抢占式的优先权调度算法，能更好地满足<strong>紧迫作业</strong>的要求<br><strong>Note: 只要新的进程到达并加入到就绪队列中，就进行优先权比较</strong><ul><li><strong>高响应比优先调度算法</strong>(HRRN,High Response Ratio Next),优先权的变化规律可描述为：$优先权 &#x3D; \frac{等待时间+预计运行时间}{预计运行时间}$ 由于等待时间与预计运行时间之和，就是系统对该作业的响应时间，故该优先权又相当于响应比 RP。据此，又可表示为$R_p &#x3D; \frac{等待时间+预计运行时间}{预计运行时间} &#x3D; \frac{响应时间}{预计运行时间}$<blockquote><p>HRRN 是介于 FCFS 和 SJ(P)F 之间的一种折中算法,HRRN 调度算法的优点是能够较好地平衡服务时间短和等待时间长的进程，避免了“饥饿”现象。由于长作业也有机会投入运行，在同一时间内处理的作业数显然要少于 SJ(P)F 算法，从而采用 HRRN 方式时其吞吐量将小于采用 SJF 算法时的吞吐量。另外，由于每次调度前要计算响应比，系统开销也要相应增加。</p></blockquote></li></ul></li></ul><h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round-Robin"></a>Round-Robin</h3><p><strong>时间片轮转调度算法</strong>(RR，Round-Robin):时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法,适合于进程调度。</p><ul><li><strong>基本原理</strong><br>系统将所有就绪进程按 FCFS 原则，排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个<strong>时间片</strong>(Time Slice)。当时间片用完时，由一个计时器发出时钟中断请求，调度程序便根据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-02-21-04-08.png"></li><li><strong>Time Slice 大小确定</strong><br>需考虑系统对响应时间的要求,就绪队列中进程的数量,系统的处理能力(保证用户键入的命令能在一个时间片内处理完毕)<ul><li>时间片太短，会增加进程切换的开销，降低系统吞吐量</li><li>时间片太长，退化成 FCFS</li></ul></li><li><strong>优缺点</strong><br>时间片的大小对计算机性能的影响。<br>存在的问题：未有效利用系统资源。<br>对于短的、计算密集型任务(CPU-bound)比较有利，因为该进程充分利用时间片，而 I&#x2F;O 密集型(I&#x2F;O-bound)任务却不利(虽然进程大部分时间都在等待 I&#x2F;O，它仍然会被分配到 CPU 时间片。这可能导致 CPU 资源的浪费)<br>常用于分时系统及事务处理系统。</li></ul><h3 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a>MQ</h3><p><strong>多级队列调度算法</strong> (MQ,Multilevel Queue):就绪队列被分解为多个独立的队列，每个队列具有自己的调度算法。前台的就绪队列是交互性作业(Interactive Job)的进程，采用时间片轮转。后台的就绪队列是批处理作业(Batch Job)的进程，采用优先权或短作业优先算法。<br>调度方式有两种：① 优先调度前台，若前台无可运行进程，才调度后台 ② 分配占用 CPU 的时间比例，如：前台 80%，后台 20%</p><blockquote><p>什么是交互性作业(Interactive Job)和批处理作业(Batch Job)？<br>Interact Job: 与用户交互的作业,在执行这类作业时，用户可以输入命令，系统立即响应并返回结果;例如 UNIX shell 的<code>ls</code><br>Batch Job:批处理作业是在没有用户交互的情况下自动执行的一组命令或程序;些作业通常被组织成批次，一次性提交给系统，然后按照预定的顺序或优先级执行</p></blockquote><h3 id="MFQ"><a href="#MFQ" class="headerlink" title="MFQ"></a>MFQ</h3><p><strong>多级反馈队列调度算法</strong>(MFQ，Multilevel Feedback Queue):最通用的调度算法，多数 OS 都使用该方法或其变形，如 UNIX、Windows 等。它可以看作是更成熟的多级队列调度,其任务可以在队列之间移动,从而更细致的区分任务</p><blockquote><p>Note:MFQ 均为为抢占式;高优先级队列中有进程进入时，会抢占低优先级队列中进程的 CPU。被抢占的进程不降级，回到原级队列中，下次仍然执行该级队列的时间片。</p></blockquote><p><strong>MFQ 调度算法</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-02-21-45-44.png"></p><ul><li>设置多个就绪队列,记作 RQ0，RQ1 … RQn，并为各个队列赋予不同的优先级队列。 第一个队列的优先级最高，第二个次之，其余各队列的优先级逐个降低。规定高优先级队列时间片小</li><li>一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统；进程一次时间片没执行完，就降至下一级队列，以此类推，降至最低优先级队列后，一直在此队列中不再下降。</li><li>系统优先调度高优先级队列中的进程，仅当 RQ0 空闲时才调度 RQ1 队列进程，以此类推</li></ul><p><strong>MFQ 性能</strong></p><ul><li>对于终端型作业用户，其所提交的作业大都属于较小的交互型作业，系统只要使这些作业在箫 1 队列规定的时间片内完成，终端型作业用户就会感到满足。</li><li>对于短批处理作业用户，如果其作业在第 1 队列中执行一个时间片即可完成，便可获得与终端作业一样的响应时间。对于稍长批处理作业用户，其作业通常只须在第 2 队列和第 3 队列各执行 1 个时间片即可完成，周转时间仍然较短。</li><li>对于长批处理作业用户，其将依次在第 1,2…n 个队列中运行，然后再按轮转方式运行，用户不必担心其作业长期得不到处理。因此，多级反馈队列调度算法能满足多用户需求。</li></ul><h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><ol><li><p>保证调度算法<br>保证的是绝对运行时间，即启动后在某个时间段内必须获得多少运行时间。<br>例如 N 个进程平均分配时间。</p></li><li><p>公平分享调度算法<br>按照用户数量平均分配时间，而不是进程间平均分配。</p></li></ol><blockquote><p>例：公平分享调度算法<br>用户 1 有 4 个进程 ABCD<br>用户 2 有 1 个进程 E</p><ol><li>时间片轮转法:<code>ABCDEABCDEABCDEABCDE……</code></li><li>所有用户获得相同的处理机时间:<code>AEBECEDEAEBECEDEAEBECEDE……</code></li><li>用户 1 获得的处理机时间是用户 2 的两倍:<code>ABECDEABECDEABECDEABECDE……</code></li></ol></blockquote><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p><strong>实时任务</strong>：任务的结束时间有严格约束(Deadline),即任务执行必须在 Deadline 之前完成;具有紧迫性。<br>前述算法不能很好地满足实时系统对调度的特殊要求，所以引入实时调度。<br><strong>实时操作系统 RTOS Real-Time Operating System</strong> 对外部输入的信息，实时操作系统能够在规定的时间内处理完毕并做出反应正确性:不仅要求计算逻辑的正确，而且要求在规定的时间内得到该结果通常给定一个开始时间或者结束时间的最后期限;多用于工业、军事等控制领域或实时信息处理方面<br><strong>硬实时系统</strong>有一个刚性的、不可改变的时间限制，它不允许任何超出时限的错误。超时错误会带来损害甚至导致系统失败、或者导致系统不能实现它的预期目标<br><strong>软实时系统</strong>的时限是柔性灵活的，它可以容忍偶然的超时错误。失败后造成的后果并不严重，例如在网络中仅仅轻微地降低了系统的吞吐量<br><strong>硬实时 HRT 与软实时 SRT</strong>之间最关键的差别在于：软实时只能提供统计意义上的实时。例如，有的应用要求系统在 95%的情况下都会确保在规定的时间内完成某个动作，而不一定要求 100%</p><h3 id="实现实时调度的基本条件"><a href="#实现实时调度的基本条件" class="headerlink" title="实现实时调度的基本条件"></a>实现实时调度的基本条件</h3><ol><li>提供必要的调度信息</li></ol><ul><li>任务的到达时间,开始截止时间,执行时间,完成截止时间</li><li>资源要求</li><li>优先级(若错过开始截止时间则赋予“绝对”优先级)</li></ul><ol start="2"><li>系统处理能力强<br>若处理机的处理能力不够强，则有可能因处理机忙不过来而使某些实时任务不能得到及时处理，从而导致发生难以预料的后果。<br>假定系统中有 m 个周期性的硬实时任务，它们的处理时间可表示为 Ci ，周期时间表示为 Pi，则在单处理机情况下，必须满足$\sum_{i&#x3D;1}^{m} \frac{C_i}{P_i} \leq 1$;若为多处理机系统,假设有 n 个处理机，则需满足$\sum_{i&#x3D;1}^{m} \frac{C_i}{P_i} \leq n$</li><li>采用抢占式调度机制:调度程序先调度开始截止时间即将到达的任务。</li><li>具有快速切换机制</li></ol><ul><li>具有快速响应外部中断的能力:及时响应紧迫的外部事件的中断请求</li><li>快速的任务分派能力:使系统中的每个运行功能单位适当的小，以减少任务切换的时间开销。</li></ul><h3 id="实时调度算法分类"><a href="#实时调度算法分类" class="headerlink" title="实时调度算法分类"></a>实时调度算法分类</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1TheProcessorScheduling-2024-04-05-20-46-52.png"></p><p><strong>非抢占式调度算法</strong></p><ol><li>非抢占式轮转调度算法（如工业生产群控系统）<br>调度程序每次选择队列中的第一个任务投入运行。该任务完成后，便把它挂在轮转队列的末尾，等待下次调度运行，而调度程序再选择下一个(队首)任务运行。<br>常用于要求不太严格的实时控制系统。</li><li>非抢占优先权调度算法<br>如果在实时系统中存在着要求较为严格(响应时间为数百毫秒)的任务，则可采用非抢占式优先调度算法为这些任务赋予较高的优先级。当这些实时任务到达时，把它们安排在就绪队列的队首，等待当前任务自我终止或运行完成后才能被调度执行。常用于有一定要求的实时控制系统。</li></ol><p><strong>抢占式调度算法</strong></p><ol><li>基于时钟中断的抢占式优先权调度算法</li><li>立即抢占(Immediate Preemption)的优先权调度算法</li></ol><h3 id="常见的实时调度算法"><a href="#常见的实时调度算法" class="headerlink" title="常见的实时调度算法"></a>常见的实时调度算法</h3><h4 id="最早截止时间优先即-EDF-Earliest-Deadline-First-算法"><a href="#最早截止时间优先即-EDF-Earliest-Deadline-First-算法" class="headerlink" title="最早截止时间优先即 EDF(Earliest Deadline First) 算法"></a>最早截止时间优先即 EDF(Earliest Deadline First) 算法</h4><p>优先级确定：根据任务的开始截止时间来确定任务的优先级。截止时间愈早，其优先级愈高。<br>实时任务就绪队列：按各任务截止时间的早晚排序；具有最早截止时间的任务排在队列的最前面。<br>调度顺序：总是选择就绪队列中的第一个任务，为之分配处理机，使之投入运行。<br>适用范围：既可用于抢占式调度，也可用于非抢占式调度方式中。</p><h4 id="最低松弛度优先即-LLF-Least-Laxity-First-算法"><a href="#最低松弛度优先即-LLF-Least-Laxity-First-算法" class="headerlink" title="最低松弛度优先即 LLF(Least Laxity First)算法"></a>最低松弛度优先即 LLF(Least Laxity First)算法</h4><p>$Laxity &#x3D; Deadline - RemainingServiceTime - CurrentTime$<br>松弛度&#x3D;完成截止时间–剩余运行时间–当前时间 (假设从现在执行任务, 完成的时间为 t1, 则松弛度为截止时间-t1)</p><p>该算法按松弛度排序实时任务的就绪队列，松弛度值最小的任务排在队列最前面，调度程序总是选择就绪队列中的队首任务执行。<br>该算法主要用于可抢占调度方式中。</p><p>q*</p><p>当等待任务的松弛度值为0时才进行抢占（如20ms时虽然A2的松弛度比B1的松弛度小，但A2并没有抢占B1）。<br>当有任务执行时，只有等待任务的松弛度值为0才会发生任务的调度，其他情况不发生调度。</p><p>任务执行结束后或无任务执行时，再比较等待任务的松弛度值，较小的先执行。 </p><h2 id="d"><a href="#d" class="headerlink" title="d"></a>d</h2>]]></content>
    
    
    <summary type="html">介绍处理机调度的层次 调度队列模型和调度准则调度算法 实时调度</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>应用层 ApplicationLayer Part Ⅱ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-2ApplicationLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-2ApplicationLayer/</id>
    <published>2024-03-28T12:41:49.000Z</published>
    <updated>2024-04-02T09:05:52.721Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS——The-Internet’s-Directory-Service"><a href="#DNS——The-Internet’s-Directory-Service" class="headerlink" title="DNS——The Internet’s Directory Service"></a>DNS——The Internet’s Directory Service</h2><h3 id="Services-Provided-by-DNS"><a href="#Services-Provided-by-DNS" class="headerlink" title="Services Provided by DNS"></a>Services Provided by DNS</h3><p>识别主机的两种方式：通过<strong>hostname</strong>或者<strong>IP address</strong>。人们喜欢记忆主机名标识方式，而路由器喜欢定长的、有着层次结构的 IP 地址。DNS 提供了一种将主机名转换为 IP 地址的服务。</p><p><strong>DNS(Domain Name System),域名系统</strong></p><ul><li>分布式数据库：一个由分层 DNS 服务器实现的分布式数据库</li><li>应用层协议：DNS 服务器实现域名转换,域名&#x2F;地址转换;DNS 协议运行在 <code>UDP</code>之下，使用 <code>53</code>号端口；<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-16-31.png"></li></ul><p><strong>DNS 服务器提供的功能</strong></p><ul><li>主机名到 IP 地址的转换（hostname to IP address translation）；</li><li>主机别名（host aliasing）：一个主机可以有一个规范主机名和多个主机别名,应用程序调用 DNS 获取主机别名对应的规范主机名（canonical hostname）以及主机的 IP 地址；</li><li>邮件服务器别名（mail server aliasing）；</li><li>负载分配（load distribution）：繁忙的站点被<strong>冗余分布在多台服务器</strong>上，每台服务器运行在不同的端系统上，每个都有着不同的 IP 地址。由于这些冗余的 Web 服务器，一个 IP 地址集合对应<strong>一个规范主机名</strong>。当客户对映射到某处到某地址集合的名字发出一个 DNS 请求时，该服务器用 IP 地址的整个集合进行响应，但在每个回答中循环这些地址次序。因为客户通常<strong>总是向 IP 地址排在最前面的服务器发送 HTTP 请求报文</strong>，所以 DNS 就在所有这些冗余的 Web 服务器之间循环分配了负载；</li></ul><h3 id="Overview-of-How-DNS-Works"><a href="#Overview-of-How-DNS-Works" class="headerlink" title="Overview of How DNS Works"></a>Overview of How DNS Works</h3><h4 id="集中式设计的问题"><a href="#集中式设计的问题" class="headerlink" title="集中式设计的问题"></a>集中式设计的问题</h4><ul><li>单点故障（a single point of failure）；</li><li>通信容量（traffic volume）；</li><li>远距离的集中式数据库（distant centralized database）；</li><li>维护（maintenance）；</li></ul><h4 id="分布式-DNS-服务器的层次结构"><a href="#分布式-DNS-服务器的层次结构" class="headerlink" title="分布式 DNS 服务器的层次结构"></a>分布式 DNS 服务器的层次结构</h4><ul><li>Root DNS servers:负责记录顶级域名服务器的信息</li><li>Top-Level Domain DNS servers:负责顶级域名 com, org, net, edu, etc, 和所有国家的顶级域名 uk, fr, ca, jp.</li><li>Authoritative DNS servers:在因特网上具有公共可访问主机（如 Web 服务器和邮件服务器）的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。组织机构的权威 DNS 服务器负责保存这些 DNS 记录。</li><li>Local DNS servers:严格来说不属于该服务器的层次结构,每个 ISP（如居民区 ISP、公司、大学）都有一个本地 DNS,也叫默认服务器,当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器,它起着代理的作用，转发请求到层次结构中。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-18-29.png"></p><blockquote><p>PS:你可以通过<code>ipconfig /all</code>命令查看本地 DNS 服务器的地址。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Wireless LAN adapter WLAN:</span><br><span class="line">Connection<span class="literal">-specific</span> DNS Suffix . :</span><br><span class="line">Description . . . . . . . . . . . : Intel(<span class="built_in">R</span>) Wi<span class="literal">-Fi</span> <span class="number">6</span> AX200 <span class="number">160</span>MHz</span><br><span class="line">Physical Address. . . . . . . . . : <span class="number">48</span><span class="literal">-51-C5-27-0C-9F</span></span><br><span class="line">DHCP Enabled. . . . . . . . . . . : Yes</span><br><span class="line">Autoconfiguration Enabled . . . . : Yes</span><br><span class="line">IPv4 Address. . . . . . . . . . . : <span class="number">113.54</span>.<span class="number">231.1</span>(Preferred)</span><br><span class="line">Subnet Mask . . . . . . . . . . . : <span class="number">255.255</span>.<span class="number">224.0</span></span><br><span class="line">Lease Obtained. . . . . . . . . . : Thursday, March <span class="number">28</span>, <span class="number">2024</span> <span class="number">12</span>:<span class="number">25</span>:<span class="number">52</span> PM</span><br><span class="line">Lease Expires . . . . . . . . . . : Thursday, March <span class="number">28</span>, <span class="number">2024</span> <span class="number">3</span>:<span class="number">16</span>:<span class="number">27</span> PM</span><br><span class="line">Default Gateway . . . . . . . . . : <span class="number">113.54</span>.<span class="number">224.1</span></span><br><span class="line">DHCP Server . . . . . . . . . . . : <span class="number">113.54</span>.<span class="number">224.1</span></span><br><span class="line">DNS Servers . . . . . . . . . . . : <span class="number">202.112</span>.<span class="number">14.21</span></span><br><span class="line"><span class="number">202.112</span>.<span class="number">14.11</span></span><br><span class="line">NetBIOS over Tcpip. . . . . . . . : Enabled</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-41-23.png"></p></blockquote><h4 id="DNS-查询方法"><a href="#DNS-查询方法" class="headerlink" title="DNS 查询方法"></a>DNS 查询方法</h4><p><strong>递归 Recursive Query</strong>：客户端只发一次请求，要求对方给出最终结果。<br><strong>迭代 Iterated Quert</strong>：客户端发出一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-14-57-53.png"></p><h4 id="DNS-缓存"><a href="#DNS-缓存" class="headerlink" title="DNS 缓存"></a>DNS 缓存</h4><ul><li>一旦名字服务器获得 DNS 映射, 它将缓存该映射到局部内存<ul><li>服务器在一定时间后将丢弃缓存的信息</li><li>本地 DNS 服务器可以缓存 TLD 服务器的 IP 地址</li><li>因此根 DNS 服务器不会被经常访问</li></ul></li><li>权威 DNS 服务器记录更新：IETF 动态更新&#x2F;通报机制</li></ul><h3 id="DNS-Records-and-Messages"><a href="#DNS-Records-and-Messages" class="headerlink" title="DNS Records and Messages"></a>DNS Records and Messages</h3><h4 id="DNS-Resource-Records"><a href="#DNS-Resource-Records" class="headerlink" title="DNS Resource Records"></a>DNS Resource Records</h4><p>DNS 服务器中存储了大量的资源记录——Resource Record(RR),RR 是一个包含了下列字段的 4 元组<code>(name, value, type, ttl)</code><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-15-31-40.png"></p><h4 id="DNS-Messages"><a href="#DNS-Messages" class="headerlink" title="DNS Messages"></a>DNS Messages</h4><ul><li>Identification 标识符: 16 位，查询和应答报文使用相同的标识符</li><li>Flags 标志:有若干个标志构成，分别标识不同的功能<ul><li>查询&#x2F;应答－0&#x2F; 1</li><li>查询希望是&#x2F;非递归查询－1&#x2F;0</li><li>应答可&#x2F;否获得(支持)递归查询－1&#x2F;0</li><li>应答是&#x2F;否来自权威名字服务器－1&#x2F; 0</li></ul></li><li>Questions 问题部分:查询的 Name, type</li><li>Answers 回答部分:对于查询,应答的资源记录可以多个资源记录，由于可以有多个 IP 地址</li><li>Authority 权威部分:域对应的权威名字服务器的信息</li><li>Additional information 附加信息部分:权威名字服务器的 IP 地址等其他有帮助的记录.</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-15-32-48.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dns.message</span><br><span class="line"><span class="keyword">import</span> dns.query</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 DNS 查询报文对象</span></span><br><span class="line">query = dns.message.make_query(<span class="string">&quot;baidu.com&quot;</span>, dns.rdatatype.ANY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 DNS 查询并接收响应报文,设置DNS服务器的IP地址为202.112.14.21</span></span><br><span class="line">response = dns.query.tcp(query, <span class="string">&quot;202.112.14.21&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印输出报文的信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Identification: <span class="subst">&#123;response.<span class="built_in">id</span>&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Flags: <span class="subst">&#123;response.flags&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Questions: <span class="subst">&#123;response.question&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Answers: <span class="subst">&#123;response.answer&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Authority: <span class="subst">&#123;response.authority&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Additional information: <span class="subst">&#123;response.additional&#125;</span>&quot;</span>)</span><br><span class="line">[OUTPUT]</span><br><span class="line">Identification: <span class="number">41532</span></span><br><span class="line">Flags: <span class="number">33152</span></span><br><span class="line">Questions: [&lt;DNS baidu.com. IN ANY RRset: []&gt;]</span><br><span class="line">Answers: [&lt;DNS baidu.com. IN A RRset: [&lt;<span class="number">110.242</span><span class="number">.68</span><span class="number">.66</span>&gt;, &lt;<span class="number">39.156</span><span class="number">.66</span><span class="number">.10</span>&gt;]&gt;, &lt;DNS baidu.com. IN NS RRset: [&lt;ns7.baidu.com.&gt;, &lt;ns2.baidu.com.&gt;, &lt;dns.baidu.com.&gt;, &lt;ns3.baidu.com.&gt;, &lt;ns4.baidu.com.&gt;]&gt;]</span><br><span class="line">Authority: []</span><br><span class="line">Additional information: [&lt;DNS dns.baidu.com. IN A RRset: [&lt;<span class="number">110.242</span><span class="number">.68</span><span class="number">.134</span>&gt;]&gt;, &lt;DNS ns2.baidu.com. IN A RRset: [&lt;<span class="number">220.181</span><span class="number">.33</span><span class="number">.31</span>&gt;]&gt;, &lt;DNS ns3.baidu.com. IN A RRset: [&lt;<span class="number">153.3</span><span class="number">.238</span><span class="number">.93</span>&gt;, &lt;<span class="number">36.155</span><span class="number">.132</span><span class="number">.78</span>&gt;]&gt;, &lt;DNS ns4.baidu.com. IN A RRset: [&lt;<span class="number">111.45</span><span class="number">.3</span><span class="number">.226</span>&gt;, &lt;<span class="number">14.215</span><span class="number">.178</span><span class="number">.80</span>&gt;]&gt;, &lt;DNS ns7.baidu.com. IN A RRset: [&lt;<span class="number">180.76</span><span class="number">.76</span><span class="number">.92</span>&gt;]&gt;, &lt;DNS ns7.baidu.com. IN AAAA RRset: [&lt;240e:bf:b801:<span class="number">1002</span>:<span class="number">0</span>:ff:b024:26de&gt;, &lt;240e:<span class="number">940</span>:<span class="number">603</span>:<span class="number">4</span>:<span class="number">0</span>:ff:b01b:589a&gt;]&gt;]</span><br></pre></td></tr></table></figure><h2 id="Peer-to-Peer-File-Distribution"><a href="#Peer-to-Peer-File-Distribution" class="headerlink" title="Peer-to-Peer File Distribution"></a>Peer-to-Peer File Distribution</h2><ul><li>没有总是在线的服务器</li><li>任意端系统之间直接通信</li><li>对等方之间可以间断连接并可以改变 IP 地址</li></ul><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>BitTorrent 是一种用于高效分发文件的协议和技术。它是一种点对点（P2P）文件共享协议，允许用户在互联网上分享和下载文件。</p><p>相比于传统的文件下载方式，BitTorrent 采用了一种分布式的下载模式，使得文件可以同时从多个来源下载，从而提高了下载速度和可靠性。BitTorrent 协议的核心思想是让下载者同时充当上传者，即将下载好的文件块分享给其他下载者，从而实现文件的高效传输。</p><p>以下是 BitTorrent 的工作原理：</p><p>种子文件（Torrent File）的创建和分享：对于要被共享的文件，首先需要创建一个种子文件，该文件包含了文件的元数据和跟踪器（Tracker）的信息。跟踪器是协调下载者之间连接的服务器，帮助下载者找到其他参与文件共享的人。这个种子文件被分享给其他用户。</p><p>Peers 的连接和数据交换：下载者（也称为 Peer）通过 BitTorrent 客户端连接到跟踪器，并获取参与共享文件的其他 Peer 的信息。然后，下载者与这些 Peer 建立连接，开始交换文件块。下载者不仅从上传者下载文件块，也同时将自己已经下载好的文件块分享给其他下载者。</p><p>分块下载和校验：文件被分成小块（通常为 256KB 或 512KB），下载者通过与其他 Peer 交换文件块来逐步下载文件。每个文件块都有一个唯一的标识符，以便下载者之间进行正确的数据交换。下载者还会进行校验，确保下载的文件块的完整性和准确性。</p><p>做种（Seeding）：当下载者完全获得整个文件后，他们可以选择继续将文件保持在 BitTorrent 网络中作为种子继续分享给其他下载者，这称为做种。通过做种，更多的用户可以从他们那里下载文件，从而促进整个网络的稳定性和可扩展性。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-15-52-44.png"></p><h2 id="Video-Streaming-and-Content-Distribution-Networks"><a href="#Video-Streaming-and-Content-Distribution-Networks" class="headerlink" title="Video Streaming and Content Distribution Networks"></a>Video Streaming and Content Distribution Networks</h2><h3 id="HTTP-Streaming-And-DASH"><a href="#HTTP-Streaming-And-DASH" class="headerlink" title="HTTP Streaming And DASH"></a>HTTP Streaming And DASH</h3><p>HTTP 流所有客户接受到相同编码的视频，但对不同用户或者不同时间，客户可用的带宽大小有很大不同。<strong>HTTP 的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）</strong>：视频编码成几个不同的版本，其中每个版本具有不同的比特率，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒的视频段数据块。</p><p>每个视频版本存储在 HTTP 服务器中，每个版本都有一个不同的 URL。HTTP 服务器也有一个<strong>告示文件（manifest file）</strong>，为每个版本提供了一个 URL 及其比特率。</p><h3 id="Content-Distribution-Networks"><a href="#Content-Distribution-Networks" class="headerlink" title="Content Distribution Networks"></a>Content Distribution Networks</h3><p>如何从海量的视频中，挑选出某些内容，采用流的方式发送给成千上万的用户?<br>CDN 使用多台分布在全球各地的服务器（这些服务器被称为边缘节点），这些服务器存储了网站中内容的副本。当用户请求访问网站时，CDN 会根据用户的地理位置，选择距离用户最近的边缘节点来响应请求。</p><ul><li><strong>Private CDN</strong> 私有 CDN 是由单个组织或企业自己建立和管理的内容分发网络。它通常由该组织或企业在自己的数据中心或云环境中架设服务器节点，用于存储和分发自己的内容。私有 CDN 的优势在于对内容的控制权和安全性更高。</li><li><strong>Third-party CDN</strong> 第三方 CDN 是由专业的 CDN 提供商运营和管理的网络基础设施。这些提供商拥有全球分布的服务器节点，并为各种网站和应用提供内容分发服务。第三方 CDN 通过在全球各地部署服务器节点，将站点或应用的静态和动态内容缓存到离用户近的节点，并通过智能路由和负载均衡，将用户的请求引导到最近的节点。</li></ul><p><strong>CDN Operation:</strong></p><p>When a browser in a user’s host is instructed to retrieve a specific video (identified by a URL), the CDN must intercept(截获) the request so that it can</p><ol><li>Determine a suitable CDN server cluster(集群) for that<br>client at that time</li><li>Redirect the client’s request to a server in that cluster.<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-20-11-15.png"><blockquote><p>许多 CDN 利用 DNS 截获用户请求并将用户重定向到最近的 CDN 服务器。</p></blockquote></li></ol><p>如下是一个用户访问 NetCinema 网页中视频的过程：</p><ul><li>用户访问 NetCinema 的网页。</li><li>当用户点击链接<code>http://video.netcinema.com/6Y7B23V</code>时，用户的主机会发送一个寻找<code>video.netcinema.com</code>的 DNS 查询。</li><li>用户的本地 DNS 服务器（LDNS）将 DNS 查询转发到 NetCinema 的权威 DNS 服务器，该服务器注意到主机名<code>video.netcinema.com</code>中的字符串 video。为了将 DNS 查询交给 KingCDN，NetCinema 的权威 DNS 服务器不返回 IP 地址，而是返回 KingCDN 域中的主机名，例如<code>a1105.kingcdn.com</code></li><li>DNS 查询进入 KingCDN 的私有 DNS 基础设施;用户的 LDNS 然后发送查询<code>a1105.kingcdn.com</code>的请求;KingCDN 的 DNS 系统指定合适的 KingCDN 内容服务器,将其 IP 地址返回给 LDNS。</li><li>LDNS 将提供内容的 CDN 节点的 IP 地址转发给用户的主机。</li><li>一旦客户端收到 KingCDN 内容服务器的 IP 地址，它就会与该 IP 地址的服务器建立 TCP 连接，并发出一个 HTTP GET 请求获取视频。如果使用 DASH，服务器会首先向客户端发送一个清单文件，其中包含一个 URL 列表，每个版本的视频对应一个 URL，客户端会动态地从不同的版本中选择块。</li></ul><h2 id="Socket-Programming-Creating-Network-Applications"><a href="#Socket-Programming-Creating-Network-Applications" class="headerlink" title="Socket Programming: Creating Network Applications"></a>Socket Programming: Creating Network Applications</h2><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-2ApplicationLayer-2024-03-28-20-40-38.png"></p>]]></content>
    
    
    <summary type="html">Application Layer Part Ⅱ,DNS,P2P,Video Streaming,CDN,Socket Programming</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>应用层 ApplicationLayer Part Ⅰ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-1ApplicationLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch6-1ApplicationLayer/</id>
    <published>2024-03-28T05:33:20.000Z</published>
    <updated>2024-04-02T09:09:10.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Principles-of-Network-Applications"><a href="#Principles-of-Network-Applications" class="headerlink" title="Principles of Network Applications"></a>Principles of Network Applications</h2><h3 id="Network-application-architecture"><a href="#Network-application-architecture" class="headerlink" title="Network application architecture"></a>Network application architecture</h3><p><strong>应用程序体系结构（application architecture）</strong>由应用程序研发者设计，规定了如何在各种端系统上组织该应用程序。现代网络应用程序中所使用的两种主流体系结构：<strong>the client-server architecture 和 the peer-to-peer (P2P) architecture.</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-18-49-55.png"></p><h4 id="Client-Server-Architecture"><a href="#Client-Server-Architecture" class="headerlink" title="Client-Server Architecture"></a>Client-Server Architecture</h4><ul><li><p>Server</p><ul><li>总是在线（always on host）；</li><li>永久的 IP 地址（permanent IP address）；</li><li>配置在数据中心（often in data centers）；</li></ul></li><li><p>Client</p><ul><li>与服务器沟通联系；</li><li>被间歇性（intermittently）的连接；</li><li>拥有动态地址；</li><li>客户之间不直接联系；</li></ul></li></ul><h4 id="P2P-Architecture"><a href="#P2P-Architecture" class="headerlink" title="P2P Architecture"></a>P2P Architecture</h4><ul><li>没有总是打开的服务器</li><li>任意一对主机(peer)直接相互通信</li><li>对等方间歇连接并且可以改变 IP 地址</li><li>自我可扩展性 self-scalability</li></ul><blockquote><p>P2P (Peer-to-Peer) 网络的自我可扩展性（self-scalability）是指网络的能力，随着参与节点数量的增加，其性能和效率不会显著下降，甚至可能会提高。这种特性是由 P2P 网络的分散性和去中心化特性赋予的。<br>在许多传统的客户端-服务器模型中，所有的请求都会集中到一台或几台服务器上，随着用户数量的增加，服务器可能会遭受过载，导致性能下降。然而，在 P2P 网络中，每个节点都可以成为数据的提供者和消费者，因此负载可以在所有的节点上进行分布，使得网络能够更好地扩展。<br>然而，这并不意味着 P2P 网络没有扩展性问题。例如，当网络规模变得非常大时，查找和路由可能会变得复杂和昂贵。因此，需要使用高效的查找和路由算法，例如分布式哈希表（DHT），来确保网络的可扩展性。</p></blockquote><h4 id="C-S-与-P2P-混合的体系结构"><a href="#C-S-与-P2P-混合的体系结构" class="headerlink" title="C&#x2F;S 与 P2P 混合的体系结构"></a>C&#x2F;S 与 P2P 混合的体系结构</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-19-44-10.png"></p><h3 id="Processes-Communicating"><a href="#Processes-Communicating" class="headerlink" title="Processes Communicating"></a>Processes Communicating</h3><h4 id="Client-And-Server-Process"><a href="#Client-And-Server-Process" class="headerlink" title="Client And Server Process"></a>Client And Server Process</h4><ul><li>进程：运行在端系统中的程序[<a href="../../UESTC/OS/ProcessvsThread.md" title="Process &amp; Thread">ProcessVsThread#Definition</a>]</li><li>同一主机上的两个进程通过内部进程通信机制进行通信</li><li>不同主机上的进程通过交换报文(message)相互通信</li></ul><blockquote><p><strong>客户进程</strong>：发起通信的进程；<br><strong>服务进程</strong>：在会话开始时等待联系的进程；</p></blockquote><h4 id="The-Interface-Between-the-Process-and-the-Computer-Network"><a href="#The-Interface-Between-the-Process-and-the-Computer-Network" class="headerlink" title="The Interface Between the Process and the Computer Network"></a>The Interface Between the Process and the Computer Network</h4><p>大多数应用程序由许多<strong>互相通信的进程对</strong>(pairs of communicating processes)组成,任何两个进程之间发送的报文都需要经由底层的网络;<strong>套接字 Socket</strong>作为软件接口,向进程提供发送和接受报文功能</p><p>由于该套接字是建立网络应用的可编程接口，因此套接字被称为应用程序和网络之间的<strong>应用程序编程接口（Application Programming Interface，API）</strong>。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-20-09-22.png"></p><h4 id="Addressing-Processes"><a href="#Addressing-Processes" class="headerlink" title="Addressing Processes"></a>Addressing Processes</h4><ul><li><strong>IP Address</strong> 用于唯一标识 Internet 上的主机</li><li><strong>Port</strong> 用于标识目的主机的接受进程</li></ul><blockquote><p>发送进程还必须识别在主机中运行的接收进程（更具体地说，是接收信息的 Socket）。这个信息是必要的，因为通常一个主机可能运行着许多网络应用。目标端口号就是为了这个目的而设立的。一些流行的应用已经被分配了特定的端口号。例如，Web 服务器被标识为 80 号端口。邮件服务器进程（使用 SMTP 协议）被标识为 25 号端口。</p></blockquote><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-20-15-36.png" style="zoom:50%;" /></center><h3 id="Transport-Services-Available-to-Applications"><a href="#Transport-Services-Available-to-Applications" class="headerlink" title="Transport Services Available to Applications"></a>Transport Services Available to Applications</h3><ol><li><p><strong>Reliable Data Transfer</strong></p><ul><li>一些应用需要 100%可靠数据传输,如金融应用</li><li>loss-tolerant applications 允许丢包(loss),常见的有多媒体应用,如视频通话等</li></ul></li><li><p><strong>Throughout</strong></p><ul><li>具有吞吐量要求是应用程序被称为带宽敏感的应用（bandwidth-sensitive application）；</li><li>弹性应用（elastic application）能够根据当时可用的带宽或多或少地利用可供使用的吞吐量；</li></ul></li><li><p><strong>Timing</strong></p><ul><li>低延时（low delay）要求；</li></ul></li><li><p><strong>Security</strong></p><ul><li>传输数据的 Cryption&amp;Decryption</li><li>Confidentiality(保密性)<ul><li>数据完整性 Data Integrity</li><li>终端验证 end-point authentication</li></ul></li></ul><table><thead><tr><th>Application</th><th>Data Loss</th><th>Throughtput</th><th>Time-Senstive</th></tr></thead><tbody><tr><td>文件传输</td><td>No loss</td><td>elastic</td><td>no</td></tr><tr><td>电子邮件</td><td>No loss</td><td>elastic</td><td>no</td></tr><tr><td>Web</td><td>No loss</td><td>elastic</td><td>no</td></tr><tr><td>实时音频&#x2F;视频</td><td>Loss-tolernet</td><td>音频: 几 kbps-1Mbps</td><td>yes,100 msec</td></tr><tr><td>存储音频&#x2F;视频</td><td>Loss-tolernet</td><td>视频:10kbps-5Mbps</td><td>yes, 几秒</td></tr><tr><td>交互式游戏</td><td>Loss-tolernet</td><td>视频:10kbps-5Mbps</td><td>yesy, 100 msec</td></tr><tr><td>即时讯息</td><td>No loss</td><td>几 kbps 以上 elastic</td><td>yes and no</td></tr></tbody></table></li></ol><h3 id="Transport-Services-Provided-by-the-Internet"><a href="#Transport-Services-Provided-by-the-Internet" class="headerlink" title="Transport Services Provided by the Internet"></a>Transport Services Provided by the Internet</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-23-27-14.png"></p><ol><li><p><strong>TCP 服务</strong></p><ul><li><p>面向连接的服务（connection-oriented）：报文开始流动之前，TCP 让客户和服务器互相交换运输层控制信息（握手阶段），握手阶段后，一条 TCP 连接（TCP connection）就在两条进程的套接字之间建立；</p></li><li><p>可靠的数据传送服务（reliable transport）：无差别、按适当顺序交付所有发送的数据；</p></li><li><p>拥塞控制机制（congestion control）</p></li><li><p>安全套接字层（Secure Sockets Layer，SSL）提供了关键的进程到进程的安全性服务<br>🚥<code>http + SSL = https</code></p> <center> <img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-23-01-46.png" style="zoom:50%;" /> </center></li></ul></li><li><p><strong>UDP 服务</strong></p><ul><li>无连接</li><li>尽最大努力交付</li><li>面向报文</li><li>无拥塞控制</li><li>支持一对一，一对多，多对一和多对多的交互通信</li><li>首部开销小</li></ul></li></ol><h3 id="Application-Layer-Protocols"><a href="#Application-Layer-Protocols" class="headerlink" title="Application Layer Protocols"></a>Application Layer Protocols</h3><p>**应用层协议(Application Layer Protocols)**定义了在不同端系统上运行的应用程序进程如何相互传递消息。具体来说，应用层协议定义了：</p><ul><li>交换的消息类型，例如，请求消息和响应消息</li><li>报文类型的语法：报文中的各个字段及其详细描述</li><li>字段的语义，即包含在字段中的信息的含义</li><li>进程何时、如何发送报文及对报文进行响应</li></ul><p>应用层协议根据其是否公开可供所有人使用，可以分为两种类型：公共领域协议和专用协议:</p><ul><li><strong>公共领域协议</strong>:由 RFC 文档定义,可供所有人使用,例如 HTTP,SMTP,POP3</li><li><strong>专用协议</strong>:由公司或组织定义,例如 Skype, KaZaA</li></ul><blockquote><p>RFC，全称是 Request for Comments（征求意见书），是由互联网工程任务组（IETF）出版的一系列备忘录，用于描述、规定或者建议互联网标准、协议、程序、或者概念。RFC 文档是互联网技术和协议的主要来源，包括了诸如 TCP&#x2F;IP、HTTP、SMTP 等核心互联网协议的规范。<br>RFC 文档的内容可以是互联网社区的共识、工作小组的产品、个人的观点，或者只是为了获取公众的反馈。RFC 文档一旦发布，编号就不再改变，如果需要对 RFC 进行修改或者更新，会以新的 RFC 编号发布。<br>值得注意的是，尽管 RFC 是”征求意见书”的缩写，但是大部分 RFC 文档实际上是互联网标准的官方规范，而不仅仅是征求意见的提案。</p></blockquote><h3 id="Network-Applications"><a href="#Network-Applications" class="headerlink" title="Network Applications"></a>Network Applications</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-26-18-20-57.png"></p><h2 id="The-Web-and-HTTP"><a href="#The-Web-and-HTTP" class="headerlink" title="The Web and HTTP"></a>The Web and HTTP</h2><h3 id="Overview-of-HTTP"><a href="#Overview-of-HTTP" class="headerlink" title="Overview of HTTP"></a>Overview of HTTP</h3><ul><li><strong>网页 WebPage，或称 Document</strong>由许多<strong>对象 Object</strong>组成。</li><li>对象就是文件，可以是 HTML 文件, JPEG 图像, Java applet, 音频文件…</li><li>多数网页由单个<strong>基本 HTML 文件 base HTML</strong>和若干个所引用的对象构成</li><li>每个对象被一个 <strong>统一资源定位符 URL Uniform Resource Locator</strong>寻址</li><li><strong>Web 浏览器（Web browser）</strong>实现了 HTTP 的客户端；<strong>Web 服务器（Web server）</strong>实现了 HTTP 的服务器端；</li><li>HTTP 使用 TCP 作为运输协议；</li><li>HTTP 超文本传输协议（HyperText Transfer Protocol）</li><li>因为 HTTP 服务器不维护客户先前的状态信息， 是无状态协议（stateless protocol）；</li></ul><blockquote><p>维护状态的协议非常复杂</p><ul><li><p>必须维护过去历史 (状态信息)</p></li><li><p>如果 server&#x2F;client 崩溃, 它们各自的状态视图可能不一致, 因此必须保持协调一致。</p></li></ul></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://www.someschool.edu/someDept/pic.gif</span><br><span class="line">👆🏻协议      👆🏻主机名         👆🏻路径名</span><br></pre></td></tr></table></figure><h3 id="Non-Persistent-and-Persistent-Connections"><a href="#Non-Persistent-and-Persistent-Connections" class="headerlink" title="Non-Persistent and Persistent Connections"></a>Non-Persistent and Persistent Connections</h3><p><strong>非持久 HTTP 连接</strong></p><ul><li>每个 TCP 连接上只传送一个对象，下载多个对象需要建立多个 TCP 连接</li><li>HTTP&#x2F;1.0 使用非持久 HTTP 连接</li></ul><p><strong>持久 HTTP 连接</strong></p><ul><li>一个 TCP 连接上可以传送多个对象</li><li>HTTP&#x2F;1.1 默认使用持久 HTTP 连接</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-01-03.png"></p><blockquote><p><strong>往返时间（Round-Trip Time，RTT）</strong>定义：该时间是指一个短分组从客户到服务器然后在返回客户所需要的时间；[<a href="Ch1-NetworkOverview.md" title="Computer Networks Overview">Ch1-NetworkOverview#往返时间 Round Trip Time</a>]</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-02-41.png" style="zoom:50%;" /></center></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-35-15.png"></p><h3 id="HTTP-Message-Format"><a href="#HTTP-Message-Format" class="headerlink" title="HTTP Message Format"></a>HTTP Message Format</h3><p>终端输入<code>curl -v &quot;https://baidu.com&quot;</code>或使用 wireshark 等抓包工具可以</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> curl -v &quot;https://baidu.com&quot;</span><br><span class="line">* Host baidu.com:443 was resolved.</span><br><span class="line">* IPv6: (none)</span><br><span class="line">* IPv4: 110.242.68.66, 39.156.66.10</span><br><span class="line">*   Trying 110.242.68.66:443...</span><br><span class="line">* Connected to baidu.com (110.242.68.66) port 443</span><br><span class="line">* schannel: disabled automatic use of client certificate</span><br><span class="line">* ALPN: curl offers http/1.1</span><br><span class="line">* ALPN: server accepted http/1.1</span><br><span class="line">* using HTTP/1.x</span><br><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; Host: baidu.com</span><br><span class="line">&gt; User-Agent: curl/8.6.0</span><br><span class="line">&gt; Accept: */*</span><br><span class="line">&gt;</span><br><span class="line">&lt; HTTP/1.1 302 Moved Temporarily</span><br><span class="line">&lt; Server: bfe/1.0.8.18</span><br><span class="line">&lt; Date: Wed, 27 Mar 2024 07:08:02 GMT</span><br><span class="line">&lt; Content-Type: text/html</span><br><span class="line">&lt; Content-Length: 161</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Location: http://www.baidu.com/</span><br><span class="line">&lt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body bgcolor=&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;/h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;bfe/1.0.8.18&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">* Connection #0 to host baidu.com left intact</span><br></pre></td></tr></table></figure><h4 id="HTTP-Request-Message"><a href="#HTTP-Request-Message" class="headerlink" title="HTTP Request Message"></a>HTTP Request Message</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/somedir/page.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.someschool.edu</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">User-agent</span><span class="punctuation">: </span>Mozilla/5.0</span><br><span class="line"><span class="attribute">Accept-language</span><span class="punctuation">: </span>fr</span><br></pre></td></tr></table></figure><ul><li><strong>请求行 request line</strong>请求报文的第一行,其有 3 个字段：方法字段、URL 字段和 HTTP 版本字段；<ul><li>方法包含<code>GET,POST,HEAD,PUT,DELETE</code>；</li></ul></li><li><strong>首部行 header line</strong> 请求行后继的行叫作</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-15-57-34.png" alt="Request"></p><h4 id="HTTP-Response-Message"><a href="#HTTP-Response-Message" class="headerlink" title="HTTP Response Message"></a>HTTP Response Message</h4><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">200</span> OK</span><br><span class="line">Connection：close</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sat, 06 Aug 2011 12:00:15 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache/1.3.0 (Unix)</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Thu, 22 Jun 2011 …...</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>6821</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"></span><br><span class="line"><span class="language-haskell"><span class="class"><span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> <span class="keyword">data</span> ...</span></span></span><br></pre></td></tr></table></figure><ul><li><p><strong>状态行 status line</strong>响应报文的第一行,其有 3 个字段：HTTP 版本字段、状态码字段和状态码短语字段；</p></li><li><p><strong>首部行 header line</strong> 响应行后继的行叫作</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-17-21-22.png"></p></li></ul><blockquote><p><strong>HTTP 状态码</strong><br>1xx （信息性状态码）：表示服务器已经接收到请求，正在处理。</p><ul><li>100 Continue: 服务器已收到请求的初始部分，客户端应继续发送其余部分。</li><li>101 Switching Protocols: 服务器已经理解客户端的请求，并将切换到更适合的协议进行通信。</li></ul><hr><p>2xx （成功状态码）：表示请求已成功处理。</p><ul><li>200 OK: 请求成功，返回所请求的内容。</li><li>201 Created: 请求成功，并在服务器上创建了一个新的资源。</li><li>202 Accepted: 请求已被接受，但尚未处理完成。</li><li>204 No Content: 请求成功，但服务器没有返回任何内容。</li></ul><hr><p>3xx （重定向状态码）：表示需要进一步操作以完成请求。</p><ul><li>301 Moved Permanently: 被请求的资源已永久移动到新位置，并且将来的请求应使用新的 URL。</li><li>302 Found: 被请求的资源暂时移动到了新位置。</li><li>304 Not Modified: 资源未被修改，可以直接使用缓存的版本。</li></ul><hr><p>4xx （客户端错误状态码）：表示客户端发送了错误的请求。</p><ul><li>400 Bad Request: 客户端发送的请求语法错误。</li><li>401 Unauthorized: 请求需要身份验证。</li><li>403 Forbidden: 服务器拒绝了请求，客户端没有权限访问请求的资源。</li><li>404 Not Found: 请求的资源在服务器上未找到。</li></ul><hr><p>5xx （服务器错误状态码）：表示服务器在处理请求时发生了错误。</p><ul><li>500 Internal Server Error: 服务器在执行请求时遇到了未知的错误。</li><li>502 Bad Gateway: 作为代理或网关的服务器收到无效的响应。</li><li>503 Service Unavailable: 服务器暂时无法处理请求，通常是由于过载或维护。</li></ul></blockquote><h3 id="User-Server-Interaction-Cookies"><a href="#User-Server-Interaction-Cookies" class="headerlink" title="User-Server Interaction: Cookies"></a>User-Server Interaction: Cookies</h3><p>前面提到 HTTP 服务器为无状态的，而一个 Web 站点通常希望能够识别用户，可能是因为服务器希望限制用户的访问，或者因为它希望把内容与用户身份联系起来。为此，HTTP 使用了 cookie(最初被称作 magic cookie)🍪<br><a href="https://en.wikipedia.org/wiki/Magic_cookie">Magic_cookie</a></p><p>cookie technology has four components:</p><ol><li>a cookie header line in the HTTP response message;</li><li>a cookie header line in the HTTP request message;</li><li>a cookie file kept on the user’s end system and managed by the user’s browser</li><li>a back-end database at the Web site.</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-17-30-02.png"></p><p><strong>Cookies 跟踪用户</strong><br>cookies 允许网站更加了解你<br>你可以提供名字和 e-mail 给网站<br>广告公司通过网站获得信息<br>Cookies 不适合游动用户<br><strong>Cookie 可用于：</strong><br>跟踪用户在给定网站上的行为（第一方 cookie）<br>在多个网站上跟踪用户行为（第三方 cookie），而无需用户选择访问跟踪器网站！<br>跟踪可能对用户不可见：可能是一个不可见的链接<br>通过 Cookie 进行的第三方跟踪：在 Firefox、Safari 浏览器中默认禁用，将于 2023 年在 Chrome 浏览器中禁用</p><h3 id="Web-Caching-proxy-server"><a href="#Web-Caching-proxy-server" class="headerlink" title="Web Caching(proxy server)"></a>Web Caching(proxy server)</h3><p><strong>Web 缓存器 Web cache,也称代理服务器 proxy server</strong>，设计它的目标是代表<strong>初始 Web 服务器（origin server）</strong>满足 HTTP 请求;一般的，Web 缓存器既是服务器又是客户机,典型的缓存器由 ISP 提供（大学、公司或居民 ISP）;引入 Weh 缓存器减少了对客户机请求的响应时间,内部网络与接入链路上的通信量,并从整体上大大降低因特网上的 Web 流量</p><blockquote><p>如图,加入 cache 后,客户端请求的对象可能在缓存器中(称作缓存命中),缓存器直接返回给客户端;图中接入链路(access link)的速率为 15Mbps,远低于局域网的网络速率,$total delay &#x3D; LAN delay + access dalay + Internet delay$,可见接入时延为该例中提升传播速率的瓶颈;可选择更快的接入链路,但这需要更多的费用;而缓存器可以减少接入链路上的流量,从而减少接入时延,同时费用相对较低</p><p>LAN delay: 在局域网中传输一个报文所需的时间<br>Access delay: 在两个路由器之间传输一个报文所需的时间<br>Internet delay: 在因特网中传输一个报文所需的时间<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-18-50-25.png" style="zoom:50%;" /></p></blockquote><p><strong>Request Steps:</strong></p><ol><li>浏览器创建一个到 Web 缓存器的 TCP 连接，并向 Web 缓存器中的对象发送一个 HTTP 请求；</li><li>Web 缓存器进行检查，看看本地是否存储该对象副本。如果有，Web 缓存器向客户返回该对象；</li><li>如果缓存器中没有该对象，它就打开一个与该对象的初始服务器的 TCP 连接。Web 缓存器向初始服务器发送请求，并得到初始服务器的响应；</li><li>当 Web 缓存器接受对象后，在本地创建给对象的副本，并向客户发送响应报文返回该对象；<br>通过使用<strong>内容分发网络（Content Distribution Network，CDN）</strong>，Web 缓存器正在因特网中发挥着越来越重要的作用。[<a href="Ch6-2ApplicationLayer.md" title="应用层 ApplicationLayer Part Ⅱ">Ch6-2ApplicationLayer#Content Distribution Networks</a>]<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-27-17-35-49.png"></li></ol><p>尽管高速缓存器能减少用户感受到的响应时间，但引入了一个新的问题，即存放在缓存器中的副本可能陈旧的。为验证缓存器中的副本是否仍然有效，你可以使用<strong>条件 GET 请求</strong>,参照如下 python 代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义报文内容和首部</span></span><br><span class="line">request = <span class="string">&quot;GET /index.html HTTP/1.1\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;Host: www.baidu.com\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;If-Modified-Since: Sat, 01 Jan 2022 00:00:00 GMT\r\n&quot;</span></span><br><span class="line">request += <span class="string">&quot;Connection: close\r\n\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建套接字并连接目标服务器</span></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&#x27;www.baidu.com&#x27;</span>, <span class="number">80</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送报文</span></span><br><span class="line">s.send(request.encode())</span><br><span class="line"></span><br><span class="line">response = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = s.recv(<span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    response += data</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.decode())</span><br><span class="line">s.close()</span><br><span class="line"></span><br><span class="line">[OUTPUT]</span><br><span class="line">HTTP/<span class="number">1.1</span> <span class="number">200</span> OK</span><br><span class="line">Accept-Ranges: <span class="built_in">bytes</span></span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Content-Length: <span class="number">9508</span></span><br><span class="line">Content-<span class="type">Type</span>: text/html</span><br><span class="line">Date: Fri, <span class="number">29</span> Mar <span class="number">2024</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">29</span> GMT</span><br><span class="line">P3p: CP=<span class="string">&quot; OTI DSP COR IVA OUR IND COM &quot;</span></span><br><span class="line">P3p: CP=<span class="string">&quot; OTI DSP COR IVA OUR IND COM &quot;</span></span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: BWS/<span class="number">1.1</span></span><br><span class="line"><span class="type">Set</span>-Cookie: BAIDUID=E79C6BEF6A7F8AA35FBC1FD6742520D8:FG=<span class="number">1</span>; expires=Thu, <span class="number">31</span>-Dec-<span class="number">37</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">55</span> GMT; <span class="built_in">max</span>-age=<span class="number">2147483647</span>; path=/; domain=.baidu.com</span><br><span class="line"><span class="type">Set</span>-Cookie: BIDUPSID=E79C6BEF6A7F8AA35FBC1FD6742520D8; expires=Thu, <span class="number">31</span>-Dec-<span class="number">37</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">55</span> GMT; <span class="built_in">max</span>-age=<span class="number">2147483647</span>; path=/; domain=.baidu.com</span><br><span class="line"><span class="type">Set</span>-Cookie: PSTM=<span class="number">1711717229</span>; expires=Thu, <span class="number">31</span>-Dec-<span class="number">37</span> <span class="number">23</span>:<span class="number">55</span>:<span class="number">55</span> GMT; <span class="built_in">max</span>-age=<span class="number">2147483647</span>; path=/; domain=.baidu.com</span><br><span class="line"><span class="type">Set</span>-Cookie: BAIDUID=E79C6BEF6A7F8AA30F2B2E6688EB66DE:FG=<span class="number">1</span>; <span class="built_in">max</span>-age=<span class="number">31536000</span>; expires=Sat, <span class="number">29</span>-Mar-<span class="number">25</span> <span class="number">13</span>:<span class="number">00</span>:<span class="number">29</span> GMT; domain=.baidu.com; path=/; version=<span class="number">1</span>; comment=bd</span><br><span class="line">Traceid: <span class="number">1711717229235279668210477533425964763324</span></span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Ua-Compatible: IE=Edge,chrome=<span class="number">1</span></span><br><span class="line">X-Xss-Protection: <span class="number">1</span>;mode=block</span><br><span class="line">Connection: close</span><br><span class="line"><span class="comment"># html file</span></span><br><span class="line">data data ... data</span><br></pre></td></tr></table></figure><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>HTTP1.1：</p><ul><li>在单个 TCP 连接上引入了多个流水线 GET</li><li>服务器按顺序响应 GET 请求（FCFS: first-come-first-served scheduling）</li><li>对于 FCFS，小对象可能必须在大对象后面等待传输 head-of-line(HOL)blocking, 线头阻塞 HOL</li><li>丢失恢复（重新传输丢失的 TCP 段）对对象传输时间的影响</li></ul><p>HTTP&#x2F;2:[RFC 7540，2015]</p><ul><li>增加了服务器向客户端发送对象的灵活性</li><li>方法、状态代码、大多数头字段与 HTTP1.1 相比没有变化</li><li>基于客户端指定的对象优先级的请求对象的传输顺序（不一定是 FCFS）</li><li>将未请求的对象推送到客户端</li><li>将对象划分为帧 frames 以减少 HOL 阻塞<blockquote><p><a href="https://www.jianshu.com/p/63fe1bf5d445">详细分析 http2 和 http1.1 区别</a></p></blockquote></li></ul><p>HTTP&#x2F;3：通过 UDP 增加了安全性、每个对象的错误和拥塞控制（更多的流水线操作）</p><h2 id="Electronic-Mail-in-the-Internet"><a href="#Electronic-Mail-in-the-Internet" class="headerlink" title="Electronic Mail in the Internet"></a>Electronic Mail in the Internet</h2><p>邮箱系统的 3 个主要组成部分:</p><ul><li><strong>用户代理 user agents</strong><ul><li>允许用户阅读,回复,转发,保存,编辑邮件；</li><li>服务器上存储的传入和传出的消息；</li><li>例如：Outlook, foxmail 等</li></ul></li><li><strong>邮件服务器 mail servers</strong><ul><li>邮箱（mailbox）包括用户传入的消息；</li><li>报文队列（message queue）中为待发送的邮件报文；</li></ul></li><li><strong>简单邮件传送协议 SMTP</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-28-09-35-41.png"></li></ul><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><h4 id="SMTP-服务概述"><a href="#SMTP-服务概述" class="headerlink" title="SMTP 服务概述"></a>SMTP 服务概述</h4><p>SMTP（Simple Mail Transfer Protocol）是一种用于电子邮件传输的标准协议。它定义了电子邮件客户端（如邮件程序）和邮件服务器之间的通信规则，以便可靠地将邮件从发送方传递到接收方。</p><ul><li>SMTP 使用持久连接</li><li>SMTP 要求邮件消息(header &amp; body)必须是 7-bit ASCII</li><li>SMTP 服务器使用 CRLF.CRLF 来判断邮件消息的结束</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-28-09-59-42.png"></p><ul><li><strong>用户代理与发送服务器的连接</strong>：用户代理（例如电子邮件客户端）使用 SMTP 协议与发送服务器建立连接。连接过程包括身份验证和协议握手等步骤。<br>用户代理提交邮件：<br>用户代理将邮件发送到发送服务器。邮件的内容、收件人、发件人等信息被打包成一个 SMTP 消息。</li><li><strong>发送服务器的邮件传递</strong>：发送服务器接收到用户代理提交的邮件后，开始根据收件人的电子邮件地址确定邮件的路由。它可能会通过 DNS 查找 MX 记录来找到目标邮件服务器，并将邮件转发给目标邮件服务器。</li><li><strong>目标邮件服务器的接收与存储</strong>：目标邮件服务器接收到邮件后将其存储，并等待用户代理或接收器以后续协议（如 POP3 或 IMAP）请求获取邮件。</li><li><strong>用户代理收取邮件</strong>：用户代理使用 POP3 或 IMAP 协议从接收服务器上下载邮件，并将邮件显示在用户界面上供用户查看和管理。</li></ul><h4 id="SMAP-与-HTTP-的区别"><a href="#SMAP-与-HTTP-的区别" class="headerlink" title="SMAP 与 HTTP 的区别"></a>SMAP 与 HTTP 的区别</h4><table><thead><tr><th>特性</th><th>SMTP</th><th>HTTP</th></tr></thead><tbody><tr><td>协议类型</td><td>推协议 push protocol</td><td>拉协议 pull protocol</td></tr><tr><td>数据编码</td><td>要求采用 7 比特 ASCII 码格式</td><td>不受 7 比特 ASCII 码限制</td></tr><tr><td>消息传递</td><td>发送文件的机器发起 TCP 连接</td><td>接收文件的机器发起 TCP 连接</td></tr><tr><td>报文封装</td><td>所有报文对象放在一个报文中</td><td>每个对象封装在不同的 HTTP 响应报文中</td></tr></tbody></table><h3 id="Mail-Message-Format"><a href="#Mail-Message-Format" class="headerlink" title="Mail Message Format"></a>Mail Message Format</h3><p>一般格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">To:发件人地址</span><br><span class="line">From:收件人地址</span><br><span class="line">Subject:邮件主题</span><br><span class="line"></span><br><span class="line">...邮件正文</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>MIME</strong>: Multipurpose Internet mail Extensions 多用途因特网邮件扩展, RFC 2045, 2046;增添额外的信头头部声明 MIME content-type,实现多媒体邮件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">From: alice@crepes.fr</span><br><span class="line">To: bob@hamburger.edu</span><br><span class="line">Subject: Picture of yummy crepe.</span><br><span class="line">MIME-Version: 1.0</span><br><span class="line">Content-Transfer-Encoding: base64</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line"></span><br><span class="line">base64 encoded data .....</span><br><span class="line">.........................</span><br><span class="line">......base64 encoded data</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Mail-Access-Protocols"><a href="#Mail-Access-Protocols" class="headerlink" title="Mail Access Protocols"></a>Mail Access Protocols</h3><p>收件人的用户代理不能使用 SMTP 得到报文，因为取得报文是一个 pull 操作，而 SMTP 协议是一个 push 协议。通过引用一个特殊的邮件访问协议来解决这个问题，该协议将收件人邮件服务器上的报文传送给他的本地<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch6-1ApplicationLayer-2024-03-28-13-22-24.png"></p><ul><li>SMTP: 递送&#x2F;存储邮件消息到接收者邮件服务器</li><li>邮件访问协议: 从服务器获取邮件消息<ul><li>POP3: Post Office Protocol-Version3 邮局协议[RFC 1939]110 端口号<br>身份认证 (代理 &lt;–&gt;服务器) 并 下载邮件消息</li><li>IMAP: Internet Message Access Protocol [RFC 3501] 143 端口<br>更多功能特征,允许用户像对待本地邮箱那样操纵远程邮箱的邮件</li><li>HTTP: Hotmail , Yahoo! Mail, etc.</li></ul></li></ul><p><strong>POP3 VS IMAP</strong></p><table><thead><tr><th>特性</th><th>POP3</th><th>IMAP</th></tr></thead><tbody><tr><td>邮件存储</td><td>下载邮件至本地客户端</td><td>在服务器上保留邮件副本</td></tr><tr><td>邮件同步</td><td>单设备上的邮件删除操作不会同步更新</td><td>多设备上的邮件操作同步更新</td></tr><tr><td>邮件管理</td><td>仅支持简单的邮件收发操作</td><td>支持复杂的邮件管理功能</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">ApplicationLayer Part Ⅰ,Principles of Network Applications,Web&amp;HTTP,Electronic Mail</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>Java Reflection</title>
    <link href="https://efterklang.github.io/Tech/Java/Java%20Reflection/"/>
    <id>https://efterklang.github.io/Tech/Java/Java%20Reflection/</id>
    <published>2024-03-25T04:31:26.000Z</published>
    <updated>2024-03-26T09:58:42.922Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">Class&lt;?&gt; clazz = user.getClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Java Reflection</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="Java" scheme="https://efterklang.github.io/categories/Tech/Java/"/>
    
    
    <category term="Java" scheme="https://efterklang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ARM指令分类</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch3-2ARM%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch3-2ARM%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB/</id>
    <published>2024-03-24T08:29:50.000Z</published>
    <updated>2024-03-25T06:48:28.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARM-指令集"><a href="#ARM-指令集" class="headerlink" title="ARM 指令集"></a>ARM 指令集</h2><h3 id="分支指令"><a href="#分支指令" class="headerlink" title="分支指令"></a>分支指令</h3><p>在 ARM 中有两种方式可以实现程序的跳转：<br>一种是使用分支转移指令直接跳转;<br>另一种则是直接向 PC 寄存器赋值来实现跳转。<br>ARM 的分支转移指令，可以从当前指令向前或向后的 32MB($2^{23}\times4&#x3D;2^{10} \times 2^{10} \times 32 $) 的地址空间跳转，根据完成的功能它可以分为 4 种:<code>B</code>、<code>BL</code>、<code>BX</code>、<code>BLX</code>。</p><blockquote><p>signed_immed_24 间接提供目标地址，真正的目标地址是由处理器根据这个有符号数和当前的 PC 值计算出来的。<br>具体计算为：先将 signed_immed_24 左移两位（即具有 26 位的偏移量），并扩展为 32 位有符号数，然后再将这 32 位有符号数与 PC 的当前值相加，得到实际的跳转地址。<br>因此 B 和 BL 指令转移的偏移量为 26 位，即转移的跨度为前后 32MB 地址空间。</p></blockquote><h4 id="跳转指令-B-及带连接的跳转指令-BL"><a href="#跳转指令-B-及带连接的跳转指令-BL" class="headerlink" title="跳转指令 B 及带连接的跳转指令 BL"></a>跳转指令 B 及带连接的跳转指令 BL</h4><p><code>B</code>指令与<code>BL</code>指令的编码格式如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-19-20-02-46.png"></p><p>从编码中看到 L 控制了 PC 与 LR 寄存器之间的开关。当 L&#x3D;0 时，该开关断开，指令为 B 指令;当 L&#x3D;1 时，该开关接通，指令为 BL 指令。<br>Signed_immed_24 表示 24 位有符号的立即数（偏移量）</p><p>B 和 BL 指令的助记符格式为：<br><code>B &#123;&lt;cond&gt;&#125; &lt;target&gt;和BL&#123;&lt;cond&gt;&#125;  &lt;target&gt;</code><br>cond 表示指令执行条件<br>target 表示跳转地址<br>功能：跳转到指定地址执行，地址范围限制在当前 PC 寄存器所指向的指令地址的 ±32MB 范围</p><p>跳转指令也叫程序转移指令。<br>写汇编程序时，可以跳转到一个绝对地址，如:<br><code>B 0x1234</code> （注： <code>B #0x1234</code> 是错误的 ）<br>编译器会把该绝对地址转换为相对地址放入指令中。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：现已知寄存器 R0 中存放了数据 a ，寄存器 R1 中存放了数据 b ，编写一个程序段，求取 a 和 b 的最大公约数并将其存入寄存器 R0 。</span><br><span class="line">gcb CMP R0,R1      ; 比较a和b的大小</span><br><span class="line">      SUBGT  R0,R0,R1; 如果a&gt;b,则a=a-b</span><br><span class="line">      SUBLT  R1,R1,R0; 如果a&lt;b,则b=b-a</span><br><span class="line">      BNE gcb        ; 如果a!=b,则返回gcb</span><br><span class="line">      MOV  PC,LR     ; 如果a=b,则返回主程序</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>B(Branch)和 BL(Branch with Link) 的区别在于</strong>：BL 在跳转之前会把 BL 指令的下一条指令地址（断点地址）保存到连接寄存器 LR（R14），因此程序在必要的时候可以通过将 LR 的内容加载到 PC 中，使程序返回到跳转点。<br>BL 这也是一个跳转指令，但它在跳转之前会将下一条指令的地址存储到链接寄存器（LR）中。这是为了在子程序或函数执行完毕后，能够返回到调用它的代码处继续执行。换句话说，BL 指令用于函数或子程序的调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_start:</span><br><span class="line">    MOV R0, #5     ; 将5放入寄存器R0</span><br><span class="line">    BL  multiply    ; 调用multiply函数</span><br><span class="line">    B   end         ; 跳转到end标签</span><br><span class="line"></span><br><span class="line">multiply:</span><br><span class="line">    LSL R0, R0, #1 ; 将R0的值乘以2(逻辑左移)</span><br><span class="line">    MOV PC, LR     ; 返回到调用multiply的地方</span><br><span class="line"></span><br><span class="line">end:</span><br><span class="line">    ; 这里是程序结束的地方</span><br></pre></td></tr></table></figure><h4 id="带状态切换的跳转指令-BX"><a href="#带状态切换的跳转指令-BX" class="headerlink" title="带状态切换的跳转指令 BX"></a>带状态切换的跳转指令 BX</h4><p>BX 指令的格式为<code>BX&#123;&lt;cond&gt;&#125; Rm</code><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-19-20-42-39.png"><br>cond 表示指令执行条件<br>Rm 寄存器，值是绝对地址值，不是偏移量，在指令执行后，Rm 中的地址值与#0XFFFF FFFE 进行 AND 运算，再被复制到程序计数器 PC。<br>带状态切换的跳转。最低位(<code>Rm[0]</code>)为 1 时，切换到 Thumb 指令执行，为 0 时，解释为 ARM 指令执行</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">        <span class="meta">CODE32</span>         <span class="comment">;32位编码</span></span><br><span class="line"><span class="symbol">ARM1</span>   <span class="keyword">LDR</span> <span class="built_in">R0</span>，<span class="symbol">=Thumb1</span> <span class="comment">;把Thumb地址赋给R0，末位自动置1</span></span><br><span class="line">        <span class="keyword">MOV</span> <span class="built_in">LR</span>,<span class="built_in">PC</span>       <span class="comment">;设置返回地址</span></span><br><span class="line">        <span class="keyword">BX</span> <span class="built_in">R0</span>           <span class="comment">;跳转，切换状态</span></span><br><span class="line">        <span class="keyword">ADD</span> <span class="built_in">R1</span>,<span class="built_in">R2</span>,<span class="number">#2</span></span><br><span class="line">          …</span><br><span class="line">        <span class="meta">CODE16</span>          <span class="comment">;16位编码</span></span><br><span class="line"><span class="symbol">Thumb1</span>  <span class="keyword">ADD</span> <span class="built_in">R1</span>，<span class="built_in">R3</span>,<span class="number">#1</span>   <span class="comment">;Thumb程序</span></span><br><span class="line">         …</span><br><span class="line">        <span class="keyword">BX</span> <span class="built_in">LR</span>           <span class="comment">;跳转到返回地址，状态切换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="带连接和状态切换的连接跳转指令-BLX"><a href="#带连接和状态切换的连接跳转指令-BLX" class="headerlink" title="带连接和状态切换的连接跳转指令 BLX"></a>带连接和状态切换的连接跳转指令 BLX</h4><pre><code> BLX 指令的格式有两种：</code></pre><p><code>BLX &lt;target&gt; 和 BLX&#123;&lt;cond&gt;&#125;  Rm</code><br>以 target 方式提供目标地址的 BLX 指令的功能是：把程序跳转到指令中所指定的目标地址继续执行，并同时将处理器的工作状态从 ARM 状态切换到 Thumb 状态，并将下一条的地址保存到寄存器 LR 中。<br>而以 Rm 方式提供目标地址的 BLX 指令，除了跳转和下一条的地址保存到 LR 之外，也可进行状态切换，但其切换的依据是 Rm 最低位的值。如果值为 0 ，则目标地址处应为 ARM 指令，如果值为 1 ，则目标地址处应为 Thumb 指令</p><h4 id="修改-PC"><a href="#修改-PC" class="headerlink" title="修改 PC"></a>修改 PC</h4><p>另一种实现指令跳转的方式是通过直接向 PC 寄存器中写入目标地址值，实现在 4GB 地址空间中任意跳转，这种跳转又称为长跳转。<br>如果在长跳转指令之前使用“MOV LR，PC” 等指令，可以保存将来返回的地址值，也就实现了在 4GB 的地址空间中的子程序调用。</p><h3 id="数据处理指令"><a href="#数据处理指令" class="headerlink" title="数据处理指令"></a>数据处理指令</h3><h4 id="数据处理指令概述"><a href="#数据处理指令概述" class="headerlink" title="数据处理指令概述"></a>数据处理指令概述</h4><p><strong>1. ARM 数据处理指令的功能</strong><br>主要完成寄存器中数据的算术和逻辑运算操作。<br><strong>2. ARM 数据处理指令的特点</strong><br><strong>操作数来源</strong>:所有的操作数要么来自寄存器，要么来自立即数，不会来自存储器。<br><strong>操作结果</strong>:如果有结果，则结果一定是为 32 位宽、或 64 位宽（长乘法指令），并且放在一个或两个寄存器中，不会写入存储器。<br><strong>有第二个操作数 Operand2</strong> :切记其三种形式：立即数、寄存器、寄存器移位。特别地,乘法指令的操作数:全部是寄存器。</p><p><strong>3. ARM 数据处理指令分类</strong><br>算术运算指令：<code>ADD ADC SUB SBC RSB RSC MUL MLA UMULL UMLAL SMULL SMLAL</code><br>逻辑运算指令： <code>AND ORR EOR BIC</code><br>数据传送指令： <code>MOV MVN</code><br>比较指令： <code>CMP CMN</code><br>测试指令： <code>TST TEQ</code><br>上述指令只能对寄存器操作，不能针对存储器。</p><p><strong>4. 数据处理指令对程序状态寄存器 CPSR 的影响</strong><br>指令中可以添加 S 后缀，以影响 CPSR 状态标志。但是比较指令（CMP 和 CMN）和测试指令(TST 和 TEQ)不需要后缀 S，它们总会直接影响 CPSR 中的状态标志。</p><p><strong>关于恢复 CPSR 原值问题：</strong></p><blockquote><p>如果指令带有 S 后缀（除了比较指令以外），同时又以 PC 为目标寄存器进行操作:<br><strong>1. 在异常模式下</strong>：则操作的同时从 SPSR(Saved Program Status Register) 恢复 CPSR(Current Program Status Register)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movs pc, #0xff/* cpsr = spsr; pc = 0xff */</span><br><span class="line">adds pc, r1, #0xff00</span><br><span class="line">      /* cpsr = spsr; pc = r1 + 0xff00 */</span><br><span class="line">ands pc, r1, r2/* cpsr = spsr; pc = r1 &amp; r2; */</span><br></pre></td></tr></table></figure><p><strong>2. 在 user 或者 system 模式</strong>：会产生不可预料的结果，因为在这两种模式下没有 SPSR<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-20-13-47-39.png"></p></blockquote><h4 id="数据处理指令格式"><a href="#数据处理指令格式" class="headerlink" title="数据处理指令格式"></a>数据处理指令格式</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-15-08-00.png"></p><p>I 用于区别立即数(I&#x3D;1)或寄存器移位(I&#x3D;0)<br>opcode 为数据处理指令操作码<br>operand2 为第二个操作数，若指令不需要全部的可用操作数时(如 MOV 指令的 Rn)，不用的寄存器域应设置为 0(由编译器自动完成)。对于比较指令,b20 位固定为 1。</p><h4 id="Data-Processing-Instructions"><a href="#Data-Processing-Instructions" class="headerlink" title="Data Processing Instructions"></a>Data Processing Instructions</h4><h5 id="加减乘"><a href="#加减乘" class="headerlink" title="加减乘"></a>加减乘</h5><p><strong>ADD——加法运算指令</strong><br><code>ADD&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2; Rd&lt;-Rn+operand2</code></p><table><thead><tr><th><strong>受影响的 CPSR 标志位</strong></th><th><strong>取值</strong></th></tr></thead><tbody><tr><td><strong>N</strong></td><td>寄存器 Rd[31]被复制到 N</td></tr><tr><td><strong>Z</strong></td><td><strong>如果 Rd 为 0，则 Z&#x3D;1，否则 Z&#x3D;0</strong></td></tr><tr><td><strong>C</strong></td><td><strong>运算结果有进位 C&#x3D;1，否则 C&#x3D;0</strong></td></tr><tr><td><strong>V</strong></td><td><strong>运算结果有溢出 V&#x3D;1，否则 V&#x3D;0</strong></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD R0，R1，R2    ;R0←（R1）+（R2）</span><br><span class="line">ADD R0，R1，#255  ;R0 ←（R1）+ 255</span><br><span class="line">ADD R0，R2，R3，LSL#1  ;R0 ←（R2） +（R3&lt;&lt;1）</span><br></pre></td></tr></table></figure><p><strong>ADC——带进位加法指令</strong><br>指令格式：<code>ADC&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2</code><br>ADC 指令将 operand2 的数据与 Rn 的值相加，再加上 CPSR 中的 C 条件标志位，结果保存到 Rd 寄存器。<br>ADC 通常用来实现字长大于 32 位的加法运算。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-15-35-45.png"></p><p><strong>SUB——减法运算指令</strong><br>指令格式：<code>SUB&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2</code><br>SUB 指令用寄存器 Rn 减去 operand2，结果保存到 Rd 中</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SUB R0，R1，R2 ;R0←（R1）-（R2）</span><br><span class="line">SUB R0，R1，#256;R0←（R1）- 256</span><br><span class="line">SUB R0，R2，R3，LSL#1;R0←（R2）-（R3&lt;&lt;1）</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>受影响的 CPSR 标志位</strong></th><th><strong>取值</strong></th></tr></thead><tbody><tr><td><strong>N</strong></td><td>寄存器 Rd[31]被复制到 N</td></tr><tr><td><strong>Z</strong></td><td><strong>如果 Rd 为 0，则 Z&#x3D;1，否则 Z&#x3D;0</strong></td></tr><tr><td><strong>C</strong></td><td><strong>运算结果有借位 C&#x3D;0，否则 C&#x3D;1</strong></td></tr><tr><td><strong>V</strong></td><td><strong>运算结果有溢出 V&#x3D;1，否则 V&#x3D;0</strong></td></tr></tbody></table><p><strong>SBC——带进位减法指令</strong><br>指令格式：<code>SBC&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2</code><br>SBC 指令用寄存器 Rn 减去 operand2，再减去 CPSR 中的 C 条件标志位的反码，结果保存到 Rd 中。<br>标志位的修改同 SUB。该指令主要用于字长大于 32 位的数据的减法运算。</p><p><strong>RSC——带进位反向减法指令</strong><br>指令格式：<code>RSC&#123;cond&#125;&#123;S&#125; Rd，Rn，operand2</code><br>RSC 指令用寄存器 operand2 减去 Rn，再减去 CPSR 中的 C 条件标志位的反码，结果保存到 Rd 中。</p><p><strong>乘法指令格式</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-15-52-42.png"><br>其中，opcode 为乘法指令操作码。S 为设置条件码。Rm 为被乘数寄存器，Rs 为乘数的寄存器。Rn&#x2F;RdLo 用于 MLA 指令相加的寄存器或 64 位乘法指令的目标寄存器(低 32 位)。Rd&#x2F;RdHi 用于目标寄存器或 64 位乘法指令的目标寄存器(高 32 位)。若指令不需要全部的可用操作数时(如 MUL 指令的 Rn)，不用的寄存器域应设置为 0(由编译器自动完成)</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-15-42-19.png"><br><strong>MUL——32 位乘法指令</strong><br>指令格式：<code>MUL&#123;cond&#125;&#123;S&#125; Rd，Rm，Rs</code><br>MUL 指令将 Rm 和 Rs 中的值相乘，结果的低 32 位保存到 Rd 中</p><table><thead><tr><th>受影响的 CPSR 标志位</th><th>取值</th></tr></thead><tbody><tr><td>N</td><td>寄存器 Rd[31]被复制到 N</td></tr><tr><td>Z</td><td>如果 Rd 为 0 则 Z&#x3D;1，否则 Z&#x3D;0</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MUL    R1，R2，R3    ;R1=R2×R3</span><br><span class="line">MULS  R0，R3，R7    ;R0=R3×R7，</span><br><span class="line">                     ;设置CPSR的N位和Z位</span><br></pre></td></tr></table></figure><p><strong>MLA——32 位乘加指令</strong><br>格式 <code>MLA&#123;cond&#125;&#123;S&#125; Rd，Rm，Rs，Rn</code><br>指令将 Rm 和 Rs 中的值相乘，再将乘积加上第 3 个操作数，结果的低 32 位保存到 Rd 中。注： Rd ≠ Rm<br>标志位的修改同 MUL。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MLA R0,R1,R2,R3   ;R0←(R1)X(R2)+(R3)</span><br><span class="line">MLAS R0,R1,R2,R3   ;  R0←(R1)X(R2)+(R3),</span><br><span class="line">                               ;并更新CPSR标志位</span><br></pre></td></tr></table></figure><p><strong>UMULL—64 位无符号乘法指令</strong><br>指令格式：<code>UMULL&#123;cond&#125;&#123;S&#125; RdLo，RdHi，Rm，Rs;RdHi, RdLo← Rm*Rs</code><br>UMULL 指令将 Rm 和 Rs 中的值作无符号数相乘，结果的低 32 位保存到 RdLo 中，高 32 位保存到 RdHi 中<br>例：<code>UMULL R0，R1，R5，R8;(R1,R0)←R5×R8</code></p><table><thead><tr><th>受影响的 CPSR 标志位</th><th>取值</th></tr></thead><tbody><tr><td>N</td><td>寄存器 RdHi[31]被复制到 N</td></tr><tr><td>Z</td><td>如果 RdHi 且 Rdlo 为 0，则 Z&#x3D;1，否则 Z&#x3D;0</td></tr></tbody></table><p><strong>UMLAL—64 位无符号乘加指令</strong><br>指令格式：<code>UMLAL&#123;cond&#125;&#123;S&#125; RdLo，RdHi，Rm，Rs;RdHi, RdLo← Rm*Rs+ RdHi, RdLo</code><br>UMLAL 指令将 Rm 和 Rs 中的值作无符号数相乘，64 位乘积与 RdHi、RdLo 相加，结果的低 32 位保存到 RdLo 中，而高 32 位保存到 RdHi 中。<br>标志的修改同 UMULL。<br>指令举例如下：<br><code>UMLAL R0，R1，R5，R8;(R1,R0)←R5×R8+(R1,R0)</code></p><p><strong>SMULL—64 位有符号乘法指令</strong><br>指令格式：<code>SMULL&#123;cond&#125;&#123;S&#125; RdLo，RdHi，Rm，Rs; RdHi, RdLo← Rm*Rs</code><br>SMULL 指令将 Rm 和 Rs 中的值作有符号数相乘，结果的低 32 位保存到 RdLo 中，而高 32 位保存到 RdHi 中。<br>例如：<code>SMULL R2，R3，R7，R6;(R3,R2)←R7×R6</code></p><table><thead><tr><th>受影响的 CPSR 标志位</th><th>取值</th></tr></thead><tbody><tr><td>N</td><td>寄存器 RdHi[31]被复制到 N</td></tr><tr><td>Z</td><td>如果 RdHi 且 Rdlo 为 0，则 Z&#x3D;1，否则 Z&#x3D;0</td></tr></tbody></table><p><strong>SMLAL—64 位有符号乘加指令</strong><br>指令格式：<code>SMLAL&#123;cond&#125;&#123;S&#125; RdLo，RdHi，Rm，Rs; RdHi, RdLo← Rm*Rs+ RdHi, RdLo</code><br>SMLAL 指令将 Rm 和 Rs 中的值作有符号数相乘，64 位乘积与 RdHi、RdLo 相加，结果的低 32 位保存到 RdLo 中，高 32 位保存到 RdHi 中。<br>标志的修改同 SMULL。</p><blockquote><p>乘法指令的特点</p><ul><li>结果寄存器不能与第一源寄存器相同。</li><li>不支持第 2 操作数为立即数。</li><li>Rd、RdHi、RdLo 不能与 Rm 为同一寄存器。</li><li>RdHi 和 RdLo 不能为同一寄存器。</li><li>避免将 R15 定义为任一操作数或结果寄存器。</li><li>早期的 ARM 处理器仅支持 32 位乘法指令。ARM7 版本和后续的在名字中有 M 的处理器才支持 64 位乘法指令。</li><li>对标志位的影响<ul><li>对 N 标志位：若结果是 32 位指令形式，Rd 的第 31 位是标志位 N;对于产生长结果的指令形式，RdHi 的第 31 位是标志位。</li><li>对 Z 标志位：如果 Rd 或 RdHi、RdLo 为 0，则标志位 Z 置位。</li><li>对 V 标志位：乘法指令不影响 V 标志位。</li><li>对 C 标志位： ARM v5 及以上的版本不影响 C 标志位; ARM v5 以前的版本，C 标志位数值不确定。</li></ul></li></ul></blockquote><h5 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h5><ol><li><p>按位与指令（AND）<br>按位与指令用于将两个寄存器中的值进行按位与运算，并将结果存储在目标寄存器中。基本语法如下：<br><code>AND Rd, Rn, Operand2</code><br>其中，Rd 是目标寄存器，Rn 是第一个操作数所在寄存器，Operand2 是第二个操作数。<br>示例：<code>AND R0, R1, R2</code><br>这个指令将 R1 和 R2 中的值进行按位与运算，并将结果存储在 R0 中。</p></li><li><p>按位或指令（ORR）<br>按位或指令用于将两个寄存器中的值进行按位或运算，并将结果存储在目标寄存器中。基本语法如下：<br><code>ORR Rd, Rn, Operand2</code><br>其中，Rd 是目标寄存器，Rn 是第一个操作数所在寄存器，Operand2 是第二个操作数。<br>示例：<br><code>ORR R0, R1, R2</code><br>这个指令将 R1 和 R2 中的值进行按位或运算，并将结果存储在 R0 中。</p></li><li><p>按位异或指令（EOR）<br>按位异或指令用于将两个寄存器中的值进行按位异或运算，并将结果存储在目标寄存器中。基本语法如下：<br><code>EOR Rd, Rn, Operand2</code><br>其中，Rd 是目标寄存器，Rn 是第一个操作数所在寄存器，Operand2 是第二个操作数。<br>示例：<br><code>EOR R0, R1, R2</code><br>这个指令将 R1 和 R2 中的值进行按位异或运算，并将结果存储在 R0 中。</p></li><li><p>位清楚指令（BIC）<br>按位非指令用于对一个寄存器中的值进行按位取反，并将结果存储在目标寄存器中。基本语法如下：<br><code>BIC Rd, Rn, Operand2</code><br>BIC 指令将寄存器 Rn 的值与 Operand2 的值的反码按位逻辑与操作，结果保存到 Rd 中。<br>指令举例如下：<br><code>BIC R1，R1，#0x0F; 将R1的低4位清0,其它位不变 </code></p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例：请把寄存器R2中的高8位数据传送到寄存器R3的低8位，原R3低24置换为高24位。</span><br><span class="line">MOV R0，R2，LSR #24;将R2右移24位，即将其高8位移至低8位送R0。</span><br><span class="line">ORR R3，R0，R3，LSL #8;将R3左移8位后将R0低8位送至R3。</span><br></pre></td></tr></table></figure><h5 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h5><p><code>MOV&#123;cond&#125;&#123;S&#125; Rd，operand2</code><br>MOV 指令将 operand2 传送到目标寄存器 Rd 中<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-24-16-10-41.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MOV R2，#0x7E; 将立即数 0x7E 传送到寄存器 R2 中</span><br><span class="line">MOVS R1，R0，LSL#3; 将寄存器 R0 * 8 传送到寄存器 R1，并影响标志位</span><br><span class="line">MOV PC，LR; PC←LR，子程序返回</span><br><span class="line">MOVS PC，LR; PC←LR，异常模式下返回 CPSR←SPSR</span><br></pre></td></tr></table></figure><blockquote><p>MOV 指令的功能总结</p><ul><li>寄存器之间传送。</li><li>立即数传送到寄存器中。（8 位立即数位图）</li><li>实现单纯的移位操作。MOV Rd，Rd，LSL，#3</li><li>实现子程序调用、从子程序中返回。当 PC 寄存器作为目标寄存器时可以实现程序跳转。</li><li>实现异常模式的返回，并把当前处理器模式的 SPSR 寄存器内容复制到 CPSR 中。</li></ul></blockquote><p><code>MVN&#123;cond&#125;&#123;S&#125; Rd，operand2</code><br>MVN 指令将 operand2 按位取反后传送到目标寄存器 Rd</p><h5 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h5><p><code>CMP&#123;cond&#125; Rn，operand2</code><br>CMP 指令将寄存器 Rn 的值减去 operand2 的值，但不存储运算结果，只根据操作的结果更新 CPSR 中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。</p><table><thead><tr><th>受影响的 CPSR 标志位</th><th>取值</th></tr></thead><tbody><tr><td>N</td><td>运算结果的第 31 位被复制到 N</td></tr><tr><td>Z</td><td>运算结果为 0 则 Z&#x3D;1，否则 Z&#x3D;0</td></tr><tr><td>C</td><td>运算结果有借位则 C&#x3D;0，否则 C&#x3D;1</td></tr><tr><td>V</td><td>运算结果有溢出则 V&#x3D;1，否则 V&#x3D;0</td></tr></tbody></table><p><code>CMN&#123;cond&#125; Rn，operand2</code><br>CMN 指令将寄存器 Rn 的值减去 operand2 的相反数（即加上 operand2 的值），但不存储运算结果，只根据操作的结果更新 CPSR 中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMN R0，#1;R0+1，判断R0是否为-1。</span><br></pre></td></tr></table></figure><h5 id="测试指令"><a href="#测试指令" class="headerlink" title="测试指令"></a>测试指令</h5><p><code>TST&#123;cond&#125; Rn，operand2</code><br>TST 指令将寄存器 Rn 的值与 operand2 的值按位逻辑“与”操作，但不存储运算结果，只根据操作的结果更新 CPSR 中的相应条件标志位。该指令一般用来检测是否设置了特定的位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TST R0，#0x01;判断 R0 的最低位是否为 0</span><br><span class="line">TST Rl，#0x0F;判断 R1 的低 4 位是否为 0</span><br></pre></td></tr></table></figure><p><code>TEQ&#123;cond&#125; Rn，operand2</code><br>TEQ 指令将寄存器 Rn 的值与 operand2 的值按位逻辑“异或”操作，但不存储运算结果，只根据操作的结果更新 CPSR 中的相应条件标志位，以便后面的指令根据相应的条件标志来判断是否执行。<br>指令举例如下：<br><code>TEQ R0，R1;比较 R0 与 R1 是否相等；(不影响 V 位和 C 位)</code></p><h3 id="存储器访问指令"><a href="#存储器访问指令" class="headerlink" title="存储器访问指令"></a>存储器访问指令</h3><p>ARM 微处理器用加载&#x2F;存储指令访问存储器，实现在寄存器和存储器之间传送数据。<br>由于 ARM 处理器对外设寄存器、I&#x2F;O 映射空间与存储器统一编址，因此，对外围设备的 I&#x2F;O 操作也用此类指令。<br>基本的加载&#x2F;存储指令仅有 5 条，分为 3 种：</p><ul><li>LDR 和 STR，单寄存器加载&#x2F;存储指令</li><li>LDM 和 STM，多寄存器加载&#x2F;存储指令</li><li>SWP，寄存器和存储器数据交换指令</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2ARM%E6%8C%87%E4%BB%A4%E5%88%86%E7%B1%BB-2024-03-24-21-49-34.png"><br>其中，I、P、U、W 用于区别不同的地址模式(偏移量)</p><ul><li>I 为 0 时，偏移量为 12 位立即数；I 为 1 时，偏移量为寄存器移位；</li><li>P 表示前&#x2F;后变址，U 表示加&#x2F;减，W 表示回写(！后缀)</li><li>L 用于区别加载(L 为 1 时)或存储(L 为 0 时)</li><li>B 用于区别字节访问(B 为 1 时)或字访问(B 为 0 时)</li><li>Rn 为基址寄存器，Rd 为源&#x2F;目标寄存器。</li></ul><h4 id="单寄存器加载-存储指令"><a href="#单寄存器加载-存储指令" class="headerlink" title="单寄存器加载&#x2F;存储指令"></a>单寄存器加载&#x2F;存储指令</h4><p>单寄存器加载&#x2F;存储指令是 ARM 在<strong>寄存器</strong>和<strong>存储器</strong>间传送单个字节和字的最灵活方式。</p><blockquote><p>LDR（Load Register）：这是一个加载指令，用于从内存中读取数据并将其加载到寄存器中。其基本格式为 LDR Rd, [Rn]，其中 Rd 是目标寄存器，Rn 是包含要读取的内存地址的寄存器;例如，LDR R1, [R2] 会将存储在 R2 寄存器所指向的内存地址中的数据加载到 R1 寄存器中。<br>STR（Store Register）：这是一个存储指令，用于将寄存器中的数据写入到内存中。其基本格式为 STR Rd, [Rn]，其中 Rd 是源寄存器，Rn 是包含要写入的内存地址的寄存器。例如，STR R1, [R2] 会将 R1 寄存器中的数据存储到 R2 寄存器所指向的内存地址中。</p></blockquote><p>根据传送数据的类型不同，单个寄存器存取指令又可以分为以下两类：<br>单字和无符号字节的加载&#x2F;存储指令<br>半字和有符号字节的加载&#x2F;存储指令</p><h5 id="单字和无符号字节的加载／存储指令"><a href="#单字和无符号字节的加载／存储指令" class="headerlink" title="单字和无符号字节的加载／存储指令"></a>单字和无符号字节的加载／存储指令</h5><p>LDR：指令从内存中取 32 位字或 8 位无符号字节数据放入寄存器；<br>STR：指令将寄存器中的 32 位字或 8 位无符号字节数据保存到存储器中。</p><p>注意：无符号字节加载时，用 0 将 8 位的操作数扩展到 32 位。</p><p><strong>Instruction Format</strong><br>LDR{cond}{T} Rd，&lt;地址&gt;;加载指定地址上的字数据，放入 Rd 中。<br>STR{cond}{T} Rd，&lt;地址&gt;;存储 Rd 中字数据，到指定地址的存储单元。<br>LDR{cond}B{T} Rd，&lt;地址&gt;;加载字节数据到 Rd 低 8 位数据位中，高 24 位为 0。<br>STR{cond}B{T} Rd，&lt;地址&gt;;存储 Rd 中字节数据， Rd 中最低字节为传送数据</p><p><strong>Postfix</strong><br>T 为可选后缀，若指令有 T，存储系统将访问看成是处理器是在用户模式下。<br>用于存储器保护。<br>不能与后变址模式、自动变址模式一起使用（即不能改变基址寄存器值）。<br>T 在用户模式下无效</p><p><strong>Addressing</strong><br>LDR&#x2F;STR 指令为基址变址寻址[<a href="Ch3-1ARM%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0" title="ARM指令集概述">Ch3-1ARM指令概述.md#基址变址寻址 Base-index Addressing</a>]（或寄存器间接寻址），由两部分组成：</p><ul><li><strong>基地址部分</strong>：为一个基址寄存器，可以为任一个通用寄存器；</li><li><strong>偏移地址部分</strong>：这一部分非常灵活，实际就类似第二个操作数，可以有以下 3 种格式：<ul><li><strong>立即数</strong>:12 位立即数是一个无符号的数值。这个数据可以加到基址寄存器，也可以从基址寄存器中减去这个数值</li><li><strong>寄存器</strong>:寄存器中的数值(无符号数)可以加到基址寄存器，也可以从基址寄存器中减去这个数值</li><li><strong>寄存器及移位常数</strong>:寄存器移位后的值(无符号数)可以加到基址寄存器，也可以从基址寄存器中减去这个数值<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LDR R1，[R0，#0x10];</span><br><span class="line">LDR R1，[R0，# -0x10];</span><br><span class="line">LDR R1，[R0，R2]</span><br><span class="line">LDR R1，[R0，-R2]</span><br><span class="line">LDR R1，[R0，R2，LSL #2] 将R0+R2×4地址处的数据读出,保存到R1中(R0、R2的值不变)</span><br><span class="line">LDR R1，[R0，-R2，LSL #2] 将R0-R2×4地址处的数据读出,保存到R1中(R0、R2的值不变)</span><br></pre></td></tr></table></figure><blockquote><p>PC（即 R15）使用的几个问题<br>使用 PC 作为基址时，使用的数值是当前执行指令的地址加 8 个字节（取指与执行相差 8 个字节）。<br>PC 不能用做偏移寄存器，也不能用于任何变址寻址模式。<br>把一个字加载到 PC，将使程序转移到所加载的地址，这是一个公认的实现跳转的方法。但是应当避免将一个字节加载到 PC。<br>把 PC 存到存储器的操作在不同体系结构的处理器中产生不同的结果，应尽可能避免。</p></blockquote></li></ul></li></ul><h3 id="协处理器指令"><a href="#协处理器指令" class="headerlink" title="协处理器指令"></a>协处理器指令</h3><h3 id="杂项指令"><a href="#杂项指令" class="headerlink" title="杂项指令"></a>杂项指令</h3>]]></content>
    
    
    <summary type="html">ARM指令分类</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM-Processor" scheme="https://efterklang.github.io/categories/UESTC/ARM-Processor/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>ARM指令集概述</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch3-1ARM%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch3-1ARM%E6%8C%87%E4%BB%A4%E6%A6%82%E8%BF%B0/</id>
    <published>2024-03-24T08:27:30.000Z</published>
    <updated>2024-03-25T01:57:48.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARM-指令集简介"><a href="#ARM-指令集简介" class="headerlink" title="ARM 指令集简介"></a>ARM 指令集简介</h2><p>ARM 微处理器的 ARM 指令集 ，所有的指令长度都是 32 位 ，并且大多数指令都在一个单独指令周期内执行。<br><strong>主要特点包括</strong>：</p><ul><li>指令是条件执行的;</li><li>ARM 微处理器的指令集是加载&#x2F;存储型的;</li><li>在多寄存器操作指令中一次最多可以完成 16 个寄存器的数据传送。</li></ul><h3 id="ARM-Instruction-Format"><a href="#ARM-Instruction-Format" class="headerlink" title="ARM Instruction Format"></a>ARM Instruction Format</h3><h4 id="助记符表示"><a href="#助记符表示" class="headerlink" title="助记符表示"></a>助记符表示</h4><p>用助记符表示的 ARM 指令格式如下：<br><code>&lt;opcode&gt; &#123;&lt;cond&gt;&#125; &#123;S&#125; &#123;&lt;Rd&gt;&#125; &#123; ，&lt;Rn&gt;&#125; &#123;，&lt;OP2&gt;&#125;</code><br>格式中<code>&lt; &gt;</code>的内容必不可少，<code>&#123; &#125;</code>中的内容可省略。</p><p><code>&lt;opcode&gt;</code>表示操作码，如 ADD 表示算术加法。<br><code>&#123;&lt;cond&gt;&#125;</code>表示指令执行的条件域，如 EQ、NE 等。<br><code>&#123;S&#125;</code>决定指令的执行结果是否影响 CPSR 的值，使用该后缀则指令执行的结将果影响 CPSR 的值，否则不影响。<br><code>&lt;Rd&gt;</code>表示目标或源寄存器。<br><code>&lt;Rn&gt;</code>表示第一个操作数，为寄存器。<br><code>&lt;op2&gt;</code>表示第二个操作数，可以是立即数、寄存器和寄存器移位操作数。<br>除了<code>&lt;opcode&gt;</code>其余域都可以选择使用</p><blockquote><p><strong>例如</strong>： 指令<code>ADDEQS R0,R1,#8;</code></p><ul><li>操作码为 ADD，</li><li>条件域 cond 为 EQ，</li><li>S 表示该指令的执行影响 CPSR 寄存器的值，</li><li>目的寄存器 Rd 为 R0，</li><li>第一个操作数寄存器 Rn 为 R1，</li><li>第二个操作数 OP2 为立即数＃8。<br>执行结果：R0 &#x3D; R1+ 8</li></ul></blockquote><h4 id="机器码表示"><a href="#机器码表示" class="headerlink" title="机器码表示"></a>机器码表示</h4><p>ARM 指令代码一般可以分为 5 个域：<br>第 1 个域是 4 位[31:28]的条件码域，4 位条件码共有 16 种组合;<br>第 2 个域是指令代码域[27:20],除了指令编码外，还包含几个很重要的指令特征和可选后缀的编码;<br>第 3 个域是第 1 个操作数寄存器 Rn，是 4 位[19:16],为 R0 ～ R15 共 16 个寄存器编码;<br>第 4 个域是目标或源寄存器 Rd，是 4 位[15:12],为 R0 ～ R15 共 16 个寄存器编码;<br>第 5 个域是第二个操作数[11:0]。</p><h4 id="可选后缀"><a href="#可选后缀" class="headerlink" title="可选后缀"></a>可选后缀</h4><ol><li><strong>S 后缀</strong></li></ol><p>指令中使用 S 后缀时，指令执行后程序状态寄存器的条件标志位将被刷新，不使用 S 后缀时，指令执行后程序状态寄存器 CPSR 的条件标志将不会发生变化。</p><blockquote><p>假设 R0&#x3D;0x1,R3&#x3D;0x3,指令执行之前 CPSR 部分标志位为 nZcv,分别执行如下指令 CPSR 的值有何变化？<br><code>SUB R1,R0,R3; R0的值减去R3的值，结果存入R1</code> &gt; <code>SUBS R1,R0,R3; R0的值减去R3的值，结果存入R1影响标志位。</code><br>分析：执行第 1 条指令对于标志寄存器的值没有任何影响，因此 CPSR 的值不变。执行第 2 条指令后 CPSR&#x3D;Nzcv。</p></blockquote><ol start="2"><li><strong>!后缀</strong></li></ol><p>如果指令地址表达式中不含！后缀，则基址寄存器中的地址值不会发生变化。<br>指令中的地址表达式中含有!后缀时，指令执行后，基址寄存器中的地址值将发生变化，变化的结果如下：<br>基址寄存器中的值（指令执行后）＝指令执行前的值＋地址偏移量<br>使用!后缀需要注意如下事项：</p><pre><code>- ！后缀必须紧跟在地址表达式后面，而地址表达式要有明确的地址偏移量;- ! 后缀不能用于 R15(PC)的后面;- 当用在单个地址寄存器后面时，必须确信这个寄存器有隐性的偏移量，例如“STMIA R7!, &#123;R0 – R3&#125;”此时地址基址寄存器 R7 的隐性偏移量是 16 字节。如果 R7 的初始值为 0X40000000，则该语句结束后为 0X40000010</code></pre><blockquote><p>例 分别执行下面两条指令有何区别？<br><code>LDR R3,[R0,#4]</code> &gt; <code>LDR R3,[R0,#4]！</code><br>分析：在上述指令中，第 1 条指令没有后缀！，指令的结果是把 R0 加 4 作为地址指针，把这个指针所指向的地址单元所存储的数据读入 R3，R0 的值不变。第 2 条指令除了实现以上操作外，还把 R0 ＋ 4 的结果送到 R0 中。</p></blockquote><ol start="3"><li><strong>B 后缀</strong><br>B 后缀的含义是：指令所涉及的数据是一个字节，不是一个字或半字。<br><code>LDR R4，[R0]</code><br>R4&#x3D;[R0]，指令传送一个字<br><code>LDRB R4，[R0]</code><br>R4&#x3D;[R0]，指令传送一个字节<br><code>LDREQB R4，[R0]</code><br>如果相等则执行，R4&#x3D;[R0]，指令传送一个字节</li></ol><h3 id="ARM-指令的条件码"><a href="#ARM-指令的条件码" class="headerlink" title="ARM 指令的条件码"></a>ARM 指令的条件码</h3><table><thead><tr><th><strong>条件码</strong></th><th><strong>条件码助记符</strong></th><th><strong>CPSR 中条件标志位值</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><strong>0000</strong></td><td><strong>EQ</strong></td><td><strong>Z&#x3D;1</strong></td><td><strong>相等</strong></td></tr><tr><td><strong>0001</strong></td><td><strong>NE</strong></td><td><strong>Z&#x3D;0</strong></td><td><strong>不相等</strong></td></tr><tr><td><strong>0010</strong></td><td><strong>CS&#x2F;HS</strong></td><td><strong>C&#x3D;1</strong></td><td><strong>无符号数大于或等于</strong></td></tr><tr><td><strong>0011</strong></td><td><strong>CC&#x2F;LO</strong></td><td><strong>C&#x3D;0</strong></td><td><strong>无符号数小于</strong></td></tr><tr><td><strong>0100</strong></td><td><strong>MI</strong></td><td><strong>N&#x3D;1</strong></td><td><strong>负数</strong></td></tr><tr><td><strong>0101</strong></td><td><strong>PL</strong></td><td><strong>N&#x3D;0</strong></td><td><strong>正数或零</strong></td></tr><tr><td><strong>0110</strong></td><td><strong>VS</strong></td><td><strong>V&#x3D;1</strong></td><td><strong>溢出</strong></td></tr><tr><td><strong>0111</strong></td><td><strong>VC</strong></td><td><strong>V&#x3D;0</strong></td><td><strong>未溢出</strong></td></tr><tr><td><strong>1000</strong></td><td><strong>HI</strong></td><td><strong>C&#x3D;1 且 Z&#x3D;0</strong></td><td><strong>无符号数大于</strong></td></tr><tr><td><strong>1001</strong></td><td><strong>LS</strong></td><td><strong>C&#x3D;0 或 Z&#x3D;1</strong></td><td><strong>无符号数小于或等于</strong></td></tr><tr><td><strong>1010</strong></td><td><strong>GE</strong></td><td><strong>N&#x3D;V</strong></td><td><strong>带符号数大于或等于</strong></td></tr><tr><td><strong>1011</strong></td><td><strong>LT</strong></td><td><strong>N!&#x3D;V</strong></td><td><strong>带符号数小于</strong></td></tr><tr><td><strong>1100</strong></td><td><strong>GT</strong></td><td><strong>Z&#x3D;0 且 N&#x3D;V</strong></td><td><strong>带符号数大于</strong></td></tr><tr><td><strong>1101</strong></td><td><strong>LE</strong></td><td><strong>Z&#x3D;1 或 N!&#x3D;V</strong></td><td><strong>带符号数小于或等于</strong></td></tr><tr><td><strong>1110</strong></td><td><strong>AL</strong></td><td></td><td><strong>无条件执行</strong></td></tr><tr><td><strong>1111</strong></td><td><strong>NV</strong></td><td><strong>ARMV3 之前</strong></td><td><strong>从不执行不要使用</strong></td></tr></tbody></table><h3 id="ARM-指令分类"><a href="#ARM-指令分类" class="headerlink" title="ARM 指令分类"></a>ARM 指令分类</h3><p>ARM 指令可以分为：分支指令、数据处理指令、存储访问指令、协处理器指令和杂项指令五类。<br><strong>1. 分支指令</strong><br>分支指令用于控制程序的执行流程、实现 ARM 代码与 Thumb 代码之间进行切换。<br><strong>2. 数据处理指令</strong><br>数据处理指令在通用寄存器上执行计算，主要分为 3 种：算术&#x2F;逻辑指令、比较指令和乘法指令。<br><strong>3. 存储访问指令</strong><br>用于加载&#x2F;存储存放于 MCU 片外存储系统中的数据。加载指令用于从内存中读取数据放入寄存器中，存储指令用于将寄存器中的数据保存到内存中。<br><strong>4. ARM 协处理器指令</strong><br>ARM 协处理器指令用于控制外部的协处理器。包括</p><ul><li><strong>数据处理指令</strong>：启动一个协处理器专用的内部操作。</li><li><strong>数据转移指令</strong>：使数据在协处理器和存储器之间进行转移。</li><li><strong>寄存器转移指令</strong>：协处理器值转移到 ARM 寄存器或 ARM 寄存器的值转移到协处理器。</li></ul><p><strong>5. 杂项指令</strong><br>包括<strong>状态寄存器转移指令</strong>和<strong>异常中断产生指令</strong>。<br>状态寄存器转移指令将 CPSR 或 SPSR 的内容转移到一个通用寄存器，或者反过来将通用寄存器的内容写入 CPSR 或 SPSR 寄存器<br>ARM 有 两条 异常中断产生指令，分别为 软中断指令 SWI 和 断点中断指令 BKPT。</p><h2 id="ARM-指令的寻址方式"><a href="#ARM-指令的寻址方式" class="headerlink" title="ARM 指令的寻址方式"></a>ARM 指令的寻址方式</h2><h3 id="立即数寻址-Immediate-Addressing"><a href="#立即数寻址-Immediate-Addressing" class="headerlink" title="立即数寻址 Immediate Addressing"></a>立即数寻址 Immediate Addressing</h3><p>立即数寻址也叫立即寻址，操作数本身就在指令中给出，取出指令也就取到了操作数。这个操作数被称为立即数，对应的寻址方式也就叫做立即数寻址。</p><p>立即数要求以“＃”为前缀，<br>对于以十六进制表示的立即数，还要求在“＃”后加上“0x”或“&amp;”;<br>对于以二进制表示的立即数，要求在“#”后加上“0b”;<br>对于以十进制表示的立即数，要求在“#”后加上“0d”或缺省。</p><p>在指令格式中，第二个操作数有 12 位：</p><p>因此有效立即数 immediate 可以表示成： <code>&lt;immediate&gt; =  immed_8 循环右移（2×rot）</code><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-14-09-35-20.png"><br><code>[8,11]这4 bit</code>移位因子 (十进制表示范围 0-15)乘 2(内存对齐,ARM 内存地址为 4 的倍数)，得到一个范围在 0-30，步长为 2 的移位值。<br>因此，将 ARM 中的立即数称为 8 位位图。“最后 8 位移动偶数位”得到立即数</p><blockquote><p>如何判断一个数是合法立即数还是非法立即数<br>判断一个数是否符合 8 位位图的原则, 首先看这个数的二进制表示中<strong>1 的个数是否不超过 8 个</strong>. 如果不超过 8 个, 再看这 n 个 1(n&lt;&#x3D;8)是否能同时放到 8 个二进制位中, 如果可以放进去, 再看这八个二进制位是否可以<strong>循环右移</strong>偶数位得到<br>我们欲使用的数. 如果可以, 则此数符合 8 位位图原理, 是合法的立即数. 否则, 不符合.</p></blockquote><h3 id="寄存器寻址-Register-Addressing"><a href="#寄存器寻址-Register-Addressing" class="headerlink" title="寄存器寻址 Register Addressing"></a>寄存器寻址 Register Addressing</h3><p>寄存器寻址就是利用寄存器中的数值作为操作数，这种寻址方式是各类微处理器经常采用的一种方式，也是一种执行效率较高的寻址方式。</p><h3 id="寄存器移位寻址-Register-Shift-Addressing"><a href="#寄存器移位寻址-Register-Shift-Addressing" class="headerlink" title="寄存器移位寻址 Register Shift Addressing"></a>寄存器移位寻址 Register Shift Addressing</h3><p>当第二操作数为寄存器型时，在执行寄存器寻址操作时，也可以对第二操作数寄存器进行移位，此时第二操作数形式为：<code>ADD  Rd, Rn, Rm，&#123;&lt;shift&gt;&#125;</code></p><p><code>Rm</code>: 第二操作数寄存器<br><code>&lt;shift&gt;</code>:用来指定移位类型和移位位数，有两种形式:5 位立即数,寄存器(用 Rs 表示)<br>在指令执行时，将寄存器移位后的内容，作为第二操作数参与运算。<br>例如指令：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">R3←R2+(R1右移2位):</span><br><span class="line">ADD R3，R2，R1，LSR #2;</span><br><span class="line">R3←R2+(R1右移R0位)</span><br><span class="line">ADD R3，R2，R1，LSR R0;</span><br></pre></td></tr></table></figure><p><strong>第二操作数的移位方式:</strong></p><p>移位位数可以用立即数方式或者寄存器方式给出，其值均小于 32，应为[0,31]</p><ul><li><code>LSL,LSR</code> 逻辑左&#x2F;右移: 空出的最低&#x2F;高有效位用 0 填充</li><li><code>ASL,ASR</code> 算术左&#x2F;右移: 算术移位的对象为<strong>带符号数</strong>;故 ASL 空出的最低有效位用 0 填充,而 ASR 移位时,如果为负数,最高有效位用 1 填充;若为正数,则用 0 填充</li><li><code>ROR</code> Rotate Right;循环右移 移出的字的最低有效位依次填入空出的最高有效位。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-16-23-02-45.png" alt="ROR"></li><li><code>RRX</code> Rotate Right Extended 带扩展的循环右移;将寄存器的内容循环右移 1 位，空位用原来 C 标志位填充<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-16-23-03-12.png" alt="RRX"></li></ul><h3 id="寄存器间接寻址-Register-Indirect-Addressing"><a href="#寄存器间接寻址-Register-Indirect-Addressing" class="headerlink" title="寄存器间接寻址 Register Indirect Addressing"></a>寄存器间接寻址 Register Indirect Addressing</h3><p>寄存器间接寻址就是以寄存器中的值作为操作数的地址，而操作数本身存放在存储器中。<br><code>LDR R0，[R4];AR0←[R4]</code><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-16-23-16-48.png" alt="Indirect-Addressing"></p><h3 id="基址变址寻址-Base-index-Addressing"><a href="#基址变址寻址-Base-index-Addressing" class="headerlink" title="基址变址寻址 Base-index Addressing"></a>基址变址寻址 Base-index Addressing</h3><p>变址寻址,也叫基址变址寻址,是指将基址寄存器的内容与指令中给出的地址偏移量相加，得到操作数所在的存储器的有效地址<br>变址寻址方式常用于访问某基地址附近的地址单元(4K 范围的偏移)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-17-12-22-21.png" alt="Base-Index Addressing"><br><code>LDR R0，[R1，＃4]; R0←mem32[R1＋4]</code></p><p><strong>偏移地址方式</strong></p><p>有三种加偏址的方式：前变址、自动变址和后变址寻址方式</p><p><strong>前变址模式</strong>(不修改基址寄存器):先基址+偏址，生成操作数地址，再做指令指定的操作。也叫前索引偏移。例如<code>STR r0,[r1,#12]</code>(将 r0 的内容存入 r1+12 的地址单元中)<br><strong>自动变址模式</strong>(修改基址寄存器)： 先基址+偏移，生成操作数地址，做指令指定的操作。然后自动修改基址寄存器。例如<code>LDR R0，[R1，＃4]!;</code>(从 R1 指向的地址加上 4 的位置加载数据到 R0，并将计算得出的地址写回到 R1 中”。)<br><strong>后变址模式</strong>(修改基址寄存器)： 基址寄存器不加偏移作为操作数地址。完成指令操作后，用(基址+偏移)的值修改基址寄存器。例如<code>STR r0,[r1],#12</code>将 r0 中的值存储到 r1 指向的地址，然后将 r1 的值加上 12 并把结果写回 r1”。</p><p><strong>偏移地址形式</strong>:可以是一个立即数，也可以是另一个寄存器，并且还可以是寄存器移位操作;常用的是立即数偏移的形式</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDR R2，[R3，#0X0C]; R2&lt;-mem32[R3＋0X0C]</span><br><span class="line">STR R1，[R0，#-0x4]!; R1-&gt;mem32[R0-0x4],R0&lt;-R0-0x4</span><br><span class="line">LDR r0，[r1，r2]; r0&lt;-mem32[r1+r2]</span><br><span class="line">LDR r0，[r1，r2，LSL #2]; r0&lt;-mem32[r1+r2*4](r2逻辑左移4位)</span><br></pre></td></tr></table></figure><h3 id="多寄存器寻址-Multiple-Register-Addressing"><a href="#多寄存器寻址-Multiple-Register-Addressing" class="headerlink" title="多寄存器寻址 Multiple Register Addressing"></a>多寄存器寻址 Multiple Register Addressing</h3><p>采用多寄存器寻址方式，一条指令可以完成多个寄存器值的传送。<br>这种寻址方式是多寄存器传送指令 LDM&#x2F;STM 的寻址方式，这种寻址方式中用一条指令最多可传送 16 个通用寄存器的值。连续的寄存器间用<code>-</code>连接，否则用<code>,</code>分隔</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDMIA R0！，&#123;R1-R4&#125;;</span><br><span class="line">R1←[R0]、R2←[R0＋4]、R3←[R0＋8]、R4←[R0＋12]</span><br></pre></td></tr></table></figure><p>LDMIA “Load Multiple Increment After”<br>从 R0 指向的地址开始，连续加载寄存器 R1, R2, R3, R4 的值，并将最后的地址写回到 R0 中”<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-17-15-24-28.png"></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4种寻址操作</span><br><span class="line">LDMIA/STMIAIncrement After(先传送，后地址加4)</span><br><span class="line">LDMIB/STMIBIncrement Before(先地址加4 ,后传送)</span><br><span class="line">LDMDA/STMDADecrement After(先传送，后地址减4)</span><br><span class="line">LDMDB/STMDBDecrement Before (先地址减4,后传送)</span><br><span class="line">⚠️注意:对于所有LDM/STM指令而言，寄存器序号低的，在低地址单元，序号大的在高地址单元！与书写顺序无关！</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-1ARM%E6%8C%87%E4%BB%A4%E9%9B%86-2024-03-17-15-38-02.png" alt="LDM/STM"></p><h3 id="堆栈寻址-Stack-Addressing"><a href="#堆栈寻址-Stack-Addressing" class="headerlink" title="堆栈寻址 Stack Addressing"></a>堆栈寻址 Stack Addressing</h3><p>堆栈是一种数据结构，按后进先出（Last In First Out， LIFO）的方式工作，使用一个称作堆栈指针的专用寄存器指示当前的操作位置，堆栈指针总是指向栈顶。</p><p>堆栈可分为两种增长方式：</p><ul><li><strong>向上生长</strong>：向高地址方向生长，称为递增堆栈。</li><li><strong>向下生长</strong>：向低地址方向生长，称为递减堆栈。</li></ul><p>根据堆栈指针指向的数据位置的不同，可分为：</p><ul><li><strong>满堆栈</strong>：堆栈指针指向最后压入堆栈的有效数据项，称为满堆栈;</li><li><strong>空堆栈</strong>：堆栈指针指向下一个待压入数据的空位置，称为空堆栈。</li></ul><p>四种类型的堆栈工作方式</p><ul><li><strong>满递增堆栈 FA</strong>(Full Ascending)：堆栈指针指向最后压入的数据，且由低地址向高地址生长。</li><li><strong>空递增堆栈 EA</strong>(Empty Ascending)：堆栈指针指向下一个将要放入数据的空位置，且由低地址向高地址生长。</li><li><strong>满递减堆栈 FD</strong>(Full Descending) ：堆栈指针指向最后压入的数据，且由高地址向低地址生长。</li><li><strong>空递减堆栈 ED</strong>(Empty Descending)：堆栈指针指向下一个将要放入数据的空位置，且由高地址向低地址生长。</li></ul><p>STMXX 是存入到主存，是入栈操作;LDMXX 是从主存读出到寄存器，是出栈操作</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">STMFD</span>  <span class="built_in">SP</span>!,&#123;<span class="built_in">R1</span>-<span class="built_in">R7</span>,<span class="built_in">LR</span>&#125;<span class="comment">;将R1-R7，LR入栈</span></span><br><span class="line"><span class="keyword">LDMFD</span>  <span class="built_in">SP</span>!,&#123;<span class="built_in">R1</span>-<span class="built_in">R7</span>,<span class="built_in">LR</span>&#125;<span class="comment">;数据出栈，放入R1-R7,LR</span></span><br></pre></td></tr></table></figure><h3 id="相对寻址-Relative-Addressing"><a href="#相对寻址-Relative-Addressing" class="headerlink" title="相对寻址 Relative Addressing"></a>相对寻址 Relative Addressing</h3><p>与基址变址寻址方式相类似，相对寻址以程序计数器 PC 的当前值为基地址，指令中的地址标号作为偏移量，将<br>两者相加之后得到操作数的有效地址</p>]]></content>
    
    
    <summary type="html">ARM指令集简介,包括ARM指令格式、ARM指令的条件码、ARM指令分类、ARM指令的寻址方式等</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM-Processor" scheme="https://efterklang.github.io/categories/UESTC/ARM-Processor/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层 DataLink Layer Ⅱ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch3-2DataLinkLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch3-2DataLinkLayer/</id>
    <published>2024-03-19T06:48:55.000Z</published>
    <updated>2024-04-02T09:05:52.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="点对点协议-Point-to-Point-Protocol"><a href="#点对点协议-Point-to-Point-Protocol" class="headerlink" title="点对点协议 Point to Point Protocol"></a>点对点协议 Point to Point Protocol</h2><p>一般的用户接入互联网的方式: 连接到某个因特网服务提供者 ISP(中国电信,中国移动.etc),用户计算机获取到 ISP 所分配的合法 IP 地址后,才能成为因特网的一员;PPPoE(PPP over Ethernet)协议在家庭和小型企业中被广泛用于连接到互联网服务提供商</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-12-15-55-21.png"></p><p>PPP（Point-to-Point Protocol）是一种网络协议,通常用于在两点之间建立直接连接,例如计算机和互联网服务提供商（ISP）的连接。PPP 可以在各种类型的物理网络上运行,包括串行线、电话线、同轴电缆、全双工光纤传输线路或无线连接等。</p><h3 id="Components-of-PPP"><a href="#Components-of-PPP" class="headerlink" title="Components of PPP"></a>Components of PPP</h3><p><strong>The Link Control Protocol (LCP)</strong>: responsible for establishing, configuring, and testing the link between the two devices. It negotiates link parameters like the maximum frame size and compression type while monitoring the link for errors and drops<br><strong>The Authentication Protocol (AP)</strong>: responsible for verifying the identities of the two devices using a range of authentication methods, including passwords, digital certificates, and biometrics<br><strong>The Network Control Protocol (NCP)</strong>: responsible for negotiating the network layer protocol used to transmit data over the connection, supporting a variety of network layer protocols such as IP, IPX, and AppleTalk!<br><a href="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-18-55-25.png"></a></p><h3 id="PPP-的主要特性和功能"><a href="#PPP-的主要特性和功能" class="headerlink" title="PPP 的主要特性和功能"></a>PPP 的主要特性和功能</h3><ul><li><strong>封装数据</strong>：PPP 可以封装 IP,IPX 等网络层协议的数据包,使它们可以在点对点链接上传输。</li><li><strong>身份验证</strong>：PPP 支持 PAP（Password Authentication Protocol）和 CHAP（Challenge Handshake Authentication Protocol）等身份验证协议,这些协议可以在建立连接时验证用户的身份。</li><li><strong>链接控制</strong>：PPP 使用 LCP（Link Control Protocol）来建立、配置和测试数据链路连接。</li><li><strong>网络控制</strong>：PPP 使用 NCP（Network Control Protocol）来建立和配置不同的网络层协议。</li><li><strong>错误检测</strong>：PPP 帧包含一个校验和字段,用于错误检测。</li><li><strong>多协议支持</strong>：PPP 支持多种网络层协议,这使得它可以在各种不同的网络环境中使用。</li></ul><p>PPP 是一种灵活且广泛使用的协议,特别适用于拨号和 DSL 连接。它是许多互联网用户连接到 ISP 的基础。它的特点是：简单；只检测差错,而不是纠正差错；不使用序号,也不进行流量控制；可同时支持多种网络层协议,是目前使用最广泛的点对点数据链路层协议</p><h3 id="PPP-帧格式"><a href="#PPP-帧格式" class="headerlink" title="PPP 帧格式"></a>PPP 帧格式</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-12-16-44-00.png" alt="Frame Format"></p><h3 id="PPP-透明传输"><a href="#PPP-透明传输" class="headerlink" title="PPP 透明传输"></a>PPP 透明传输</h3><p>面向字节的异步链路：字节填充法(插入转义字符)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-15-34-56.png"><br>面向比特的同步链路：比特填充法(插入比特 0)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-15-37-14.png"></p><h3 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h3><p>能够对接收端收到的帧进行检测,并立即丢弃有差错的帧。因此 PPP 向上层提供的是不可靠传输服务</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-15-51-31.png"></p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-18-18-43-26.png"></p></center><blockquote><ul><li>Bob initiates a connection by dialing his ISP’s phone number</li><li>Bob’s modem establishes a physical connection with the ISP’s modem over a phone line</li><li>The two modems exchange LCP packets for negotiating the connection parameters. Parameters are, for instance, the maximum frame size and compression type</li><li>They agree to a maximum frame size of 1500 bytes with no compression</li><li>After the LCP negotiation, Bob’s modem and the ISP’s modem authenticate each other’s identities</li><li>The ISP uses the Challenge-Handshake Authentication Protocol (CHAP) to verify Bob’s identity. Bob, however, employs the Password Authentication Protocol (PAP) to verify the ISP’s identity</li><li>Once authentication is complete, the two modems exchange NCP packets. So, they determine which network layer protocol will be used to transmit data over the connection</li><li>They agree to use the TCP&#x2F;IP protocol suite</li><li>With the NCP negotiation complete, we can transmit the data between Bob’s computer and the internet using the TCP&#x2F;IP protocol suite through encapsulated frames transmitted over the PPP connection</li><li>Finally, when Bob finishes using the internet, he can terminate the PPP connection by disconnecting the modem or logging off the ISP’s **server<br>*PPP 协议已不是纯粹的数据链路层的协议,它还包含了物理层和网络层的内容*</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-19-10-51-14.png"></p><h2 id="媒体接入控制-Media-Access-Control"><a href="#媒体接入控制-Media-Access-Control" class="headerlink" title="媒体接入控制 Media Access Control"></a>媒体接入控制 Media Access Control</h2><h3 id="MAC-引入"><a href="#MAC-引入" class="headerlink" title="MAC 引入"></a>MAC 引入</h3><p><strong>局域网的数据链路层</strong></p><ul><li>局域网最主要的<strong>特点</strong>是：<ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。</li></ul></li><li>局域网具有如下<strong>主要优点</strong>：<ul><li>具有广播功能,从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。</li><li>便于系统的扩展和逐渐地演变,各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li></ul><p><strong>数据链路层的两个子层</strong><br>为了使数据链路层能更好地适应多种局域网标准,IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ul><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ul><p>与接入到传输媒体有关的内容都放在 MAC 子层,而 LLC 子层则与传输媒体无关。<strong>不管采用何种协议的局域网,对 LLC 子层来说都是透明的。</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-19-15-39-34.png"></p><p>为什么要媒体接入控制（介质访问控制）？<br><strong>共享信道带来的问题</strong><br>若多个设备在共享信道上同时发送数据,则会造成彼此干扰,导致发送失败。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-22-22-20-50.png" alt="DataLinkLayerPart2-2024-03-22-22-20-50"></p><p><strong>媒体接入控制(MAC)可分为</strong></p><p><strong>1. 静态信道划分 Static Channel Allocation</strong><br>静态信道划分（Static Channel Allocation）是一种通信网络中的资源分配策略,它将可用的频谱资源事先固定地分配给各个用户或者信道。这种方式下,即使某个用户或信道当前没有数据需要传输,其分配的资源也不能被其他用户或信道使用,因此可能导致资源的浪费。谨常在无线网络的物理层中使用</p><p>SCA 有三种主要的技术,在这些技术中,每个用户或信道都被分配到一个特定的频率带宽、时间槽或编码。</p><ul><li>频分多址 FDMA,Frequency Division Multiple Access</li><li>时分多址 TDMA,Time Division Multiple Access</li><li>码分多址 CDMA,Code Division Multiple Access</li></ul><p><strong>2. 动态接入控制 Dynamic Access Control</strong></p><p>动态接入控制（Dynamic Access Control）是一种网络通信中的资源分配策略,它根据网络的实时需求动态地分配资源。与静态信道划分（如 FDMA、TDMA、CDMA）相比,动态接入控制可以更有效地利用可用资源。在动态接入控制中,如果一个用户没有数据需要传输,其分配的资源可以被其他用户使用,从而避免了资源的浪费。这种方式需要一个接入控制协议来确定哪些用户可以在哪个时刻使用网络资源。</p><ul><li>受控接入 Controlled Access(已经被淘汰)<ul><li>集中控制 Centralized Control</li><li>分散控制 Distributed Control</li></ul></li><li>随机接入 Random Access<ul><li>ALOHA</li><li>CSMA&#x2F;CD</li><li>CSMA&#x2F;CA</li></ul></li></ul><h3 id="MAC-定义"><a href="#MAC-定义" class="headerlink" title="MAC 定义"></a>MAC 定义</h3><p><strong>Media access control</strong>, medium access control or simply MAC, is a specific network data transfer policy. It determines how data transmits through a regular network cable. The protocol exists to ease data packets’ transfer between two computers and ensure no collision or simultaneous data transit occurs.</p><p>The medium access control – commonly referred to as the MAC protocol – is, effectively, a sublayer or MAC sublayer that controls hardware responsible for the communication with a wired, wireless or optical transmission medium.</p><p>The MAC sublayer is part of the two sublayers scheme: data link layer. The other part of the data link layer is the logical link control (LLC) sublayer. The LLC sublayer offers multiplexing and flow control for the logical link, and the MAC sublayer acts as the interface between the LLC sublayer and the physical layer within a transmission medium.<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart2-2024-03-19-15-02-02.png"></p><p><strong>媒体访问控制（MAC）</strong>是数据通信协议中一种子层,它是数据链路层的一部分。MAC 子层的主要职责是控制设备如何访问网络介质（例如以太网,Wi-Fi）,以便进行有效的信息传输。<br>MAC 地址是一个设备网络接口的唯一标识符。它通常由六组两位十六进制数字组成,例如：<code>00:0A:95:9D:68:16</code>。每个网络设备的 MAC 地址都是全球唯一的,由设备制造商在生产时分配。<br>MAC 地址在网络通信中起着关键作用。当一个设备需要发送数据包到另一个设备时,它会使用目标设备的 MAC 地址来定位它。这是在同一局域网（LAN）内进行通信的基础。</p><h3 id="静态划分信道-Static-Channel-Allocation"><a href="#静态划分信道-Static-Channel-Allocation" class="headerlink" title="静态划分信道 Static Channel Allocation"></a>静态划分信道 Static Channel Allocation</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-25-18-53-09.png"></p><p><strong>复用 (Multiplexing)</strong> 是通信技术中的一个重要概念。复用就是通过一条物理线路同时传输多路用户的信号。当网络中传输媒体的传输容量大于多条单一信道传输的总通信量时,可利用复用技术在一条物理线路上建立多条通信信道来充分利用传输媒体的带宽。</p><h5 id="频分复用-FDM-Frequency-Division-Multiplexing"><a href="#频分复用-FDM-Frequency-Division-Multiplexing" class="headerlink" title="频分复用 FDM (Frequency Division Multiplexing)"></a>频分复用 FDM (Frequency Division Multiplexing)</h5><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-09-41-34.png"></p><p>将传输线路的频带资源划分成多个子频带,形成多个子信道,各子信道间需要留出隔离频带,以免造成子信道间的十扰。当多路信号输入一个多路复用器时,这个复用器将每一路信号调制到不同频率的载波上。接收端由相应的分用器通过滤波将各路信号分开,将合成的复用信号恢复成原始的多路信号。</p><h5 id="时分复用-TDM-Time-Division-Multiplexing"><a href="#时分复用-TDM-Time-Division-Multiplexing" class="headerlink" title="时分复用 TDM (Time Division Multiplexing)"></a>时分复用 TDM (Time Division Multiplexing)</h5><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是 TDM 帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li>时分复用的所有用户在不同的时间占用同样的频带宽度。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-09-42-39.png"></p><h5 id="波分复用-WDM-Wavelength-Division-Multiplexing"><a href="#波分复用-WDM-Wavelength-Division-Multiplexing" class="headerlink" title="波分复用 WDM (Wavelength Division Multiplexing)"></a>波分复用 WDM (Wavelength Division Multiplexing)</h5><p>波分复用就是光的频分复用,使用一根光纤来同时传输多个光载波信号;光信号传输一段距离后会衰减,所以要用<strong>掺铒光纤放大器 EDFA(Erbium-Doped Fiber Amplifier)</strong> 放大光信号<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-10-07-39.png"></p><h5 id="码分复用-CDM-Code-Division-Multiplexing"><a href="#码分复用-CDM-Code-Division-Multiplexing" class="headerlink" title="码分复用 CDM (Code Division Multiplexing)"></a>码分复用 CDM (Code Division Multiplexing)</h5><p><strong>码分复用 CDM</strong> 是另一种共享信道的方法。实际上,由于该技术主要用于多址接入,人们更常用的名词是<strong>码分多址 CDMA(Code Division MuItipIe Access)</strong> 同理,频分复用 FDM 和时分复用 TDM 同样可用于多址接入,相应的名词是频分多址 FDMA(Frequency Division Multiple Access) 和时分多址 TDMA(Time Division Multiple Access);与 FDM 和 TDM 不同,CDM 的每一个用户可以在同样的时间使用同样的频带进行通信。由于各用户使用经过特殊挑选的不同码型,因此各用户之间不会造成干扰。CDM 最初是用于军事通信的,因为这种系统所发送的信号有很强的抗干扰能力,其频谱类似于白噪声,不易被敌人发现。随着技术的进步,CDMA 设备的价格和体积都大幅度下降,因而现在已广泛用于民用的移动通信中</p><blockquote><p>复用与多址的概念。可简单理解如下：</p><ul><li>复用(Multiplexing)是将单一媒体的频带资源划分成很多子信道,这些子信道之间相互独立,互不干扰。从媒体的整体频带资源上看,每个子信道只占用该媒体频带资的一部分。</li><li>多址(Multiple Access),更确切地应该称为多点接入,处理的是动态分配信道给用户;这在用户暂时性占用信道(如移动通信)的应用中是必须的。在信道永久性地分配给用户(如无线广播等)的应用中,多址是不需要的</li><li>某种程度上,FDMA,TDMAS CDMA 可以分别看成是 FDM,TDM,CDM 的应用</li></ul></blockquote><ul><li><p>在 CDMA 中,每一个比特时间再划分为 m 个短的间隔,称为<strong>码片 (Chip)</strong>;通常 m 的值是 64 或 128 为了简单起见,在后续的举例中,我们假设 m 为 8;</p></li><li><p>使用 CDMA 的每一个站被指派一个唯一的 m bit <strong>码片序列 (Chip Sequence);</strong></p><ul><li>一个站如果要发送比特 1 ,则发送它自己的 m bit 码片序列；</li><li>一个站如果要发送比特 0 ,则发送它自己的 m bit 码片序列的二进制反码；<br>指派给（ DMA 系统中某个站点的码片序列为 <code>00011011</code><br>发送比特 1:发送自己的码片序列 <code>00011011</code><br>发送比特 0:发送自己的码片序列的二进制反码 <code>11100100</code><br>为了方便，我们按惯例将码片序列中的 0 写为-1, 将 1 写为+ 1 。则该站点的码片序列是<code>(-1 -1 -1 + 1 + 1 -1 + 1 + 1)</code></li></ul></li><li><p>码片序列需要满足的条件</p><ul><li>每个站的 Chip Sequence 不能相同,实际上常采用伪随机码片序列,这样可以使得码片序列之间的相关性很小,从而减小干扰；</li><li>每个站的 Chip Sequence 必须相互正交,令向量 S 表示站 S 的码片序列，令向量 T 表示其他任何站的码片序列。两个不同站 S 和 T 的码片序列正交，就是向量 S 和 T 的规格化内积为 0 ：</li><li>满足的 4 个条件如公式所示<div>$$  \begin{array}{ll}  S \cdot T \equiv \frac{1}{m} \sum_{i=1}^{m} S_{i} T_{i}=0 &  S \cdot \bar{T} \equiv 0 \\  S \cdot S \equiv \frac{1}{m} \sum_{i=1}^{m} S_{i} S_{i}=\frac{1}{m} \sum_{i=1}^{m} S_{i}^{2}=\frac{1}{m} \sum_{i=1}^{m}( \pm 1)^{2}=1 &   S \cdot \bar{S} \equiv-1   \end{array}$$</div></li></ul></li></ul><p><strong>Examples</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-15-29-46.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-15-44-04.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-15-47-32.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch3-2DataLinkLayer-2024-03-26-15-48-11.png"></p><h3 id="动态接入控制-Dynamic-Access-Control"><a href="#动态接入控制-Dynamic-Access-Control" class="headerlink" title="动态接入控制 Dynamic Access Control"></a>动态接入控制 Dynamic Access Control</h3>]]></content>
    
    
    <summary type="html">介绍数据链路层的 PPP 协议和 MAC 协议</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>Thread</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch2-4Thread/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch2-4Thread/</id>
    <published>2024-03-14T11:36:01.000Z</published>
    <updated>2024-03-29T06:55:04.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>为使程序能并发执行，系统必须进行以下的一系列操作:<strong>创建进程</strong> <strong>撤消进程</strong> <strong>进程切换</strong><br>由于进程是一个资源的拥有者，因此在创建、撤销和切换中，系统必须为此付出较大的时间和空间的开销。<br>如何使多个程序更好的并发执行，同时又能减少系统开销？</p><p><strong>进程的概念体现出两个特点</strong>：</p><ul><li><strong>资源所有权</strong>：一个进程包括一个保存进程映像的虚地址空间，并且随时分配对资源的控制或所有权，包括内存、I&#x2F;O 通道、I&#x2F;O 设备、文件等。</li><li><strong>调度／执行</strong>：进程是被操作系统调度的实体。</li></ul><p>调度和分派的部分通常称为<strong>线程或轻型进程</strong>（lightweight process），而资源所有权的部分通常称为<strong>进程</strong></p><p><strong>线程</strong>具有许多传统进程所具有的特征，所以又称为<strong>轻型进程</strong>(Light-Weight Process) ，相应地把传统<strong>进程</strong>称为<strong>重型进程</strong>(Heavy-Weight Process)，传统进程相当于只有一个线程的任务。<br>在引入了线程的操作系统中，通常一个进程都拥有若干个线程，至少也有一个线程。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-4Thread-2024-03-13-09-23-33.png" alt="Create Thread vs Create Process"></p><p><strong>History</strong></p><ul><li><strong>60 年代</strong>：提出进程(Process)概念，在 OS 中一直都是以进程作为能拥有资源和独立运行的基本单位的。</li><li><strong>80 年代中期</strong>：提出线程（Thread）概念，线程是比进程更小的能独立运行的基本单位，目的是提高系统内程序并发执行的程度，进一步提高系统的吞吐量。</li><li><strong>90 年代</strong>：多处理机系统得到迅速发展，线程能比进程更好地提高程序的并行执行程度，充分发挥多处理机的优越性。</li></ul><h3 id="线程的共享问题"><a href="#线程的共享问题" class="headerlink" title="线程的共享问题"></a>线程的共享问题</h3><p>进程内的所有线程共享进程的很多资源,而这种共享又带来了同步问题</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程间共享                 线程私有</span><br><span class="line">进程指令       线程ID</span><br><span class="line">全局变量        寄存器集合（包括PC和栈指针）</span><br><span class="line">打开的文件           栈（用于存放局部变量）</span><br><span class="line">信号处理程序                信号掩码</span><br><span class="line">当前工作目录                优先级</span><br><span class="line">用户ID</span><br></pre></td></tr></table></figure><h3 id="线程的互斥问题"><a href="#线程的互斥问题" class="headerlink" title="线程的互斥问题"></a>线程的互斥问题</h3><p><strong>对全局变量进行访问的基本步骤</strong></p><ul><li>将内存单元中的数据读入寄存器</li><li>对寄存器中的值进行运算</li><li>将寄存器中的值写回内存单元<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-4Thread-2024-03-13-09-33-01.png"></li></ul><h4 id="线程的属性"><a href="#线程的属性" class="headerlink" title="线程的属性"></a>线程的属性</h4><ul><li><strong>轻型实体</strong> 线程自己基本不拥有系统资源，只拥有少量必不可少的资源：TCB，程序计数器、一组寄存器、栈。</li><li><strong>独立调度和分派的基本单位</strong> 在多线程 OS 中,线程是独立运行的基本单位,因而也是独立调度和分派的基本单位。</li><li><strong>可并发执行</strong> 同一进程中的多个线程之间可以并发执行，一个线程可以创建和撤消另一个线程。</li><li><strong>共享进程资源</strong> 它可与同属一个进程的其它线程共享进程所拥有的全部资源。</li></ul><h2 id="线程与进程的比较"><a href="#线程与进程的比较" class="headerlink" title="线程与进程的比较"></a>线程与进程的比较</h2><p><strong>Ref</strong><br>[<a href="Ch2-1ProcessContorl" title="进程的描述及控制">Ch2-1ProcessContorl#进程的描述 Process</a>]<br>[<a href="ProcessvsThread" title="Process &amp; Thread">ProcessvsThread#Comparison</a>]</p><h2 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a>线程的控制</h2><h3 id="Create-Terminate-Thread"><a href="#Create-Terminate-Thread" class="headerlink" title="Create&#x2F;Terminate Thread"></a>Create&#x2F;Terminate Thread</h3><p><strong>线程的创建</strong>：</p><ul><li>在多线程 OS 环境下，应用程序在启动时，通常仅有一个“初始化线程”线程在执行。</li><li>在创建新线程时，需要利用一个线程创建函数(或系统调用)，并提供相应的参数。</li><li>如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。</li><li>在线程创建函数执行完后，将返回一个线程标识符供以后使用。</li></ul><p><strong>线程的终止</strong>：</p><ul><li>线程完成了自己的工作后自愿退出；</li><li>或线程在运行中出现错误或由于某种原因而被其它线程强行终止。</li></ul><p><strong>线程的三种终止方式</strong></p><ul><li>线程从启动例程函数中返回，函数返回值作为线程的退出码</li><li>线程被同一进程中的其他线程取消</li><li>线程在任意函数中调用 <code>pthread_exit</code> 函数终止执行</li></ul><h2 id="线程间的同步与通信"><a href="#线程间的同步与通信" class="headerlink" title="线程间的同步与通信"></a>线程间的同步与通信</h2><h3 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁 Mutex"></a>互斥锁 Mutex</h3><p>互斥锁是一种比较简单的、用于实现进程间对资源互斥访问的机制。<br>由于操作互斥锁的时间和空间开销都较低，因而较适合于高频度使用的关键共享数据和程序段。<br>互斥锁可以有两种状态， 即开锁(unlock)和关锁(lock)状态。</p><p><strong>上锁的两种方式</strong></p><ul><li>阻塞方式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//用来锁住互斥体变量。如果参数 mutex 所指的互斥体已经被锁住了，那么发出调用的线程将被阻塞直到其他线程对 mutex 解锁。</span></span><br><span class="line">lock(mutex)</span><br><span class="line">访问</span><br><span class="line">unlock(mutex)</span><br></pre></td></tr></table></figure><ul><li>非阻塞方式</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（trylock） then</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//如果互斥体已经被上锁，该调用不会阻塞等待，而会返回一个错误代码。</span></span><br></pre></td></tr></table></figure><h3 id="条件变量-Condition-Variable"><a href="#条件变量-Condition-Variable" class="headerlink" title="条件变量 Condition Variable"></a>条件变量 Condition Variable</h3><p>在多线程编程中，条件变量是一种同步机制，用于在某个特定条件变为真时唤醒一个或多个线程。条件变量通常与互斥锁（mutex）一起使用，以确保线程在检查条件和对条件进行等待时不会发生竞争条件。</p><p>以下是条件变量在控制线程同步中的一般用法：</p><ul><li><strong>等待条件</strong>：当线程需要等待某个条件变为真时，它会首先获取与条件变量相关联的互斥锁。然后，它会检查条件是否已经满足。如果条件未满足，线程会调用条件变量的等待方法（例如在 Java 中的 <code>Condition.await()</code>）。这将释放互斥锁，并使线程进入睡眠状态，等待条件变为真。</li><li><strong>改变条件</strong>：当线程改变可能会影响条件的状态的数据时，它会首先获取互斥锁，然后修改数据。修改完成后，它会调用条件变量的唤醒方法（例如在 Java 中的 <code>Condition.signal()</code>或 <code>Condition.signalAll()</code>），以唤醒正在等待该条件的所有线程。然后，它会释放互斥锁。</li><li><strong>响应唤醒</strong>：当线程被唤醒时（即，它从等待方法返回时），它会重新获取互斥锁，并再次检查条件。这是必要的，因为在多线程环境中，条件可能在线程被唤醒和线程实际运行之间的时间内发生变化。</li></ul><p>使用条件变量可以使线程在等待某个条件时不必进行忙等待（即，不断地检查条件是否已经满足）。这可以大大提高系统的效率，因为线程在等待时不会消耗 CPU 资源。</p><h3 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h3><ul><li><strong>私用信号量</strong>(private semaphore)。<br>当某线程需利用信号量来实现同一进程中各线程之间的同步时，可调用创建信号量的命令来创建一私用信号量，其数据结构存放在应用程序的地址空间中。<br>私用信号量属于特定的进程所有，OS 并不知道私用信号量的存在，因此，一旦发生私用信号量的占用者异常结束或正常结束，但并未释放该信号量所占有空间的情况时，系统将无法使它恢复为 0(空)，也不能将它传送给下一个请求它的线程。</li><li><strong>公用信号量</strong>(public semaphore)。<br>公用信号量是为实现不同进程间或不同进程中各线程之间的同步而设置的。<br>有着一个公开的名字供所有的进程使用，故称为公用信号量。<br>其数据结构是存放在受保护的系统存储区中，由 OS 为它分配空间并进行管理，故也称为<strong>系统信号量</strong><br>如果信号量的占有者在结束时未释放该公用信号量，则 OS 会自动将该信号量空间回收，并通知下一进程。因此公用信号量是一种比较安全的同步机制</li></ul><h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><p>各类线程的实现细节，其中上下文切换是核心</p><h3 id="用户级线程-User-Level-Threads"><a href="#用户级线程-User-Level-Threads" class="headerlink" title="用户级线程 User-Level Threads"></a>用户级线程 User-Level Threads</h3><ul><li><strong>用户级线程</strong>仅存在于<strong>用户空间</strong>中。对于这种线程的创建、撤消、线程之间的同步与通信等功能，都<strong>无须内核</strong>来实现。</li><li>对于用户级线程的切换，通常是发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。由于切换的规则远比进程调度和管理的规则简单，因而使线程的切换速度特别快。可见，这种线程是与内核无关的</li><li>由应用程序完成所有线程的管理<br><strong>线程库</strong>(用户空间)：通过一组管理线程的函数库来提供一个线程运行管理系统（运行系统）</li><li>内核不知道线程的存在</li><li>线程切换不需要核心态特权</li><li>调度算法可以是进程专用的</li></ul><p><strong>Pros And Cons:</strong></p><ul><li>线程切换不调用内核</li><li>调度是应用程序特定的：可以选择最好的算法</li><li>可运行在任何操作系统上（只需要线程库），可以在一个不支持线程的 OS 上实现</li></ul><hr><ul><li>当线程执行一个系统调用时，该线程及其所属进程内的所有线程都会被阻塞。</li><li>多线程应用不能利用多处理机进行多重处理。</li></ul><p><strong>用户级线程实现</strong></p><p>用户级线程是在<strong>用户空间</strong>实现的。所有用户级线程都具有相同的数据结构，它们都运行在一个中间系统上。</p><p>当前有两种方式实现的中间系统：</p><ul><li><strong>运行时系统</strong>（又称为线程库）<br>用于管理和控制线程的函数的集合，包括创建、撤消线程函数、线程同步和通信函数、线程调度函数等。<br>用户级线程不能直接利用系统调用，必须通过<strong>运行时系统</strong>间接利用系统调用。</li><li><strong>内核控制线程</strong><br>这种线程又称为轻型进程 LWP（Light Weight Process）<br>每个进程都可拥有多个 LWP，每个 LWP 都有自己的 TCB，其中包括线程标识符、优先级、状态、栈和局部存储区等<br>LWP 可通过系统调用来获得内核提供的服务，当一个用户级线程运行时，只要将它连接到一个 LWP 上，它便具有了内核支持线程的所有属性</li></ul><h3 id="内核支持线程-Kernel-Supported-Threads"><a href="#内核支持线程-Kernel-Supported-Threads" class="headerlink" title="内核支持线程 Kernel Supported Threads"></a>内核支持线程 Kernel Supported Threads</h3><ul><li>内核支持线程，是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，是<strong>依靠内核</strong>实现的。</li><li>在内核空间中为每一个内核支持线程设置了一个线程控制块 TCB， 内核是根据该控制块而感知某线程的存在的，并对其加以控制。</li></ul><p><strong>Pros and Cons</strong></p><ul><li>在多处理器系统中，内核能够同时调度同一进程中多个线程并行执行；</li><li>如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程；</li><li>内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小；</li><li>内核本身也可以采用多线程技术，可以提高系统的执行速度和效率。</li></ul><hr><p>对于线程切换而言，其模式切换的开销较大<br>在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态再转到用户态进行，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。</p><blockquote><p>和用户级相比，内核支持线程有什么不同?<br>由内核完成线程的创建、调度等<br>主要工作仍是保存现场,但保存位置为内核栈<br>每个执行序列需有两个栈: 用户栈+内核栈<br>用户栈：普通的函数调用<br>内核栈：系统调用、中断处理</p></blockquote><p><strong>内核支持线程的实现</strong></p><p>在仅设置了内核支持线程的 OS 中，一种可能的线程控制方法是，系统在创建一个新进程时，便为它分配一个任务数据区 PTDA(Per Task Data Area),其中包括若干个线程控制块 TCB 空间。TCB 包含了线程的各种信息，如线程的状态（运行、就绪、阻塞等）、寄存器的值、栈指针、优先级、线程 ID 等。每个线程都有一个与之对应的 TCB。</p><p>在创建新进程时，系统会为该进程的 PTDA 预分配若干个 TCB 空间,用来存放该进程将要创建的线程的 TCB。当进程创建新线程时，一个空闲的 TCB 会被取出并填充该线程的信息。当线程结束时，其 TCB 会被回收并放回到空闲的 TCB 池中。</p><p>通过这种方式，系统可以有效地管理和调度线程。每次线程切换时，系统只需要保存当前线程的状态到其 TCB 中，然后从下一个线程的 TCB 中恢复其状态，就可以实现线程的切换。</p><h3 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h3><blockquote><p><strong>EX1</strong><br>进程 A 包含了 1 个用户级线程$t_{1}$，进程 B 包含了 100 个用户级线程$t_{i},i \in (1,100)$，$t_1$运行的时间和$t_i$的运行时间是否一样？<br>不一样，$t_1$运行的时间是$t_{i}$的 100 倍,进程 B 获得 CPU 的时间与进程 A 的相等<br><strong>EX2</strong><br>若进程 A 和进程 B 中的线程都是内核支持线程，两者的运行时间是否一样？<br>$t_1&#x3D;t_i$,进程 B 获得 CPU 的时间是进程 A 的 100 倍<br><strong>Explanation</strong><br>当一个系统设置了<strong>用户级线程</strong>时，虽然每个进程可能有多个线程，但对于操作系统内核来说，它只看到进程，而看不到进程内部的线程。因此，内核的调度仍然是<strong>以进程为单位</strong>进行的。在采用时间片轮转调度算法时，操作系统会<strong>公平地将处理器时间分配给每个进程</strong>。也就是说，每个进程都会轮流获得一定的处理器时间（时间片）来执行。这确保了各个进程之间的公平性。<br>而运行<strong>内核支持线程</strong>时,操作系统内核是可以看到进程内部的线程的。因此，内核的调度是<strong>以线程为单位</strong>进行的。也就是说，每个线程都会轮流获得一定的处理器时间（时间片）来执行。这确保了各个线程之间的公平性。</p></blockquote>]]></content>
    
    
    <summary type="html">Thread</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Interprocess Communication</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch2-3InterprocessCommunication/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch2-3InterprocessCommunication/</id>
    <published>2024-03-11T06:54:48.000Z</published>
    <updated>2024-03-21T09:54:37.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程通信的类型-Types-Of-IPC"><a href="#进程通信的类型-Types-Of-IPC" class="headerlink" title="进程通信的类型 Types Of IPC"></a>进程通信的类型 Types Of IPC</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><strong>低级通信</strong>：进程之间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。<br>信号量机制作为同步工具是卓有成效的，但作为通信工具，则不够理想，<br>主要表现在下述两方面：</p><ol><li>效率低，生产者每次只能向缓冲池投放一个产品(消息)，消费者每次只能从缓冲区中取得一个消息；</li><li>通信对用户不透明。</li></ol><hr><p><strong>高级通信</strong>：是指用户可直接利用操作系统所提供的一组通信命令高效地传送大量数据的一种通信方式。常用的高级通信方式有 :</p><ul><li><strong>共享存储器系统</strong>：在内存中分配一片空间作为共享存储区</li><li><strong>管道通信</strong>：写者向管道文件中写入数据；读者从该文件中读出数据</li><li><strong>消息传递系统</strong>：以消息（Message）为单位在进程间进行数据交换<ul><li>直接通信方式</li><li>间接通信方式</li></ul></li><li><strong>客户机-服务器系统</strong></li></ul><h3 id="共享存储器系统-Shared-Memory-System"><a href="#共享存储器系统-Shared-Memory-System" class="headerlink" title="共享存储器系统 Shared-Memory System"></a>共享存储器系统 Shared-Memory System</h3><ol><li><p><strong>基于共享数据结构的通信方式</strong><br>诸进程共用某些数据结构，借以实现诸进程间的信息交换。<br>如在生产者—消费者问题中，就是用有界缓冲区这种数据结构来实现通信的。这种通信方式是低效的，只适于传递相对少量的数据。</p></li><li><p><strong>基于共享存储区的通信方式</strong><br>由操作系统在内存中划分出一块区域作为共享存储区。<br>进程在通信前向操作系统申请共享存储区中的一个分区。<br>然后，申请进程把获得的共享存储分区连接到本进程上，此后便可象读&#x2F;写普通存储器一样地读&#x2F;写共享存储分区。<br>该方式下，通信进程之间的同步与互斥访问共享存储区由进程负责。</p></li></ol><h3 id="管道通信-Pipe-Communication"><a href="#管道通信-Pipe-Communication" class="headerlink" title="管道通信 Pipe Communication"></a>管道通信 Pipe Communication</h3><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名 pipe 文件。<br>向管道(共享文件)提供输入的发送进程 Writer， 以<strong>字符流 Character Stream</strong>形式将大量的数据写入管道；<br>接受管道输出的接收进程 Reader，则从管道中读数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。<br>这种方式首创于 UNIX 系统，由于它能有效地传送大量数据，因而又被引入到许多其它操作系统中。</p><p>为了协调双方的通信，管道机制必须提供以下<strong>三方面</strong>的协调能力：</p><ul><li><strong>互斥</strong>，即当一个进程正在对 pipe 执行读&#x2F;写操作时，其它(另一)进程必须等待。</li><li><strong>同步</strong>，指当写(输入)进程把一定数量(如 4KB)的数据写入 pipe，便去睡眠等待， 直到读(输出)进程取走数据后，再把他唤醒。当读进程读空 pipe 时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒。</li><li><strong>确定对方是否存在</strong>，只有确定了对方已存在时，才能进行通信。</li></ul><p>Linux 命名管道非常适合同一机器上两个进程之间传递数据，其形式也是一个文件，但是读取与写入时遵循 FIFO 的原则。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;/tmp/my_fifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE PIPE_BUF</span></span><br><span class="line">mkfifo(FIFO_NAME,<span class="number">0777</span>);</span><br></pre></td></tr></table></figure><h3 id="消息传递系统-Message-Passing-System"><a href="#消息传递系统-Message-Passing-System" class="headerlink" title="消息传递系统 Message-Passing System"></a>消息传递系统 Message-Passing System</h3><p>应用最广泛的进程通信机制,进程间数据交换以格式化的信息 Message 为单位<br>程序员使用通信原语完成通信，其实现细节被隐藏，简化了通信程序的编写复杂性<br>微内核与服务器程序的通信采用本机制，可满足多处理机 OS、分布式 OS、计算机网络的通信要求</p><p><strong>消息传递通信的实现方法</strong></p><ul><li><strong>直接通信方式</strong> <code>send(),receive()</code></li><li><strong>间接通信方式</strong> 信箱</li></ul><h4 id="直接通信方式"><a href="#直接通信方式" class="headerlink" title="直接通信方式"></a>直接通信方式</h4><p>指发送进程利用 OS 提供的发送命令,直接把消息发送给目标进程。通常，系统提供下述两种类型的通信命令(原语)：</p><ul><li><strong>对称寻址方式 Symmetric Addressing</strong><br><code>Send(Receiver, Message);</code><br><code>Receive(Sender, Message);</code><br>例如，原语<code>Send(P2, m1)</code>表示将消息 m1 发送给接收进程 P2; 而原语<code>Receive(P1，m1)</code>则表示接收由 P1 发来的消息 m1</li><li><strong>非对称寻址方式 Asymmetric Addressing</strong><br><code>Send(P, Message);</code>发送一个消息给接收进程 P；<br><code>Receive(id,Message);</code>接收来自任何进程的消息，进程 id 不固定</li></ul><p>利用直接通信原语，来解决生产者-消费者问题：<br>当生产者生产出一个产品(消息)后，便用 Send 原语将消息发送给消费者进程；而消费者进程则利用 Receive 原语来得到一个消息。如果消息尚未生产出来，消费者必须等待，直至生产者进程将消息发送过来</p><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeat</span></span><br><span class="line">     …</span><br><span class="line">    produce an item <span class="keyword">in</span> nextp;</span><br><span class="line">      …</span><br><span class="line">    send(consumer, nextp);</span><br><span class="line">   <span class="keyword">until</span> false;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    receive(producer, nextc);</span><br><span class="line">      …</span><br><span class="line">    consume the item <span class="keyword">in</span> nextc;</span><br><span class="line">  <span class="keyword">until</span> false;</span><br></pre></td></tr></table></figure><p><strong>消息缓冲队列通信机制</strong></p><p>发送进程利用 <code>send</code> 原语将消息直接发送给接收进程的消息缓冲队列；<br>接收进程利用 <code>receive</code> 原语接收消息；<br>用于本地进程通信。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-13-21-04.png"></p><p><strong>Send</strong></p><ul><li><strong>发送进程</strong>在利用发送原语发送消息之前，应先在自己的内存空间，设置一发送区<code>a</code>，把待发送的消息正文、发送进程标识符、消息长度等信息填入其中，然后调用发送原语，把消息发送给目标(接收)进程。</li><li>发送原语首先根据发送区<code>a</code>中所设置的消息长度<code>a.size</code>来申请一缓冲区<code>i</code>，接着，把发送区<code>a</code>中的信息复制到缓冲区<code>i</code>中。为了能将<code>i</code>挂在<strong>接收进程的消息队列</strong><code>mq</code>上，应先获得<strong>接收进程</strong>的内部标识符<code>j</code>，然后将<code>i</code>挂在<code>j.mq</code>上。</li><li>由于该队列属于临界资源, 故在执行<code>insert</code>操作的前后，需要执行<code>wait</code>和<code>signal</code>操作</li></ul><p><strong>Receive</strong></p><ul><li><strong>接收进程</strong>调用接收原语<code>receive(b)</code>，从自己的消息队列<code>mq</code>中,摘下第一个消息缓冲区 i,并将其中的数据复制到以 b 为首址的指定消息接收区内</li><li>完成消息的接收后接收进程返回到用户态继续进行</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-13-24-54.png"></p><h4 id="消息传递系统实现中的若干问题"><a href="#消息传递系统实现中的若干问题" class="headerlink" title="消息传递系统实现中的若干问题"></a>消息传递系统实现中的若干问题</h4><ul><li><p><strong>通信链路(communication link)</strong><br>为使在发送进程和接收进程之间能进行通信，必须在两者之间建立一条通信链路。有两种方式建立通信链路。</p><ul><li>第一种方式：由发送进程在通信之前，用显式的“建立连接”命令(原语)请求系统为之建立一条通信链路；在链路使用完后，也用显式方式拆除链路。这种方式主要用于计算机网络中</li><li>第二种方式: 发送进程无须明确提出建立链路的请求，只须利用系统提供的发送命令(原语)，系统会自动地为之建立一条链路。这种方式主要用于单机系统中。</li></ul><p>根据通信链路的<strong>连接方法</strong>，又可把通信链路分为两类：</p><ul><li><strong>点对点连接通信链路</strong>，这时的一条链路只连接两个结点(进程)；</li><li><strong>多点连接链路</strong>，指用一条链路连接多个(n ＞ 2)结点(进程)。<br>而根据<strong>通信方式</strong>的不同，则又可把链路分成两种：</li><li><strong>单向通信链路</strong>，只允许发送进程向接收进程发送消息；</li><li><strong>双向链路</strong>，既允许由进程 A 向进程 B 发送消息，也允许进程 B 同时向进程 A 发送消息。</li></ul></li><li><p><strong>消息的格式</strong></p><ul><li><strong>定长消息</strong><br>在某些 OS 中，消息是采用比较短的定长消息格式，这减少了对消息的处理和存储开销。</li><li><strong>变长消息</strong><br>在有的 OS 中，采用另一种变长的消息格式，即进程所发送消息的长度是可变的。系统在处理和存储变长消息时，须付出更多的开销，但方便了用户。<br>注意：这两种消息格式各有其优缺点，故在很多系统(包括计算机网络)中，是同时都用的。</li></ul></li><li><p><strong>进程同步方式</strong><br>进程间通过消息队列通信，则进程之间需同步，其同步方式有三种：</p><ul><li><strong>发送进程阻塞,接收进程阻塞</strong>：进程间汇合同步，有消息时传递，无消息时同时阻塞。</li><li><strong>发送进程不阻塞,接收进程阻塞</strong>：发送者尽快发送消息，接收者平时阻塞收到消息才唤醒，例如多个用户共享一个打印服务。</li><li><strong>发送进程和接收进程均不阻塞</strong>：发送者和接收者均忙于自身事务，直到无法继续才阻塞。例如发送进程和接收进程间关联一个长度为 n 的消息队列。</li></ul></li></ul><h4 id="间接通信方式"><a href="#间接通信方式" class="headerlink" title="间接通信方式"></a>间接通信方式</h4><p>信箱是间接通信方式的一种实现，是一种特殊的消息队列，用于进程间通信。</p><p><strong>信箱的创建和撤消</strong>:进程可利用信箱创建原语来建立一个新信箱。创建者进程应给出信箱名字、信箱属性(公用、私用或共享)；对于共享信箱，还应给出共享者的名字。当进程不再需要读信箱时，可用信箱撤消原语将之撤消。<br><strong>消息的发送和接收</strong>:当进程之间要利用信箱进行通信时，必须使用共享信箱，并利用系统提供的下述通信原语进行通信。<br><code>Send(mailbox, message);</code> 将一个消息发送到指定信箱；<br><code>Receive(mailbox, message);</code> 从指定信箱中接收一个消息；</p><p>信箱定义为一种数据结构。在逻辑上，可以将其分为信箱头 MailboxHeader 和信箱体 MailboxBody 两部分</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-00-40.png"></p><p>信箱可由操作系统创建，也可由用户进程创建，创建者是信箱的拥有者。据此，可把信箱分为以下三类：</p><ul><li><strong>私用信箱</strong> 用户<strong>进程</strong>可为自己建立一个新信箱，并作为该进程的一部分。信箱的拥有者有权从信箱中读取消息，其他用户则只能将自己构成的消息发送到该信箱中。这种私用信箱可采用单向通信链路的信箱来实现。当拥有该信箱的进程结束时，信箱也随之消失。</li><li><strong>公用信箱</strong> 由<strong>操作系统</strong>创建，并提供给系统中的所有核准进程使用。进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息。显然，公用信箱应采用双向通信链路的信箱来实现。通常，公用信箱在系统运行期间始终存在。</li><li><strong>共享信箱</strong> 由某<strong>进程</strong>创建，在创建时或创建后，指明它是可共享的，同时须指出共享进程(用户)的名字。信箱的拥有者和共享者，都有权从信箱中取走发送给自己的消息。</li></ul><p>在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系：</p><ul><li><strong>一对一关系</strong> 这时可为发送进程和接收进程建立一条两者专用的通信链路，使两者之间的交互不受其他进程的干扰</li><li><strong>多对一关系</strong> 允许提供服务的进程与多个用户进程之间进行交互，也称为客户&#x2F;服务器交互(client&#x2F;server interaction)</li><li><strong>一对多关系</strong> 允许一个发送进程与多个接收进程进行交互，使发送进程可用广播方式，向接收者(多个)发送消息</li><li><strong>多对多关系</strong>。允许建立一个公用信箱，让多个进程都能向信箱中投递消息；也可从信箱中取走属于自己的消息</li></ul><h3 id="客户机-服务器系统-Client-Server-System"><a href="#客户机-服务器系统-Client-Server-System" class="headerlink" title="客户机-服务器系统 Client-Server System"></a>客户机-服务器系统 Client-Server System</h3><h4 id="套接字-Socket"><a href="#套接字-Socket" class="headerlink" title="套接字 Socket"></a>套接字 Socket</h4><p><strong>Socket 定义</strong><br>Windows Sockets 是<strong>为上层应用程序提供的一种标准网络接口</strong>，主要用于网络中的数据通信。上层应用程序不用关心 Winsock 的实现细节，它为上层应用程序提供透明的服务。<br>Windows Sockets 规范以 U.C. Berkeley 大学 BSD UNIX 中流行的 Socket 接口为范例定义了一套 microsoft Windows 下网络编程接口。<br>它不仅包含了人们所熟悉的 Berkeley Socket 风格的库函数；也包含了一组针对 Windows 的扩展库函数，以使程序员能充分地利用 Windows 消息驱动机制进行编程。</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-18-48.png" style="zoom:50%;" /></center><p><strong>TCP&#x2F;IP</strong></p><p>TCP&#x2F;IP 协议的核心部分是传输层协议(TCP、UDP)，网络层协议(IP)和物理接口层，这三层通常是在操作系统内核中实现。因此用户一般不涉及。<br>编程时，编程界面有两种形式：由内核直接提供的系统调用；使用以库函数方式提供的各种函数。前者为核内实现，后者为核外实现。用户服务要通过核外的应用程序才能实现，所以要使用套接字(socket)来实现。</p><p><strong>TCP&#x2F;IP 协议与 WinSock 的关系</strong></p><p>WinSock 不是一种网络协议，它只是一个网络编程接口，可以把它当作一些协议的封装。<br>WinSock 就是 TCP&#x2F;IP 协议的一种封装，可以通过调用 WinSock 的接口函数来调用 TCP&#x2F;IP 的各种功能.<br>例如想用 TCP&#x2F;IP 协议发送数据，就可以使用 WinSock 的接口函数 Send()来调用 TCP&#x2F;IP 的发送数据功能，至于具体怎么发送数据，WinSock 已经帮用户封装好了这种功能。</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-20-43.png" alt="TCP" style="zoom:67%;" /><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-28-31.png" alt="UDP" style="zoom:50%;" /></center><h4 id="远程过程调用-RPC"><a href="#远程过程调用-RPC" class="headerlink" title="远程过程调用 RPC"></a>远程过程调用 RPC</h4><p><strong>远程过程调用 RPC</strong>(Remote Procedure Call)，是一个通信协议，用于通过网络连接的系统。该协议允许运行于一台主机(本地)系统上的进程调用另一台主机(远程)系统上的进程，而对程序员表现为常规的过程调用，无需额外地为此编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称做远程方法调用。<br>RPC 主要是为了解决的两个问题：</p><ul><li>解决分布式系统中，服务之间的调用问题。</li><li>远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑</li></ul><p><strong>Steps</strong></p><ol><li>调用客户端存根；执行传送参数</li><li>调用本地系统内核发送网络消息</li><li>消息传送到远程主机</li><li>服务器存根得到消息并取出参数</li><li>执行远程过程</li><li>执行的过程将结果返回服务器存根</li><li>服务器存根封装结果，调用远程系统内核</li><li>消息传回本地主机</li><li>客户存根从内核接收消息</li><li>客户接收存根返回的数据</li></ol><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-3InterprocessCommunication-2024-03-11-14-51-43.png" alt="Ch2-3InterprocessCommunication-2024-03-11-14-51-43"></p></center>]]></content>
    
    
    <summary type="html">IPC, Interprocess Communication</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Concurrency vs Parallelism</title>
    <link href="https://efterklang.github.io/UESTC/OS/ConcurrencyvsParallelism/"/>
    <id>https://efterklang.github.io/UESTC/OS/ConcurrencyvsParallelism/</id>
    <published>2024-03-10T13:30:40.000Z</published>
    <updated>2024-03-21T09:57:24.773Z</updated>
    
    <content type="html"><![CDATA[<p>当我们谈论计算机科学和互联网技术时，经常会遇到并发(concurrency)和并行(parallelism)这两个词。它们听起来相似，但实际上又有一些重要的区别。</p><h2 id="并发-Concurrency"><a href="#并发-Concurrency" class="headerlink" title="并发 Concurrency"></a>并发 Concurrency</h2><p>是指两个或多个事件在<strong>同一时间间隔内</strong>发生<br>CPU 交替执行多个程序,由于切换速度很快,以人类的感觉来看是同时执行的;但在微观层面,在同一时刻只能有一条指令执行处理器分时复用,多线程交织执行;在特定某个时刻，某一个线程以排他方式独占 CPU 资源，而在不同时刻，不同的线程占用 CPU 运行，从而实现在一段时间内同时执行多个线程的表象。</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ConcurrencyvsParallelism-2024-03-10-19-00-41.png"></p></center><h2 id="并行-Parallelism"><a href="#并行-Parallelism" class="headerlink" title="并行 Parallelism"></a>并行 Parallelism</h2><p>是指两个或多个事件在<strong>同一时刻</strong>发生</p><p>同一时刻内,无论从微观还是宏观层面来看，有多条指令在多个处理器上是同时执行的</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ConcurrencyvsParallelism-2024-03-10-19-00-49.png"></p></center><h2 id="总结-Conclusion"><a href="#总结-Conclusion" class="headerlink" title="总结 Conclusion"></a>总结 Conclusion</h2><p>多 CPU 指的是在一套系统中拥有多颗 CPU，常见于服务器、工作站或计算中心，可以提供庞大的算力。</p><p>多核是指在一枚处理器（processor）中集成两个或多个完整的计算引擎。</p><table><thead><tr><th></th><th align="center"><strong>Thread Concurrency</strong></th><th align="center"><strong>Thread Parallelism</strong></th><th align="center"><strong>Process Concurrency</strong></th><th align="center">**Process Parallelism **</th></tr></thead><tbody><tr><td>多 CPU</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td></tr><tr><td>多核</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">✔️</td><td align="center">❌</td></tr><tr><td>单核 CPU</td><td align="center">✔️</td><td align="center">❌</td><td align="center">✔️</td><td align="center">❌</td></tr></tbody></table><p>操作系统会拆分 CPU 为一段段时间的运行片，轮流分配给不同的程序。对于多 cpu，多个进程可以并行在多个 cpu 中计算，当然也会存在进程切换；对于单 cpu，多个进程在这个单 cpu 中是并发运行，根据时间片读取上下文+执行程序+保存上下文。同一个进程同一时间段只能在一个 cpu 中运行，如果进程数小于 cpu 数，那么未使用的 cpu 将会空闲。</p><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此 CPU 切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p><p>对于多核 cpu，进程中的多线程并行执行，执行过程中存在线程切换，线程切换开销较小。对于单核 cpu，多个线程在 cpu 中并发执行，根据时间片切换线程。同一个线程同一时间段只能在一个 cpu 内核中运行，如果线程数小于 cpu 内核数，那么将有多余的内核空闲。</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.jianshu.com/p/cbf9588b2afb">https://www.jianshu.com/p/cbf9588b2afb</a><br><a href="https://zhuanlan.zhihu.com/p/383279972">https://zhuanlan.zhihu.com/p/383279972</a><br><a href="https://blog.csdn.net/weixin_45163798/article/details/104596138">https://blog.csdn.net/weixin_45163798&#x2F;article&#x2F;details&#x2F;104596138</a></p>]]></content>
    
    
    <summary type="html">并发Concurrency和并行Parallelism</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>LinuxCmds</title>
    <link href="https://efterklang.github.io/Dev/Linux/LinuxCmds/"/>
    <id>https://efterklang.github.io/Dev/Linux/LinuxCmds/</id>
    <published>2024-03-10T07:20:17.000Z</published>
    <updated>2024-03-29T07:02:53.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>查询指定文件夹下的文件个数<code>ls -A &lt;folder_path&gt;  wc -l</code><br>重命名&#x2F;移动文件 <code>mv &lt;old_name&gt; &lt;new_name&gt;</code> <code>mv &lt;old_path&gt; &lt;new_path&gt;</code><br>将指定文件夹下的所有文件移动到另一个指定的目录<code>mv &lt;source_folder&gt;/* &lt;target_folder&gt;</code></p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Ctrl + L clear</span><br><span class="line">Ctrl + K 删除从光标位置到行尾的内容</span><br><span class="line">Ctrl + U 删除从光标位置到行首的内容</span><br><span class="line">Ctrl + A：移动光标到行首。</span><br><span class="line">Ctrl + E：移动光标到行尾</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录个人常用的Linux命令</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Linux" scheme="https://efterklang.github.io/categories/Dev/Linux/"/>
    
    
    <category term="Linux" scheme="https://efterklang.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>ARM中断及异常</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD/</id>
    <published>2024-03-09T08:33:02.000Z</published>
    <updated>2024-03-24T08:33:50.154Z</updated>
    
    <content type="html"><![CDATA[<h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>中断是主机与外设进行数据通信的重要机制，它负责处理处理器外部的事件;<strong>异常实质上也是一种中断，只不过它主要负责处理处理器内部事件</strong>。计算机通常是用中断来处理外中断和内部异常，因此在ARM技术中，将二者统称为异常。<br><strong>中断</strong>当处理器遇有外部设备发生 “紧急事件” 需要它来处理时，它就必须停下 “手头上的工作” 先去处理这个 “紧急事件”。处理器的这种工作过程，或者这种工作状态就叫做中断。<br><strong>中断请求</strong>当外部设备有紧急事件需要处理器进行处理时，外部设备必须向处理器发送一个 电信号（脉冲或电平） 来表示有事件需要处理器来处理。这个信号叫做 中断请求信号 ，或称 中断请求。<br><strong>中断源</strong>发出中断请求信号的外部设备或事件就叫做中断源。<br><strong>异常</strong>由内部事件引起的中断叫做异常。</p><p><strong>中断向量和中断向量表</strong><br>为了与普通子程序的首地址进行区分，<strong>中断服务程序的首地址（入口地址）通常被叫做中断向量</strong>，或中断矢量。以后还会看到，凡是能直接或间接指向中断服务程序的都叫中断向量。<br><strong>在处理器收到中断请求之后，它们都需要获得中断服务程序首地址——中断向量。</strong><br>所有的中断向量都按一定规律存放在一个固定的存储区域，这个集中存放了中断向量或与中断向量相关信息的存储区域就叫做<strong>中断向量表</strong>。</p><h3 id="中断请求信号的屏蔽"><a href="#中断请求信号的屏蔽" class="headerlink" title="中断请求信号的屏蔽"></a>中断请求信号的屏蔽</h3><p><strong>可屏蔽中断</strong> 人们把带有开关，能阻止中断请求的中断输入端叫做可屏蔽中断信号输入端。这类中断叫可屏蔽中断。<br><strong>非屏蔽中断</strong> 人们把不带开关，不能阻止中断请求的中断输入端叫做非屏蔽中断信号输入端。这类中断叫非屏蔽中断。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD-2024-03-09-14-22-06.png"></p><p>为了对处理器可以接收中断源的数目进行扩充及对中断进行必要的管理，在中断源和处理器之间还配有如下图所示的<strong>中断控制器</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD-2024-03-09-14-22-54.png"></p><h3 id="中断优先级及中断嵌套"><a href="#中断优先级及中断嵌套" class="headerlink" title="中断优先级及中断嵌套"></a>中断优先级及中断嵌套</h3><p>处理器通常只有一个可屏蔽中断请求输入端。对于具有 多个中断源的系统来说，当有两个或两个以上中断源同时发生中断请求时就会出现所谓的竞争。<br>竞争可以通过优先级的方法来处理，具体实现方法有两种：硬件实现方法和软件实现方法。</p><h3 id="ARM异常响应"><a href="#ARM异常响应" class="headerlink" title="ARM异常响应"></a>ARM异常响应</h3><p><strong>处理器响应中断的条件</strong></p><ul><li>处理器程序状态寄存器的中断屏蔽标志处于<strong>非屏蔽状态</strong></li><li>没有更高级的中断请求正在响应或正在发出、正挂起；</li><li>处理器在<strong>现行指令执行结束后</strong></li></ul><p><strong>中断的处理过程</strong></p><ul><li>当有中断请求发生且满足上述条件时，计算机系统就会响应中断请求，并自动将被中断程序的下一条指令地址（断点地址）保存和关闭中断；接下来便将自中断向量表查询得到的与该中断源对应的中断向量送入PC，并转去执行中断服务程序。</li><li>当执行到中断服务程序末尾时，执行中断返回指令或跳转指令，把保存的断点地址送回 PC，以在断点处接续执行被中断的程序。</li></ul><p><strong>ARM的中断(异常)向量表</strong></p><p>ARM的中断向量表内存放的是响应异常和中断的转移指令而不是中断向量地址。<br>在ARM处理器中，当异常发生时，完成当前指令后跳转到相应的异常中断处理程序入口执行异常中断处理。异常处理完毕后返回原来的程序断点继续执行原来的程序。</p><p><strong>进入异常</strong></p><p>在异常发生后，ARM内核会作以下工作：</p><ul><li>在适当的LR中保存断点的地址</li><li>把当前程序状态寄存器（CPSR）中的内容保存到模式私有寄存器SPSR中</li><li>将寄存器CPSR中的MODE域设置为中断（异常）应进入的运行模式；</li><li>对CPSR的I位和F位进行相应的设置，以防止再次响应同一个中断请求。</li><li>强制PC从相关的异常向量处取指，即到中断向量表中获取中断向量，转向用户所编写的中断（异常）服务程序。<br>注：异常总是在ARM状态中进行处理。当处理器处于Thumb状态时发生了异常，在异常向量地址装入PC时，会自动切换到ARM状态</li></ul><p><strong>异常返回</strong></p><p>当异常结束时，异常处理程序必须做如下处理：</p><ul><li>将SPSR的值复制回CPSR</li><li>将LR中的值减去偏移量后存入PC，偏移量根据异常的类型而有所不同。</li></ul><h3 id="ARM的中断-异常"><a href="#ARM的中断-异常" class="headerlink" title="ARM的中断(异常)"></a>ARM的中断(异常)</h3><p>ARM按事件的紧急程度为每个中断（异常）都定义了一个固定的优先级别。当多个异常同时发生时，一个固定的优先级系统决定它们被处理的顺序：</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ARM%E5%BC%82%E5%B8%B8%E5%92%8C%E4%B8%AD%E6%96%AD-2024-03-09-16-31-02.png"></p></center><h4 id="快速中断请求异常FIQ"><a href="#快速中断请求异常FIQ" class="headerlink" title="快速中断请求异常FIQ"></a>快速中断请求异常FIQ</h4><p>有些嵌入式系统的应用对实时性要求比较高，需要足够快的中断响应速度，比如数据转移或通道处理。ARM在设计上充分地考虑了嵌入式系统的这一特点，在IRQ异常之外还设计了一种快速中断请求（FIQ）异常，并在硬件结构和资源分配上给予了足够的支持。<br>为减少延时，ARM在快中断中采取了 两个措施：<br>专门为快中断配置了较多的私有寄存器，从而可使中断服务程序有足够的寄存器来使用，而不必与被中断服务程序使用同一组寄存器，这样就免去了因寄存器冲突而必需的保护及恢复现场工作。<br>ARM把FIQ的中断向量放在了中断（异常）向量表末尾 0X0000001C处，因此它后面没有其它中断向量，允许用户将中断服务程序直接放在这里。</p><h4 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h4><p>自行查阅资料</p>]]></content>
    
    
    <summary type="html">ARM处理器异常及中断</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM-Processor" scheme="https://efterklang.github.io/categories/UESTC/ARM-Processor/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title>ARM处理器及系统结构</title>
    <link href="https://efterklang.github.io/UESTC/ARM-Processor/Ch2-1ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/"/>
    <id>https://efterklang.github.io/UESTC/ARM-Processor/Ch2-1ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</id>
    <published>2024-03-09T06:12:26.000Z</published>
    <updated>2024-03-24T08:33:59.516Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ARM-介绍"><a href="#ARM-介绍" class="headerlink" title="ARM 介绍"></a>ARM 介绍</h2><p>ARM（Advanced RISC Machines）有 3 种含义：</p><ul><li>是一个公司的名称;</li><li>是一种技术的名称</li><li>是一类微处理器的通称;</li></ul><p>基于 ARM 技术 的微处理器应用约占据了 32 位 RISC 微处理器 80% 以上的市场份额，其中，在手机市场，ARM 占有绝对的垄断地位。</p><p><strong>处理器 Processor</strong>（也称为中央处理单元或 CPU）是计算机的核心组件，它负责执行大部分的计算和逻辑操作。处理器不仅包括处理芯片，还有其他几个关键的部分:</p><ul><li><strong>内核</strong>（Cores）：现代处理器通常包含多个内核，每个内核都可以独立执行指令。多核处理器可以同时执行多个任务，提高了性能。</li><li><strong>缓存</strong>（Cache）：缓存是一种快速存储器，用于存储处理器可能需要的数据和指令。通过使用缓存，处理器可以减少从主内存获取数据的时间，提高性能。</li><li><strong>控制单元</strong>（Control Unit）：控制单元是处理器的一个部分，负责管理和协调处理器的操作。它解释和执行存储在内存中的指令。</li><li><strong>算术逻辑单元</strong>（Arithmetic Logic Unit, ALU）：ALU 负责执行所有的算术和逻辑操作，包括加法、减法、乘法、除法以及比较操作。</li><li><strong>寄存器</strong>（Registers）：寄存器是一种非常快速的存储器，用于临时存储和访问正在被处理器处理的数据和指令。</li><li><strong>总线</strong>（Buses）：总线是连接处理器和其他系统组件（如内存、硬盘、输入&#x2F;输出设备等）的通道，用于数据传输。</li></ul><p><strong>ARM 公司</strong>是一家总部位于英国 Cambridge 的设计和许可证公司，专注于处理器核心的设计。ARM 并不直接生产和销售芯片，而是设计和开发处理器架构，然后向各种芯片制造商授权这些设计。这些芯片制造商，如高通（Qualcomm）、三星（Samsung）、苹果（Apple）等，会基于 ARM 的设计，制造出各自的处理器产品。</p><p>ARM 的业务模式使得它可以专注于设计和优化处理器架构，而无需投入大量资金来建立和维护自己的制造设施。同时，芯片制造商可以利用 ARM 的设计来生产高效、低功耗的芯片，而无需自行从头开始设计处理器架构。</p><p>采用 RISC 架构的 ARM 微处理器一般有如下<strong>特点</strong>：</p><ul><li>体积小、功耗低、低成本、高性能；</li><li>支持 Thumb（16 位）&#x2F;ARM（32 位）双指令集，能很好地兼容 8 位&#x2F;16 位 器件；</li><li>大量使用 寄存器，指令执行速度更快；</li><li>大多数数据操作都在寄存器中完成；</li><li>寻址方式灵活简单，执行效率高；</li><li>指令长度固定。</li></ul><h2 id="ARM-Processor-系列介绍"><a href="#ARM-Processor-系列介绍" class="headerlink" title="ARM Processor 系列介绍"></a>ARM Processor 系列介绍</h2><p><strong>ARM 处理器指令集的特点</strong></p><p>ARM 内核不是一个纯粹的 RISC 体系结构，ARM 指令集与纯粹的 RISC 的定义有以下几个不同。</p><ul><li>一些特定指令的周期数可变，并不是每条 ARM 指令都是单周期的。</li><li>内嵌的桶形移位器(可以单个时钟周期内对二进制数进行多位的移位操作)产生了更为复杂的指令，扩展了指令的功能，因此改善了内核的性能。</li><li>支持 16 位的 Thumb 指令集，提高了代码密度。</li><li>支持条件执行：每条指令都可以设置一个执行条件，只有条件满足时才执行。</li><li>增强指令：一些功能强大的数字信号处理指令被加入到 ARM 指令集中。</li></ul><p><strong>ARM 指令集体系结构的演变</strong>（了解）</p><blockquote><p>ARM 公司定义了不同版本的 ARM 指令集体系结构版本，用 vn 来标识（n 是版本号，目前是 1-8）。<br>ARM v1 ～ v3 版本的处理器未得到大量应用，ARM 处理器的大量广泛应用是从其 v4 版本开始的。<br>v7 系列 CPU 被称作 CoreTex 系列<br>到目前 v8 是最新的版本， 可以选择 64 或 32 执行状态。64 执行状态针对 64 位处理技术，引入了一个全新指令集 A64，可以存取大虚拟地址空间。</p></blockquote><p><code>ARMv4</code><br>ARMv4 是目前支持的最老的架构,是基于 32-bit 地址空间的 32-bit 指令集。ARMv4 除了支持 ARMv3 的指令外还扩展了：<br>支持 halfword 的存取<br>支持 byte 和 halfword 的符号扩展读<br>进一步的明确了会引起 Undefined 异常的指令<br>对以前的 26bits 体系结构的 CPU 不再兼容</p><p><code>ARMv4T</code><br>ARMv4T 增加了 16-bit Thumb  指令集，这样使得编译器能产生紧凑代码(相对于 32-bit 代码，内存能节省到 35%以上)并保持 32-bit 系统的好处。<br>Thumb 在处理器中仍然要扩展为标准的 32 位 ARM 指令来运行。用户采用 16 位 Thumb 指令集最大的好处就是可以获得更高的代码密度和降低功耗。</p><p><code>ARMv8</code><br>2011 年 11 月，ARM 公司发布了新一代处理器架构 ARM V8，<strong>ARM 的首个 64 位架构</strong>;ARM 2012 年十月发布了 Cortex-A53 and Cortex-A57 核心。2013 年苹果基于 V8 架构的 Apple 7 使用在了 iPhone 5S 上。</p><p><code>Cortex</code><br>ARM 推出的Cortex 系列包括：Cortex-A、Cortex-R 和Cortex-M三个系列。</p><ul><li><code>Cortex-A(Application)</code>系列主要应用于复杂的应用中，支持：ARM、Thumb和 Thumb2指令集。</li><li><code>Cortex-R(Real-time)</code>系列是为实时操作系统设计的嵌入式处理器，能带来更小的芯片面积和低功耗。</li><li><code>Cortex-M(Microcontroller)</code>系列处理器结合了多种突破性技术，集成了许多紧耦合系统外设，以便能满足下一代产品的控制要求，适用于高性能、低成本需求的嵌入式应用。 Cortex-M主要针对单片机领域。</li></ul><p><strong>ARM9的5 级流水线</strong>(流水线的级数，代表的是指令周期被划分成的阶段数量)<br>5级流水线 是 ARM9TDMI 的主要特征之一，其设计减少了在每个时钟内必须完成的最大工作量，进而允许使用较高的时钟频率。</p><ul><li><strong>取指</strong>：指令从存储器中取出，放入指令流水线</li><li><strong>译码</strong>：指令译码，从寄存器堆中读取寄存器操作数</li><li><strong>执行</strong>：把一个操作数移位，产生ALU的结果。如果指令是Load或Store，在ALU中计算存储器的地址</li><li><strong>缓存</strong>&#x2F;数据：如果需要，则访问数据存储器；否则，ALU的结果只是简单地缓冲一个时钟周期，以便使所有指令具有同样的流水线流程</li><li><strong>回写</strong>：将指令产生的结果写回到寄存器堆，包括任何从寄存器读出的数据</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-19-42.png" alt="classic name"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ARM 处理器命名</span><br><span class="line">规则：ARM&#123;x&#125;&#123;y&#125;&#123;z&#125;&#123;T&#125;&#123;D&#125;&#123;M&#125;&#123;I&#125;&#123;E&#125;&#123;J&#125;&#123;F&#125;&#123;-S&#125;</span><br><span class="line">x -- 处理器系列</span><br><span class="line">y -- 存储管理/保护单元</span><br><span class="line">z -- cache</span><br><span class="line">T -- 支持 Thumb 指令集</span><br><span class="line">D -- 支持片上调试</span><br><span class="line">M -- 支持快速乘法器</span><br><span class="line">I -- 支持 Embedded ICE，支持嵌入式跟踪调试</span><br><span class="line">E -- 支持增强型 DSP(Digital Signal Processor) 指令</span><br><span class="line">J -- 支持 Jazelle</span><br><span class="line">F -- 具备向量浮点单元 VFP</span><br><span class="line">-S -- 可综合版本</span><br></pre></td></tr></table></figure><h2 id="ARM-Processor-工作状态"><a href="#ARM-Processor-工作状态" class="headerlink" title="ARM Processor 工作状态"></a>ARM Processor 工作状态</h2><h3 id="ARM-状态和-Thumb-状态"><a href="#ARM-状态和-Thumb-状态" class="headerlink" title="ARM 状态和 Thumb 状态"></a>ARM 状态和 Thumb 状态</h3><blockquote><p><strong>Thumb 指令集</strong><br>嵌入式系统在某些应用场合对存储成本或空间要求比较苛刻，为了让用户更好地控制代码量，于是设计了 2 套指令系统，分别为 ARM 指令集和 Thumb 指令集。其中 ARM 指令集为 32 位（字）长度，具有最完整的功能；Thumb 指令集为 16 位（半字）长度，能实现 ARM 指令集的大部分功能<br>在功能上可以认为 Thumb 是 ARM 指令集的子集</p></blockquote><p>既然 ARM 处理器共存 2 种指令集，那么到底何时执行 ARM 指令集，何时执行 Thumb 指令集呢?<br>ARM 处理器有 2 个处理器状态与这 2 套指令集分别对应;ARM 处理器的两种状态可以通过相应的指令进行切换;</p><p>ARM9TDMI 核是具有 T 变种的 ARM 处理器核，其<strong>工作状态一般有以下两种</strong>，并可在两种状态之间切换。</p><ul><li>ARM 状态:执行 32 位的字对齐的 ARM 指令。是系统上电默认的状态。</li><li>Thumb 状态:执行 16 位的、半字对齐的 Thumb 指令。</li></ul><p><strong>Note</strong></p><ul><li>ARM 指令集与 Thumb 指令集不能同时混合使用</li><li>ARM 和 Thumb 状态间的切换并不影响处理器模式或寄存器内容。</li><li>从一个 ARM 例程调用另一个 Thumb 例程时，内核必须切换状态，反之亦然</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-34-34.png" alt="Work state"></p><h3 id="指令长度和数据格式"><a href="#指令长度和数据格式" class="headerlink" title="指令长度和数据格式"></a>指令长度和数据格式</h3><p>ARM 微处理器的指令长度可以是 32 位（在 ARM 状态下），也可以为 16 位（在 Thumb 状态下）。<br>ARM 微处理器中支持字节<strong>Byte（8 位）、半字 Half-Word（16 位）、字 Word（32 位）</strong>三种数据类型。</p><ul><li>如果一个数据是以字方式存储的，那么它就是字对齐的；</li><li>如果一个数据是以半字方式存储的，那么它就是半字对齐的。</li></ul><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-39-05.png" alt="alignment"></p></center><p><em><code>0x4002</code> 和 <code>0x4004</code> 相差 2 个 Byte,即 16bit,所以为半字对齐 Half-Word Aligned</em></p><h2 id="ARM-Processor-运行模式"><a href="#ARM-Processor-运行模式" class="headerlink" title="ARM Processor 运行模式"></a>ARM Processor 运行模式</h2><p>ARM 体系结构支持<strong>7 种</strong>运行模式：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-49-18.png" alt="ARM Processor Mode"></p><ul><li><strong>用户模式</strong>（USR）正常程序执行模式，大部分任务执行在这种模式下。用户模式是用户程序的工作模式。该没有权限去操作其它硬件资源，也不能切换到其它模式下。</li><li><strong>系统模式</strong>（SYS）系统模式是特权模式，不受用户模式的限制。用户模式和系统模式共用一套寄存器，但比用户模式有更高的权限，可以访问所有系统资源及进行模式切换。</li><li><strong>一般中断模式</strong>（IRQ）一般中断模式也叫通用中断模式，用于处理一般的中断请求，通常在硬件产生中断信号之后自动进入该模式，该模式为特权模式，可以自由访问系统硬件资源。</li><li><strong>快速中断模式</strong>（FIQ）快速中断模式是相对一般中断模式而言的，它是用来处理对时间要求比较紧急的中断请求，主要用于高速数据传输及通道处理中，其中断优先级相对普通中断更高</li><li><strong>管理模式</strong>（Supervisor，SVC） 管理模式是 CPU 上电后默认模式，因此在该模式下主要用来做系统的初始化，软中断处理也在该模式下。系统复位或开机、软中断时进入到 SVC 模式下。</li><li><strong>中止模式</strong>（ABT）中止模式用于支持虚拟内存或存储器保护，当用户程序访问非法地址，没有权限读取的内存地址时，会进入该模式。</li><li><strong>未定义模式</strong>（UND）CPU 在指令的译码阶段不能识别该指令操作时，会进入未定义模式，进行未定义陷阱处理。</li></ul><blockquote><p><strong>特权模式</strong>: 除用户模式外的其它 6 种处理器模式称为特权模式（Privileged Modes）。在特权模式下，程序可以访问所有的系统资源，也可以任意的进行处理器模式切换。只有在特权模式下才允许对当前程序状态寄存器（CPSR）的所有控制位直接进行读&#x2F;写访问，而在非特权模式下只允许对 CPSR 的控制位进行间接访问（SWI 方式）。<br>特权模式中除系统模式之外的其他 5 种模式又统称为<strong>异常模式</strong>。它们除了可以通过在特权下的程序切换进入外，也可以由特定的异常进入。其中管理模式也称为超级用户模式，是为操作系统提供软中断的特有模式。大多数的用户程序运行在用户模式下。当处理器工作在用户模式时，需要进行处理器模式切换时，应用程序可以产生异常处理，在异常处理过程中进行处理器模式切换。这种体系结构可以使操作系统控制整个系统资源的使用。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-15-53-32.png" alt="fix:快速中断为FIQ"></p><h2 id="ARM-Register"><a href="#ARM-Register" class="headerlink" title="ARM Register"></a>ARM Register</h2><p>ARM 处理器有如下 37 个用户可见寄存器。<br>31 个通用寄存器：</p><ul><li><code>R0~R15</code></li><li><code>R13_svc,R14_svc,</code></li><li><code>R13_abt,R14_abt,</code></li><li><code>R13_und、R14_und、</code></li><li><code>R13_irq、 R14_irq </code></li><li><code>R8_fiq~R14_fiq。</code></li></ul><p>6 个状态寄存器：</p><ul><li>1 个 CPSR</li><li>5 个 SPSR（ SPSR_svr、 SPSR_abt 、 SPSR_und 、 SPSR_irq 、 SPSR_frq ）；</li></ul><p>ARM 处理器共有 7 种运行模式，在每一种处理器模式中都有一组相应的寄存器。</p><p>在 ARM 状态下，任一时刻都可以访问到 16 个 通用寄存器和 1~2 个状态寄存器。各种模式下能访问的寄存器如下图所示</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-16-06-15.png"></p><h3 id="堆栈指针-SP-R13"><a href="#堆栈指针-SP-R13" class="headerlink" title="堆栈指针 SP R13"></a>堆栈指针 SP R13</h3><p>寄存器R13通常用作堆栈指针，称作SP。每种异常模式都有自己的分组R13。通常R13应当被初始化成指向给异常模式所分配的堆栈。<br>其中用户模式和系统模式共用一个，每种异常模式都有专用的R13寄存器。它们通常指向各模式所对应的专用堆栈，也就是说ARM处理器允许用户程序有6个不同的堆栈空间。</p><h3 id="链接寄存器-LR-R14"><a href="#链接寄存器-LR-R14" class="headerlink" title="链接寄存器 LR R14"></a>链接寄存器 LR R14</h3><p>寄存器R14(链接寄存器或LR)在体系结构中有两种特殊用途：<br><strong>用途1</strong><br>在各种模式下，R14用来保存子程序的返回地址。当一条BL或者BLX指令执行子程序调用时，R14设为子程序的返回地址。返回时，通过复制R14中的地址值到PC中来实现子程序的返回。通常有以下<strong>2种方式</strong><br><strong>Method1:执行下列指令之一</strong></p><ul><li><code>MOV  PC, LR</code> 把LR中的值写入到PC寄存器中</li><li><code>BX LR</code>跳转(带状态切换)到LR地址所指向的指令执行。用于从实现从一个状态返回另外一个状态并继续执行。<br> <strong>Method2</strong><br>在子程序入口，执行R14的入栈操作<code>STMFP SP!, &#123;&lt;registers&gt;, LR&#125;</code> 该条指令用于把，<registers>和LR（R14）等多个寄存器压入堆栈，SP（R13）指向堆栈顶部。<br>并使用匹配的指令返回<code>LDMFP SP!, &#123;&lt;registers&gt;, PC&#125;</code>该条指令用于把堆栈顶部多个单元，执行出栈操作，出栈的数据保存到<registers>和PC等多个寄存器中。<br>注：执行该操作后，原R14入栈的值，出栈后就保存到PC中了，相当于执行了把R14的值写入到PC的操作。<br><strong>用途2</strong><br>当发生异常时，相关异常模式下的R14就设为异常返回地址。异常的返回地址与子程序的返回类似。区别在于有些异常有一个小常量的偏移</li></ul><h3 id="程序计数器-PC-R15"><a href="#程序计数器-PC-R15" class="headerlink" title="程序计数器 PC R15"></a>程序计数器 PC R15</h3><p>无论处理器处于何种状态，程序计数器 R15（即 PC）总是指向“正在取指”的指令，而不是指向“正在执行”的指令或正在“译码”的指令。<br>一般来说，人们习惯性约定将“正在执行的指令作为参考点”，称之为当前第 1 条指令。<br>因此，PC 总是指向第 3 条指令，或者说 PC 总是指向当前正在执行的指令地址再加 2 条指令的地址。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-16-13-50.png"></p><blockquote><p>MOV 执行时,LDR 在取值,相差 2 条指令的地址,如果为 ARM 指令,设三条指令地址分别为 <code>0x4000,0x4004,0x4008</code>,PC 值等于当前指令的地址+8Bytes,<code>0x4000 + 8 = 0x4008</code><br>当处理器处于 Thumb 状态时，每条指令长为 2 字节，所以 PC 的值为正在执行的指令地址加 4 字节，即：<code>PC值=当前程序执行位置+4字节</code></p></blockquote><h3 id="程序状态寄存器-PSR"><a href="#程序状态寄存器-PSR" class="headerlink" title="程序状态寄存器 PSR"></a>程序状态寄存器 PSR</h3><p><strong>当前程序状态寄存器</strong>（CPSR,Curren Program Status Register）可以在任何处理器模式下被访问，它包含下列内容：</p><ul><li>ALU 状态标志（条件码标志位）；</li><li>当前的处理器模式；</li><li>中断使能标志；</li><li>设置处理器的状态。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-21-20-39.png"></p><p>每一种异常器模式下，都有一个专用的物理寄存器做<strong>备份程序状态寄存器</strong>（SPSR,Saved Program Status Register ）。当特定的异常中断发生时，这个物理寄存器负责存放当前程序状态寄存器的内容。当异常处理程序返回时，再将其内容恢复到当前程序状态寄存器。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-21-28-07.png"></p><p>这些<strong>条件标志位</strong>会根据程序中的算数指令或逻辑指令的执行结果进行改变，而且这些条件标志位可由大多数指令检测以决定指令是否执行。</p><ul><li><code>N</code> 本位设置成当前指令执行结果的第 31 位。当两个由补码表示的有符号整数运算时，N&#x3D;1 表示结果为负数；否则结果为正数或零。</li><li><code>Z</code> Z&#x3D;1 表示运算的结果为零，否则结果不为零。</li><li><code>C</code> 分 4 种情况设置 C 的方法：<ul><li>在加法指令中（包括比较指令 CMN），当结果产生了进位，则 C&#x3D;1，表示无符号数运算发生上溢出，其它情况下 C&#x3D;0;</li><li>在减法指令中（包括比较指令 CMP），当运算中发生了借位，则 C&#x3D;0，其它情况下 C&#x3D;1;</li><li>对于在操作数中包含移位操作的运算指令（非加&#x2F;减指令），C 被设置成被移位寄存器最后移出去的位;</li><li>对于其它非加&#x2F;减法运算指令，C 的值通常不受影响。</li></ul></li><li><code>V</code> 下面分两种情况讨论 V 的设置方法：<ul><li>对于加&#x2F;减运算指令，当操作数和运算结果都是以二进制的补码表示的带符号的数时，且运算结果超出了有符号运算的范围时溢出。V&#x3D;1 表示符号位溢出；</li><li>对于非加&#x2F;减法指令，通常不改变标志位 V 的值。</li></ul></li><li><code>Q</code>（了解）在带 DSP 指令扩展的 ARMV5 及更高版本中，Q 标志位被指定用于指示增强 DSP 指令是否发生了溢出。在 ARMV5 以前的版本及 ARMV5 的非 E 系列处理器中，Q 标志位没有被定义，属于待扩展的位。</li></ul><p><strong>控制位</strong>:CPSR 的低 8 位属于控制位。</p><ul><li><code>I,F</code>中断禁止位（第 7、6 位） I&#x3D;1：IRQ 被禁止；F&#x3D;1：FIQ 被禁止。</li><li><code>T</code>状态控制位（第 5 位）T 是处理器的状态控制位。T&#x3D;0：处理器处于 ARM 状态；T&#x3D;1：处理器处于 Thumb 状态。<br>注意：绝对不要强制改变 CPSR 寄存器中的控制位 T。如果这样做，处理器会进入一个无法预知的状态。</li><li><code>MMMMM</code>模式控制位<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-08-21-37-07.png"></li></ul><p><strong>注意</strong><br>通过程序修改 CPSR 可以进入<strong>异常</strong>(除 SYS 以外的特权模式)。除此之外，也可以在内核对异常或者中断响应时由硬件切换到异常模式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 例：从系统模式切换到管理模式 --&gt;</span><br><span class="line">&lt;!-- MSR CPSR_c, #D3 是一条ARM汇编语言指令，用于修改当前程序状态寄存器（Current Program Status Register，CPSR）的特定字段。这条指令的具体含义如下：</span><br><span class="line">MSR：这是一个Move to Status Register的指令，用于将一个值移动到一个状态寄存器中。</span><br><span class="line">CPSR_c：这表示目标是CPSR的控制字段（control field）</span><br><span class="line">#D3：这是一个立即数，表示要将CPSR的控制字段设置为十六进制的D3。在二进制中，D3等于1101 0011。 --&gt;</span><br><span class="line"></span><br><span class="line">MSR CPSR_c,#D3;</span><br></pre></td></tr></table></figure><p>用户模式与系统模式不能由异常进入，也就是说要想进入系统模式，必须通过修改 CPSR 才能实现。<br><code>MSR CPSR_c,#DF;</code></p><h2 id="ARM-Storage"><a href="#ARM-Storage" class="headerlink" title="ARM Storage"></a>ARM Storage</h2><h3 id="ARM存储方法"><a href="#ARM存储方法" class="headerlink" title="ARM存储方法"></a>ARM存储方法</h3><p>ARM处理器外部采用冯·诺依曼（von Neumann）结构，指令和数据共用一条32位数据总线，只有装载、存储和交换指令可访问存储器中的数据。<br>ARM处理器将存储器看作是一个从0开始的线性递增的字节集合，其中每个数组元素（字节）都是可以寻址的。<br>ARM支持<strong>大端模式（big-endian）</strong>和<strong>小端模式（little-endian）</strong>两种内存模式。<br>在大端模式下，一个字的高地址单元放的是数据的低位；而在小端模式下，数据的低位放在内存中低地址单元中。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-1ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-09-13-14-43.png"><br>一个基于ARM的实际芯片可能只支持小端存储器格式，也可能只支持大端存储器格式，还可能两者都支持。<br>ARM指令集不包含任何直接选择大小端存储器格式的指令，但是一个同时支持大小端存储器格式基于ARM的芯片可以通过硬件配置（一般使用芯片的引脚来配置）来匹配存储器系统所使用的规则。如果芯片有一个标准系统控制的协处理器（例如ARM920T的CP15协处理器），系统控制协处理器寄存器1的bit7可用于改变配置。<br>注意：对于 <code>S3C2440</code>是通过<strong>软件</strong>来指定存储器格式的（通过设置CP15协处理器协处理器寄存器1的bit7来实现），<strong>缺省为小端格式</strong>。</p><h3 id="ARM体系的存储空间"><a href="#ARM体系的存储空间" class="headerlink" title="ARM体系的存储空间"></a>ARM体系的存储空间</h3><p>ARM9使用 $2^{32}$ 个8位字节地址空间，字节地址的排列从 $0～2^{32}-1$<br>地址空间也可以看作是包含$2^{30}$个32位字，地址以字为单位进行分配。也就是将地址除以4，地址为A的字包含4个字节，地址分别为 <code>A、A+1、A+2和A+3</code>。<br>与此同时，地址空间还可被看作包含$2^{31}$个16位半字，地址按照半字进行分配。地址为A的半字包含2个字节，地址分别为 <code>A和A+1</code>。</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-1ARM%E5%A4%84%E7%90%86%E5%99%A8%E5%8F%8A%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2024-03-09-13-35-31.png"></p></center><h3 id="ARM存储器结构"><a href="#ARM存储器结构" class="headerlink" title="ARM存储器结构"></a>ARM存储器结构</h3><p>ARM处理器有的带有指令cache和数据cache，但不带有片内RAM和片内ROM。<br>系统所需的RAM和ROM（包括Flash）都通过总线外接。<br>有的ARM片内还带有存储器管理单元MMU（Memory Management Unit）</p><h3 id="存储器映射I-O"><a href="#存储器映射I-O" class="headerlink" title="存储器映射I&#x2F;O"></a>存储器映射I&#x2F;O</h3><p>基于ARM内核的芯片具有许多的外设，这些外设访问的标准方法是使用存储器映射的I&#x2F;O（存储器统一编址），为外设的每个寄存器都分配一个地址。通常，从这些地址装载数据用于读入，向这些地址保存数据用于输出。有些地址的装载和保存用于外设的控制功能，而不是输入或输出功能。<br>注意：存储器映射的I&#x2F;O位置的操作不同于正常的存储器位置的操作。通常，把存储器映射的I&#x2F;O位置标记为无高速缓存和无缓冲区，以避免处理器把这部分地址当普通内存，调入到cache中，进行缓存操作。</p><h3 id="Flash组织形式"><a href="#Flash组织形式" class="headerlink" title="Flash组织形式"></a>Flash组织形式</h3><p>目前几乎所有MCU的程序都存储在Flash中。Flash分为片内和片外两种。片外Flash又有以下种类。<br>NOR Flash:NOR Flash读取速度快，但是擦除和写入速度慢。<br>NAND Flash:NAND Flash读取速度比NOR Flash慢，但擦除和写入速度很快</p><h3 id="RAM的组织形式"><a href="#RAM的组织形式" class="headerlink" title="RAM的组织形式"></a>RAM的组织形式</h3><p>芯片自带的RAM不够用时需要外加，外加的RAM一般是SDRAM和DDR RAM，极少数使用SRAM，因为SRAM的价格相对较贵，但SRAM速度要比动态RAM快。<br>SRAM:只需要在IDE中设置好地址。<br>SDRAM&#x2F;DDR RAM:不仅要在IDE中设置好起始地址，还要在程序中做初始化操作后才能使用。如果使用仿真器，那么在仿真运行程序前，要执行一个初始化脚本文件，或者执行一系列命令对SDRAM和DDR RAM进行初始化，否则会运行出错。</p>]]></content>
    
    
    <summary type="html">ARM处理器及系统结构;ARM介绍,ARM Processor 系列介绍,ARM处理器工作状态＆运行模式,ARM Register以及ARM存储</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="ARM-Processor" scheme="https://efterklang.github.io/categories/UESTC/ARM-Processor/"/>
    
    
    <category term="ARM" scheme="https://efterklang.github.io/tags/ARM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://efterklang.github.io/Home/%E8%93%AC%E6%88%B7%E6%89%8B%E5%8D%B7/"/>
    <id>https://efterklang.github.io/Home/%E8%93%AC%E6%88%B7%E6%89%8B%E5%8D%B7/</id>
    <published>2024-03-08T06:43:54.631Z</published>
    <updated>2024-03-28T04:45:18.829Z</updated>
    
    <content type="html"><![CDATA[<style>h2 {    font-family: Microsoft JhengHei;    /* font-family: 楷体; */    color: #426cc2;    /* text-align: center; */    font-style: bold;}</style><div><h2>蓬户掩兮井径荒 青苔满兮履綦绝 园种邵平之瓜 门栽先生之柳 晓起呼童子 问山桃落乎 辛夷开未 手瓮灌花 除虫丝蛛总于时 不巾不履 坐水窗 追凉风 焚好香 烹苦茗 忽见异鸟来鸣树间 小倦即卧 康凉枕一觉  美睡萧然无梦 即梦亦不离竹坪茶坞间 </h2></div>]]></content>
    
    
      
      
    <summary type="html">

&lt;style&gt;
h2 {
    font-family: Microsoft JhengHei;
    /* font-family: 楷体; */
    color: #426cc2;
    /* text-align: center; */
    font-st</summary>
      
    
    
    
    
    <category term="中国古代诗词" scheme="https://efterklang.github.io/tags/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BB%A3%E8%AF%97%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>Git for Android</title>
    <link href="https://efterklang.github.io/Dev/Git/GitforAndroid/"/>
    <id>https://efterklang.github.io/Dev/Git/GitforAndroid/</id>
    <published>2024-03-08T05:24:31.000Z</published>
    <updated>2024-03-17T07:50:24.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DownLoad"><a href="#DownLoad" class="headerlink" title="DownLoad"></a>DownLoad</h2><ol><li>在F-Droid 中搜索<code>Mgit</code>，下载并安装。(Play商店中也有,但功能不能正常使用)</li><li>在<a href="https://github.com/maks/MGit">Github</a>仓库选择合适的版本下载</li></ol><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Clone-a-remote-repository"><a href="#Clone-a-remote-repository" class="headerlink" title="Clone a remote repository"></a>Clone a remote repository</h3><ul><li>Click on the <code>+</code> icon to add a new repository</li><li>Enter remote URL <a href="#URL-format">see URL format below</a></li><li>Enter local repository name - note that this is not the full path, as MGit stores all repositories in the same local directory (can be changed in MGit settings)</li><li>Click the Clone button</li><li>If required, you will be prompted for credentials to connect to the remote repo. MGit will download the repository (all branches) to your device</li></ul><h3 id="Create-a-local-repository"><a href="#Create-a-local-repository" class="headerlink" title="Create a local repository"></a>Create a local repository</h3><ul><li>Click on the + icon to add a new repository</li><li>Click on Init Local to create a local repository</li><li>Enter the name for this repository when prompted</li><li>A local empty repo will be created</li></ul><h3 id="URL-format"><a href="#URL-format" class="headerlink" title="URL format"></a>URL format</h3><p><strong>SSH URLs</strong><br>SSH running on standard port (22): <code>ssh://username@server_name/path/to/repo</code><br>SSH running on non-standard port: <code>ssh://username@server_name:port/path/to/repo</code><br>username is needed - by default, MGit tries to connect as root.<br><strong>HTTP(S) URLs</strong><br>HTTP(S) URL: <code>https://server_name/path/to/repo</code></p><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p><strong>MGit App</strong><br><code>Settings -&gt; SSH Keys -&gt; + icon -&gt; input NewFileName -&gt; Generate Key -&gt; Open File and Copy the content</code><br><strong>Github</strong><br><a href="https://github.com/settings/keys">Settings&#x2F;keys</a><br>New SSH Key -&gt; input Title -&gt; Paste the content</p>]]></content>
    
    
    <summary type="html">安卓平台Git客户端的使用</summary>
    
    
    
    <category term="Dev" scheme="https://efterklang.github.io/categories/Dev/"/>
    
    <category term="Git" scheme="https://efterklang.github.io/categories/Dev/Git/"/>
    
    
    <category term="Git" scheme="https://efterklang.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>ProcessSync</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch2-2ProcessSync/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch2-2ProcessSync/</id>
    <published>2024-03-08T03:42:42.000Z</published>
    <updated>2024-03-21T09:56:25.239Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h2><h3 id="定义-Definition"><a href="#定义-Definition" class="headerlink" title="定义 Definition"></a>定义 Definition</h3><p>每一个进程具有<strong>顺序性</strong>，但是在多道程序设计系统中，多个进程要<strong>竞争</strong>，<strong>轮流占用</strong>处理器。<br>有两个进程 A 和 B，它们各自顺序执行时的操作序列如下：<br>进程 A ： <code>a1，a2，a3，…，am</code><br>进程 B ： <code>b1，b2，b3，…，bm</code><br>在多道程序设计系统中，处理器可能执行的操作序列<br><code>a1， b1 ，a2， b2 ，a3， b3 …</code><br><code>a1， a2， b1 ，a3 ，b2 ，b3 …</code></p><p>进程的并发性:在一个进程的工作没有完成之前，另一个进程就可以开始工作，这些进程就称为可同时执行的。或者称它们<strong>具有并发性</strong>，并且把可同时执行的进程称为<strong>并发进程</strong>。</p><ul><li>如果一个进程的执行不影响另一个进程的执行结果，也不依赖另一个进程的进展情况，即它们是各自独立的，则称这些进程相互之间是<strong>无关</strong>的。</li><li>如果一个进程的执行要依赖其他进程的进展状况，或者可能会影响其他进程的执行结果，则说这些进程是有<strong>交互</strong>的。<ul><li>对于有交互的并发进程来说，并发会破坏“封闭性”和“可再现性”</li></ul></li></ul><p><strong>进程互斥</strong>:多个进程不能同时使用同一个资源，某个进程使用该资源时，其他进程必须等待。<br><strong>进程同步</strong>:多个进程的调用存在时序关系，某些进程的执行必须先于另一些进程。<br><strong>进程通信</strong>:多个进程之间传递消息。</p><h3 id="问题引入-Intro"><a href="#问题引入-Intro" class="headerlink" title="问题引入 Intro"></a>问题引入 Intro</h3><p>由于进程交替修改了共享变量造成结果可能不正确。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     生产者                           消费者</span><br><span class="line"> register1∶ = counter;             register2∶= counter;</span><br><span class="line"> register1∶= register1+1;         register2∶ = register2-1;</span><br><span class="line"> counter∶= register1;               counter∶ = register2;</span><br><span class="line">假设：counter的当前值是5。</span><br><span class="line">无论生产者先执行，还是消费者先执行，结果都是5.</span><br><span class="line">但是，如果按下述顺序执行：</span><br><span class="line">         register1 ∶  = counter;               (register1 = 5)</span><br><span class="line">         register1 ∶  = register1 + 1;        (register1 =6)</span><br><span class="line">         register2 ∶  = counter;               (register2 = 5)</span><br><span class="line">         register2 ∶  = register2 - 1;         (register2=4)</span><br><span class="line">         counter  ∶  = register 1;             (counter=6)</span><br><span class="line">         counter  ∶  = register2;               (counter=4)</span><br><span class="line">Counter的值最终为4。</span><br><span class="line">两次结果不一致，程序执行失去了再现性</span><br></pre></td></tr></table></figure><p>有交互的并发进程执行时出现<strong>与时间有关</strong>(time-dependent,即与进程调度的顺序有关)的错误，其根本原因是<strong>对共享资源（变量）的使用不受限</strong>，为了使并发进程能正确地执行，必须对共享变量的使用加以限制。</p><p>进程竞争资源首先必须解决“互斥”问题。某些资源必须互斥使用，如打印机、共享变量、表格、文件等。这类资源又称为<strong>临界资源 critical resource</strong>，访问临界资源的那段代码称为<strong>临界区 critical section</strong>。<br>任何时刻，只允许一个进程进入临界区，以此实现进程对临界资源的互斥访问。</p><p>可把一个访问临界资源的循环进程描述如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">    entry section</span><br><span class="line">    critical section</span><br><span class="line">    exit section</span><br><span class="line">    remainder section</span><br><span class="line">until false</span><br><span class="line"></span><br><span class="line">&lt;entry section&gt;:判断是否可以进入临界区，如果可以进入，则必须设置临界区使用标志，</span><br><span class="line">阻止其它后来的进程进入临界区。</span><br><span class="line">&lt;critical section&gt;:进入临界区，使用临界资源。</span><br><span class="line">&lt;exit section&gt;:当临界区内的进程执行完毕并退出临界区时，在“退出区”修改临界区使用标志，</span><br><span class="line">并负责唤醒阻塞队列中的一个进程，让其进入临界区。</span><br><span class="line">&lt;remainder section&gt;:其它代码</span><br></pre></td></tr></table></figure><p><strong>阻塞队列 Blocking Queue</strong>:当一个进程试图进入临界区，而临界区已经被其它进程占用时，该进程必须等待，直到临界区空闲为止。这些等待进程的队列称为阻塞队列。<br><strong>死锁 Deadlock</strong>:当两个或多个进程互相等待对方释放资源，而导致它们都无法继续执行时，称为死锁。</p><p><strong>临界区使用原则</strong>(互斥条件)</p><ol><li><strong>空闲让进</strong>。如果临界区空闲，则只要有进程申请就立即让其进入。</li><li><strong>忙则等待</strong>。每次仅允许一个进程处于临界区。</li><li><strong>有限等待</strong>。进程只能在临界区内逗留有限时间，不得使其他进程在临界区外无限期等待。</li><li><strong>让权等待</strong>。当进程不能进入自己的临界区时，应立即释放处理机，以免进程处于“忙等”状态。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-06-15-40-04.png" alt="Critical Section"></p><h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3><p>1965 年，荷兰的 E.W.Dijkstra 提出了信号量同步机制用于进程同步,现广泛应用于存在临界资源和临界区控制的场合<br>信号量是一个一般的锁,信号量即信号的数量;开锁实际上就是发一个信号,等待锁打开就是等待一个信号<br><code>锁: &#123;0,1&#125;  信号量: &#123;-∞, … , -2, -1, 0, 1, 2, … , ∞&#125;</code></p><p>信号量按照<strong>功能</strong>来分：</p><ul><li>互斥信号量：用于申请或释放资源的使用权，常初始化为 1。</li><li>资源信号量：用于申请或归还资源，可以初始化为大于 1 的正整数，表示系统中某类资源的可用个数。<br>按照<strong>信号量机制的发展</strong>分为：</li><li>整形信号量</li><li>记录型信号量</li><li>AND 型信号量</li><li>信号量集</li></ul><blockquote><p>In computer science, a semaphore is a variable or abstract data type used to control access to a common resource by multiple threads and avoid critical section problems in a concurrent system such as a multitasking operating system. Semaphores are a type of synchronization primitive. A trivial semaphore is a plain variable that is changed (for example, incremented or decremented, or toggled) depending on programmer-defined conditions.<br>The semaphore concept was invented by Dutch computer scientist Edsger Dijkstra in 1962 or 1963, when Dijkstra and his team were developing an operating system for the Electrologica X8. That system eventually became known as the THE multiprogramming system.</p></blockquote><p>两个或多个进程可以通过传递信号进行合作，可以迫使进程在某个位置暂时停止执行（阻塞等待），直到它收到一个可以“向前推进”的信号（被唤醒）。相应地，将实现信号灯作用的变量称为信号量。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-13-57-59.png"></p><h4 id="整形信号量-Integer-Semaphore"><a href="#整形信号量-Integer-Semaphore" class="headerlink" title="整形信号量 Integer Semaphore"></a>整形信号量 Integer Semaphore</h4><p>定义为一个整形量, 用来表示空闲资源的数目;仅能通过两个标准的原子操作 <code>wait(s),signal(s)</code>来访问它,又称为<strong>P 操作和 V 操作</strong></p><ul><li><em>Proberen</em>(荷兰语，意为“尝试”): <code>wait(s)</code> 操作用于申请资源（或使用权），进程执行 wait 原语时，可能会阻塞自己；<br><code>while S &lt;= 0 do no-op; S--; // 申请资源</code></li><li><em>Verhogen</em>(荷兰语，意为“增加”): <code>signal(s)</code>操作用于释放资源（或归还资源使用权），进程执行 signal 原语时，有责任唤醒一个阻塞进程。<br><code>S++; // 释放资源</code></li></ul><p><strong>Note</strong></p><ul><li>必须成对使用 <code>wait</code>和 <code>signal</code>原语</li><li>wait、signal 原语不能出现次序错误、重复或遗漏<ul><li>遗漏 wait 原语则不能保证互斥访问</li><li>遗漏 signal 原语则不能在使用临界资源之后将其释放</li></ul></li></ul><h4 id="记录型信号量-Record-Semaphore"><a href="#记录型信号量-Record-Semaphore" class="headerlink" title="记录型信号量 Record Semaphore"></a>记录型信号量 Record Semaphore</h4><p>记录型信号量机制，是一种不存在<strong>忙等现象</strong>的进程同步机制。<br>操作系统内核以系统调用形式提供 <code>wait</code>和 <code>signal</code>原语，应用程序通过该系统调用实现进程间的互斥。<br>工程实践证明，利用信号量方法实现进程互斥是高效的，一直被广泛采用。</p><p>记录型信号量的数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点，用于表示等待队列中的进程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> pid;  <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录型信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// value的初值表示系统中某类资源的数目， value的初始值&gt;1时，称为资源信号量， value的初始值=1时，称为互斥信号量</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* listOfProcess;  <span class="comment">// 信号量的阻塞队列</span></span><br><span class="line">&#125; RecordSemaphore;</span><br></pre></td></tr></table></figure><blockquote><p>“忙等”（Busy Waiting）是一种进程同步策略中的现象，也被称为”自旋等待”。当一个进程试图进入一个被其他进程占用的临界区时，如果使用了忙等策略，那么这个进程会在一个循环中不断检查临界区是否可用，直到它变为可用状态。换句话说，进程在等待期间保持活跃，并消耗 CPU 时间，而不是被挂起或转移到等待状态。<br>虽然忙等可以在某些情况下（如等待时间预期非常短）提供很好的响应时间，但它通常被视为一种效率低下的策略，因为它浪费了 CPU 的计算能力，尤其是在等待时间较长的情况下。<br>与此相反，记录型信号量机制（Blocking or Sleeping Semaphore Mechanism）允许进程在等待进入临界区时进入睡眠状态，从而不消耗 CPU 时间。当临界区可用时，进程会被唤醒。这种方法更有效，但可能导致上下文切换的开销，因为系统需要在运行和等待的进程之间切换。</p></blockquote><p>记录型信号量的 P，V 操作 wait(s)和 signal(s)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/cProcessSync-2024-03-06-22-28-32.png"></p><p><code>s.value&gt;=0</code> 时，<code>s.queue</code> 为空；<br><code>s.value&lt;0</code> 时，<code>s.value</code> 的 绝对值为 <code>s.queue</code> 中等待进程的个数<br><code>s.value</code> 初始值为 1 时，称为互斥信号量；<code>s.value</code> 初始值&gt;1 时，称为资源信号量。<br>当仅有两个并发进程共享临界资源时，互斥信号量仅能取值 1、0、－1。其中，</p><ul><li><code>s.value=1</code>, 表示无进程进入临界区</li><li><code>s.value=0</code>，表示已有一个进程进入临界区</li><li><code>s.value=-1</code>,则表示已有一进程正在等待进入临界区<br>当用 s 来实现 n 个进程的互斥时，<code>s.value</code> 的取值范围为 1 ～-(n-1)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(RecordSemaphore* s)</span> &#123;</span><br><span class="line">    s-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        block(s-&gt;listOfProcess); <span class="comment">//进程阻塞, 进入S.L队列；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">singal</span><span class="params">(RecordSemaphore* s)</span> &#123;</span><br><span class="line">    s-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt;= <span class="number">0</span>) &#123; <span class="comment">// s-&gt;value=0时,则在s-&gt;value++之前value=-1,即有1个进程在等待</span></span><br><span class="line">        wakeup(s-&gt;listOfProcess); <span class="comment">// 唤醒阻塞队列中的一个进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AND-型信号量-AND-Semaphore"><a href="#AND-型信号量-AND-Semaphore" class="headerlink" title="AND 型信号量 AND Semaphore"></a>AND 型信号量 AND Semaphore</h4><p>如果一个进程需要事先获得一个或多个共享资源后才能执行任务。例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process A:                 process B:</span><br><span class="line">wait(Dmutex);            wait(Emutex);</span><br><span class="line">wait(Emutex);             wait(Dmutex);</span><br></pre></td></tr></table></figure><p>最后，进程 A 和 B 就处于僵持状态，在无外力作用下，两个进程都无法从僵持状态中解脱出来，这此 A 和 B 进入<strong>死锁</strong>状态。</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-10-25-04.png" alt="DeadLock"></p></center><p>AND 同步机制的基本思想：将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。<br>原子操作：所有资源要么全部分配到进程，要么一个也不分配 .<br>在 wait 操作中，增加了一个“AND”条件，故称为 <code>AND同步</code>，或称为 <code>同时wait</code>操作.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swait</span><span class="params">(S1, S2, …, Sn)</span>&#123; <span class="comment">//P原语；</span></span><br><span class="line">  <span class="keyword">if</span> (S1 ≥<span class="number">1</span> and S2 ≥ <span class="number">1</span> … Sn ≥ <span class="number">1</span>) &#123;<span class="comment">//满足资源要求时的处理；</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      <span class="comment">// wait的处理是s先减1，再判断是否&lt;0，若是就进入阻塞队列。如果要不阻塞，则s的初始值需要&gt;=1</span></span><br><span class="line">      <span class="comment">// Swait与wait的处理不同，这里是在确信可满足资源要求时，才进行减1操作</span></span><br><span class="line">      Si=Si<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*某些资源不够时的处理；</span></span><br><span class="line"><span class="comment">    进程进入第一个小于1的信号量的阻塞队列 ;</span></span><br><span class="line"><span class="comment">    恢复PC寄存器为Swait开始时的状态；*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  Ssignal(S1, S2, …, Sn)&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    Si++; <span class="comment">//释放占用的资源；</span></span><br><span class="line">    <span class="keyword">for</span> (each process P waiting in Si.L)&#123;</span><br><span class="line">      <span class="comment">//检查每种资源的阻塞队列中的所有进程；</span></span><br><span class="line">      <span class="comment">//从阻塞队列Si.queue中取出进程P;</span></span><br><span class="line">      P = Si.<span class="built_in">queue</span>.getHead();</span><br><span class="line">      <span class="keyword">if</span>(判断P是否通过Swait中的测试)&#123;<span class="comment">//注:与signal不同，需重新判断进程P进入就绪队列;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">//未通过检查（资源不够用）时的处理；</span></span><br><span class="line">        进程P进入某阻塞队列；<span class="comment">//然后继续循环判断下一个进程</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="信号量集-Semaphore-Set"><a href="#信号量集-Semaphore-Set" class="headerlink" title="信号量集 Semaphore Set"></a>信号量集 Semaphore Set</h4><p>在记录型信号量机制中，<code>wait(S)</code>或 <code>signal(S)</code>操作仅能对信号量施以加 1 或减 1 操作，意味着每次只能获得或释放一个单位的临界资源。<br>在每次分配时，采用信号量集来控制，可以分配多个单位的资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Si—i 类资源现有数量；ti—i 类资源的分配下限值；di—申请i 类资源数量;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swait</span> <span class="params">( S1, t1, d1; ... ; Sn, tn, dn )</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (S1 ≥ t1 and S2 ≥ t2 … Sn ≥ tn) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      Si=Si-di;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//假设首先发现 Sj &lt; tj，进程进入Sj.L队列；</span></span><br><span class="line">    <span class="comment">//进程投入与Sj相关的阻塞队列</span></span><br><span class="line">    <span class="comment">//恢复PC寄存器为Swait开始时的状态；</span></span><br><span class="line">    <span class="comment">//启动进程调度程序，调度其它进程执行；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//si—i 类资源现有数；di—i 类资源释放数量 ;</span></span><br><span class="line"><span class="type">void</span> Ssignal ( S1, d1; ... ; Sn, dn )&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    Si=Si+di;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把与Si有关队列中的进程移入就绪队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“信号量集机制”可以用于各种情况的资源分配和释放，几种特殊情况：</p><ul><li><code>Swait(S, d, d)</code>表示每次申请 d 个资源，当少于 d 个时，便不分配</li><li><code>Swait(S, 1, 1)</code>表示一般的记录型互斥信号量（S&#x3D;1 时）或资源信号量（S&gt;1 时）</li><li><code>Swait(S, 1, 0)</code>可作为一个可控开关（当 S1 时，允许多个进程进入临界区；当 S&#x3D;0 时，禁止任何进程进入临界区）</li></ul><h4 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h4><p><strong>利用信号量实现进程互斥</strong><br>为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量 mutex，并设其初始值为 1，然后将各进程访问该资源的临界区 CS 置于 wait（mutex）和 signal（mutex）操作之间即可。<br><strong>利用信号量来描述前趋（合作）关系</strong><br>假设我们有两个任务 A 和 B，其中任务 B 依赖于任务 A 的完成。我们可以使用一个初始值为 0 的信号量来描述这种前驱关系。具体的操作步骤如下：<br>任务 A 在完成后，执行一个信号量的 V 操作（signal），将信号量的值加 1。<br>任务 B 在开始前，执行一个信号量的 P 操作（wait）。如果信号量的值大于 0，那么将信号量的值减 1 并继续执行。如果信号量的值等于 0，那么任务 B 将阻塞，直到信号量的值大于 0。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-14-10-39.png"></p><blockquote><p><code>parbegin</code> 和 <code>parend</code> 是并发编程中用来表示并行开始和并行结束的关键字</p></blockquote><p>例：用 And 信号量来描述如下的前趋图<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-14-12-29.png" alt="Precedence Graph"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var a,<span class="keyword">b,c,d,e,f,g: </span>semaphore: <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;</span><br><span class="line">Parbegin</span><br><span class="line">       <span class="keyword">begin </span><span class="built_in">S1</span><span class="comment">; Ssignal(a,b); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(a); </span><span class="built_in">S2</span><span class="comment">; Ssignal(c,d); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(b); </span><span class="built_in">S3</span><span class="comment">; signal(e); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(c); </span><span class="built_in">S4</span><span class="comment">; signal(f); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(d); </span><span class="built_in">S5</span><span class="comment">; signal(g); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">Swait(e,f,g); </span><span class="built_in">S6</span><span class="comment">; end;</span></span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure><h3 id="硬件同步机制-Hardware-Synchronization-Mechanism"><a href="#硬件同步机制-Hardware-Synchronization-Mechanism" class="headerlink" title="硬件同步机制 Hardware Synchronization Mechanism"></a>硬件同步机制 Hardware Synchronization Mechanism</h3><p><strong>利用计算机硬件指令解决临界区问题</strong><br>对临界区管理将标识看做一个锁，“锁开”进入，“锁关”等待。<br>初始打开，每个进入临界区的进程必须对锁进行测试。<br>测试和关锁操作必须连续（原子操作）</p><blockquote><p>虽然可以利用软件方法解决诸进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。相应地，目前许多计算机已提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。</p></blockquote><ol><li>关中断</li><li>利用 Test-and-Set 指令实现互斥</li><li>利用 Swap 指令实现进程互斥</li></ol><h4 id="关中断实现互斥-Disable-Interrupts"><a href="#关中断实现互斥-Disable-Interrupts" class="headerlink" title="关中断实现互斥 Disable Interrupts"></a>关中断实现互斥 Disable Interrupts</h4><p><strong>中断</strong>是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得 CPU 暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。<br><strong>中断处理</strong>是指 CPU 响应中断，转入中断处理程序，系统开始处理中断。<br><strong>中断响应</strong>是指 CPU 收到中断请求后转向相应的事件处理程序。<br><strong>开中断</strong>就是指系统可以在连续运行时中断，去运行中断服务函数<br><strong>关中断</strong>就是指关闭系统中断，系统不响应其他的中断，不允许系统打断连续的运行</p><p><strong>关中断</strong><br>进入锁测试前关闭中断，完成锁测试并上锁后打开中断<br>进程在临界区时计算机系统不响应中断，不会引发调度</p><p><strong>Pros And Cons</strong></p><ul><li>关中断是实现互斥的最简单的方法之一。</li></ul><hr><ul><li>滥用关中断权力可能导致严重后果；</li><li>关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；</li><li>关中断方法也不适用于多 CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">bool</span> <span class="title function_">are_interrupts_enabled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_operation</span><span class="params">(<span class="type">void</span> (*operation)())</span> &#123;</span><br><span class="line">    start_atomic_operation();</span><br><span class="line">    operation();</span><br><span class="line">    end_atomic_operation(are_interrupts_enabled());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_atomic_operation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果中断是开启的，那么关闭中断</span></span><br><span class="line">    <span class="keyword">if</span> (are_interrupts_enabled()) &#123;</span><br><span class="line">        disable_interrupts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">end_atomic_operation</span><span class="params">(<span class="type">bool</span> were_interrupts_enabled)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果在原子操作开始之前中断是开启的，那么重新开启中断</span></span><br><span class="line">    <span class="keyword">if</span> (were_interrupts_enabled) &#123;</span><br><span class="line">        enable_interrupts();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    enable_interrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Test-And-Set-指令实现互斥"><a href="#Test-And-Set-指令实现互斥" class="headerlink" title="Test And Set 指令实现互斥"></a>Test And Set 指令实现互斥</h4><p>这是一种借助 TS(Test-and-Set)硬件指令以实现互斥的方法。在许多计算机中都提供了这种指令。</p><p><code>lock=false</code>表示资源空闲，<code>*lock=TURE</code>表示资源正在被使用。<br>当资源被使用时，TS 返回 ture，则 <code>while TS（&amp;lock)</code>；语句条件为真会一直循环等待。</p><p>这段代码是一个实现了简单的自旋锁（spinlock）的例子，使用了一个称为 Test-and-Set（TS）的原子操作。自旋锁是一种用于同步的低级别的原子操作，通常用于保护短期的临界区（critical section）。<br>自旋锁可能会导致资源浪费，因为在等待获取锁的过程中，线程并不会释放 CPU，而是会一直忙等待。因此，自旋锁通常只用于保护非常短期的临界区。对于保护长期的临界区，通常会使用其他的同步机制，如互斥锁（mutex）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">boolen <span class="title function_">TS</span><span class="params">(boolen *lock)</span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock =TURE;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">while</span> <span class="title function_">TS</span><span class="params">( &amp;lock)</span>;</span><br><span class="line">    critical section;</span><br><span class="line">    lock :=FALSE;</span><br><span class="line">    remainder section;</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="利用-Swap-指令实现进程互斥"><a href="#利用-Swap-指令实现进程互斥" class="headerlink" title="利用 Swap 指令实现进程互斥"></a>利用 Swap 指令实现进程互斥</h4><p>该指令称为对换指令，在 <code>Intel 80x86</code>中又称为 <code>XCHG</code>指令，用于交换两个字的内容。</p><h4 id="管程-Moniter"><a href="#管程-Moniter" class="headerlink" title="管程 Moniter"></a>管程 Moniter</h4><p>虽然信号量机制是一种既方便、又有效的进程同步机制，但每个要访问临界资源的进程都必须自备同步操作 wait（S）和 signal（s）。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。这样，在解决上述问题的过程中，便产生了一种新的进程同步工具——管程 。</p><blockquote><p>Monitors are a higher-level synchronization construct that simplifies process synchronization by providing a high-level abstraction for data access and synchronization. Monitors are implemented as programming language constructs, typically in object-oriented languages, and provide mutual exclusion, condition variables, and data encapsulation in a single construct.<br><a href="#ref">Moniter-Ref</a></p></blockquote><h3 id="经典同步问题-Classic-Synchronization-Problems"><a href="#经典同步问题-Classic-Synchronization-Problems" class="headerlink" title="经典同步问题 Classic Synchronization Problems"></a>经典同步问题 Classic Synchronization Problems</h3><ul><li>生产者&#x2F;消费者问题 Producer-Consumer Problem</li><li>哲学家进餐问题 Dining Philosophers Problem</li><li>读者&#x2F;写者问题 Readers-Writers Problem</li></ul><h4 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer-Consumer Problem"></a>Producer-Consumer Problem</h4><p>生产者与消费者是一个广义的概念，可以代表一类具有相同属性的进程。生产者和消费者进程共享一个大小固定的缓冲池;一个或多个生产者生产数据，并将生产的数据存入缓冲池;一个或多个消费者从缓冲池中取数据。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ProcessSync-2024-03-08-11-03-26.png" alt="Producer-Consumer Problem"></p><p>必须使生产者和消费者互斥进入缓冲区。即，某时刻只允许一个实体（生产者或消费者）访问缓冲区，生产者互斥消费者和其它任何生产者。<br>生产者不能向满缓冲池写数据，消费者也不能在空缓冲池中取数据，即生产者与消费者必须同步。</p><p><strong>涉及两类进程</strong>：<br>生产者进程和消费者进程<br><strong>需要保证以下同步关系</strong>：</p><ol><li>多个进程互斥地访问公共缓冲池；互斥信号量 mutex</li><li>不能向满的缓冲池中添加产品；可用的空资源信号量 empty</li><li>不能从空的缓冲池中提取产品。可用的满资源信号量 full<br>full + empty&#x3D;N</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ProcessSync-2024-03-08-11-9-11.png"></p><blockquote><p>每个进程中各个 wait 操作的次序是重要的：先检查资源数目，再检查是否互斥.否则可能死锁<br>如：producer 先申请互斥，进入后，申请空资源，发现空资源不可用，必须等待 comsumer 先申请满资源，使用后释放出来。但此时，由于 producer 占用了互斥资源，因此 consumer 无法进入。故而陷入死锁状态</p></blockquote><h4 id="Dining-Philosophers-Problem"><a href="#Dining-Philosophers-Problem" class="headerlink" title="Dining Philosophers Problem"></a>Dining Philosophers Problem</h4><p>五个哲学家五只筷子，哲学家循环做着思考和吃饭的动作，吃饭程序是：先取左边筷子，再取右边筷子，再吃饭，再放筷子。</p><ol><li>至多只允许四个哲学家同时进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。</li><li>在哲学家进餐问题中，要求每个哲学家先获得两个临界资源(筷子)后方能进餐，这在本质上就是前面所介绍的 AND 同步问题，故用 AND 信号量机制可获得最简洁的解法,且可避免死锁。</li><li>规定奇数号的哲学家先拿起他左边的筷子,然后再去拿他右边的筷子;而偶数号的哲学家则相反.按此规定,将是 2,3 号哲学家竞争 3 号筷子,4,5 号哲学家竞争 5 号筷子.即三个哲学家都  竞争奇数号筷子,获得后,再去竞争偶数号筷子,最后总会 1 个哲学家能获得两支筷子而进餐.</li></ol><h4 id="Readers-Writers-Problem"><a href="#Readers-Writers-Problem" class="headerlink" title="Readers-Writers Problem"></a>Readers-Writers Problem</h4><p>该问题为多个进程访问一个共享数据区建立了一个通用模型，如数据库、文件、内存区及一组寄存器等数据。若干读进程只能读数据，若干写进程只能写数据。</p><p>例如，一个联网售票系统，数据的查询和更新非常频繁，不可避免会出现多个进程试图查询或修改（读&#x2F;写）其中某一条数据的情形。多个进程同时读一条记录是可以的。如果一个进程正在更新数据库中的某条记录，则所有其他进程都不能访问（读或写）该记录，否则可能会将同一个座位销售多次。</p><p><strong>读者&#x2F;写者进程满足的条件</strong></p><ol><li>允许多个读者进程可以同时读数据；</li><li>不允许多个写者进程同时写数据，即只能互斥写数据；</li><li>若有写者进程正在写数据，则不允许读者进程读数据。</li></ol><p><strong>Sol</strong><br>利用记录型信号量解决读者-写者问题<br>利用信号量集解决读者-写者问题</p><h4 id="Exercies"><a href="#Exercies" class="headerlink" title="Exercies"></a>Exercies</h4><blockquote><p><strong>EX1</strong><br>三个进程 P1，P2，P3 协作解决文件打印问题，P1 将文件记录从磁盘读入内存的缓冲区 1，每执行一次读一个记录；P2 将缓冲区 1 的内容取出放到缓冲区 2 中；P3 将缓冲区 2 的内容打印出来，每执行一次打印一个记录。缓冲区的大小和一个记录大小一样。<br>用 P、V 操作来保证文件的正确打印。<br><strong>引申</strong><br>有三个进程 A1、A2、A3，它们共享两个缓冲区 B1 和 B2。缓冲区 B1 中可以存放 n 件产品，缓冲区 B2 中可以存放 m 件产品。进程 A1 每次生产一件产品，并把产品存入缓冲区 B1。进程 A2 每次生产一件产品，并把产品存入缓冲区 B2。进程 A3 每次从缓冲区 B2 中取一件产品区消费。为了防止把产品存入已满的缓冲，或者从空缓冲中取产品，或重复取一产品，用 PV 操作实现它们的相互制约关系。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ProcessSync-2024-03-08-11-24-27.png" alt="ex"></p><hr><p><strong>EX2</strong><br>某工厂有一个可以存放设备的仓库，总共可以存放 8 台设备。生产部门生产的每一台设备都必须入库，销售部门可以从仓库中提出设备供应客户。设备出&#x2F;入库需要借助运输工具，现只有一套运输工具，每次只能运一台设备<br>请设计生产部门和销售部门进程。</p><hr><p><strong>EX3</strong><br>桌上放一个盘子，每次只能放一个水果，爸爸像盘子里放苹果，妈妈向盘子里放橘子，女儿专吃苹果,儿子专吃橘子。盘子空的时候爸爸或妈妈才能向盘子里面放一个水果，仅当盘子里有自己需要的水果时才可取一个水果。把爸爸、妈妈、儿子、女儿看做四个进程，用 PV 操作进行管理，使这四个进程能正确地并发执行。<br><strong>引申</strong><br>如果盘子的容量改为 2，且任何时刻只允许爸爸、妈妈、女儿、儿子中的一个进程去访问盘子（放或者取）。</p></blockquote><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://en.wikipedia.org/wiki/Semaphore_(programming)">Semaphore-wikipedia</a><br><a href="https://www.cnblogs.com/youxin/p/3586577.html">https://www.cnblogs.com/youxin/p/3586577.html</a><br><a href="https://www.geeksforgeeks.org/monitors-in-process-synchronization/">Moniter</a></p>]]></content>
    
    
    <summary type="html">进程同步</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>进程的描述及控制</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch2-1ProcessContorl/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch2-1ProcessContorl/</id>
    <published>2024-03-06T06:00:51.000Z</published>
    <updated>2024-03-21T09:55:19.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前驱图和程序执行-Precedence-Graph-and-Program-Execution"><a href="#前驱图和程序执行-Precedence-Graph-and-Program-Execution" class="headerlink" title="前驱图和程序执行 Precedence Graph and Program Execution"></a>前驱图和程序执行 Precedence Graph and Program Execution</h2><h3 id="前驱图-Precedence-Graph"><a href="#前驱图-Precedence-Graph" class="headerlink" title="前驱图 Precedence Graph"></a>前驱图 Precedence Graph</h3><p><strong>前趋图(Precedence Graph)</strong>:一个<strong>有向无循环</strong>图 DAG(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。图中的每个结点可用于表示一条语句、一个程序段等；结点间的有向边表示在两个结点之间存在的前趋关系。<br><strong>初始结点(InitialNode)</strong> 前趋图中没有前趋的结点<br><strong>终止结点(FinalNode)</strong> 前趋图中没有后继的结点</p><pre><code>→=&#123;(Pi, Pj)|Pi must complete before Pj may start&#125;(Pi, Pj)∈→ 或 Pi→PjPi是Pj的直接前趋，Pj是Pi的直接后继。</code></pre><p>若一个程序由若干程序段（即操作）组成，而这些操作必须按照某种先后次序执行，这类执行过程就是程序的顺序执行。</p><h3 id="程序执行-Program-Execution"><a href="#程序执行-Program-Execution" class="headerlink" title="程序执行 Program Execution"></a>程序执行 Program Execution</h3><p><strong>程序执行方式</strong></p><ul><li>顺序执行—单道批处理系统</li><li>并发执行–多道批处理系统<ul><li>应用级并发是指若干应用程序的并发执行。</li><li>系统级并发是指操作系统自身软件的并发执行。</li></ul></li></ul><p><strong>顺序执行</strong></p><p>若一个程序由若干程序段（即操作）组成，而这些操作必须按照某种先后次序执行，这类执行过程就是<strong>程序的顺序执行</strong></p><ul><li><strong>顺序性</strong>：处理机的操作严格按照程序所规定的顺序执行。</li><li><strong>封闭性</strong>：程序运行时独占全机资源，程序一旦开始执行，其执行结果不受外界因素影响。</li><li><strong>可再现性</strong>：只要程序执行时的环境和初始条件相同，都将获得相同的结果。</li></ul><p><strong>并发执行的特征</strong></p><ul><li><strong>间断性</strong>：由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间，形成了相互制约的关系，导致并发程序具有“执行——暂停——执行”这种间断性的活动规律。</li><li><strong>失去封闭性</strong>：是多个程序共享系统中的各种资源，因而这些资源的状态将由多个程序来改变，致使程序的运行已失去了封闭性。</li><li><strong>不可再现性</strong>：程序在并发执行时，由于失去了封闭性，导致不可再现性 。</li></ul><h2 id="进程的描述-Process"><a href="#进程的描述-Process" class="headerlink" title="进程的描述 Process"></a>进程的描述 Process</h2><h3 id="Definition-Features-Components-States"><a href="#Definition-Features-Components-States" class="headerlink" title="Definition,Features,Components,States"></a>Definition,Features,Components,States</h3><p><strong>为什么引入进程?</strong></p><p>并发执行：进程使得多个任务可以在同一时间段内交替执行，这种并发执行使得 CPU 可以在等待一个任务的 IO 操作完成时执行另一个任务，从而提高了系统的效率和吞吐量。<br>独立性：每个进程都有自己的私有地址空间，这意味着一个进程不能直接访问另一个进程的内存。这种内存保护机制有助于防止一个进程意外或恶意地干扰另一个进程。<br>简化编程模型：在没有进程的情况下，程序员必须手动管理多任务执行和资源分配。有了进程，这些任务就由操作系统自动处理，程序员可以专注于应用程序的逻辑。<br>资源管理：进程是资源分配和管理的基本单位。操作系统可以根据每个进程的需要和优先级分配资源，如 CPU 时间、内存空间等。</p><p>[<a href="ProcessvsThread" title="Process &amp; Thread">ProcessvsThread#Process</a>]</p><h3 id="进程控制块-PCB"><a href="#进程控制块-PCB" class="headerlink" title="进程控制块 PCB"></a>进程控制块 PCB</h3><p>PCB 是操作系统中用于描述进程的一种数据结构，它是操作系统中最重要的数据结构之一。PCB 中包含了进程的所有信息，是操作系统对进程进行控制和管理的数据结构。它包含以下<strong>主要信息</strong>：</p><ul><li><strong>进程标识符信息</strong></li><li><strong>处理机的状态信息</strong></li><li><strong>进程的调度信息</strong></li><li><strong>进程控制信息</strong></li></ul><h4 id="PCB-的主要信息"><a href="#PCB-的主要信息" class="headerlink" title="PCB 的主要信息"></a>PCB 的主要信息</h4><ol><li><strong>进程标识符 PID</strong></li></ol><p><strong>进程标识符</strong>用于唯一地标识一个进程。一个进程通常有两种标识符：</p><ul><li>内部标识符。为每一个进程赋予一个唯一的数字标识符，通常是进程的序号。设置内部标识符主要是为了方便操作系统使用。</li><li>外部标识符。它由创建者提供，通常是由字母、数字组成，往往是由用户（进程）在访问该进程时使用。</li></ul><ol start="2"><li><strong>处理机状态信息 Processor State Information</strong></li></ol><p>处理机状态信息主要是由处理机的各种寄存器的内容组成的。例如:</p><ul><li>通用寄存器，又称为用户可视寄存器。</li><li>指令计数器 PC，其中存放了要访问的下一条指令的地址。</li><li>程序状态字 PSW，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等</li><li>用户栈指针 SP，用于存放系统调用参数及调用地址。栈指针指向该栈的栈顶。</li></ul><ol start="3"><li><strong>进程调度信息 Scheduling Information</strong></li></ol><p>在 PCB 中还存放一些与进程调度和进程对换有关的信息。</p><ul><li><strong>进程状态</strong>。指明进程的当前状态</li><li><strong>进程优先级</strong>。</li><li><strong>事件</strong>。是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因。</li><li><strong>其它信息</strong>。如：进程已等待 CPU 的时间总和、进程已执行的时间总和等；</li></ul><p>可参考<code>linux kernel sched.h task_struct</code>结构</p><ol start="4"><li><strong>进程控制信息 Process Control Information</strong></li></ol><ul><li><strong>程序和数据的地址</strong> 进程的程序和数据所在的内存或外存地址。</li><li><strong>进程同步和通信机制</strong> 实现进程同步和进程通信时必需的机制，如消息队列指针、信号量等。</li><li><strong>资源清单</strong> 进程所需的全部资源及已经分配到该进程的资源的清单；</li><li><strong>链接指针</strong> 本队列下一个进程的 PCB 的首地址。</li></ul><h4 id="PCB-的组织方式"><a href="#PCB-的组织方式" class="headerlink" title="PCB 的组织方式"></a>PCB 的组织方式</h4><ol><li><strong>线性方式</strong>:把系统中所有的 PCB 都组织在一张线性表中。</li><li><strong>链接方式</strong>:把具有同一状态的 PCB，用其中的链接指针链接成一个队列。(通常，可根据等待事件的不同，组织多个不同的阻塞队列,如等待打印机和等待内存等)</li><li><strong>索引方式</strong>:相同状态的进程 PCB 组织在一张表格中，系统根据所有进程的状态建立几张索引表，系统分别记载各 PCB 表格的起始地址<br>因为进程的主要操作就是插入和删除，因此，链接方式使用更多一些</li></ol><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86-2024-03-04-21-52-11.png" alt="进程管理-2024-03-04-21-52-11"></p><h4 id="PCB-的作用"><a href="#PCB-的作用" class="headerlink" title="PCB 的作用"></a>PCB 的作用</h4><p>进程控制块的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位(进程)。<br>在进程的整个生命期中，操作系统总是通过 PCB 对进程进行控制的。所以说，PCB 是进程存在的唯一标志。<br>OS 是根据 PCB 来对并发执行的进程进行控制和管理的，如：<br>进程创建：分配进程控制块<br>进程调度：保存和读取进程控制块<br>进程撤销：回收进程控制块</p><h2 id="进程控制-Process-Control"><a href="#进程控制-Process-Control" class="headerlink" title="进程控制 Process Control"></a>进程控制 Process Control</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>进程控制 Process Control</strong>:操作系统的核心功能之一。包括进程的创建,终止,调度,状态转换,同步,通信等。进程控制一般是由 OS 内核中的一组原语来实现的。<br><strong>原语 Primitive</strong>:操作系统内核或微核提供核外调用的过程或函数称为原语,其由若干条指令构成，用于完成特定功能的一段程序。原语在执行过程不允许被中断。<br><strong>原子操作 Atom Operation</strong>：执行中不能被其它进程（线程）打断的操作就叫原子操作。当该次操作不能完成的时候，必须回到操作之前的状态，原子操作不可拆分。<br><strong>内核 Kernel</strong>:计算机硬件的第一层扩充软件，为系统对进程控制、存储器管理等提供有效的机制。内核常驻内存，紧靠硬件，运行效率较高。在不同操作系统中，内核所包含的功能不尽相同，但一般应包含以下功能：<br>支撑功能:中断处理,时钟管理,原语操作<br>资源管理功能:进程管理,存储器管理,设备管理</p><h3 id="进程的创建与终止"><a href="#进程的创建与终止" class="headerlink" title="进程的创建与终止"></a>进程的创建与终止</h3><p><strong>进程创建原语</strong>执行的操作:</p><ol><li>申请空白 PCB。</li><li>为新进程分配资源。</li><li>初始化进程控制块。</li></ol><ul><li>初始化标识信息。</li><li>初始化处理机状态信息。使程序计数器指向程序的入口地址，使栈指针指向栈顶；</li><li>初始化处理机控制信息：进程的状态、优先级。</li></ul><ol start="4"><li>将新进程插入就绪队列，启动调度。</li></ol><p><strong>引起进程创建的主要事件</strong></p><p>用户登录<br>作业调度<br>提供服务<br>应用请求</p><p><strong>引起进程终止的事件</strong></p><ol><li>正常结束。</li><li>异常结束：</li></ol><ul><li>越界错误。</li><li>保护错。</li><li>非法指令。</li><li>特权指令错。</li><li>运行超时。</li><li>等待超时。</li><li>算术运算错、被 0 除：</li><li>I&#x2F;O 故障。</li></ul><ol start="3"><li>外界干预:外界干预并非指在本进程运行中出现了异常事件，而是指进程应外界的请求而终止运行。</li></ol><ul><li>操作员或操作系统干预。由于某种原因，例如，发生了死锁，由操作员或操作系统终止该进程；</li><li>父进程请求终止该进程；</li><li>当父进程终止时，OS 也将他的所有子孙进程终止。</li></ul><p><strong>进程的终止过程</strong></p><ol><li>根据被终止进程的 PID 找到它的 PCB，从中读出该进程的状态。</li><li>若被终止进程正处于执行状态，应立即终止该进程的执行，重新进行调度。</li><li>若该进程还有子孙进程，立即将其所有子孙进程终止。</li><li>将被终止进程所拥有的全部资源，归还给其父进程，或者归还给系统。</li><li>将被终止进程的 PCB 从所在队列中移出</li></ol><h3 id="进程的阻塞与唤醒-Block-and-Wakeup"><a href="#进程的阻塞与唤醒-Block-and-Wakeup" class="headerlink" title="进程的阻塞与唤醒 Block and Wakeup"></a>进程的阻塞与唤醒 Block and Wakeup</h3><p><strong>引起进程阻塞的原因</strong></p><ul><li>请求系统服务。</li><li>启动某种操作：如 I&#x2F;O 操作。</li><li>新数据尚未到达。</li><li>无新工作可做</li></ul><p><strong>进程阻塞的过程</strong></p><p>处于运行状态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息，当被等待的事件未发生时，由进程自己执行阻塞原语 block，使自己由运行态变为阻塞态。可见，进程的阻塞是进程自身的一种主动行为。</p><ol><li>正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语<code>block</code>把自己阻塞；（阻塞是主动行为）</li><li>把进程控制块中的现行状态由<code>running</code>改为<code>blocked</code>，并将 PCB 插入阻塞队列；</li><li>转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换。</li></ol><p><strong>进程的唤醒过程</strong></p><p>当被阻塞进程所期待的事件出现时，例如，当进程提出 I&#x2F;O 请求时，进程会进入到阻塞状态，但是不能让这个进程一直处于阻塞状态，等到其 I&#x2F;O 操作完成时，那么系统就要采用唤醒原语 wakeup 唤醒这个处于阻塞的进程，以使它继续执行。</p><ol><li>当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该 I&#x2F;O 设备的进程）调用唤醒原语 <code>wakeup()</code>，将等待该事件的进程唤醒。（唤醒是一种被动行为）</li><li>唤醒原语的执行过程是：<br>把被阻塞的进程从等待该事件的阻塞队列中移出<br>将其 PCB 中的现行状态由阻塞改为就绪<br>将该 PCB 插入到就绪队列中等待 CPU 调度</li></ol><h3 id="进程的挂起与激活-Suspend-and-Active"><a href="#进程的挂起与激活-Suspend-and-Active" class="headerlink" title="进程的挂起与激活 Suspend and Active"></a>进程的挂起与激活 Suspend and Active</h3><p>当有引起进程挂起的事件，系统利用挂起原语<code>suspend（）</code>将指定进程或者处于阻塞状态的进程挂起。<br>当有发生激活进程的事件发生，若该进程在外存中已有足够的空间时，可将在外存上处于静止就绪的进程从外存调入内存，系统利用激活原语<code>active()</code>将指定进程激活</p><p><strong>进程的挂起</strong><br>当出现了引起进程挂起的事件时，系统将利用挂起原语<code>suspend()</code>将指定进程挂起或处于阻塞状态的进程挂起。（挂起是主动行为）<br>调用挂起原语的进程只能挂起自己或其子孙进程;内核的 sleep()函数是在挂起原语的基础上利用定时器实现的。</p><p><strong>挂起原语的执行过程</strong></p><ol><li>检查将要被挂起的进程的状态<br><code>running</code>：将该进程的 PCB 中的现行状态由<code>running</code>改为<code>ready suspend</code>,设置 CPU 调度标志为真；<br><code>ready</code>: PCB 中的现行状态由<code>running</code>改为<code>ready suspend</code>；<br><code>blocked</code>：将该进程的 PCB 中的现行状态由<code>blocked</code>改为<code>blocked suspend</code>；</li><li>将被挂起进程的 PCB 复制到指定的内存区域。</li><li>若处于运行状态，则转向调度程序重新调度</li></ol><blockquote><p><strong>Ex</strong>:请判断下列说法哪些的正确的？</p><ul><li><input disabled="" type="checkbox"> 进程可以由自己创建(❌,进程可以创建子进程,但不能自己创建自己)</li><li><input checked="" disabled="" type="checkbox"> 进程可以由自己阻塞</li><li><input checked="" disabled="" type="checkbox"> 进程可以由自己挂起</li><li><input disabled="" type="checkbox"> 进程可以由自己激活</li><li><input disabled="" type="checkbox"> 进程可以由自己唤醒</li><li><input disabled="" type="checkbox"> 进程可以由自己撤消</li></ul></blockquote>]]></content>
    
    
    <summary type="html">操作系统进程管理:前趋图和程序执行,进程的描述,进程控制</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Process &amp; Thread</title>
    <link href="https://efterklang.github.io/UESTC/OS/ProcessvsThread/"/>
    <id>https://efterklang.github.io/UESTC/OS/ProcessvsThread/</id>
    <published>2024-03-04T06:24:55.000Z</published>
    <updated>2024-03-29T07:03:52.718Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><ul><li>A process is an instance of a program running in a computer.</li><li>A process is an independent unit of execution in a computer program, including the complete set of instructions and the associated memory and resources.</li><li>It is a program that is under execution.</li></ul><p>典型的进程定义有：</p><ul><li>进程是程序的一次执行。</li><li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li><li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li></ul><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul><li><strong>动态性 Dynamic</strong>:进程的实质是进程实体的一次执行过程，因此，动态性是进程的最基本的特征。动态性表现在“它由创建而产生，由调度而执行，由撤消而消亡”。可见，进程实体有一定的生命期。</li><li><strong>并发性 Concurrency</strong>:多个进程实体同存于内存中，且能在一段时间内同时运行。</li><li><strong>独立性 Independence</strong>:进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位。</li><li><strong>异步性 Asynchronism</strong>:进程按各自独立的、不可预知的速度向前推进，或说进程实体按异步方式运行。</li></ul><h3 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h3><p><strong>进程实体 Process Entity</strong>包括：</p><ul><li><strong>程序块 Program Block</strong>: The code that is to be executed.</li><li><strong>数据块 Data Block</strong>: The variables and data that are used by the program.</li><li><strong>堆栈 Stack</strong>: The stack that is used to store the temporary data and function calls.</li><li><strong>进程控制块 Process control block(PCB)</strong>: It is a data structure that contains information about the process. It includes process state, process ID, CPU registers, CPU scheduling information, memory management information, and other information. It is used by the operating system to manage the process.</li></ul><p>[<a href="Ch2-1ProcessContorl" title="进程的描述及控制">Ch2-1ProcessContorl#进程控制块 PCB</a>]</p><h3 id="States"><a href="#States" class="headerlink" title="States"></a>States</h3><ul><li><strong>新建态 New</strong>: 进程已经创建，但未被 OS 接纳为可执行进程，并且程序还在辅存，PCB 在内存</li><li><strong>就绪态 Ready</strong>: The process is ready to be executed.</li><li><strong>运行态 Running</strong>: The process is currently being executed.</li><li><strong>阻塞态 Blocked&#x2F;等待态 Waiting</strong>: The process is waiting for some event to occur.</li><li><strong>终止态 Exit</strong>: 因停止或取消，被 OS 从执行状态释放</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-04-13-43-46.png" alt="5 states model"></p><p>当出现了引起进程挂起的事件时，用户请求将自己挂起，或者父进程请求挂起自己的子进程，这时使用挂起原语<code>Suspend()</code><br>当发生激活事件后，系统利用激活原语<code>Active()</code> 将指定进程激活。激活原语将进程从外存调入内存，然后检查进程状态<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-04-14-00-16.png"><br>挂起状态又称为静止状态，一个就绪进程被挂起，变为静止就绪；阻塞状态进程被挂起，称为静止阻塞。处于静止状态的进程保存在磁盘(外存)上，它只有被对换到内存才能被调度执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-04-13-59-41.png"></p><p><strong>Note</strong></p><ul><li>即使进程等待的事件已经发生，只要进程处于挂起状态，它就不能执行。只有当进程从挂起状态恢复时，它才能根据自身的就绪条件（如等待的事件是否已经发生）决定是否可以执行。</li><li>使之挂起的进程可以为：自身、其父进程、OS</li><li>只有挂起它的进程才能使之由挂起状态转换为其他状态</li></ul><p><strong>Causes of Suspension</strong></p><ul><li>终端用户的请求。</li><li>父进程请求。</li><li>负荷调节的需要。当实时系统中的工作负荷较重，把一些不重要的进程挂起，以保证系统能正常运行。</li><li>操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。</li></ul><blockquote><p><strong>Blocked VS Suspend</strong></p><p><strong>阻塞</strong>：正在执行的进程<strong>由于发生某事件（如 I&#x2F;O 请求、申请缓冲区失败等）</strong>暂时无法继续执行。此时引起进程调度，OS 把处理机分配给另一个就绪进程，而让受阻进程处于暂停状态，一般将这种状态称为阻塞状态。<br><strong>挂起</strong>：由于<strong>系统和用户的需要</strong>引入了挂起的操作，进程被挂起意味着该进程处于静止状态。如果进程正在执行，它将暂停执行，若原本处于就绪状态，则该进程此时暂不接受调度。</p><p><strong>Same</strong>：</p><ul><li>进程都暂停执行</li><li>进程都释放 CPU，即两个过程都会涉及上下文切换</li></ul><p><strong>Diff</strong>：</p><ul><li><strong>对系统资源占用不同</strong>：虽然都释放了 CPU，但阻塞的进程仍处于内存中，而挂起的进程通过“对换 Swapping”技术被换出(Swap Out)到外存（磁盘）中。</li><li><strong>发生时机不同</strong>：阻塞一般在进程等待资源（IO 资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS 为了提高内存利用率需要将暂时不能运行的进程（处于就绪或阻塞队列的进程）调出到磁盘</li><li><strong>恢复时机不同</strong>：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其激活</li></ul></blockquote><blockquote><p>Program vs Process: A program is a passive entity, such as a file containing a list of instructions stored on disk, whereas a process is an active entity, with a program counter specifying the next instruction to execute and a set of associated resources.</p><p><strong>可执行程序和进程的区别</strong></p><ul><li>程序是永存的；进程是暂时的，是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；</li><li>程序是静态的观念，进程是动态的观念；</li><li>进程具有并发性，而程序没有；</li><li>进程是竞争计算机资源的基本单位，程序不是。</li><li>进程和程序不是一一对应的：<ul><li>一个程序可对应多个进程即多个进程可执行同一程序；</li><li>一个进程可以执行一个或几个程序。</li></ul></li></ul></blockquote><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><ul><li>A thread is a basic unit of CPU utilization.</li><li>It is a single sequence stream within a process.</li><li>A thread is a lightweight process. It shares the same memory space and system resources with other threads in the same process.</li></ul><p>也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。</p><blockquote><p>[<a href="Ch2-4Thread" title="Thread">Ch2-4Thread#线程概述</a>]</p></blockquote><h3 id="Features-1"><a href="#Features-1" class="headerlink" title="Features"></a>Features</h3><ul><li><strong>Lightweight</strong>: Threads are lightweight compared to processes. It takes less time to create and terminate threads.</li><li><strong>Shared resources</strong>: Threads in the same process share the same memory space and system resources.</li><li><strong>Efficiency</strong>: Threads are more efficient than processes because they share the same memory space and system resources.</li></ul><h3 id="Components-1"><a href="#Components-1" class="headerlink" title="Components"></a>Components</h3><p><strong>TCB Components</strong></p><ul><li><p><strong>Tid</strong>: A unique thread identifier in the process.</p><blockquote><p>同进程一样，每个线程也有一个线程 ID;进程 ID 在整个系统中是唯一的，线程 ID 只在它所属的进程环境中唯一</p></blockquote></li><li><p><strong>Register set</strong>: These are small storage areas that quickly hold and release data. They store intermediate values during execution.Including <strong>Program counter</strong> which keeps track of the execution of the thread, indicating the address of the next instruction to be executed.</p></li><li><p><strong>Stack</strong>: It is a data structure that stores temporary data like function parameters, return addresses, and local variables.</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-13-10-44-36.png" alt="Components"></p><h3 id="States-1"><a href="#States-1" class="headerlink" title="States"></a>States</h3><p>同进程一样，线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。<br>线程运行时有以下 3 种状态：</p><ul><li><strong>Running 执行状态</strong>:表示线程正获得 CPU 而运行；</li><li><strong>Ready 就绪状态</strong>:表示线程已具备了各种运行条件，一旦获得 CPU 便可执行；</li><li><strong>Blocked 阻塞状态</strong>:表示线程在运行中因某事件而受阻，处于暂停执行的状态；</li></ul><h2 id="Comparison"><a href="#Comparison" class="headerlink" title="Comparison"></a>Comparison</h2><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p><strong>线程</strong>具有许多传统进程所具有的特征，所以又称为<strong>轻型进程</strong>(Light-Weight Process) ，相应地把传统<strong>进程</strong>称为<strong>重型进程</strong>(Heavy-Weight Process)，传统进程相当于只有一个线程的任务。<br>在引入了线程的操作系统中，通常一个进程都拥有若干个线程，至少也有一个线程。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-4Thread-2024-03-13-09-23-33.png" alt="Create Thread vs Create Process"></p><p>下面从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较。</p><ul><li><strong>调度</strong> 在传统的操作系统中，进程作为拥有资源和独立调度、分派的基本单位。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。</li><li><strong>并发性</strong> 在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。</li><li><strong>拥有资源</strong> 一般而言，线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I&#x2F;O 设备等，可以供该进程中的所有线程所共享。</li><li><strong>独立性</strong> 同一进程中的不同线程共享进程的内存空间和资源</li><li><strong>系统开销</strong> 线程的切换只需要保存和设置少量的寄存器内容，不涉及存储器管理方面的操作。 由于一个进程中的多个线程具有相同的地址空间，在同步和通信的实现方面线程也比进程容易。在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。</li><li><strong>支持多处理机系统</strong> 一个进程分为多个线程分配到多个处理机上并行执行，可加速进程的完成。</li></ul><p><strong>Linux Process&#x2F;Thread Control Operations Comparison</strong></p><table><thead><tr><th align="center">应用功能</th><th align="center">线程</th><th align="center">进程</th></tr></thead><tbody><tr><td align="center">创建</td><td align="center">pthread_create</td><td align="center">fork,vfork</td></tr><tr><td align="center">退出</td><td align="center">pthread_exit</td><td align="center">exit</td></tr><tr><td align="center">等待</td><td align="center">pthread_join</td><td align="center">wait、waitpid</td></tr><tr><td align="center">取消&#x2F;终止</td><td align="center">pthread_cancel</td><td align="center">abort</td></tr><tr><td align="center">读取 ID</td><td align="center">pthread_self()</td><td align="center">getpid()</td></tr><tr><td align="center">同步互斥&#x2F;通信机制</td><td align="center">互斥锁、条件变量、读写锁</td><td align="center">无名管道、有名管道、信号、消息队列、信号量、共享内存</td></tr></tbody></table><h3 id="Java-Example"><a href="#Java-Example" class="headerlink" title="Java Example"></a>Java Example</h3><p>摘录自<a href="https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">javaguide</a></p><p>从下图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessvsThread-2024-03-04-14-13-53.png" width="80%"></center><p>线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。<br>线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p><h3 id="有了进程为什么还需要线程"><a href="#有了进程为什么还需要线程" class="headerlink" title="有了进程为什么还需要线程?"></a>有了进程为什么还需要线程?</h3><p>进程切换是一个开销很大的操作，线程切换的成本较低。<br>线程更轻量，一个进程可以创建多个线程。<br>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。<br>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</p><h3 id="为什么要使用多线程"><a href="#为什么要使用多线程" class="headerlink" title="为什么要使用多线程?"></a>为什么要使用多线程?</h3><p><strong>总体上</strong></p><p><strong>从计算机底层来说</strong>： 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。<br><strong>从当代互联网发展趋势来说</strong>： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</p><p><strong>计算机底层</strong></p><p><strong>单核时代</strong>：在单核时代多线程主要是为了提高单进程利用 CPU 和 IO 系统的效率。 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，一个线程被 IO 阻塞，其他线程还可以继续使用 CPU。从而提高了 Java 进程利用系统资源的整体效率。<br><strong>多核时代</strong>: 多核时代多线程主要是为了提高进程利用多核 CPU 的能力。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高，约等于（单核时执行时间&#x2F;CPU 核心数）。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><p><a href="https://teaching.csse.uwa.edu.au/units/CITS2002/lectures/lecture07/singlepage.html">https://teaching.csse.uwa.edu.au/units/CITS2002/lectures/lecture07/singlepage.html</a></p>]]></content>
    
    
    <summary type="html">介绍进程和线程</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Copilot GPT4 Service</title>
    <link href="https://efterklang.github.io/Tech/Others/CopilotGPT4Service/"/>
    <id>https://efterklang.github.io/Tech/Others/CopilotGPT4Service/</id>
    <published>2024-03-01T09:05:01.000Z</published>
    <updated>2024-03-26T11:19:01.412Z</updated>
    
    <content type="html"><![CDATA[<article class="message is-danger">        <div class="message-header"><p>文章已过时</p></div>        <div class="message-body">            <p>Copilot-GPT4-Service Repo 已被 Github 禁用,无法继续使用</p>        </div>    </article><h2 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a>Prerequisite</h2><p>拥有一个 github 账号,并且订阅了 Github Copilot 服务<br>在通过 <a href="https://education.github.com/students">Github 学生认证</a>后,可免费使用 Github Copilot</p><h2 id="Step1-下载-Copilot-GPT4-Service"><a href="#Step1-下载-Copilot-GPT4-Service" class="headerlink" title="Step1.下载 Copilot-GPT4-Service"></a>Step1.下载 Copilot-GPT4-Service</h2><p><a href="https://github.com/aaamoon/copilot-gpt4-service/releases/tag/0.2.0">https://github.com/aaamoon/copilot-gpt4-service/releases/tag/0.2.0</a></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/copilot-gpt4-service.png" alt="Copilot-GPT4-Service"></p><h2 id="Step2-运行-service-获取-copilot-token"><a href="#Step2-运行-service-获取-copilot-token" class="headerlink" title="Step2.运行 service,获取 copilot token"></a>Step2.运行 service,获取 copilot token</h2><p>解压缩,并以管理员权限运行<code>Step1</code>中下载的可执行文件;然后按照如下步骤 copilot token</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>运行脚本(二选一即可),按照脚本提示进行操作即可;复制得到的 token,形如 <code>ghu_6lGZ6JxxxxxxxxxxxxxxxxD0kykBm</code><br><strong>方法一: python script</strong><br><a href="https://raw.githubusercontent.com/aaamoon/copilot-gpt4-service/master/shells/get_copilot_token.py">get_copilot_token.py</a><br><strong>方法二:batch script</strong><br><a href="https://raw.githubusercontent.com/aaamoon/copilot-gpt4-service/master/shells/get_copilot_token.bat">get_copilot_token.bat</a></p><h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># method <span class="number">1</span></span><br><span class="line">bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/aaamoon/copilot-gpt4-service/master/shells/get_copilot_token.sh)&quot;</span><br><span class="line"># method <span class="number">2</span></span><br><span class="line">pip install requests</span><br><span class="line">python3 &lt;(curl -fsSL https://raw.githubusercontent.com/aaamoon/copilot-gpt4-service/master/shells/get_copilot_token.py)</span><br></pre></td></tr></table></figure><h2 id="Step3-config-NextChat"><a href="#Step3-config-NextChat" class="headerlink" title="Step3. config NextChat"></a>Step3. config NextChat</h2><p>下载<a href="https://github.com/ChatGPTNextWeb/ChatGPT-Next-Web/releases/tag/v2.11.2">NextChat</a></p><p>参照下图进行配置,其中 <code>OpenAI API Key</code>填入在 Step2 中获得的<code>token</code></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/NextChat.png" alt="NextChat Settings"></p><p>后台运行<code>Copilot-GPT4-Service</code>后即可无限制使用 GPT4</p>]]></content>
    
    
    <summary type="html">使用Github Copilot的GPT4服务</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="Others" scheme="https://efterklang.github.io/categories/Tech/Others/"/>
    
    
    <category term="Others" scheme="https://efterklang.github.io/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>操作系统概论</title>
    <link href="https://efterklang.github.io/UESTC/OS/Ch1-1OSIntroduction/"/>
    <id>https://efterklang.github.io/UESTC/OS/Ch1-1OSIntroduction/</id>
    <published>2024-02-28T05:35:16.000Z</published>
    <updated>2024-03-29T08:08:35.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OS-的定义"><a href="#OS-的定义" class="headerlink" title="OS 的定义"></a>OS 的定义</h2><p>当前对于 OS 还没有一个统一的、适用的定义<br>定义 1:操作系统是一组控制和管理计算机软硬件资源、合理地对各类作业进行调度以及方便用户使用的<strong>程序集合</strong><br>定义 2:操作系统是位于硬件层(HAL)之上，所有其它系统软件层之下的一个<strong>系统软件</strong>，使得管理系统中的各种软件和硬件资源得以充分利用，方便用户使用计算机系统</p><h2 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a>操作系统的目标和作用</h2><p><strong>目标</strong></p><ul><li><strong>方便性</strong>:操作系统使计算机更易于使用。</li><li><strong>有效性</strong>:操作系统允许以更有效的方式使用计算机系统资源。<ul><li>提高系统资源利用率</li><li>提高系统的吞吐量</li></ul></li><li><strong>可扩展性</strong>:在操作系统中,允许有效地开发，测试和引进新的系统功能。</li><li><strong>开放性</strong>:实现应用程序的可移植性和互操作性,要求具有统一的开放的环境。</li></ul><p><strong>作用</strong></p><ol><li>OS 作为用户与计算机硬件系统之间的接口</li></ol><ul><li>计算机用户需要的用户命令 ：由 OS 实现的所有用户命令所构成的集合常被称为 OS 的 Interface(用户接口)；有时也称为命令接口。<br><strong>命令的表示形式</strong>： - 字符形式：较灵活但因繁琐而难记； - 菜单形式：试图在字符终端上提供友好的用户界面 - 图形形式：因直观而易记但不灵活。</li><li>应用软件需要的 System Call(系统调用)：由 OS 实现的所有系统调用所构成的集合被人们称为程序接口或应用编程接口(Application Programming Interface,API)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA-2024-02-28-13-54-05.pnge"></li></ul><blockquote><p>操作系统应隐藏复杂的、困难的、丑陋的、特殊的硬件细节，呈现给程序（程序员）良好、清晰、优雅、一致的抽象<br>操作系统的任务就是创建好的抽象，并实现和管理它所创建的抽象</p></blockquote><ol start="2"><li>OS 作为计算机系统资源的管理者(软硬件资源)</li></ol><ul><li>处理机管理， 用于分配和控制处理机；</li><li>存储器管理，主要负责内存的分配与回收；</li><li>I&#x2F;O 设备管理，负责 I&#x2F;O 设备的分配与操纵；</li><li>文件管理，负责文件的存取、共享和保护。</li><li>对于多用户系统，需要管理共享资源，避免发生冲突。</li></ul><blockquote><p>操作系统的任务是在相互竞争的程序之间有序地控制对硬件设备的分配<br>资源管理包括用以下两种不同的方式实现<strong>多路复用（共享）</strong>资源</p><ul><li>在时间上复用：当一种资源在时间上复用时，不同的程序“轮流”实用它；例如 CPU、打印机等</li><li>在空间上复用：每个客户都得到资源的一部分；例如内存、磁盘等</li></ul></blockquote><ol start="3"><li>OS 用作扩充机器<br>裸机：完全无软件的计算机系统。<br>操作系统用来扩充机器功能，使其便于使用;在裸机上覆盖管理软件，实现对设备的操作，并向上提供一组操作命令;隐藏对设备操作的具体细节，实现对硬件操作的多个层次的抽象。<br>通常把覆盖了软件的机器称为<strong>扩充机器或虚机器</strong></li></ol><h2 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h2><ul><li><p><strong>无操作系统</strong><br>采用人工操作方式: 一台计算机的所有资源由用户独占，降低了计算机资源利用率，人操作慢，出现了严重的人机矛盾。<br>缺点：用户独占全机,CPU 等待人工操作</p></li><li><p><strong>单道批处理操作系统Single-programming System</strong>:系统对作业的处理都是成批进行的，且在内存中始终仅存一道作业运行，运行结束或出错，才自动调另一道作业运行，故称为单道批处理系统。<br>单道批处理系统主要特征：自动性、顺序性、单道性。<br>单道批处理系统主要优点：减少人工操作，解决了作业的自动接续。<br>单道批处理系统主要缺点：平均周转时间长，没有交互能力。</p></li><li><p><strong>多道批处理操作系统Multi-programming System</strong>: 在内存中存放多道作业运行，运行结束或出错，自动调度内存中的另一道作业运行。<br>多道批处理系统主要特征：多道性、无序性、调度性（进程调度和作业调度）。<br>多道批处理的主要优点：提高了资源利用率和吞吐能力。<br>多道批处理的主要缺点：平均周转时间长，没有交互能力。<br>多道批处理系统需要解决的 5 个问题</p><ol><li>处理机管理：分配和控制 CPU。</li><li>存储器管理：内存分配与回收</li><li>I&#x2F;O 设备管理：I&#x2F;O 设备的分配与操纵。</li><li>文件管理：文件的存取、共享和保护。</li><li>作业管理：如何组织作业运行。</li></ol></li></ul><blockquote><p>Multi-programming System vs Single-programing System<br>单道系统是指一次只能运行一个程序的系统。在单道系统中，每个作业（Job）按顺序执行，直到完成后才能开始下一个作业。<br>多道系统允许同时运行多个程序。在多道系统中，多个作业可以同时进入内存并并发执行。操作系统通过任务调度算法决定哪个作业获得处理器时间，以实现作业间的切换和共享资源。这样可以提高系统资源利用率和吞吐量。</p></blockquote><ul><li><p><strong>分时操作系统</strong>(time-sharing OS):时间共享操作系统是一种允许多个用户同时共享系统资源的操作系统。在这种操作系统中，CPU 时间被分割成微小的片段，并依次分配给每个用户，使得每个用户都感觉到他们独占了整个系统。这种操作系统的主要目标是最大化 CPU 的利用率和响应时间。</p><p><strong>特点</strong></p><ul><li>多路性：一个主机与多个终端相连；</li><li>独立性：彼此独立操作，互不干扰；</li><li>及时性：系统能在很短的时间得到回答；</li><li>交互性：能实现人机对话（区别于批处理系统）；</li></ul><p><strong>典型系统</strong></p><ul><li>Multics (MIT)</li><li>UNIX</li></ul></li><li><p><strong>实时操作系统</strong>(real time OS):是计算机及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致的运行</p><p><strong>特点</strong></p><ul><li>多路性：能对多个对象进行控制</li><li>独立性：独立运行，不混淆，不破坏</li><li>交互性：仅限于访问系统中某些特定的专用服务程序</li><li>可靠性：高可靠性，应具有多级容错防护能力</li><li>及时性：控制对象必须在截止时间内完成</li></ul><p><strong>分类</strong></p><ol><li>任务执行是否为周期性来划分<br>周期性实时任务<br>非周期性实时任务</li><li>按截止时间来划分<br>硬实时任务<br>软实时任务</li></ol></li></ul><h2 id="操作系统的基本特征"><a href="#操作系统的基本特征" class="headerlink" title="操作系统的基本特征"></a>操作系统的基本特征</h2><p>现代 OS 的四个基本特征：</p><ol><li>并发性（最重要的特征）</li><li>共享性</li><li>虚拟性</li><li>异步性</li></ol><p>并发是最重要的特征，其它特征都以并发为前提</p><h3 id="并发-Concurrency"><a href="#并发-Concurrency" class="headerlink" title="并发 Concurrency"></a>并发 Concurrency</h3><p>Key:</p><ul><li>区分<strong>并发 Concurrency</strong>&amp;<strong>并行 Parallelism</strong></li><li>区分<strong>进程 Process</strong>&amp;<strong>线程 Thread</strong>&amp;<strong>程序 Program</strong></li></ul><h3 id="共享-Sharing"><a href="#共享-Sharing" class="headerlink" title="共享 Sharing"></a>共享 Sharing</h3><p>共享：是指系统中的资源可供内存中多个<strong>并发执行的进程</strong>共同使用。</p><ul><li><strong>互斥共享</strong>（Exclusive Sharing）：在这种方式下，一次只能有一个进程使用资源。当一个进程正在使用资源时，其他进程必须等待。这种方式通常用于那些不能同时被多个进程共享的资源，例如打印机、磁带驱动器等。</li><li><strong>分时共享</strong>（Time-Sharing）：在这种方式下，资源在多个进程之间进行切换，每个进程在一段时间内独占资源。通过快速切换，可以使得用户感觉到他们似乎在同时使用资源。这种方式通常用于那些可以被多个进程共享的资源，例如 CPU、内存等。</li><li><strong>同时共享</strong>（Concurrent Sharing）：在这种方式下，多个进程可以同时访问资源，而无需等待。这种方式通常用于那些可以被多个进程同时读取的资源，例如文件、数据库等。</li><li><strong>虚拟共享</strong>（Virtual Sharing）：在这种方式下，每个进程都有一个资源的虚拟副本，使得每个进程都感觉到他们独占了资源。这种方式通常用于那些可以被复制的资源，例如虚拟内存、虚拟机等。</li></ul><h3 id="虚拟性-Virtualization"><a href="#虚拟性-Virtualization" class="headerlink" title="虚拟性 Virtualization"></a>虚拟性 Virtualization</h3><p><strong>虚拟</strong>：是指通过某种技术把一个物理实体变为（映射为）若干个逻辑上的对应物。<br><strong>时分复用技术</strong><br>虚拟处理机：分时实现<br>虚拟设备：SPOOLING 技术<br><strong>空分复用技术</strong><br>虚拟磁盘技术：逻辑分区<br>虚拟存储器：虚拟存储管理实现</p><h3 id="异步性-Asynchrony"><a href="#异步性-Asynchrony" class="headerlink" title="异步性 Asynchrony"></a>异步性 Asynchrony</h3><p><strong>异步</strong> 多道程序环境下程序（进程）以异步的方式执行，每道程序在何时执行、各自执行的顺序、完成时间都是不确定的，也是不可预知的。</p><h2 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h2><p>操作系统的主要任务是为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程度地提高系统中各种资源的利用率和方便用户的使用。</p><p>操作系统应具有五方面的功能：</p><ol><li>处理机管理（CPU）</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>方便用户使用的用户接口。</li></ol><h3 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h3><p>按照一定的算法把处理机分配给进程（线程），并对其进行有效的管理和控制</p><ol><li><strong>进程控制</strong><br>主要功能：为作业创建进程、撤消（终止）已结束的进程，以及控制进程在运行过程中的状态转换。</li><li><strong>进程同步和互斥</strong><br>主要任务是为多个进程(含线程)的运行进行协调。<br>进程互斥方式：这是指诸进程在对临界资源进行访问时，应采用互斥方式。<br>进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调。（信号量机制）</li><li><strong>进程通信</strong></li><li><strong>进程调度</strong></li></ol><h3 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h3><p>为多道程序的运行提供良好的环境，方便用户使用存储器，提高存储器的利用率以及能从逻辑上扩充内存。</p><ol><li><p><strong>内存分配</strong><br>内存分配的两种方式 ：</p><ul><li>静态分配方式：每个作业的内存空间是在作业装入时确定。运行时不可再申请新的内存空间，也不允许作业在内存中“移动”。</li><li>动态分配方式：每个作业的内存空间是在作业装入时确定。但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中“移动”。</li></ul><p>内存分配的主要任务是：</p><ul><li>为每道程序分配内存空间，使它们“各得其所”。</li><li>提高存储器的利用率，尽量减少不可用的内存空间（碎片）。</li><li>允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。</li></ul></li><li><p><strong>内存保护</strong><br>确保每道用户程序都只在自己的内存空间内运行，彼此互不干扰。<br>绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转移到非共享的其它用户程序中去执行。</p></li><li><p><strong>地址映射</strong><br>为保证程序能正确运行，存储器管理必须提供地址映射功能，即能够将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。该功能应在硬件的支持下完成</p></li><li><p><strong>内存扩充</strong><br>借助于虚拟存储技术，从逻辑上扩充内存容量</p></li></ol><h3 id="设备管理功能"><a href="#设备管理功能" class="headerlink" title="设备管理功能"></a>设备管理功能</h3><p>完成用户进程提出的 I&#x2F;O 请求；为用户进程分配其所需的 I&#x2F;O 设备；提高 CPU 和 I&#x2F;O 设备的利用率；提高 I&#x2F;O 速度；方便用户使用 I&#x2F;O 设备。</p><ol><li><strong>缓冲管理</strong>：有效地缓和 CPU 和 I&#x2F;O 设备速度不匹配的矛盾 ，提高 CPU 的利用率。</li><li><strong>设备分配</strong>：根据 I&#x2F;O 请求，分配其所需的设备。</li><li><strong>设备处理</strong>：设备处理程序又称为设备驱动程序。</li></ol><h3 id="文件管理功能"><a href="#文件管理功能" class="headerlink" title="文件管理功能"></a>文件管理功能</h3><p>主要任务：对用户文件和系统文件进行管理，以方便用户使用，并保证文件的安全性。</p><ol><li>文件存储空间的管理</li><li>目录管理</li><li>文件的读&#x2F;写管理和保护</li></ol><h3 id="操作系统与用户之间的接口"><a href="#操作系统与用户之间的接口" class="headerlink" title="操作系统与用户之间的接口"></a>操作系统与用户之间的接口</h3><p>用户接口,由 OS 实现的所有用户命令所构成的集合常被人们称为 OS 的 Interface(用户接口)；有时也称为命令接口。该接口又进一步分为联机用户接口、脱机用户接口和图形用户接口三种。<br>程序接口，由 OS 实现的所有系统调用所构成的集合被人们称为程序接口或应用编程接口(Application Programming Interface,API)。程序接口是为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的唯一途径。</p><h2 id="操作系统的结构设计"><a href="#操作系统的结构设计" class="headerlink" title="操作系统的结构设计"></a>操作系统的结构设计</h2><p>操作系统是一个大型系统软件，其结构已经历了四代的变革：</p><ul><li>第一代的 OS 是无结构的</li><li>第二代 OS 采用了模块式结构</li><li>第三代是层次式结构</li><li>现代 OS 结构是微内核结构</li></ul><h3 id="模块化结构（模块-接口法）"><a href="#模块化结构（模块-接口法）" class="headerlink" title="模块化结构（模块-接口法）"></a>模块化结构（模块-接口法）</h3><p>使用分块结构的系统包含若干 module；其中，每个模块实现一组基本概念以及与其相关的基本属性。</p><p><strong>块与块之间的相互关系</strong></p><ul><li>所有各块的实现均可以任意引用其它各块所提供的概念及属性。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA-2024-03-01-11-55-53.pnge" alt="module"></p><p><strong>优点</strong><br>提高了 OS 设计的正确性、可理解性和可维护性。<br>增强了 OS 的可适应性。<br>加速了 OS 的开发过程。</p><p><strong>缺点</strong><br>对模块的划分及对接口的规定要精确描述很困难。<br>从功能观点来划分模块时，未能将共享资源和独占资源加以区别。</p><h3 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h3><p>使用分层系统结构包含若干 layer（层）；其中，每一层实现一组基本概念以及与其相关的基本属性。</p><p><strong>层与层之间的相互关系</strong></p><ul><li>所有各层的实现不依赖其以上各层所提供的概念及其属性，只依赖其直接下层所提供的概念及属性；</li><li>每一层均对其上各层隐藏其下各层的存在。</li></ul><p><strong>层次的设置时应考虑的因素</strong></p><ul><li><strong>程序嵌套</strong> 通常 OS 的每个功能的实现，并非是只用一个程序便能完成的，而是要经由若干个软件层才有可能完成，因此实现 OS 时，应考虑每个功能可能形成的程序嵌套。</li><li><strong>运行频率</strong> 将那些经常活跃的模块放在最接近硬件的层</li><li><strong>公用模块</strong> 把供多种资源管理程序调用的公用模块，设置在最低层，以便调用。</li><li><strong>用户接口</strong> 命令接口、程序接口以及图形用户接口。这些接口应设置在 OS 的最高层，直接提供给用户使用。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA-2024-03-01-11-56-32.pnge" alt="DeltaCORE的体系结构：层次＋模块结构"></p><h3 id="微内核技术"><a href="#微内核技术" class="headerlink" title="微内核技术"></a>微内核技术</h3><p>所谓微内核技术，是指精心设计的、能实现现代 OS 核心功能的小型内核，它与一般的 OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。<br>当前比较流行的、能支持多处理机运行的 OS 几乎全部都采用了微内核结构，如 Mach OS，windows 2000</p><p>微内核所提供的功能，通常都是一些最基本的功能，如进程管理、低级存储器管理、中断和陷入处理、进程间通信、低级 I&#x2F;O 功能</p><p><strong>微内核特点</strong></p><ul><li>足够小的内核。</li><li>基于客户&#x2F;服务器模式</li><li>应用“机制与策略分离”原理</li><li>采用面向对象技术</li></ul>]]></content>
    
    
    <summary type="html">简述操作系统的定义,目标和作用,发展过程,基本特征,主要功能,结构设计</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="OS" scheme="https://efterklang.github.io/categories/UESTC/OS/"/>
    
    
    <category term="OS" scheme="https://efterklang.github.io/tags/OS/"/>
    
  </entry>
  
  <entry>
    <title>Structed vs Unstructed Data</title>
    <link href="https://efterklang.github.io/Tech/DataBase/StructedvsUnstructedData/"/>
    <id>https://efterklang.github.io/Tech/DataBase/StructedvsUnstructedData/</id>
    <published>2024-02-27T04:53:46.000Z</published>
    <updated>2024-03-06T02:35:12.713Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Structured-Data"><a href="#Structured-Data" class="headerlink" title="Structured Data"></a>Structured Data</h2><p><strong>结构化数据</strong>是高度组织和整齐格式化的数据。它是可以放入表格和电子表格中的数据类型。结构化数据也被称为定量数据(Quantitative Data)，在项目中，保存和管理这些的数据一般为关系数据库，当使用结构化查询语言(SQL)时，计算机程序很容易检索&amp;操作数据。<br>结构化数据可以通过多种方式从多种来源生成。它可以来自企业软件，如客户关系管理（CRM）系统，会计程序和其他应用程序中使用的关键业务运营。它可以从在线来源生成，包括社交媒体平台和网络调查。它也可以来自人工输入。<br>此外，可以使用依赖于人工智能（AI）和自然语言处理（NLP）的商业智能（BI）工具从非结构化数据中提取结构化数据。</p><h2 id="Unstructured-Data"><a href="#Unstructured-Data" class="headerlink" title="Unstructured Data"></a>Unstructured Data</h2><p><strong>非结构化数据</strong>是没有固有结构或组织的信息。非结构化数据通常被称为“对象”,常见的非结构化数据包括各种办公文档、图片、视频、音频、设计文档、日志文件、机器数据等。这类数据占全球生成的所有数据的 80%到 90%。</p><p><img src="/img/thumbnails/StructuredVsUnstructuredData.png"></p><h2 id="Semi-Structured-Data"><a href="#Semi-Structured-Data" class="headerlink" title="Semi-Structured Data"></a>Semi-Structured Data</h2><p>在某种程度上，大多数数据是非结构化和结构化数据的混合。半结构化数据是结构化数据的一个松散定义的子集。可以将其视为添加了标签、关键字和元数据以使其更有用的非结构化数据</p><p>Semi-structured data occupies the middle ground between structured and unstructured data as data that has some degree of organization but is not fully organized into a fixed record format found in a traditional system or database</p><p>For example, you could add some structure to a natively unstructured XML document using metadata to explain who created the document and when, and keywords to describe the content and make it possible to be found in searches. In the case of HTML documents, which would otherwise be unstructured, H1 tags are used to identify their titles while H2 identify subsections, making it more easily searchable.</p><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.datamation.com/big-data/structured-vs-unstructured-data/">Datamation</a></p>]]></content>
    
    
    <summary type="html">结构化数据与非结构化数据的区别</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="DataBase" scheme="https://efterklang.github.io/categories/Tech/DataBase/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>数据链路层 DataLink Layer Ⅰ</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch3-1DataLinkLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch3-1DataLinkLayer/</id>
    <published>2024-02-20T15:33:45.000Z</published>
    <updated>2024-04-02T09:10:34.813Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据链路层概述-Overview"><a href="#数据链路层概述-Overview" class="headerlink" title="数据链路层概述 Overview"></a>数据链路层概述 Overview</h2><p><strong>节点 Node</strong> 运行链路层协议的任何设备<br><strong>链路 Link</strong> 指从一个结点到相邻结点的一段物理线路，中间没有其他的交换结点<br><strong>数据链路 Data Link</strong> 把实现通信协议的硬件和软件加到链路上，就构成了数据链路<br><strong>帧 Frame</strong> 是数据链路层的传输单位，由数据部分和控制部分组成</p><p><strong>The Service Provide by the Link Layer</strong></p><ul><li><strong>Framing</strong> 封装成帧</li><li><strong>Link access</strong> 链路接入</li><li><strong>Reliable delivery</strong> 可靠交付</li><li><strong>Error detection and correction</strong> 差错检测和纠正</li></ul><blockquote><p>局域网属于数据链路层<br>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。<br>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，局域网仍属于数据链路层的范围</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-19-23-39-51.png" alt="DataLinkLayer"><br><strong>从层次上来看数据的流动</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-19-23-50-50.pnge" alt="数据流动"><br><strong>仅从数据链路层观察帧的流动</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-19-23-50-57.pnge" alt="DataLinkLayer-2024-02-19-23-50-57"></p><p>数据链路层使用的信道<br>数据链路层属于计算机网路的低层。数据链路层使用的信道主要有以下两种类型：</p><ul><li><strong>点对点信道 point to point link</strong></li><li><strong>广播信道 broadcast link</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-19-23-56-10.pnge" alt="DataLinkLayer-Channel"></li></ul><p>数据链路层的三个重要问题</p><ul><li><strong>封装成帧 Framing</strong> 在数据前后添加帧头和帧尾，用于标识帧的开始和结束</li><li><strong>差错检测 Error Detection</strong> 传输过程中可能会产生比特差错,通过帧尾中的检错码检测帧中是否有误码</li><li><strong>可靠传输 Reliable delivery</strong> 如果接收方收到有误码的帧，会丢弃这个帧。如果数据链路层向其上层提供的是不可靠服务，那么丢弃后不会再有更多措施;如果是可靠服务则需要其他措施，来确保接收方主机重新收到帧的正确副本</li></ul><p>对于<strong>广播信道</strong>的数据链路层,还有以下问题需解决</p><ul><li><strong>确认帧的接收 Link Access</strong> 主机如何确认帧是发送给自己的? 可以通过 MAC 地址来确认</li><li><strong>数据碰撞 Collide</strong> 如果两个主机同时发送数据，可能会发生数据碰撞</li></ul><blockquote><p>随着技术的发展，交换技术的成熟，在有线（局域网）领域使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的交换式局域网取代了共享式局域网;在无线局域网中仍然使用的是共享信道技术</p></blockquote><p><strong>Where Is the Link Layer Implemented?</strong><br>链路层的主体部分在<strong>网络适配器（network adapter）</strong>中实现，网络适配器有时也称为<strong>网络接口卡（Network Interface Card，NIC）</strong>，一个典型的主机体系结构如下图所示：</p><center><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayerPart1-2024-03-19-11-42-15.png"></p></center><h2 id="封装成帧-Framing"><a href="#封装成帧-Framing" class="headerlink" title="封装成帧 Framing"></a>封装成帧 Framing</h2><h3 id="封装与解包-Encapsulation-De-encapsulation"><a href="#封装与解包-Encapsulation-De-encapsulation" class="headerlink" title="封装与解包 Encapsulation&amp;De-encapsulation"></a>封装与解包 Encapsulation&amp;De-encapsulation</h3><p><strong>封装</strong>(Encapsulation)是低层协议从高层协议接收数据，然后将数据放入其帧的数据部分的过程。因此，封装是把一种数据包封装另一种数据包的过程。<br><strong>解包</strong>(Decapsulation)与之相反,高层协议从低层协议接收数据，然后逐层将数据从帧的数据部分取出的过程。</p><blockquote><p>Generally, Encapsulation is a process by which a lower-layer protocol receives data from a higher-layer protocol and then places the data into the data portion of its frame. Thus, encapsulation is the process of enclosing one type of packet using another type of packet.</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-20-16-22-10.pnge" alt="Packet Encapsulation&amp;De-encapsulation"></p><p><strong>封装成帧</strong>(Framing)指<strong>数据链路层</strong>接受上层交付的协议数据单元,并为其添加帧头和帧尾,使之成为帧的过程</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-20-16-49-51.pnge" alt="DataLinkLayer-2024-02-20-16-49-51"></p><p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，通过物理层将构成帧的 bits 转换成电信号交给传输媒体，接收方的数据链路层再从物理层交付的比特流中提取出 frames<br>解包过程如何提取 frames?</p><ul><li><strong>PPP 帧</strong> 依据帧头和帧尾的<strong>标志符</strong>确定帧的开始和结束(帧定界)从而提取出 frames</li><li><strong>以太网 V2 的 MAC 帧</strong> 根据前导码(1 字节的帧开始定界符,7 字节的前同步码)来定界,帧间间隔为 96bit 的时间<ul><li>前同步码:作用是使接收方的时钟与发送方的时钟同步</li><li>帧开始定界符:标志帧的开始</li><li>以太网规定帧间间隔为 96bit 的时间,因此 MAC 帧不需要帧结束定界符</li></ul></li></ul><h3 id="透明传输-Transparent-transmission"><a href="#透明传输-Transparent-transmission" class="headerlink" title="透明传输 Transparent transmission"></a>透明传输 Transparent transmission</h3><p><strong>透明传输</strong>是指不管所传数据是什么样的比特组合，都应当能够在链路上传送。因此，链路层就“看不见”有什么妨碍数据传输的东西。</p><p>当所传数据中的比特组合恰巧与某一个控制信息完全一样时，就必须采取适当的措施，使收方不会将这样的数据误认为是某种控制信息。这样才能保证数据链路层的传输是透明的。</p><p><strong>解决办法</strong></p><ol><li><strong>字符填充&#x2F;字节填充</strong></li></ol><ul><li>发送方扫描数据,当数据中出现与帧定界符相同的比特串时,在其前面插入转义字符 ESC;</li><li>接受方将遇到的第一个帧定界符认为是帧的开始</li><li>遇到转义字符时,则知道后面的比特串虽与帧定界符相同,但并非帧定界符而是数据,因此剔除转义字符 ESC 然后将其后的字符作为数据处理</li><li>当再次遇到帧定界符时,认为帧结束<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-20-22-26-20.pnge" alt="character stuffing"><br>ps:遇到与转移字符相同的比特串时,则在转义字符前面再插入转义字符</li></ul><ol><li><strong>比特填充</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-20-22-42-11.pnge" alt="DataLinkLayer-2024-02-20-22-42-11"></li></ol><p>为了提高帧的传输效率，应当使帧的数据部分的长度尽可能大些。<br>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元 MTU(Maximum Transfer Unit)</p><h2 id="差错检测-Error-Detection"><a href="#差错检测-Error-Detection" class="headerlink" title="差错检测 Error Detection"></a>差错检测 Error Detection</h2><h3 id="差错检测的基本概念"><a href="#差错检测的基本概念" class="headerlink" title="差错检测的基本概念"></a>差错检测的基本概念</h3><p>实际的通信链路都不是理想的，比特在传输过程中可能会产生差错：<code>1</code>可能会变成<code>0</code> ，而<code>0</code>也可能变成<code>1</code>,这称为<strong>比特差错</strong>。<br>在一段时间内，传输错误的比特占所传输比特总数的比率称为<strong>误码率</strong>BER(Bit Error Rate)<br>使用<strong>差错检测码</strong>来检测数据在传输过程中是否产生了比特差错，是数据链路层所要解决的重要问题之一<br><strong>帧校验序列 FCS</strong>(Frame Check Sequence)是差错检测码的一种，用于检测帧中是否有误码,通常使用<strong>循环冗余校验 CRC</strong>来计算 FCS</p><h3 id="奇偶校验-Parity-Check"><a href="#奇偶校验-Parity-Check" class="headerlink" title="奇偶校验 Parity Check"></a>奇偶校验 Parity Check</h3><p>奇偶校验在待发送的数据后面<strong>添加 1 位奇偶校验位</strong>，使整个数据（包括所添加的校验位在内）中<code>1</code>的个数为奇数（奇校验）或偶数（偶校验）。<br>如果有<strong>奇数个</strong>bit 发生误码，则奇偶性发生变化，可以检查出误码；<br>如果有<strong>偶数个</strong>bit 发生误码，则奇偶性不发生变化，不能检查出误码（漏检）<br>由于漏检率高，奇偶校验在实际中很少使用<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-25-17-32-09.pnge" alt="Parity Check"></p><h3 id="二维奇偶校验-Two-Dimensional-Parity-Check"><a href="#二维奇偶校验-Two-Dimensional-Parity-Check" class="headerlink" title="二维奇偶校验 Two-Dimensional Parity Check"></a>二维奇偶校验 Two-Dimensional Parity Check</h3><p>假设传输信息 D 有 d 位，在偶校验方案中，会增加一个附加的比特，使得这 d+1 个比特中 1 的总数是偶数。由于普通的奇偶校验方式检错能力有限，所以产生了二维的奇偶校验。D 中的 d 个比特被划分为 i 行 j 列，对每行每列计算奇偶值，产生的 i+j+1 个奇偶比特构成了链路层帧的差错检测比特。</p><h3 id="校验和-Checksumming-Method"><a href="#校验和-Checksumming-Method" class="headerlink" title="校验和 Checksumming Method"></a>校验和 Checksumming Method</h3><p><strong>因特网检验和（Internet checksum）</strong>基于这种方法，即数据的字节作为 16 比特的整数对待并求和。</p><h3 id="循环冗余校验-Cyclical-Redundancy-Check"><a href="#循环冗余校验-Cyclical-Redundancy-Check" class="headerlink" title="循环冗余校验 Cyclical Redundancy Check"></a>循环冗余校验 Cyclical Redundancy Check</h3><p>收发双方约定好一个生成多顶式<code>G(x)</code>;<br>发送方基于待发送的数据和生成多顶式计算出<strong>差错检测码</strong>(冗余码)，将其添加到待传输数据的后面一起传输<br>接收方通过生成多项式来计算收到的数据是否产生了误码；</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-25-17-35-47.pnge" alt="CRC"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-25-17-36-46.pnge" alt="CRC Polynomial"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-25-17-42-02.pnge" alt="CRC Example"><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-25-17-43-07.pnge" alt="CRC Example"></p><p>检错码只能检测出帧在传输过程中出现了差错，但井不能定位错误，因此<strong>无法纠正错误</strong><br>要想纠正传输中的差错，可以使用冗余信息更多的<strong>纠错码</strong>进行前向纠错,但纠错码的开销比较大，在计算机网络中较少使用。<br>循环冗余校验有很好的检错能力,漏检率非常低，虽然计算比较复杂，但非常易于用硬件实现，因此被广泛应用于数据链路层。<br>在计算机网络中通常采用<strong>检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧</strong>，这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。</p><h2 id="可靠传输-Reliable-Transmission"><a href="#可靠传输-Reliable-Transmission" class="headerlink" title="可靠传输 Reliable Transmission"></a>可靠传输 Reliable Transmission</h2><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><strong>可能发送的差错</strong></p><ul><li><strong>比特错误</strong> 使用差错检测技术（例如循环冗余校验 CRC，接收方的数据链路层就可检测出帧在传输过程中是否产生了误码（比特错误）。一般情况下，有线链路的误码率比较低，为了减小开销，井不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</li><li><strong>分组丢失</strong> 路由器输入队列快满了，主动丢弃收到的分组</li><li><strong>分组时序</strong> 数据并未按照发送顺序依次到达接收端</li><li><strong>分组重复</strong> 由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的超时重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成分组重复的传输差错</li></ul><p><strong>三种可靠传输方式</strong></p><ul><li><strong>停止等待协议 SW</strong></li><li><strong>回退 N 帧协议 GBN</strong></li><li><strong>选择重传协议 SR</strong></li></ul><p><strong>Ref</strong><br><a href="https://www.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/">https://www.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/</a><br><a href="https://zhuanlan.zhihu.com/p/126312611">https://zhuanlan.zhihu.com/p/126312611</a></p><h3 id="停止等待协议-Stop-and-Wait-Protocol"><a href="#停止等待协议-Stop-and-Wait-Protocol" class="headerlink" title="停止等待协议 Stop-and-Wait Protocol"></a>停止等待协议 Stop-and-Wait Protocol</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-27-17-07-37.pnge" alt="SW Protocol"></p><p><strong>确认与否认</strong></p><p>首先，每次发送方都只发一个数据分组，接收方对数据分组进行差错检测，检验是否有误码;</p><p>如果没有误码，接收方发送<code>ACK</code>确认分组,发送方收到<code>ACK</code>确认分组后，发送方才能发送下一个数据分组。</p><p>如果有误码,接收方发送<code>NAK</code>否认分组并丢弃当前分组,发送方收到<code>NAK</code>否认分组后，重发数据分组。</p><p><strong>超时重传</strong></p><p>接收方收不到数据分组，就不会发送<code>ACK</code>或<code>NAK</code>。如果不采取其他措施，发送方就会一直处于等待接收方<code>ACK</code>或<code>NAK</code>的状态。数据分组在传输过程中有可能遇到已经满了的路由器等情况，此时路由器会丢失该分组，如此便会产生数据分组被丢失，发送方等不到接收方的<code>ACK</code>或者<code>NAK</code>,导致发送方陷入等待状态。</p><p>为解决该问题，可以在发送方发送完一个数据分组时，启动一个超时计时器。若到了超时计时器所设置的重传时间而发送方仍收不到接收方的任何<code>ACK</code>或<code>NAK</code>，则重传原来的数据分组，这就叫做<strong>超时重传</strong>。</p><p>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为<strong>略大于从发送方到接收方的平均往返时间</strong>;在数据链路层点对点的往返时间比较确定，重传时间比较容易设定。然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</p><p><strong>确认丢失</strong></p><p>实际过程中,接收方发送的<code>ACK</code>或<code>NAK</code>也可能会丢失,发送方收不到接收方的<code>ACK</code>或<code>NAK</code>，触发超时计时器,会重传数据分组。如果接收方成功接收了数据分组，但发送<code>ACK</code>的分组丢失了，发送方会重传数据分组，这样会导致接收方收到重复的数据分组。</p><p>为解决该问题,我们用一个比特位给每个数据分组一个序号（0 或 1），当重新传输数据分组的时候，接收方检测到这个数据分组的序号,如果刚才的数据分组的序号相同就丢弃该数据分组，否则接收该数据分组。然后发送<code>ACK</code>确认分组。</p><p>这里为什么可以只用<code>0</code>和<code>1</code>呢，主要还是因为停止等待协议的特性，即每发送完一个数据分组便等待发送方的<code>ACK</code>或<code>NAK</code>，只要保证每发送一个新的数据分组，其发送序号与上次发送的数居分组的序号不同就可以了，因比用一个比特来编号就够了。</p><p><strong>确认迟到</strong></p><p>为了让发送方能够判断所收到的<code>ACK</code>分组是否是重复的，需要给<code>ACK</code>分组编号，所用比特数量与数据分组编号所用比特数量一样。数据链路层一般不会出现<code>ACK</code>分组迟到的情况，因此在数据链路层实现停止．等待协议可以不用给<code>ACK</code>分组编号。</p><p><strong>信道利用率</strong></p><p>[<a href="Ch1-NetworkOverview.md" title="Computer Networks Overview">Ch1-NetworkOverview#利用率 Utilization</a>]</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-27-17-22-30.pnge" alt="DataLinkLayer-2024-02-27-17-22-30"></p><h3 id="回退-N-帧协议-Go-Back-N-Protocol"><a href="#回退-N-帧协议-Go-Back-N-Protocol" class="headerlink" title="回退 N 帧协议 Go-Back-N Protocol"></a>回退 N 帧协议 Go-Back-N Protocol</h3><p>在停止-等待协议中，随着 RTT 的变大，信道的利用率也会变低（卫星通信），解决该问题的方法是：不以停等方式运行，允许发送方发送多个分组而无须等待确认。因为许多从发送方向接收方输送可以看成是填充到一条流水线中，故这种技术被称为<strong>流水线（pipeline）</strong>，下图为停等和流水线发送示意图：</p><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-27-17-45-07.pnge" alt="pipeline" style="zoom:80%;" /></center><p>在回退 N 步协议中，将基序号（base）定义为最早未确认分组的序号，将下一个序号（nextseqnum）定义为最小的未使用序号，则将序号范围分割成如下 4 段：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-27-17-53-56.pnge"><br><strong>Notes</strong></p><ul><li>如果某个报文段没有被正确接收，则从这个报文段到后面的报文段都要重新发送。</li><li>采用累计应答的方式。例如接收端返回 ACK&#x3D;3，则证明报文段 3 以及之前的报文段都被正确接收。(GBN 如何保证 3 之前的数据被正确接收了呢？在 GBN 的接收窗口$W_{R}&#x3D;1$,即按顺序逐个接受数据,因此接收方只能<strong>按序接受</strong>正确到达的数据分组)</li><li>接收端不对失序到达的分组进行缓存。</li><li>回退帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数员，是一种连续 ARQ 协议，</li><li>在协议的工作过程中发送窗囗和接收窗囗不断向前滑动，因此这类协议又称为滑动圊囗协议。</li><li>缺点:如果发生错误，GBN 协议会<strong>丢弃后续的所有包</strong>，即使它们已经到达并且没有错误。这可能导致效率低下，特别是在通信线路质量不好的情况下</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-02-27-17-43-56.pnge"></p><h3 id="选择重传协议-Selective-Repeat-Protocol"><a href="#选择重传协议-Selective-Repeat-Protocol" class="headerlink" title="选择重传协议 Selective Repeat Protocol"></a>选择重传协议 Selective Repeat Protocol</h3><p>GBN 协议的接收窗口尺寸 WR 只能等于 1 ，因此接收方只能按序接收正确到达的数据分组。一个数据分组的误码会导致其后续多个数据分组不能被接收方按序接收而丢弃（尽管它们无乱序和误码）。这必然会造成发送方对这些数据分组的超时重传，显然这是对通信资源的极大浪费。为了进一步提高性能，可设法只重传出现误码的数据分组。因此，接收窗口的尺寸不应再等于 1 （而应大于 1 ）以便接收方先收下失序到达但无误码井且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一井送交上层。这是选择重传协议。</p><div>$$发送窗口尺寸W_{T}必须满足: 1 < W_{T} \lt 2^{n-1}; n为分组中的bit数 \\若W_{T} = 1,则退化为停止等待协议;若W_{T} \gt 2^{n-1},则会造成接收方无法辨别新旧数据分组的问题\\接收窗口尺寸W_{R}必须满足: 1 < W_{R} \leq W_{T}\\若W_{R} = 1,则退化为回退 N 帧协议;W_{R} \gt W_{T}没有意义$$</div><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataLinkLayer-2024-03-12-14-22-54.png"></p><h2 id="点对点协议-Point-to-Point-Protocol"><a href="#点对点协议-Point-to-Point-Protocol" class="headerlink" title="点对点协议 Point to Point Protocol"></a>点对点协议 Point to Point Protocol</h2><p>点对点协议 PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</p><p>PPP 协议是因特网工程任务组 IEIF 在 1992 年制定的。经过 1993 年和 1994 年的修订，现在的 PPP 协议已成为因特网的正式标准[RFC1661，RFC1662]</p><p>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</p>]]></content>
    
    
    <summary type="html">介绍数据链路层相关的部分知识点:Overview,Framing,Error Detection,Reliable Transmission</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>Java Stream</title>
    <link href="https://efterklang.github.io/Tech/Java/Java%20Stream/"/>
    <id>https://efterklang.github.io/Tech/Java/Java%20Stream/</id>
    <published>2024-02-19T13:59:41.000Z</published>
    <updated>2024-03-13T01:45:05.867Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>Java 8 引入用于操作<strong>集合</strong>(Collection)的 Stream API,它将元素集合抽象为<strong>流</strong>(stream),元素如同水流一样在管道(pipeline)中传输,我们可以方便地对流进行各种<strong>操作</strong>(Operation),最终得到我们想要的结果,我们将这种操作的方式称为<strong>流式处理</strong>(stream processing)</p><h3 id="操作分类"><a href="#操作分类" class="headerlink" title="操作分类:"></a><strong>操作分类:</strong></h3><ul><li>Intermediate operations: 返回一个新的 Stream,可进行链式操作</li><li>Terminal operations: 返回一个 result 或 side-effect,只能放在最后</li></ul><p>如下是一个使用 Stream 对 Collection 进行操作的代码示例,其中<code>filter</code>为<strong>中间操作</strong>,<code>forEach</code>为<strong>终止操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    List&lt;String&gt; nameList = Arrays.asList(<span class="string">&quot;Valerie&quot;</span>, <span class="string">&quot;Jack&quot;</span>, <span class="string">&quot;John&quot;</span>, <span class="string">&quot;Jerry&quot;</span>, <span class="string">&quot;Jesus&quot;</span>);</span><br><span class="line">    nameList.stream()</span><br><span class="line">            .filter(name -&gt; name.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">            .filter(name -&gt; name.length() == <span class="number">4</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line">[OUTPUT]</span><br><span class="line">Jack</span><br><span class="line">John</span><br></pre></td></tr></table></figure><h3 id="Stream-特点"><a href="#Stream-特点" class="headerlink" title="Stream 特点:"></a><strong>Stream 特点:</strong></h3><ul><li><strong>Lazy Evaluation</strong>: 中间操作<strong>不会立即执行</strong>,只有在遇到终止操作时流才开始真正的遍历,即一次遍历中执行多个操作(映射,过滤等),这种特性称为<strong>惰性求值</strong>(lazy evaluation),这种特性使得 Stream API 可以进行更高效的操作</li><li><strong>Internal Iteration</strong>: 传统的集合操作是<strong>外部迭代</strong>(external iteration),即用户需要手动迭代集合中的每一个元素,而 Stream API 是<strong>内部迭代</strong>(internal iteration),用户只需要告诉 Stream API 需要对集合进行什么操作,而不需要关心具体的迭代过程</li><li><strong>Immutability</strong>: Stream 不会改变原有的数据结构,它只是对原有的数据进行操作,并返回一个新的 Stream</li><li><strong>Parallel Processing</strong> : JDK 源码注解中提到 <em>Stream pipelines may execute either sequentially or in parallel</em>, 即 Stream 既可被顺序处理,也可并行处理,从而充分利用多核处理器的优势</li></ul><center><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/JavaStream-2024-02-18-23-25-32.png" alt="Stream" style="zoom:50%;" /></center><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><table><thead><tr><th>Method</th><th>方法作用</th><th>Operation 类别</th></tr></thead><tbody><tr><td><code>count</code></td><td>计数</td><td>terminal</td></tr><tr><td><code>forEach</code></td><td>迭代处理</td><td>terminal</td></tr><tr><td><code>reduce</code></td><td>归约</td><td>terminal</td></tr><tr><td><code>collect</code></td><td>收集</td><td>terminal</td></tr><tr><td><code>findAny</code></td><td>查找</td><td>terminal</td></tr><tr><td><code>anyMatch</code></td><td>匹配</td><td>terminal</td></tr><tr><td><code>filter</code></td><td>过滤</td><td>intermediate</td></tr><tr><td><code>sorted</code></td><td>排序</td><td>intermediate</td></tr><tr><td><code>distinct</code></td><td>去重</td><td>intermediate</td></tr><tr><td><code>limit</code></td><td>取用前几个</td><td>intermediate</td></tr><tr><td><code>skip</code></td><td>跳过前几个</td><td>intermediate</td></tr><tr><td><code>map</code></td><td>映射</td><td>intermediate</td></tr><tr><td><code>concat</code></td><td>拼接</td><td>intermediate</td></tr></tbody></table><blockquote><p>To perform a computation, stream operations are composed into a stream pipeline. A stream pipeline consists of a <strong>source</strong> (which might be an array, a collection, a generator function, an I&#x2F;O channel, etc), zero or more <strong>intermediate operations</strong> (which transform a stream into another stream, such as filter(Predicate)), and a <strong>terminal operation</strong> (which produces a result or side-effect, such as count() or forEach(Consumer)). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.</p></blockquote><h2 id="创建-Stream"><a href="#创建-Stream" class="headerlink" title="创建 Stream"></a>创建 Stream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Collection 的 stream()和 parallelStream()方法</span></span><br><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream1 = list.stream();</span><br><span class="line">Stream&lt;Integer&gt; stream2 = list.parallelStream();</span><br><span class="line"><span class="comment">// 使用 Arrays 的 stream() 方法</span></span><br><span class="line">Stream&lt;Integer&gt; stream3 = Arrays.stream(<span class="keyword">new</span> <span class="title class_">Integer</span>[] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);</span><br><span class="line"><span class="comment">// 使用 Stream 类的静态方法 of()、iterate()、generate()</span></span><br><span class="line">Stream&lt;Integer&gt; stream4 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// of() 内部调用的是 Arrays.stream() method</span></span><br><span class="line">Stream&lt;Double&gt; stream5 = Stream.iterate(<span class="number">10.0</span>,num -&gt; num &gt; <span class="number">0.5</span>, num -&gt; num / <span class="number">2</span>);</span><br><span class="line">stream5.forEach(System.out::println);<span class="comment">// 10.0 5.0 2.5 1.25 0.625 0.3125</span></span><br><span class="line">Stream&lt;Double&gt; stream6 = Stream.generate(Math::random).limit(<span class="number">5</span>);</span><br><span class="line">stream6.forEach(System.out::println);<span class="comment">// 5 个随机小数</span></span><br></pre></td></tr></table></figure><h2 id="Methods-分析"><a href="#Methods-分析" class="headerlink" title="Methods 分析"></a>Methods 分析</h2><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code><br>Returns a stream consisting of the elements of this stream that match the given predicate.</p><p>filter 方法接受一个 Predicate <strong>函数式接口实例</strong>[<a href="functionalInterface" title="Functional Interface">functionalInterface.md</a>],用于过滤流中的元素,返回一个新的 stream,其中包含符合条件的元素</p><p>Predicate 是一个 Java 8 新增的函数式接口,它接受一个参数并返回一个布尔值,我们通常使用 Lambda 表达式来创建 Predicate 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Commonly used methods in Predicate</span></span><br><span class="line">stream.filter(element -&gt; element.length() &gt; <span class="number">5</span>)</span><br><span class="line">stream.filter(element -&gt; element.startsWith(<span class="string">&quot;J&quot;</span>))</span><br><span class="line">stream.filter(element -&gt; element.endsWith(<span class="string">&quot;y&quot;</span>))</span><br><span class="line">stream.filter(element -&gt; element.equals(<span class="string">&quot;Jerry&quot;</span>))</span><br><span class="line">stream.filter(element -&gt; element.contains(<span class="string">&quot;e&quot;</span>))</span><br><span class="line">stream.filter(element -&gt; element.matches(<span class="string">&quot;.*[aeiou].*&quot;</span>))</span><br></pre></td></tr></table></figure><h3 id="forEach-find-match"><a href="#forEach-find-match" class="headerlink" title="forEach,find,match"></a>forEach,find,match</h3><p>Stream 支持类似于 Collection 的遍历以及查询的操作,需要注意的是,Stream 中的元素是以<code>Optional</code>类型存在的<br><strong>Traverse</strong></p><ul><li><code>void forEach(Consumer&lt;? super T&gt; action)</code><br>forEach 接受一个 Consumer <strong>函数式接口</strong>,用于遍历流中的每一个元素,并对其进行操作<br>Consumer 是一个 Java 8 新增的函数式接口,它接受一个参数,无返回值,例如<code>System.out::println;</code></li></ul><hr><p><strong>Find</strong></p><ul><li><code>Optional&lt;T&gt; findFirst()</code><br>Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.</li><li><code>Optional&lt;T&gt; findAny()</code><br>Returns an Optional describing the first element of this stream, or an empty Optional if the stream is empty. If the stream has no encounter order, then any element may be returned.</li></ul><hr><p><strong>Match</strong></p><ul><li><code>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</code><br>只要有一个元素匹配传入的条件，就返回 true</li><li><code>boolean allMatch(Predicate&lt;? super T&gt; predicate)</code><br>所有元素都匹配传入的条件，才返回 true</li><li><code>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</code><br>所有元素都不匹配传入的条件，才返回 true</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//forEach</span></span><br><span class="line">list.stream().forEach(System.out::println);</span><br><span class="line"><span class="comment">// Find</span></span><br><span class="line">Optional&lt;String&gt; first = list.stream().findFirst();</span><br><span class="line">Optional&lt;String&gt; any = list.stream().findAny();</span><br><span class="line"><span class="comment">// Match</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isExist</span> <span class="operator">=</span> list.stream().anyMatch(element -&gt; element.length() &gt; <span class="number">5</span>);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isAllMatch</span> <span class="operator">=</span> list.stream().allMatch(element -&gt; element.startsWith(<span class="string">&quot;J&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="map-flatMap"><a href="#map-flatMap" class="headerlink" title="map,flatMap"></a>map,flatMap</h3><p>map 意为映射,可将一个 Stream 中的元素映射成另一个 Stream,如下代码将一个 String 类型的 Stream 映射成一个 Integer 类型的 Stream</p><ul><li><p><code>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</code><br>Returns a stream consisting of the results of applying the given function to the elements of this stream.</p></li><li><p><code>&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T,? extends Stream&lt;? extends R&gt;&gt; mapper)</code><br>Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element. Each mapped stream is closed after its contents have been placed into this stream. (If a mapped stream is null an empty stream is used, instead.)</p></li><li><p><code>map</code>方法接受一个<strong>函数式接口实例</strong>mapper,根据 mapper 将流中的<strong>元素映射成新的元素</strong>,返回一个新的<strong>stream</strong>,其中包含映射后的元素</p></li><li><p><code>flatMap</code>方法接受一个<strong>函数式接口实例</strong>mapper ,用于将流中的<strong>元素映射成流</strong>,并将映射后的流扁平化,即将多个流连接成一个流,返回<strong>拼接后的 stream</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;String&gt; nameList = Arrays.asList(<span class="string">&quot;Valerie&quot;</span>, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        nameList.stream()</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .map(name -&gt; <span class="string">&quot;Hello, &quot;</span> + name)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        nameList.stream()</span><br><span class="line">            .map(String::toUpperCase)</span><br><span class="line">            .flatMap((String name) -&gt; Arrays.stream(name.split(<span class="string">&quot;&quot;</span>)))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[OUTPUT]</span><br><span class="line">Hello, VALERIE</span><br><span class="line">Hello, JACK</span><br><span class="line">Hello, JOHN</span><br><span class="line">Hello, TOM</span><br><span class="line">Hello, JERRY</span><br><span class="line">Hello, JESUS</span><br><span class="line"><span class="comment">// flatMap</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 给定两个数字列表 获取所有的数对</span></span><br><span class="line">        List&lt;Integer&gt; numbers1 = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">        List&lt;Integer&gt; numbers2 = Arrays.asList(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// numbers2.stream().map(y -&gt; new int[] &#123; x, y &#125;)返回Stream&lt;int[]&gt;,flatMap将每个x对应的Stream&lt;int[]&gt;连接</span></span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; pairs = numbers1.stream().flatMap(x -&gt; numbers2.stream().map(y -&gt; <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; x, y &#125;))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] pair : pairs) &#123;</span><br><span class="line">            System.out.print(Arrays.toString(pair));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">[OUTPUT]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>][<span class="number">1</span>, <span class="number">4</span>][<span class="number">2</span>, <span class="number">3</span>][<span class="number">2</span>, <span class="number">4</span>][<span class="number">3</span>, <span class="number">3</span>][<span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>reduce</code> 意为归约,顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。</p><ul><li><p><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code><br>无初始值，返回一个 Optional,参数为一个 BinaryOperator <strong>函数式接口实例</strong>,用于将流中的元素两两结合<br>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any.<br><strong>Parameters:</strong></p><ul><li>accumulator - an associative, non-interfering, stateless function for combining two values</li></ul><p><strong>Returns:</strong><br>an Optional describing the result of the reduction</p></li><li><p><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code><br>有初始值，返回类型与初始值的类型一致,参数为初始值和一个 BinaryOperator <strong>函数式接口实例</strong></p></li><li><p><code>&lt;U&gt; U reduce(U identity, BiFunction&lt;U,? super T,U&gt; accumulator, BinaryOperator&lt;U&gt; combiner)</code></p><p><strong>Parameters</strong>:</p><ul><li><code>identity</code> the identity value for the combiner function</li><li><code>accumulator</code> an associative, non-interfering, stateless function for incorporating an additional element into a result</li><li><code>combiner</code> an associative, non-interfering, stateless function for combining two values, which must be compatible with the accumulator function</li></ul><p><strong>Returns</strong>:<br>the result of the reduction</p></li></ul><hr><blockquote><p>Associative（可结合的）：这意味着累积器函数在处理多个值时，其操作的顺序不影响最终结果。即无论值是如何组合的，累积器函数总是产生相同的结果。例如，加法和乘法都是可结合的操作。<br>Non-interfering（不干扰的）：累积器函数在处理值时不会改变这些值的状态。它只是简单地将值组合起来，而不影响原始值。<br>Stateless（无状态的）：累积器函数不依赖于或修改任何外部状态。它只根据传入的参数来计算结果，不涉及任何外部的、可变的或全局的状态。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求所有员工的工资之和、最高工资</span></span><br><span class="line"><span class="comment">// 求工资之和方法1：Stream&lt;Person&gt; -&gt; Stream&lt;Integer&gt; -&gt; Optional&lt;Integer&gt;</span></span><br><span class="line">Optional&lt;Integer&gt; sumSalary =</span><br><span class="line">                personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line"><span class="comment">// 求工资之和方法2：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">sumSalary2</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getSalary(),</span><br><span class="line">                Integer::sum);</span><br><span class="line"><span class="comment">// 求最高工资方法1：Stream&lt;Person&gt; -&gt; Stream&lt;Integer&gt; -&gt; Integer</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">maxSalary1</span> <span class="operator">=</span></span><br><span class="line">                personList.stream().map(Person::getSalary).reduce(Integer::max).get();</span><br><span class="line"><span class="comment">// 求最高工资方法2：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">maxSalary2</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>,</span><br><span class="line">                (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class="line">                (max1, max2) -&gt; max1 &gt; max2 ? max1 : max2);</span><br><span class="line"><span class="comment">// 求最高工资方法3：</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">maxSalary3</span> <span class="operator">=</span> personList.stream().reduce(<span class="number">0</span>,</span><br><span class="line">                                (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class="line">                                Integer::max);</span><br></pre></td></tr></table></figure><h3 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h3><p><code>stream()</code>方法可以将集合,数组转换为 Stream,而<code>collect()</code>方法则可以将 Stream 转换为集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] strArr = list.stream().toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">List&lt;Integer&gt; strLengthList = list.stream().map(String::length).collect(Collectors.toList());</span><br><span class="line">List&lt;String&gt; strList = list.stream().collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure><h3 id="count-max-min"><a href="#count-max-min" class="headerlink" title="count,max,min"></a>count,max,min</h3><p>如下方法均为 terminal operation</p><ul><li><code>long count()</code><br>Returns the count of elements in this stream.</li><li><code>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</code><br>Returns the maximum element of this stream according to the provided Comparator.</li><li><code>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)</code><br>Returns the minimum element of this stream according to the provided Comparator.</li></ul><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a href="https://www.geeksforgeeks.org/stream-iteratetpredicateunaryoperator-method-in-java-with-examples/">Stream iterate</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">oracle docs</a><br><a href="https://cloud.tencent.com/developer/article/2140067">Java8 新特性之 Stream 流（含具体案例）</a><br><a href="https://zhuanlan.zhihu.com/p/87274197">由浅入深体验 Stream 流（附带教程）</a><br><a href="https://juejin.cn/post/7216209996526452797">Java 8 Stream 和 Optional: 实践指南</a><br><a href="https://dev.java/learn/api/streams/reducing/">Reducing a Stream</a></p>]]></content>
    
    
    <summary type="html">介绍 Java 8 引入的 Stream API</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="Java" scheme="https://efterklang.github.io/categories/Tech/Java/"/>
    
    
    <category term="Java" scheme="https://efterklang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>物理层 Physical Layer</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch2-PhysicalLayer/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch2-PhysicalLayer/</id>
    <published>2024-02-17T13:48:22.000Z</published>
    <updated>2024-04-02T09:09:10.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="物理层的基本概念-Overview"><a href="#物理层的基本概念-Overview" class="headerlink" title="物理层的基本概念 Overview"></a>物理层的基本概念 Overview</h2><ul><li><strong>物理层的任务</strong><br>屏蔽掉不同传输媒体和通信手段间的差异，使数据链路层感受不到这种差异</li><li><strong>五种信道复用方式</strong><br>时分复用、频分复用、统计时分复用、码分复用、波分复用</li><li><strong>三种宽带接入方式</strong><br>非对称数字用户线（ADSL 技术，基于电话用户线改造）、光纤同轴混合网（HFC 网）、FTTx 技术</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-13-36-05.png" alt="PhysicalLayer"></p><h2 id="物理层下面的传输媒体-Transmission-Media"><a href="#物理层下面的传输媒体-Transmission-Media" class="headerlink" title="物理层下面的传输媒体 Transmission Media"></a>物理层下面的传输媒体 Transmission Media</h2><p>传输媒体也称为传输介质或传输媒介，它就是数据传输系统中在发送器和接收器之间的物理通路。<br>传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。在导引型传输媒体中，电磁波被导引沿着固体媒体（铜线或光纤）传播，而非导引型传输媒体就是指自由空间，在非导引型传输媒体中电磁波的传输常称为无线传输</p><p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，只能将其放置到物理层之下。</p><h3 id="导引型传输媒体-Guided-Transmission-Media"><a href="#导引型传输媒体-Guided-Transmission-Media" class="headerlink" title="导引型传输媒体 Guided Transmission Media"></a>导引型传输媒体 Guided Transmission Media</h3><h4 id="Coaxial-Cable"><a href="#Coaxial-Cable" class="headerlink" title="Coaxial Cable"></a>Coaxial Cable</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-13-40-08.png" alt="PhysicalLayer-Coaxial cable"></p><h4 id="Twisted-Pair"><a href="#Twisted-Pair" class="headerlink" title="Twisted Pair"></a>Twisted Pair</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-13-40-47.png" alt="PhysicalLayer-Twisted pair"></p><h4 id="Optical-Fiber"><a href="#Optical-Fiber" class="headerlink" title="Optical Fiber"></a>Optical Fiber</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-13-49-54.png" alt="PhysicalLayer-Optical fiber1"><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-13-51-21.png" alt="PhysicalLayer-Optical fiber2"></p><h4 id="Power-Line"><a href="#Power-Line" class="headerlink" title="Power Line"></a>Power Line</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-13-42-42.png" alt="PhysicalLayer-Power line"></p><h3 id="非导引型传输媒体-Unguided-Transmission-Media"><a href="#非导引型传输媒体-Unguided-Transmission-Media" class="headerlink" title="非导引型传输媒体 Unguided Transmission Media"></a>非导引型传输媒体 Unguided Transmission Media</h3><blockquote><p>若通信线路要通过一些高山或岛屿，有时就很难施工。即使是在城市中，挖开马路敷设电缆也不是一件很容易的事。当通信距离很远时，敷设电缆既昂贵又费时。但利用无线电波在自由空间的传播就可较快地实现多种通信。由于这种通信方式不使用上一节所介绍的各种导引型传输媒体，因此就将自由空间称为“非导引型传输媒体”。<br>特别要指出的是，由于信息技术的发展，社会各方面的节奏变快了。人们不仅要求能够在运动中进行电话通信（即移动电话通信），而且还要求能够在运动中进行计算机数据通信（俗称上网）。因此在最近十几年无线电通信发展得特别快，因为<strong>利用无线信道进行信息的传输，是在运动中通信的唯一手段</strong><br>短波通信质量较差，速率较低。无限电微波通信可传输电话、图像、数据等信息。紫外线及更高波段目前还不能用于通信。卫星通信的优点是通信距离远，缺点是传播时延高，保密性差。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-14-05-46.png" alt="Unguided Transmission Media"><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-14-06-57.png" alt="Unguided Transmission Media"></p><h4 id="Radio-wave"><a href="#Radio-wave" class="headerlink" title="Radio wave"></a>Radio wave</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-14-11-14.png" alt="PhysicalLayer-Radio wave"></p><h4 id="Microwave"><a href="#Microwave" class="headerlink" title="Microwave"></a>Microwave</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-14-11-21.png" alt="PhysicalLayer-Microwave"></p><h4 id="Infrared"><a href="#Infrared" class="headerlink" title="Infrared"></a>Infrared</h4><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-14-11-43.png" alt="PhysicalLayer-Infrared"></p><h4 id="Visible-light"><a href="#Visible-light" class="headerlink" title="Visible light"></a>Visible light</h4><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">百度百科-LIFI</a></p><h2 id="传输方式-Transmission-Mode"><a href="#传输方式-Transmission-Mode" class="headerlink" title="传输方式 Transmission Mode"></a>传输方式 Transmission Mode</h2><ul><li>串行传输和并行传输</li><li>同步传输和异步传输</li><li>单工通信(单向通信)、半双工通信(双向交替通信)和全双工通信(双向同时通信)</li></ul><h3 id="串行和并行传输-Serial-and-Parallel-Transmission"><a href="#串行和并行传输-Serial-and-Parallel-Transmission" class="headerlink" title="串行和并行传输 Serial and Parallel Transmission"></a>串行和并行传输 Serial and Parallel Transmission</h3><p><strong>串行传输</strong><br>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可<br><strong>并行传输</strong><br>一次发送 n 个比特，因此，在发送端和接收端之间需要有 n 条传输线路<br>并行传输的优点是比串行传输的速度 n 倍，但成本高<br>数据在传输线路上的传输采用是串行传输，计算机内部的数据传输常用并行传输</p><h3 id="同步和异步传输-Synchronous-and-Asynchronous-Transmission"><a href="#同步和异步传输-Synchronous-and-Asynchronous-Transmission" class="headerlink" title="同步和异步传输 Synchronous and Asynchronous Transmission"></a>同步和异步传输 Synchronous and Asynchronous Transmission</h3><p><strong>同步传输</strong></p><ul><li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li><li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是 0 还是 1</li><li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位,所以要使收发双发时钟保持同步</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-14-17-25.png" alt="PhysicalLayer-Synchronous Tranmission"></p><p><strong>异步传输</strong></p><ul><li>以字节为单位传输，字节之间的时间间隔不固定</li><li>接收端仅在每个字节的起始处对字节内的 bit 实现同步</li><li>通常再每个字节的前后加上起始位和结束位<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-14-18-08.png" alt="PhysicalLayer-Asynchronous Tranmission"></li></ul><h3 id="单工、半双工和全双工通信-Simplex-Half-Duplex-and-Full-Duplex-Communication"><a href="#单工、半双工和全双工通信-Simplex-Half-Duplex-and-Full-Duplex-Communication" class="headerlink" title="单工、半双工和全双工通信 Simplex, Half-Duplex, and Full-Duplex Communication"></a>单工、半双工和全双工通信 Simplex, Half-Duplex, and Full-Duplex Communication</h3><p>信道[<a href="GlossaryOfNetwork.md" title="Glossary Of Networks">GlossaryOfNetwork#Physical Layer</a>]和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。<br>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ul><li><strong>单工通信</strong>（Simplex Communication）<br>又称<strong>单向通信</strong>,即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-15-23-46-14.png" alt="Simplex Communication"></li><li><strong>半双工通信</strong>（Half-Duplex Communication）<br>又称<strong>双向交替通信</strong>,通信的双发可以交替地发送和接收信息，但不能同时进行。对讲机就是这种通信方式<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-16-10-38-44.png" alt="Half-Duplex Communication"></li><li><strong>全双工通信</strong>（Full-Duplex Communication）<br>又称<strong>双向同时通信</strong>,通信的双方可以同时发送和接收信息。电话就是这种通信方式<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-16-10-39-36.png" alt="Full-Duplex Communication"></li></ul><blockquote><p>单向通信只需要一条信道，而双向交替通信或双向同时通信则需要两条信道（每个方向各一条）<br>双向同时通信的传输效率最高</p></blockquote><h2 id="编码和调制-Encoding-and-Modulation"><a href="#编码和调制-Encoding-and-Modulation" class="headerlink" title="编码和调制 Encoding and Modulation"></a>编码和调制 Encoding and Modulation</h2><p><strong>编码</strong>Encoding 将信息转化为特定格式以便传输和存储的过程。<br><strong>调制</strong>Modulation 将数字信号转化为模拟信号的过程，使得信号能够在传输介质中传播</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GlossaryOfNetwork-2024-02-16-20-07-18.png" alt="Encoding-Modulation"></p><h3 id="编码方式-Encoding"><a href="#编码方式-Encoding" class="headerlink" title="编码方式 Encoding"></a>编码方式 Encoding</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-15-10-20.png" alt="Encoding"></p><h4 id="不归零编码-Non-Return-to-Zero-NRZ-Encoding"><a href="#不归零编码-Non-Return-to-Zero-NRZ-Encoding" class="headerlink" title="不归零编码 Non-Return-to-Zero (NRZ) Encoding"></a>不归零编码 Non-Return-to-Zero (NRZ) Encoding</h4><p>正电平与负电平分别表示 1 和 0(或 0 和 1)，不归零编码中的电平不会在码元时间内归零，即在整个码元时间内，电平不会出现零电平<br>连续的两个 1 或 0 会导致电平保持不变，接收端如何判断这是两个码元还是一个码元呢？这需要额外一根传输线来传输时钟信号，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元。但是对于计算机网络，宁愿利用这根传输线传输数据信号，而不是传输时钟信号，因此不归零编码在计算机网络中并不常用</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-14-39-53.png" alt="NRZ Encoding"></p><h4 id="归零编码-Return-to-Zero-RZ-Encoding"><a href="#归零编码-Return-to-Zero-RZ-Encoding" class="headerlink" title="归零编码 Return-to-Zero (RZ) Encoding"></a>归零编码 Return-to-Zero (RZ) Encoding</h4><p>每个码元传输结束后信号都要”归零”,接收方只要在信号归零后进行采样即可，不需要单独的时钟信号。这相当于把时钟信号用归零的方式编码到数据之内,这称为”自同步”。但这种编码方式浪费了大量带宽<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-15-10-58.png" alt="RZ Encoding"></p><h4 id="曼彻斯特编码-Manchester-Encoding"><a href="#曼彻斯特编码-Manchester-Encoding" class="headerlink" title="曼彻斯特编码 Manchester Encoding"></a>曼彻斯特编码 Manchester Encoding</h4><p>在<strong>每个码元的中间时刻</strong>，电平都会发生变化，这样接收方就可以根据这个变化来判断码元的开始和结束。曼彻斯特编码的优点是不需要单独的时钟信号，而且不会浪费带宽，因此在计算机网络中应用较多,传统以太网就是使用曼彻斯特编码的</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-15-13-16.png" alt="Manchester Encoding"></p><h4 id="差分曼彻斯特编码-Differential-Manchester-Encoding"><a href="#差分曼彻斯特编码-Differential-Manchester-Encoding" class="headerlink" title="差分曼彻斯特编码 Differential Manchester Encoding"></a>差分曼彻斯特编码 Differential Manchester Encoding</h4><p>每位中间的跳变仅提供时钟定时，而用每位开始时有无跳变表示“0”或“1”，有跳变为“0”，无跳变为“1”。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-17-33-36.png" alt="Differential Manchester Encoding"></p><h3 id="调制方式-Modulation"><a href="#调制方式-Modulation" class="headerlink" title="调制方式 Modulation"></a>调制方式 Modulation</h3><p>调试是将数字信号转化为模拟信号的过程，使得信号能够在传输介质中传播。模拟信号通常使用连续的变化来表示信息，如正弦波或方波。调制技术可以将数字信号转化为特定频率范围内的模拟信号，以方便传输和接收。</p><h4 id="基本调制方式-Basic-Modulation"><a href="#基本调制方式-Basic-Modulation" class="headerlink" title="基本调制方式 Basic Modulation"></a>基本调制方式 Basic Modulation</h4><p>三种基本调制方式：</p><ul><li><strong>调频</strong> Frequency Modulation (FM)</li><li><strong>调幅</strong> Amplitude Modulation (AM)</li><li><strong>调相</strong> Phase Modulation (PM)</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-17-44-55.png" alt="Basic-Modulation"></p><h4 id="混和调制-Hybrid-Modulation"><a href="#混和调制-Hybrid-Modulation" class="headerlink" title="混和调制 Hybrid Modulation"></a>混和调制 Hybrid Modulation</h4><p><strong>正交振幅调制 QAM</strong><br>QAM（Quadrature Amplitude Modulation）是一种混合调制技术，它是将调幅和调相结合起来的一种调制方式。QAM 信号是由两路正交的调制信号叠加而成的，一路是调幅信号，另一路是调相信号。QAM 信号的频谱效率很高，因此在数字通信中应用广泛。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-21-18-37.png" alt="QAM-16"></p><h2 id="信道的极限容量-Channel-Capacity"><a href="#信道的极限容量-Channel-Capacity" class="headerlink" title="信道的极限容量 Channel Capacity"></a>信道的极限容量 Channel Capacity</h2><h3 id="信号失真-Signal-Distortion"><a href="#信号失真-Signal-Distortion" class="headerlink" title="信号失真 Signal Distortion"></a>信号失真 Signal Distortion</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-21-28-28.png" alt="Signal Distortion"></p><h3 id="Nyquist-Theorem-and-Shannon-Theorem"><a href="#Nyquist-Theorem-and-Shannon-Theorem" class="headerlink" title="Nyquist Theorem and Shannon Theorem"></a>Nyquist Theorem and Shannon Theorem</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-21-34-20.png" alt="Nyquist Theorm"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-21-40-36.png" alt="Shannon Theorem"></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/PhysicalLayer-2024-02-17-21-40-50.png" alt="Comparison"></p><h2 id="信道复用-Channel-Multiplexing"><a href="#信道复用-Channel-Multiplexing" class="headerlink" title="信道复用 Channel Multiplexing"></a>信道复用 Channel Multiplexing</h2><p>[<a href="Ch3-2DataLinkLayer.md" title="数据链路层 DataLink Layer Ⅱ">Ch3-2DataLinkLayer#静态划分信道 Static Channel Allocation</a>]</p><p>复用(multiplexing)是通信技术中的基本概念。计算机网络中的信道广泛地使用各种复用技术。可分为频分复用、时分复用、波分复用及码分复用等</p><p>将一个物理信道根据时间、频率、空间等资源划分为多个虚拟信道。这么做的好处有二：一是减少管道的个数，为运营商减少线路成本；二是提升单通道的容量。</p><p><strong>Reference</strong>:<br><a href="https://blog.csdn.net/qq_37085158/article/details/127960426">【计算机网络系列】物理层：信道复用技术（频分复用、时分复用、波分复用及码分复用）</a><br><a href="https://blog.csdn.net/m0_46204224/article/details/106062968">图文并茂——频分复用、时分复用、码分复用、复用和多址的区别</a></p>]]></content>
    
    
    <summary type="html">介绍 Physical Layer 相关知识点,包括传输媒体,传输方式,编码和调制,信道的极限容量等内容</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>Glossary Of Networks</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/GlossaryOfNetwork/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/GlossaryOfNetwork/</id>
    <published>2024-02-13T14:39:43.000Z</published>
    <updated>2024-04-02T09:05:52.678Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OSI-Model"><a href="#OSI-Model" class="headerlink" title="OSI Model"></a>OSI Model</h2><p><strong>实体</strong> 任何可发送或接受信息的硬件或软件进程<br><strong>对等实体</strong> 收发双方层次相同中的实体<br><strong>协议 Protocol</strong> 控制两个对等实体进行逻辑通信的规则的集合<br><strong>协议三要素</strong>：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GlossaryOfNetwork-2024-02-13-23-27-42.png" alt="Protocol"><br><strong>服务 Service</strong> 在协议的控制下,两个对等实体间的逻辑通信使得本层能够向上层提供的功能;要实现本层的功能,又需要使用下层提供的服务<br><strong>服务访问点</strong> 在统一系统中相邻两层的实体交换信息的逻辑接口,用于区分不同的服务类型;</li><li>数据链路层的服务访问点为帧的类型字段</li><li>网络层的服务访问点为 IP 数据报首部中的协议字段</li><li>运输层的服务访问点为端口号<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GlossaryOfNetwork-2024-02-13-23-33-14.png" alt="Service"><br><strong>协议数据单元 PDU</strong> 对等层次之间传送的数据包<br><strong>服务数据单元 SDU</strong> 同一系统内,层间交换的数据包<br>多个 SDU 可以组成一个 PDU,也可以将一个 SDU 分成多个 PDU<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GlossaryOfNetwork-2024-02-13-23-32-57.png" alt="SDU,PDU"></li></ul><h2 id="Physical-Layer"><a href="#Physical-Layer" class="headerlink" title="Physical Layer"></a>Physical Layer</h2><p><strong>机械特性</strong> Mechanical Characteristics 定义物理连接特性,包括 采用的规格,接口形状,引线数目,排列情况,引脚数量<br><strong>电气特性</strong> Electrical Characteristics 传输二进制时,传输信号的电压范围,阻抗匹配,传输速率,距离限制<br><strong>功能特性</strong> Functional Characteristics 描述电平的意义,接口部件,信号线用途等<br><strong>过程特性</strong> Procedural Characteristics 规定 各个物理线路工作规程,时序关系</p><blockquote><p>电气特性根据电压确定电平,功能特性则是根据电平确定信号的意义</p></blockquote><p><strong>信道</strong> Channel,信道不等于电路，信道表示<strong>向某一方向传送信息的媒体</strong>，一条通信电路通常包含一条发送信道和一条接受信道。<br>严格来说，传输媒体不能和信道划等号,对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道。对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道。如果使用信道复用技术，一条传输媒体还可以包含多个信道</p><ul><li><strong>数据</strong> (data) —— 运送消息的实体</li><li><strong>信号</strong> (signal) —— 数据的电气的或电磁的表现</li><li><strong>模拟信号</strong> (analogous signal) —— 代表消息的参数的取值是连续的</li><li><strong>数字信号</strong> (digital signal) —— 代表消息的参数的取值是离散的</li><li><strong>码元</strong> (code) —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形</li><li><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号<br>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制 (modulation)</li></ul><p><strong>编码</strong>Encoding 是将信息转化为特定格式以便传输和存储的过程。在数字通信中，信息通常以二进制形式表示，即由一串 0 和 1 组成。<br>常见的编码方式包括不归零编码（NRZ）、非归零编码（RZ）、曼切斯特编码等。不归零编码将每个二进制位表示为一定的电平，低电平表示 0，高电平表示 1；非归零编码在每个二进制位的中间还添加了一个中间电平，以表示 0 或 1 的边界；曼切斯特编码将每个二进制位分成两个时间间隔，每个时间间隔表示 0 或 1。</p><p><strong>调制</strong>Modulation 是将数字信号转化为模拟信号的过程，使得信号能够在传输介质中传播。模拟信号通常使用连续的变化来表示信息，如正弦波或方波。调制技术可以将数字信号转化为特定频率范围内的模拟信号，以方便传输和接收。<br>常见的调制技术包括振幅调制（AM）、频率调制（FM）和相位调制（PM）等。振幅调制通过改变模拟信号的幅度来表示数字信号的 0 和 1；频率调制通过改变模拟信号的频率来表示数字信号的 0 和 1；相位调制通过改变模拟信号的相位来表示数字信号的 0 和 1。<br>Ref: <a href="https://blog.csdn.net/m0_70911440/article/details/135403323">编码和调制</a><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GlossaryOfNetwork-2024-02-16-20-07-18.png" alt="Encoding-Modulation"></p><h2 id="Data-Link-Layer"><a href="#Data-Link-Layer" class="headerlink" title="Data Link Layer"></a>Data Link Layer</h2><p><strong>链路 Link</strong> 指从一个结点到相邻结点的一段物理线路，中间没有其他的交换结点<br><strong>数据链路 Data Link</strong> 把实现通信协议的硬件和软件加到链路上，就构成了数据链路<br><strong>Frame</strong>,帧,数据链路层的传输单位,由数据部分和控制部分组成<br><strong>ACK</strong>,确认帧,接收方收到帧后,返回一个确认帧,表示已经收到帧<br><strong>NAK</strong>,否定确认帧,接收方收到帧后,返回一个否定确认帧,表示帧出错,要求重发</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p><strong>URL</strong>,Uniform Resource Locator,统一资源定位符,互联网上用来标识资源的地址。网络上的所有资源都靠 URL 来定位，每一个文件就对应着一个 URL，就像是路径地址。理论上，文件资源和 URL 一一对应。实际上也有例外，比如某些 URL 指向的文件已经被重定位到另一个位置，这样就有多个 URL 指向同一个文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/GlossaryOfNetwork-2024-02-13-23-02-09.png" alt="URL"></p>]]></content>
    
    
    <summary type="html">计算机网路相关术语</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Glossary" scheme="https://efterklang.github.io/tags/Glossary/"/>
    
  </entry>
  
  <entry>
    <title>Computer Networks Overview</title>
    <link href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch1-NetworkOverview/"/>
    <id>https://efterklang.github.io/UESTC/ComputerNetworking/Ch1-NetworkOverview/</id>
    <published>2024-02-13T14:22:52.000Z</published>
    <updated>2024-04-02T09:05:52.722Z</updated>
    
    <content type="html"><![CDATA[<style>p {    text-indent: 2em;}</style><h2 id="计算机网络在信息时代的作用"><a href="#计算机网络在信息时代的作用" class="headerlink" title="计算机网络在信息时代的作用"></a>计算机网络在信息时代的作用</h2><p>计算机网络已经由<strong>通信基础设施</strong>发展成为一种重要的<strong>信息服务基础设施</strong></p><h2 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01node-2024-01-29-23-35-08.png" alt="NetWork and Internet"></p><ul><li><strong>NetWork</strong> <strong>网络</strong>,由若干<strong>结点</strong>(Node)和<strong>链路</strong>(Link)组成</li><li><strong>internet</strong> <strong>互联网&#x2F;互连网</strong>,多个网络可以通过<strong>路由器</strong>(Router)互联起来,形成一个覆盖范围更大的网络,互联网是由<strong>网络和网络之间</strong>互联而成的,是<strong>网络的网络</strong>(Network of Networks)</li><li><strong>Internet</strong> <strong>因特网</strong>世界上最大的互联网络.</li><li><strong>Host</strong> <strong>主机</strong>,连接到因特网上的计算机</li></ul>`<article class="message is-info"><div class="message-header">`<p>internet 和 Internet 的区别</p>`</div><div class="message-body">`<ul><li><strong>internet</strong>(互联网或互连网)是一个通用名词，它泛指多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。</li><li><strong>Internet</strong>（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络互连而成的特定计算机网络，它采用 TCP&#x2F;IP 协议族作为通信的规则，其前身是美国的 ARPANET。</li></ul><p>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。</p>`</div></article>`<h3 id="Internet-发展的三个阶段"><a href="#Internet-发展的三个阶段" class="headerlink" title="Internet 发展的三个阶段"></a>Internet 发展的三个阶段</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Internet%E5%8F%91%E5%B1%95%E9%98%B6%E6%AE%B5.png" alt="Internet发展阶段"></p><h4 id="ISP-互联网服务提供商"><a href="#ISP-互联网服务提供商" class="headerlink" title="ISP(互联网服务提供商)"></a><strong>ISP(互联网服务提供商)</strong></h4><p><strong>Internet</strong>上的主机通过<strong>ISP</strong>接入<strong>Internet</strong>,之后才能互相通信;<strong>ISP</strong>可以从因特网管理机构申请到成块的 IP 地址,同时拥有通信线路以及路由器等联网设备.<strong>机构&#x2F;个人</strong>缴纳一定的费用,就可以从<strong>ISP</strong>租用<strong>IP 地址</strong>,并通过<strong>ISP</strong>接入<strong>Internet</strong>。中国的主流<strong>ISP</strong>有:中国电信、中国移动、中国联通等</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-01-29-23-48-41.png" alt="ISP"></p><blockquote><p><strong>第一层 ISP</strong>（Tier 1 ISP）：这些是全球互联网的主干网络运营商，它们拥有遍布全球的网络基础设施。这些公司的网络通常覆盖了全球的主要地区和城市，包括北美、欧洲、亚洲、澳大利亚等。。第一层 ISP 之间通过免费的互联网络（Peering）协议进行数据交换，不需要向其他 ISP 支付费用。<br>以下是一些知名的第一层 ISP 及其总部所在地：</p><ul><li>AT&amp;T：总部位于美国德克萨斯州达拉斯。</li><li>Verizon：总部位于美国纽约州纽约。</li><li>Level 3 Communications：总部位于美国科罗拉多州布隆菲尔德，现已被 CenturyLink（现为 Lumen Technologies）收购。</li><li>NTT Communications：总部位于日本东京。</li><li>Telia Company：总部位于瑞典斯德哥尔摩。</li></ul><hr><p><strong>第二层 ISP</strong>（Tier 2 ISP）：这些 ISP 拥有自己的网络基础设施，但是不足以覆盖全球，所以它们需要购买第一层 ISP 的服务，以便将数据传输到全球的其他地方。第二层 ISP 通常会向本地或区域的客户提供服务。</p><hr><p><strong>第三层 ISP</strong>（Tier 3 ISP）：这些 ISP 通常没有自己的网络基础设施，而是购买第二层 ISP 的服务，然后将其转售给最终用户。第三层 ISP 通常会提供一些增值服务，如电子邮件、网页托管和虚拟专用网络（VPN）。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-01-30-00-00-56.png" alt="基于ISP的三层结构Internet示意图"></p><h3 id="Internet-的标准化工作"><a href="#Internet-的标准化工作" class="headerlink" title="Internet 的标准化工作"></a>Internet 的标准化工作</h3><ul><li>因特网的标准化工作对因特网的发展起到了非常重要的作用。</li><li>因特网在指定其标准上的一个很大的特点是<strong>面向公众</strong>。<ul><li>因特网所有的 RFC(Request For Comments)技术文档都可从因特网上<a href="http://www.ietf.org/rfc.html">免费下载</a>；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ul></li><li><strong>因特网协会 ISOC 是一个国际性组织</strong>，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。<ul><li><strong>因特网体系结构委员会 IAB</strong>，负责管理因特网有关协议的开发；</li><li><strong>因特网工程部 IETF</strong>，负责研究中短期工程问题，主要针对协议的开发和标准化；</li><li><strong>因特网研究部 IRTF</strong>，从事理论方面的研究和开发一些需要长期考虑的问题。</li></ul></li><li>制定因特网的正式标准需要四个阶段:<ul><li>因特网草案</li><li>建议标准(该阶段的标准会开始写入 RFC 文档)</li><li>草案标准</li><li>因特网标准<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-01-30-18-53-28.png" alt="ISOC,IAB,IETF,IRTF"></li></ul></li></ul><h3 id="Internet-的组成"><a href="#Internet-的组成" class="headerlink" title="Internet 的组成"></a>Internet 的组成</h3><p><strong>边缘部分</strong> 由所有连接在因特网上的<strong>主机</strong>组成.这部分是用户直接使用的,用于通信和资源共享.<br><strong>核心部分</strong> 由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成,这部分是为边缘部分提供服务的(提供连通性和交换).</p><blockquote><p><strong>路由器</strong>是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。<br>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为<strong>端系统</strong>(end system)<br>端系统在功能上可能有很大的差别：</p><ol><li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li><li>大的端系统则可以是一台非常昂贵的大型计算机。</li><li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个 ISP。</li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-01-31-13-58-21.png" alt="Internet的组成"></p><h2 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h2><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是路由器(router)。路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</p><h3 id="电路交换-Circuit-Switching"><a href="#电路交换-Circuit-Switching" class="headerlink" title="电路交换 Circuit Switching"></a>电路交换 Circuit Switching</h3><p>传统的电话两两相连,但当用户很多时,这种方式就不可行了,因此引入中间设备(电话交换机),使用电话交换机接通电话线的方式称为电路交换。</p><p>从通信资源的分配角度来看,交换就是按照某种方式动态地分配传输线路的资源</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-01-31-17-18-53.png" alt="Circuit Switching"></p><p>电路交换的三个步骤是:建立连接(分配通信资源),传输数据(一直占用通信资源),释放连接<br>(归还通信资源)</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-01-31-19-41-51.png" alt="Circuit Switching"></p><p>而当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。这是因为计算机数据是突发式地出现在传输线路上的。所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p><h3 id="分组交换-Packet-Switching"><a href="#分组交换-Packet-Switching" class="headerlink" title="分组交换 Packet Switching"></a>分组交换 Packet Switching</h3><ul><li><strong>报文</strong>: 信息交换的基本单位,在网络中传输的信息单位</li><li><strong>分组</strong>: 为了传输方便,将报文划分为固定长度的数据块(分组,packet),在每一个数据段前面,加上一些由必要的控制信息组成的首部(报头),称为分组。</li></ul><hr><ul><li><strong>发送方</strong>:构造分组,发送分组</li><li><strong>路由器</strong>:缓存分组,转发分组(分组转发)</li><li><strong>接收方</strong>:接受分组,还原报文</li></ul><blockquote><p>在路由器的输入和输出端口之间没有直接连线,路由器处理分组的过程是:把收到的分组先放入缓存,查找转发表,找出某个目的地址的最佳输出端口,然后从缓存中取出该分组,通过输出端口转发出去.</p><p>在分组交换中，每个packet独立地通过网络进行传输。这意味着分组可以通过不同的路径到达目的地，并且可能会在不同的时间到达。在接收端，这些分组会被重新组装成原始的报文。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-01-31-20-06-03.png" alt="Packet Switching"></p><h3 id="报文交换-Message-Switching"><a href="#报文交换-Message-Switching" class="headerlink" title="报文交换 Message Switching"></a>报文交换 Message Switching</h3><p>在报文交换中，整个报文作为一个单元进行发送，并且在整个传输过程中保持其完整性。报文在发送前需要完全准备好，并且在传输过程中不会被分割。这种方式的优点是简单，但缺点是如果报文很大，那么它可能会占用网络资源一段很长的时间，导致网络拥塞。报文交换主要用于早期的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代。</p><h3 id="三种交换方式对比"><a href="#三种交换方式对比" class="headerlink" title="三种交换方式对比"></a>三种交换方式对比</h3><p><strong>电路交换</strong></p><ul><li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li><li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li></ul><hr><p><strong>报文交换</strong></p><ul><li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li><li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li></ul><hr><p><strong>分组交换</strong></p><ul><li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li><li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-01-31-20-29-36.png" alt="交换方式对比"></p><h2 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h2><h3 id="计算机网络的定义"><a href="#计算机网络的定义" class="headerlink" title="计算机网络的定义"></a>计算机网络的定义</h3><p>计算机网络的最简单的定义是：一些<strong>互相连接的</strong>、<strong>自治</strong>的计算机的<strong>集合</strong></p><ul><li><strong>互联</strong> 计算机之间可以通过<strong>有线或无线</strong>的方式进行数据通信</li><li><strong>自治</strong> 指计算机有独立性,有自己的软硬件,可以单独允许使用</li><li><strong>集合</strong> 至少两台计算机组成</li></ul><hr><p>计算机网络较好的定义是: 计算机网络主要是由一些<strong>通用的，可编程的硬件（一定包含有中央处理机 CPU）互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用。</strong></p><ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li><li>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</li></ul><h3 id="计算机网络的分类"><a href="#计算机网络的分类" class="headerlink" title="计算机网络的分类"></a>计算机网络的分类</h3><ul><li><strong>按交换技术分类</strong>: 电路交换网络 报文交换网络 分组交换网络</li><li><strong>按使用者分类</strong>: 公用网 专用网</li><li><strong>按传输介质分类</strong>: 有线网络 无线网络</li><li><strong>按覆盖范围分类</strong>: Wide&#x2F;Metropolitan&#x2F;Local&#x2F;Personal Area Network</li><li><strong>按拓扑结构分类</strong> 总线型 环型 星型 网状型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-01-31-23-38-14.png" alt="拓扑结构分类"></p><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率-Rate"><a href="#速率-Rate" class="headerlink" title="速率 Rate"></a>速率 Rate</h3><p><strong>bit</strong> 比特.计算机中数据量的单位,也是信息论中信息量的单位.一个 bit 即是一个二进制数字,它只能取 0 或 1 两个值 <code>8bit = 1Byte; KB=1024B,MB=1024KB,GB=1024MB,TB=1024GB</code></p><p><strong>rate</strong> 比特率,数据率.连接在计算机网络上的主机在数字信道上传送数据位数的速率,单位为 bit&#x2F;s,也称为 bps(bit per second)<code>1kbs=1000bps,1Mbps=1000kbs,1Gbps=1000Mbps</code></p><blockquote><p>100MB 的数据块,网卡的发送速率为 100Mbps,求发送所需时间?</p><div>$$\frac{100MB}{100Mbps}=\frac{MB}{Mbps}=\frac{2^{20}B}{10^6bps}=\frac{2^{20}\times8}{10^6s^{-1}}=8.388608s$$</div></blockquote><h3 id="带宽-Bandwidth"><a href="#带宽-Bandwidth" class="headerlink" title="带宽 Bandwidth"></a>带宽 Bandwidth</h3><p><strong>Bandwidth</strong>在模拟信号系统中,表示<strong>信号</strong>所包含的各种不同频率成分所占据的<strong>频率范围</strong>(即最高频率与最低频率之差),单位为 Hz;在计算机网络中,表示网络中的<strong>通信线路</strong>所能传输数据的能力,网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的<strong>最高数据率</strong>(即网络设备所支持的最高速度),单位为 bps.</p><p>带宽的这两种表述之间有着密切的联系,一条通信线路的频带宽度越宽，理论上所能传输的最高数据率也越高。(具体可自行查阅信号与系统相关知识,例如香农定理)</p><h3 id="吞吐量-Throughput"><a href="#吞吐量-Throughput" class="headerlink" title="吞吐量 Throughput"></a>吞吐量 Throughput</h3><p>吞吐量是指单位时间内实际通过某个网络(或信道、接口)的数据量,单位为 bps.</p><p>吞吐量受网络的带宽或或额定速率的限制(吞吐量往往小于带宽),同时还受到网络中其他因素的影响,例如网络拥塞、路由器转发速率、主机处理速度等.<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-01-23-30-42.png" alt="Throughput"></p><h3 id="时延-Delay"><a href="#时延-Delay" class="headerlink" title="时延 Delay"></a>时延 Delay</h3><p><strong>时延</strong>时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。<br>网络时延由以下几部分组成</p><ul><li><strong>发送时延&#x2F;传输时延 Transmission delay:</strong><br>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。<br>$$<br>R&#x3D;链路带宽 (bps)<br>L&#x3D;分组长度 (bits)<br>发送分组比特流的时间 &#x3D; L&#x2F;R<br>$$</li><li><strong>传播时延 Propagation delay</strong><br>电磁波在信道中传播一定的距离需要花费的时间。<br>$$<br>d &#x3D; 物理链路的长度<br>s &#x3D; 介质的信号传播速度 (2x10^8 m&#x2F;s)<br>传播延迟 &#x3D; d&#x2F;s<br>$$</li><li><strong>节点处理时延 Nodal processing delay</strong><br>主机或路由器在收到分组时要花费一定时间进行处理(检查错误位,选择输出链路),高速路由器的处理延迟为微秒级</li><li><strong>排队时延 Queueing delay</strong><br>常被看作是处理时延的一部分。分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-04-10-31-44.png" alt="delay"></p><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延(处理时延 + 排队时延)</p><h3 id="时延带宽积-Delay-Bandwidth-Product"><a href="#时延带宽积-Delay-Bandwidth-Product" class="headerlink" title="时延带宽积 Delay-Bandwidth Product"></a>时延带宽积 Delay-Bandwidth Product</h3><p>时延带宽积(bit) &#x3D; 传播时延(s) * 带宽(bps)</p><blockquote><p>类比带宽为水管的横切面面积,传播时延理解为水流经过水管的时间,时延带宽积就是水管的容量,即水管中能够容纳的水的数量.<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-04-10-44-48.png" alt="DBP"></p></blockquote><h3 id="往返时间-Round-Trip-Time"><a href="#往返时间-Round-Trip-Time" class="headerlink" title="往返时间 Round Trip Time"></a>往返时间 Round Trip Time</h3><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，往返时间(RTT)也是一个重要的性能指标<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-04-10-49-44.png" alt="RTT"></p><h3 id="利用率-Utilization"><a href="#利用率-Utilization" class="headerlink" title="利用率 Utilization"></a>利用率 Utilization</h3><p>利用率分为<strong>信道利用率</strong>和<strong>网络利用率</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-05-00-45-34.png" alt="Utilization"></p><h3 id="丢包率-Packet-Loss-Rate"><a href="#丢包率-Packet-Loss-Rate" class="headerlink" title="丢包率 Packet Loss Rate"></a>丢包率 Packet Loss Rate</h3><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-05-00-46-50.png" alt="PLR"></p><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="常见的计算机网络体系结构"><a href="#常见的计算机网络体系结构" class="headerlink" title="常见的计算机网络体系结构"></a>常见的计算机网络体系结构</h3><p>计算机网络是一个复杂的系统,早在 ARPANET 时代,就已经意识到了网络的复杂性,因此提出了分层的思想。分层将复杂问题分解为若干较小的局部问题,使得网络的设计和管理变得更加容易。</p><blockquote><p>各层之间相互独立：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。这个和我们对开发时系统进行分层是一个道理。<br>提高了灵活性和可替换性：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的结构。这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。<br>大问题化小：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。<br><a href="https://javaguide.cn/cs-basics/network/other-network-questions.html">JavaGuide</a></p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-06-23-37-58.png" alt="Network architecture"><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-14-23-02-01.png" alt="Network architecture"><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-14-22-59-23.png" alt="Network architecture"><br>OSI(Open System Interconnection)七层模型是国际标准化组织(ISO)制定的一个通信系统的框架,它将通信系统划分为七层,每一层都有自己的功能,并且每一层的功能都是相对独立的,只与相邻的两层进行通信。但由于 OSI 模型过于复杂,实际应用中并不常用,而是使用 TCP&#x2F;IP 四层模型</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-05-19-46-15.png" alt="OSI Model"></p><p>TCP&#x2F;IP 体系结构相当于将 OSI 体系结构的<strong>物理层和数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层和表示层</strong>。</p><p>在用户主机的操作系统中，通常都带有符合 TCP&#x2F;IP 体系结构标准的 TCP&#x2F;IP 协议族。而用于网络互连的路由器中，也带有符合 TCP&#x2F;IP 体系结构标准的 TCP&#x2F;IP 协议族。只不过路由器一般只包含网络接口层和网际层。</p><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ComputerNetwork01-2024-02-06-23-35-10.png" alt="TCP/IP"></p><p><strong>Reference</strong><br><a href="https://javaguide.cn/cs-basics/network/osi-and-tcp-ip-model.html">JavaGuide-Network-OSI and TCP&#x2F;IP</a><br><a href="https://www.bilibili.com/video/BV1c4411d7CQ/?p=9">bilibili-计网体系结构分层思想举例</a><br><a href="https://www.bilibili.com/video/BV1c4411d7CQ?p=12">bilibili-习题 1</a><br><a href="https://www.bilibili.com/video/BV1c4411d7CQ?p=13">bilibili-习题 2</a></p>]]></content>
    
    
    <summary type="html">计算机网络概述</summary>
    
    
    
    <category term="UESTC" scheme="https://efterklang.github.io/categories/UESTC/"/>
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/categories/UESTC/Computer-Networking/"/>
    
    
    <category term="Computer Networking" scheme="https://efterklang.github.io/tags/Computer-Networking/"/>
    
  </entry>
  
  <entry>
    <title>DataBase Advance 存储引擎与索引</title>
    <link href="https://efterklang.github.io/Tech/DataBase/DataBase04/"/>
    <id>https://efterklang.github.io/Tech/DataBase/DataBase04/</id>
    <published>2024-02-13T04:41:37.000Z</published>
    <updated>2024-02-27T05:03:26.819Z</updated>
    
    
    <summary type="html">数据库学习笔记</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="DataBase" scheme="https://efterklang.github.io/categories/Tech/DataBase/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>DataBase Base 多表查询&amp;事务</title>
    <link href="https://efterklang.github.io/Tech/DataBase/DataBase03/"/>
    <id>https://efterklang.github.io/Tech/DataBase/DataBase03/</id>
    <published>2024-02-12T15:46:06.000Z</published>
    <updated>2024-02-13T07:36:15.818Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多表查询-Multi-Table-Query"><a href="#多表查询-Multi-Table-Query" class="headerlink" title="多表查询 Multi-Table Query"></a>多表查询 Multi-Table Query</h1><h2 id="多表关系"><a href="#多表关系" class="headerlink" title="多表关系"></a>多表关系</h2><p>项目开发中,在进行数据库表结构设计时,会根据业务需求及业务模块之间的关系,分析并设计表结构,由于业务之间相互关联所以各个表结构之间也存在着各种联系,基本上分为三种：<br><strong>一对一</strong> one to one<br>如用户与用户详情的关系<br>多用于单表拆分,将一张表的基础字段和扩展字段分开存储,减少数据冗余,提高数据库性能.可在任意一方添加外键关联另一方的主键,并且外键字段设置 UNIQUE 约束.<br><strong>一对多(多对一)</strong> one to many<br>如一个部门对应多个员工,一个员工只能对应一个部门.<br>这种关系一般是通过在多的一方添加外键来实现的.(员工表中设置部门 id 作为外键,指向部门表中的主键)<br><strong>多对多</strong> many to many<br>如一个学生可以选择多个课程,一个课程也可以被多个学生选择.<br>这种关系一般是通过添加第三张表来实现的.(学生表,课程表,学生课程表),中间表中设置学生 id 和课程 id 作为外键,指向学生表和课程表的主键.</p><blockquote><p>为方便理解,以下以员工表和部门表为例进行说明.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------------+</span></span><br><span class="line"><span class="operator">|</span> ID <span class="operator">|</span> Name  <span class="operator">|</span> DepartmentID <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> John  <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Alice <span class="operator">|</span>          <span class="number">200</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Bob   <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> David <span class="operator">|</span>          <span class="number">300</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> departments;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----+-----------+</span></span><br><span class="line"><span class="operator">|</span> ID  <span class="operator">|</span> Name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+-----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">200</span> <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="number">300</span> <span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----+-----------+</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="多表查询概述"><a href="#多表查询概述" class="headerlink" title="多表查询概述"></a>多表查询概述</h2><p>合并查询(笛卡尔积,显示所有组合结果,不常用)<br><code>SELECT * FROM table1,table2;</code><br>消除无效组合(内连接)<br><code>SELECT * FROM employee, department WHERE employee.dept_id = department.id;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees,departments;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------------+-----+-----------+</span></span><br><span class="line"><span class="operator">|</span> ID <span class="operator">|</span> Name  <span class="operator">|</span> DepartmentID <span class="operator">|</span> ID  <span class="operator">|</span> Name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------------+-----+-----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> John  <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span> <span class="number">300</span> <span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> John  <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span> <span class="number">200</span> <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> John  <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Alice <span class="operator">|</span>          <span class="number">200</span> <span class="operator">|</span> <span class="number">300</span> <span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Alice <span class="operator">|</span>          <span class="number">200</span> <span class="operator">|</span> <span class="number">200</span> <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Alice <span class="operator">|</span>          <span class="number">200</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Bob   <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span> <span class="number">300</span> <span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Bob   <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span> <span class="number">200</span> <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Bob   <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> David <span class="operator">|</span>          <span class="number">300</span> <span class="operator">|</span> <span class="number">300</span> <span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> David <span class="operator">|</span>          <span class="number">300</span> <span class="operator">|</span> <span class="number">200</span> <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> David <span class="operator">|</span>          <span class="number">300</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------------+-----+-----------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees,departments <span class="keyword">WHERE</span> employees.DepartmentID <span class="operator">=</span> departments.ID;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------------+-----+-----------+</span></span><br><span class="line"><span class="operator">|</span> ID <span class="operator">|</span> Name  <span class="operator">|</span> DepartmentID <span class="operator">|</span> ID  <span class="operator">|</span> Name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------------+-----+-----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> John  <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> Alice <span class="operator">|</span>          <span class="number">200</span> <span class="operator">|</span> <span class="number">200</span> <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> Bob   <span class="operator">|</span>          <span class="number">100</span> <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> David <span class="operator">|</span>          <span class="number">300</span> <span class="operator">|</span> <span class="number">300</span> <span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------+--------------+-----+-----------+</span></span><br></pre></td></tr></table></figure><h2 id="内连接查询-Inner-Join"><a href="#内连接查询-Inner-Join" class="headerlink" title="内连接查询 Inner Join"></a>内连接查询 Inner Join</h2><p>内连接查询的是两张表交集的部分</p><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code><br>显式内连接(性能较高)<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查询员工姓名,以及对应的部门名称</span></span><br><span class="line"><span class="comment">-- 隐式</span></span><br><span class="line"><span class="keyword">SELECT</span> e.Name,d.Name <span class="keyword">FROM</span> employees <span class="keyword">AS</span> e, departments <span class="keyword">AS</span> d <span class="keyword">WHERE</span> e.DepartmentID <span class="operator">=</span> d.ID;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Name  <span class="operator">|</span> Name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+</span></span><br><span class="line"><span class="operator">|</span> John  <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Alice <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Bob   <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> David <span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+</span></span><br><span class="line"><span class="comment">-- 显式</span></span><br><span class="line"><span class="keyword">SELECT</span> e.Name,d.Name <span class="keyword">FROM</span> employees <span class="keyword">AS</span> e <span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> d <span class="keyword">ON</span> e.DepartmentID <span class="operator">=</span> d.ID;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Name  <span class="operator">|</span> Name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+</span></span><br><span class="line"><span class="operator">|</span> John  <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Alice <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Bob   <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> David <span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+</span></span><br></pre></td></tr></table></figure><blockquote><p>sql inner join 3 tables example<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataBase03-2024-02-12-10-09-03.png" alt="SQL Inner Join"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">first_name,</span><br><span class="line">last_name,</span><br><span class="line">job_title,</span><br><span class="line">department_name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">employees e</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> departments d <span class="keyword">ON</span> d.department_id <span class="operator">=</span> e.department_id</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> jobs j <span class="keyword">ON</span> j.job_id <span class="operator">=</span> e.job_id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e.department_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/DataBase03-2024-02-12-10-10-40.png" alt="SQL Inner Join"></p></blockquote><h2 id="外连接查询-Outer-Join"><a href="#外连接查询-Outer-Join" class="headerlink" title="外连接查询 Outer Join"></a>外连接查询 Outer Join</h2><p>分为<strong>左外连接、右外连接、全外连接</strong>(Left Join, Right Join, Full Join)</p><p>左连接查询：查询左表的所有数据,右表中符合条件的数据<br>右连接查询：查询右表的所有数据,左表中符合条件的数据<br>全连接查询：查询两个表的所有数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- left join</span></span><br><span class="line"><span class="keyword">SELECT</span> e.Name,d.Name <span class="keyword">FROM</span> employees <span class="keyword">AS</span> e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments <span class="keyword">AS</span> d <span class="keyword">ON</span> e.DepartmentID <span class="operator">=</span> d.ID;</span><br><span class="line"><span class="comment">-- right join</span></span><br><span class="line"><span class="keyword">SELECT</span> e.Name,d.Name <span class="keyword">FROM</span> departments <span class="keyword">AS</span> d <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> employees <span class="keyword">AS</span> e <span class="keyword">ON</span> e.DepartmentID <span class="operator">=</span> d.ID;</span><br><span class="line"><span class="comment">-- 以上两句等价</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Name  <span class="operator">|</span> Name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+</span></span><br><span class="line"><span class="operator">|</span> John  <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Alice <span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Bob   <span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> David <span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+-----------+</span></span><br></pre></td></tr></table></figure><p><a href="https://www.sqltutorial.org/sql-left-join/">sqltutorial-left-join</a><br><a href="https://www.sqltutorial.org/sql-full-outer-join/">sqltutorial-full-outer-join</a></p><h2 id="自连接查询-Self-Join"><a href="#自连接查询-Self-Join" class="headerlink" title="自连接查询 Self Join"></a>自连接查询 Self Join</h2><p>当前表与自身的连接查询，自连接必须使用表别名;自连接查询，可以是内连接查询，也可以是外连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.Name,B.Name</span><br><span class="line"><span class="keyword">FROM</span> employees A</span><br><span class="line"><span class="keyword">JOIN</span> employees B</span><br><span class="line"><span class="keyword">ON</span> A.DepartmentID <span class="operator">=</span> B.DepartmentID <span class="operator">&amp;&amp;</span> A.Name <span class="operator">&lt;</span> B.Name;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> Name <span class="operator">|</span> Name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br><span class="line"><span class="operator">|</span> Bob  <span class="operator">|</span> John <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+------+</span></span><br></pre></td></tr></table></figure><p><a href="https://www.sqltutorial.org/sql-self-join/">sqltutorial-self-join</a></p><h2 id="联合查询-Union"><a href="#联合查询-Union" class="headerlink" title="联合查询 Union"></a>联合查询 Union</h2><p>把多次<code>SELECT</code>查询的结果合并，形成一个新的查询集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表A ...</span><br><span class="line"><span class="keyword">UNION</span> [<span class="keyword">ALL</span>]</span><br><span class="line"><span class="keyword">SELECT</span> 字段列表 <span class="keyword">FROM</span> 表B ...</span><br></pre></td></tr></table></figure><p><strong>Note</strong>: UNION 会自动去重, UNION ALL 不会去重;联合查询比使用 or 效率高，不会使索引失效</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Name <span class="keyword">FROM</span> employees <span class="keyword">UNION</span> <span class="keyword">SELECT</span> Name <span class="keyword">FROM</span> departments;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> Name      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br><span class="line"><span class="operator">|</span> John      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Alice     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Bob       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> David     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sales     <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Marketing <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> HR        <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------+</span></span><br></pre></td></tr></table></figure><h2 id="子查询-Subquery"><a href="#子查询-Subquery" class="headerlink" title="子查询 Subquery"></a>子查询 Subquery</h2><p><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br>在 SQL 中，子查询（Subquery）是嵌入在其他 SQL 查询中的查询,又称嵌套查询。<br>子查询可以用在各种 SQL 语句中，如 <code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>，以及在 <code>WHERE</code> 或 <code>HAVING</code> 子句中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> EmployeeName, Salary</span><br><span class="line"><span class="keyword">FROM</span> Employees</span><br><span class="line"><span class="keyword">WHERE</span> Salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Salary) <span class="keyword">FROM</span> Employees);</span><br></pre></td></tr></table></figure><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询返回值为单个值,数字,String,Date）<br>常用操作符：<code>- &lt; &gt; &gt; &gt;= &lt; &lt;=</code></li><li>列子查询（子查询返回值为一列）<br>常用操作符:<code>IN,NOT IN,SOME,ANY,ALL</code>(<code>SOME</code>和<code>ANY</code>是等价的,只要子查询返回的任意一个值满足条件即可,<code>ALL</code>是所有值都满足条件才返回结果)</li><li>行子查询（子查询返回值为一行）<br>常用操作符:<code>=, &lt;, &gt;, IN, NOT IN</code></li><li>表子查询（子查询返回值为多行多列）<br>常用操作符:<code>IN</code></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 标量子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> Salary <span class="operator">&gt;</span> (<span class="keyword">SELECT</span> <span class="built_in">AVG</span>(Salary) <span class="keyword">FROM</span> employees);</span><br><span class="line"><span class="comment">-- 列子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> Salary <span class="keyword">IN</span> (<span class="keyword">SELECT</span> Salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> DepartmentID <span class="operator">=</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> Salary <span class="operator">&gt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> Salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> DepartmentID <span class="operator">=</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> Salary <span class="operator">&gt;</span> <span class="keyword">ANY</span> (<span class="keyword">SELECT</span> Salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> DepartmentID <span class="operator">=</span> <span class="number">100</span>);</span><br><span class="line"><span class="comment">-- 行子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> (salary, manager) <span class="operator">=</span> (<span class="keyword">SELECT</span> salary,manager <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line"><span class="comment">-- 表子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> e.<span class="operator">*</span>, d.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> entrydate <span class="operator">&gt;</span> <span class="string">&#x27;2006-01-01&#x27;</span>) <span class="keyword">AS</span> e</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept <span class="keyword">AS</span> d</span><br><span class="line"><span class="keyword">ON</span> e.dept <span class="operator">=</span> d.id;</span><br></pre></td></tr></table></figure><hr><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h1 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务 Transaction"></a>事务 Transaction</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>在 SQL 中，事务（Transaction）是作为单个逻辑工作单元执行的一系列操作，这些操作要么完全完成，要么完全不完成。事务是数据库完整性的关键，它确保了数据库从一个一致的状态转换到另一个一致的状态。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Manual transaction</span></span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> ID <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> Salary <span class="operator">=</span> <span class="number">1000</span> <span class="keyword">WHERE</span> ID <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> Salary <span class="operator">=</span> <span class="number">2000</span> <span class="keyword">WHERE</span> ID <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果出现错误,可以使用 ROLLBACK 回滚事务</span></span><br><span class="line"><span class="keyword">ROLLBACK</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用START/BEGIN TRANSACTION</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION; <span class="comment">-- 或者 BEGIN;</span></span><br><span class="line">statement1;</span><br><span class="line">statement2;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p><strong>ACID</strong></p><ul><li><strong>原子性</strong>（Atomicity）：事务中的所有操作要么全部完成，要么全部不完成。如果事务中的某个操作失败，那么整个事务将被回滚，数据库状态不会改变。</li><li><strong>一致性</strong>（Consistency）：事务确保数据库从一个一致的状态转换到另一个一致的状态。事务开始和结束时，所有的业务规则都必须保持一致。</li><li><strong>隔离性</strong>（Isolation）：每个事务都在一个独立的工作区中执行，事务之间不会互相影响。这意味着并发事务的修改必须被隔离，直到事务提交，其他事务才能看到这些修改。</li><li><strong>持久性</strong>（Durability）：一旦事务被提交，它对数据库的更改就是永久性的。即使发生系统故障，更改也不会丢失。</li></ul><h2 id="并发事务-Concurrent-Transaction"><a href="#并发事务-Concurrent-Transaction" class="headerlink" title="并发事务 Concurrent Transaction"></a>并发事务 Concurrent Transaction</h2><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><p>多用户并发访问数据库时,可能会出现以下问题：</p><ul><li><p><strong>dirty read</strong><br>A transaction reads data written by a concurrent uncommitted transaction.</p></li><li><p><strong>nonrepeatable read</strong><br>A transaction re-reads data it has previously read and finds that data has been modified by another transaction (that committed since the initial read).</p></li><li><p><strong>phantom read</strong><br>A transaction re-executes a query returning a set of rows that satisfy a search condition and finds that the set of rows satisfying the condition has changed due to another recently-committed transaction.</p></li><li><p><strong>serialization anomaly</strong><br>The result of successfully committing a group of transactions is inconsistent with all possible orderings of running those transactions one at a time.</p></li></ul><h3 id="Transaction-Isolation-Level"><a href="#Transaction-Isolation-Level" class="headerlink" title="Transaction Isolation Level"></a>Transaction Isolation Level</h3><table><thead><tr><th>Isolation Level</th><th>Dirty Read</th><th>Nonrepeatable Read</th><th>Phantom Read</th><th>Serialization Anomaly</th></tr></thead><tbody><tr><td>Read uncommitted</td><td>Allowed, but not in PG</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>Read committed</td><td>Not possible</td><td>Possible</td><td>Possible</td><td>Possible</td></tr><tr><td>Repeatable read</td><td>Not possible</td><td>Not possible</td><td>Allowed, but not in PG</td><td>Possible</td></tr><tr><td>Serializable</td><td>Not possible</td><td>Not possible</td><td>Not possible</td><td>Not possible</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 设置事务隔离级别</span></span><br><span class="line"><span class="keyword">SET</span> <span class="operator">&lt;</span>SESSION<span class="operator">|</span><span class="keyword">GLOBAL</span><span class="operator">&gt;</span> TRANSACTION ISOLATION LEVEL <span class="operator">&lt;</span>READ UNCOMMITTED<span class="operator">|</span>READ COMMITTED<span class="operator">|</span>REPEATABLE READ<span class="operator">|</span>SERIALIZABLE<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>Reference:<br><a href="https://www.postgresql.org/docs/9.5/transaction-iso.html">postgresql-transaction-isolation-levels</a><br><a href="https://zhuanlan.zhihu.com/p/254453080">zhihu</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">数据库学习笔记，本篇主要记录SQL多表查询以及Transaction相关的知识点。</summary>
    
    
    
    <category term="Tech" scheme="https://efterklang.github.io/categories/Tech/"/>
    
    <category term="DataBase" scheme="https://efterklang.github.io/categories/Tech/DataBase/"/>
    
    
    <category term="DataBase" scheme="https://efterklang.github.io/tags/DataBase/"/>
    
    <category term="SQL" scheme="https://efterklang.github.io/tags/SQL/"/>
    
  </entry>
  
</feed>

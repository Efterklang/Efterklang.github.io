<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>网络层控制平面 Network Layer:Control Plane - Efterklang</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Efterklang"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Efterklang"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="介绍网络层的控制平面，包括路由算法，较为详细介绍了Dijkstra算法(链路状态选路算法)Distance-Vector Routing Algorithms(距离向量算法)以及层次选路三种选路算法。并介绍因特网中的选路协议（内部网关协议：RIP、OSPF、IGRP；外部网关协议：BGP），介绍SDN的概念，用途，架构"><meta property="og:type" content="article"><meta property="og:title" content="网络层控制平面 Network Layer:Control Plane"><meta property="og:url" content="https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-2NetworkLayer/"><meta property="og:site_name" content="Efterklang"><meta property="og:description" content="介绍网络层的控制平面，包括路由算法，较为详细介绍了Dijkstra算法(链路状态选路算法)Distance-Vector Routing Algorithms(距离向量算法)以及层次选路三种选路算法。并介绍因特网中的选路协议（内部网关协议：RIP、OSPF、IGRP；外部网关协议：BGP），介绍SDN的概念，用途，架构"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://efterklang.github.io/img/thumbnails/Networks/network_layer2.jpg"><meta property="article:published_time" content="2024-04-27T12:34:19.000Z"><meta property="article:modified_time" content="2024-06-16T07:45:01.417Z"><meta property="article:author" content="Efterklang"><meta property="article:tag" content="计算机网络"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://efterklang.github.io/img/thumbnails/Networks/network_layer2.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://efterklang.github.io/"},"headline":"网络层控制平面 Network Layer:Control Plane","image":["https://efterklang.github.io/img/thumbnails/Networks/network_layer2.jpg"],"datePublished":"2024-04-27T12:34:19.000Z","dateModified":"2024-06-16T07:45:01.417Z","author":{"@type":"Person","name":"efterklang"},"publisher":{"@type":"Organization","name":"Efterklang","logo":{"@type":"ImageObject","url":{"light":"/img/sunflower.png","dark":"/img/sunflower.png"}}},"description":"介绍网络层的控制平面，包括路由算法，较为详细介绍了Dijkstra算法(链路状态选路算法)Distance-Vector Routing Algorithms(距离向量算法)以及层次选路三种选路算法。并介绍因特网中的选路协议（内部网关协议：RIP、OSPF、IGRP；外部网关协议：BGP），介绍SDN的概念，用途，架构"}</script><link rel="canonical" href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-2NetworkLayer/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/tokyo-night-dark.css"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><meta name="msvalidate.01" content="039770FFD6F5D1B53B42B9D3271EA9B9"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-HKYTDLW5FP" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-HKYTDLW5FP');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Efterklang" type="application/atom+xml">
</head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/gallery">Gallery</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/onedrive">Onedrive</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="github" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/thumbnails/Networks/network_layer2.jpg" alt="网络层控制平面 Network Layer:Control Plane" referrerpolicy="no-referrer"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-27T12:34:19.000Z" title="4/27/2024, 8:34:19 PM">2024-04-27</time></span><span class="level-item"><a class="link-muted" href="/categories/UESTC/">UESTC</a><span> / </span><a class="link-muted" href="/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="level-item">an hour read (About 8771 words)</span><span class="level-item leancloud_visitors" id="/UESTC/ComputerNetworking/Ch4-2NetworkLayer/" data-flag-title="网络层控制平面 Network Layer:Control Plane"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">网络层控制平面 Network Layer:Control Plane</h1><div class="content"><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>路由算法确定了通过网络的端到端路径，转发表确定了在路由器上的本地转发，转发表是链接数据平面与控制平面的主要元素，本篇将介绍其是如何计算、维护的</p>
<ul>
<li><strong>每个路由器控制 Per-router control</strong>：每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值。<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-11-17-28.png" style="zoom:50%;"></li>
<li><strong>逻辑集中式控制 Logically centralized control</strong>：逻辑集中式控制器计算并分发转发表以供每台路由器使用，如下图所示：<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-11-17-38.png" style="zoom:50%;"></li>
</ul>
<h2 id="Routing-Algorithms"><a href="#Routing-Algorithms" class="headerlink" title="Routing Algorithms"></a>Routing Algorithms</h2><p><strong>路由的基本概念</strong></p>
<ul>
<li>默认路由器：与主机直接相连的路由器，又叫第一跳路由器。每当主机发送一个分组时，都先传送给它的默认路由器。<ul>
<li>源路由器：源主机的默认路由器。</li>
<li>目的路由器：目的主机的默认路由器。</li>
<li>从源主机到目的主机的选路归结为从源路由器到目的路由器的选路。</li>
</ul>
</li>
<li>路由算法：是确定一个分组从源路由器到目的路由器所经路径的算法</li>
<li>路由算法的关键：在给定的一组路由器以及连接路由器的链路中，找到一条从源路由器到目的路由器的“好”路径。</li>
</ul>
<p><strong>网络的抽象图模型</strong></p>
<p>图$G &#x3D; (N，E)$表示 N 个节点和 E 条边的集合，每条边是来自 N 的一对节点。<br>Node 节点：表示路由器(做出分组转发判决的点)。如 $u，v，w，x，y，z$<br>Edge 边：连接节点的线段，表示路由器之间的物理链路。如$(u，v)、 (u，x) 、(u，w)、…$<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-13-50-15.png" style="zoom:70%;"></p>
<p>Cost 可以表示对应链路的物理长度、或链路速度、或与链路相关的费用。<br>定义：$c(x，y)$ 表示从节点 x 到节点 y 的链路费用,规定若节点 x 与节点 y 不直接相连则$c(x,y)&#x3D;\infty$</p>
<h3 id="Routing-Algorithms-Classification"><a href="#Routing-Algorithms-Classification" class="headerlink" title="Routing Algorithms Classification"></a>Routing Algorithms Classification</h3><ul>
<li><strong>集中式路由选择算法 Centralized Routing Algorithm</strong>：用完整、全局性的网络知识计算出从源到目的地之间的最低开销路径。具有全局状态信息的算法常被称作<strong>链路状态(Link State，LS)算法</strong>，因为该算法必须知道网络中每条链路的开销。</li>
<li><strong>分布式路由算法 Decentralized Routing Algorithm</strong>：路由器以迭代、分布式计算的方式计算出最低开销路径。没有节点拥有关于网络链路开销的完整信息。一个分散式路由选择算法为<strong>距离向量(Distance-Vector，DV)算法</strong>，每个节点维护到网络中所有其他节点的开销估计的向量。</li>
</ul>
<hr>
<ul>
<li><strong>静态路由算法</strong>：路由确定后基本不再变化。只有人工干预调整时，可能有一些变化。</li>
<li><strong>动态路由算法</strong>：当网络的流量负载或拓扑发生变化时，路径可能发生改变。可以周期性地或直接地响应拓扑或链路费用的变化。易受选路循环、路由振荡之类问题的影响。</li>
</ul>
<h3 id="Link-State-Routing-Algorithms"><a href="#Link-State-Routing-Algorithms" class="headerlink" title="Link State Routing Algorithms"></a>Link State Routing Algorithms</h3><p><strong>链路状态选路算法</strong></p>
<p>在实践中，这经常由链路状态广播（link state broadcast）算法完成。下面给出的链路状态路由选择算法是 Dijkstra’s algorithm</p>
<p><strong>Dijkstra’s Alogorithm</strong></p>
<ul>
<li>所有节点知道网络拓扑，以及每条链路的费用信息<ul>
<li>通过链路状态广播来实现</li>
<li>所有节点拥有相同的信息</li>
</ul>
</li>
<li>计算任意一个节点（源节点）到所有其他节点的最低费用路径<ul>
<li>给出该节点的转发表</li>
</ul>
</li>
<li>迭代：通过 k 次迭代后可以知道到达 k 个目的节点的最低费用路径</li>
<li>基本思想：以源节点为起点，每次找出一个到源节点的费用最低的节点，直到把所有的目的节点都找到为止。</li>
</ul>
<p>定义以下符号</p>
<ul>
<li><code>c(x,y)</code>: 表示从节点 x 到节点 y 的链路费用,规定若节点 x 与节点 y 不直接相连则<code>c(x,y)=∞</code></li>
<li><code>D(v)</code>：到算法的本次迭代，从源节点到目的节点 v 的最低开销；</li>
<li><code>p(v)</code>：从源到 v 沿着当前最小开销路径的前一个节点（v 的邻居）；</li>
<li><code>N&#39;</code>：节点子集；如果从源到 v 的最低开销路径已经确定，v 在<code>N&#39;</code>中</li>
<li><code>u</code> 源节点</li>
</ul>
<h4 id="Link-State-LS-Algorithm-for-Source-Node-u"><a href="#Link-State-LS-Algorithm-for-Source-Node-u" class="headerlink" title="Link-State (LS) Algorithm for Source Node u"></a>Link-State (LS) Algorithm for Source Node u</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Initialization:</span><br><span class="line">  N&#x27; = &#123;u&#125;</span><br><span class="line">  for all nodes v</span><br><span class="line">    if v is a neighbor of u:</span><br><span class="line">      then D(v) = c(u,v)</span><br><span class="line">    else  D(v) = ∞</span><br><span class="line"></span><br><span class="line">while N&#x27; != N:</span><br><span class="line">  # 从N&#x27;的补集中找一个到源节点费用最低的节点</span><br><span class="line">  find w not in N&#x27; such that D(w) is a minimum</span><br><span class="line">    add w to N&#x27;</span><br><span class="line">    update D(v) for each neighbor v of w and not in N&#x27;:</span><br><span class="line">      D(v) = min(D(v),D(w)+c(w,v))</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-13-50-15.png" style="zoom:70%;">
以上图为例,计算从u到所有可能目的节点的最低费用路径。算法迭代如下
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-15-30-57.png" style="zoom:70%;">

<br>

<article class="message is-info">
        <div class="message-header"><p>LS</p>
</div>
        <div class="message-body">
            <p>Dijkstra 例题 2 基于 Dijkstra 算法计算路由器 A 的算法表<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-10-20-04-16.png" style="zoom:100%;"></p>
<table>
<thead>
<tr>
<th>Step</th>
<th>N’</th>
<th>D(B),p(B)</th>
<th>D(C),p(C)</th>
<th>D(D),p(D)</th>
<th>D(E),p(E)</th>
<th>D(F),p(F)</th>
<th>D(G),p(G)</th>
<th>D(H),p(H)</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>A</td>
<td>4,A</td>
<td>$\infty$</td>
<td>$\infty$</td>
<td>1,A</td>
<td>3,A</td>
<td>$\infty$</td>
<td>$\infty$</td>
</tr>
<tr>
<td>2</td>
<td>AE</td>
<td>4,A</td>
<td>$\infty$</td>
<td>$\infty$</td>
<td></td>
<td>3,A</td>
<td>$\infty$</td>
<td>$\infty$</td>
</tr>
<tr>
<td>3</td>
<td>AEF</td>
<td>4,A</td>
<td>$\infty$</td>
<td>8,F</td>
<td></td>
<td></td>
<td>6,F</td>
<td>$\infty$</td>
</tr>
<tr>
<td>4</td>
<td>AEFB</td>
<td></td>
<td>7,B</td>
<td>8,F</td>
<td></td>
<td></td>
<td>5,B</td>
<td>$\infty$</td>
</tr>
<tr>
<td>5</td>
<td>AEFBG</td>
<td></td>
<td>6,G</td>
<td>8,F</td>
<td></td>
<td></td>
<td></td>
<td>7,G</td>
</tr>
<tr>
<td>6</td>
<td>AEFBGC</td>
<td></td>
<td></td>
<td>8,F</td>
<td></td>
<td></td>
<td></td>
<td>7,G</td>
</tr>
<tr>
<td>7</td>
<td>AEFBGCH</td>
<td></td>
<td></td>
<td>8,F</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>AEFBGCHD</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>

        </div>
    </article>

<p>构建从源节点到所有目的节点的路径</p>
<ul>
<li>对于每个节点，都得到从源节点沿着它的最低费用路径的前驱节点；</li>
<li>每个前驱节点，又可得到它的前驱节点；以此继续，可以得到到所有目的节点的完整路径。<br>如节点 z 的前驱节点依次为：<code>p(z)=y,z-&gt;y;p(y)=x,z-&gt;y-&gt;x;p(x)=u,z-&gt;y-&gt;x-&gt;u</code></li>
<li>得出从源节点 u 到节点 z 的最低费用路径为：uxyz，费用为 4。</li>
<li>根据目的节点找出顺序和其费用以及前驱节点，可以画出源节点 u 到所有目的节点的最低费用路径树。<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-15-44-55.png" style="zoom:70%;"></li>
<li>根据得到的所有目的节点的完整路径，或最低费用路径树，可以生成源节点的转发表。<strong>转发表</strong>存放从源节点到每个目的节点的最低费用路径上的下一跳节点。即指出对于发往某个目的节点的分组，从该节点发出后的下一个节点。</li>
</ul>
<blockquote>
<p>默认路由 <code>*</code> ：表示所有具有相同“下一跳”的表项。即将“下一跳”相同的项合并为一项，目的节点用<code>*</code>表示。优先级最低，转发分组时，当找不到对应表项时，才使用默认路由。</p>
</blockquote>
<p><strong>Dijkstra’s Algorithm 复杂度</strong><br>设 n 个节点(除源节点)，最坏情况下要经多少次计算才能找到从源节点到所有目的节点的最低费用路径?<br>第一次迭代：搜索所有的 n 个节点以确定最低费用节点<br>第二次迭代：检查 n-1 个节点；<br>第三次：检查 n-2 个节点；<br>依次类推。<br>所有迭代中需要搜寻的节点总数为 $\frac{n(n+1)}{2}$<br>算法复杂性为 $O(n^2)$</p>
<p>且路线上的流量变化和拥塞会使 LS 算法产生<strong>路由震荡 Routing Oscillations</strong></p>
<h3 id="The-Distance-Vector（DV）Routing-Algorithm"><a href="#The-Distance-Vector（DV）Routing-Algorithm" class="headerlink" title="The Distance-Vector（DV）Routing Algorithm"></a>The Distance-Vector（DV）Routing Algorithm</h3><p>距离向量路由算法有以下特征</p>
<ul>
<li><strong>迭代 Iterative</strong>：计算过程一直持续到邻居之间无更多信息交换为止。</li>
<li><strong>分布式 Distributed</strong>：每个节点都从其直接相连邻居接收信息，进行计算，再将计算结果分发给邻居。</li>
<li><strong>异步 Asynchronous</strong>：不要求所有节点相互之间步伐一致地操作。</li>
<li><strong>自我终结 Self-termination</strong>：算法能自行停止。</li>
</ul>
<p><strong>Bellman-Ford 方程</strong></p>
<p>$$d_x(y)&#x3D;min_v{c(x,v)+d_v(y)}$$</p>
<ul>
<li>$d_x(y)$：节点 x 到节点 y 的最低开销路径的 cost。</li>
<li>$v$: 节点 x 的邻居节点。</li>
<li>$c(x,v)+ d_v(y)$：x 与某个邻居 v 之间的直接链路费用 c(x,v)加上邻居 v 到 y 的最小费用。即 x 经 v 到节点 y 的最小的路径费用。</li>
<li>$min_v$ ：从所有经直接相连邻居节点到节点 y 的费用中选取的最小路径费用。</li>
</ul>
<h4 id="Distance-Vector-DV-Algorithm"><a href="#Distance-Vector-DV-Algorithm" class="headerlink" title="Distance-Vector (DV) Algorithm"></a>Distance-Vector (DV) Algorithm</h4><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-19-17-16.png" style="zoom:50%;">
<br>

<p>对每个节点 x:</p>
<ol>
<li>初始化</li>
<li>等待 (收到本地链路代价变化或邻居来距离矢量更新)</li>
<li>重新计算距离矢量,更新距离向量</li>
<li>如果到任何目的节点的距离矢量发生变化, 通知邻居</li>
<li>goto2</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-13-50-15.png" style="zoom:70%;">
仍以该图为例,计算源节点u到目的节点z的最低费用路径。

<ul>
<li>邻居 v：$d_v(z) &#x3D; 5、c(u,v) &#x3D; 2$</li>
<li>邻居 w：$d_w(z) &#x3D; 3、c(u,w) &#x3D; 5$</li>
<li>邻居 x：$d_x(z) &#x3D; 3、c(u,x) &#x3D; 1$</li>
</ul>
<div>
$$
d_u(z) = min \{ c(u,v) + d_v(z), c(u,w) + d_w(z) , c(u,x) + d_x(z)\} \\
= min\{2+5,5+3,1+3\} = 4
$$
</div>

<p>即源节点 u 经相邻节点 x 到目的节点 z 的路径费用最低，为 4</p>
<p><strong>节点的距离向量表</strong></p>
<ul>
<li>行：该节点的距离向量 Dx 和其邻居的距离向量 Dv</li>
<li>列：所有目的节点。</li>
</ul>
<p>节点 x 的距离向量 $D_x$ ，即节点 x 到每个目的节点 y 的估计费用； $Dx &#x3D; [D_x(y) | y \in N ]$<br>节点 x 每个邻居的距离向量 $D_v$ ，即 x 的邻居 v 到每个目的节点 y 的估计费用，$Dv &#x3D; [D_v(y)：y \in N]$</p>
<p>如何更新距离向量?</p>
<ul>
<li>每个节点不断向邻居发送其距离向量的 copy；</li>
<li>当节点 x 收到一个邻居 v 的新距离向量，先保存，并用 B-F 公式更新自己的距离向量：<br>$D_x(y)&#x3D;min_v{c(x,v)+D_v(y)}$<br>从所有经邻居 v 到节点 y 的费用中选取最小路径费用</li>
<li>若距离向量发生改变，将新的距离向量通知给邻居。</li>
<li>当距离向量不再变化，算法终止，此时$D_x(y)$收敛到$d_x(y)$，即得到节点 x 到节点 y 的最低费用路径。</li>
<li>多次重复从邻居接收更新距离向量、重新计算选路表项、并向邻居发送更新通知的过程，直到没有更新报文</li>
<li>算法进入静止状态，直到某个链路费用发生改变为止。</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-19-35-25.png" style="zoom:100%;">

<article class="message is-info">
        <div class="message-header"><p>DV</p>
</div>
        <div class="message-body">
            <p><strong>练习</strong><br>考虑如图所示的子网，该子网使用了距离-向量算法，下面的向量刚刚到达路由器 C：<br>来自 B 的向量为（5，0， 8，12，6，2）；<br>来自 D 的向量为（16，12，6，0，9，10）；<br>来自 E 的向量为（7，6，3，9，0，4）；<br>经过测量，C 到 B、D 和 E 的延迟分别为 6，3 和 5，那么 C 到达所有结点的最短路径是？<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-10-16-10-53.png" style="zoom:100%;"></p>
<p>各个向量对应元素的意思是(A,B,C,D,E,F)，路由节点 X 到其他节点 X’所需要的延迟。（注：这里是 C 经 B、C 经 D、C 经 E，再到目标节点的延迟）<br>如图写出过后，从这些向量中的所有元素中选出各对应点里面的延迟最小值的，组成一个新向量，即（11，6，0，3，5，8）</p>

        </div>
    </article>

<hr>
<h4 id="Distance-Vector-Algorithm-Link-Cost-Changes-and-Link-Failure"><a href="#Distance-Vector-Algorithm-Link-Cost-Changes-and-Link-Failure" class="headerlink" title="Distance-Vector Algorithm: Link-Cost Changes and Link Failure"></a>Distance-Vector Algorithm: Link-Cost Changes and Link Failure</h4><p>当一个节点检测到从它到邻居的链路费用发生变化时，就更新其距离向量，如果最低费用路径的费用发生变化，通知其邻居。</p>
<ul>
<li><p><strong>某链路费用减少时情况</strong><br>如图所示，当 y 到 x 的链路费用从 4 变为 1 的情况。</p>
<ul>
<li><p><code>t0</code>：y 检测到 x 的链路费用从 4 变为 1，更新其距离向量，并通知其邻居 z；</p>
</li>
<li><p><code>t1</code>：z 收到来自 y 的更新报文，并更新自己的距离表，此时到节点 x 的最低费用减为 2，并通知其邻居 y；</p>
</li>
<li><p><code>t2</code>：y 收到来自 z 的更新报文，并更新自己的距离表，此时到节点 x 的最低费用不变仍为 1。不发送更新报文，算法静止。<br>当 x 与 y 之间费用减少，DV 算法只需两次迭代到达静止状态。节点之间链路费用减少的“好消息”在网络中能迅速传播,即 <em>good news travels fast</em></p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-08-19-44-30.png" style="zoom:50%;"></li>
</ul>
</li>
<li><p><strong>某链路费用增加时情况</strong><br>假设 x 与 y 之间的链路费用从 4 增加到 60<br><strong>链路费用变化前</strong><br>$D_y(x)&#x3D;4 ，D_y(z)&#x3D;1， D_z(y)&#x3D;1，D_z(x)&#x3D;5$</p>
<ul>
<li><code>t0</code> ：y 检测到链路费用从 4 变为 60。更新到 x 的最低路径费用<br>$D_y(x)&#x3D;min{c(y,x)+ D_x(x), c(y,z)+ D_z(x)}&#x3D;min{60+0,1+5}&#x3D;6$<br>此时 $D_y(x)&#x3D;6 ，D_y(z)&#x3D;1， D_z(y)&#x3D;1，D_z(x)&#x3D;5$<br>经节点 z 到 x 费用最低，此新费用错误，发给节点 z。</li>
<li><code>t1</code> ：z 收到新费用，更新其到 x 的最低路径费用<br>$D_z(x )&#x3D;min{ c(z,x)+ D_x(x), c(z,y)+ D_y(x)}&#x3D;min{50+0,1+6}&#x3D;7$<br>此时 $D_y(x)&#x3D;6 ，D_y(z)&#x3D;1， D_z(y)&#x3D;1，D_z(x)&#x3D;7$<br>经节点 y 到 x 费用最低，发给节点 y。</li>
<li><code>t2</code>：y 收到新费用，更新到 x 的最低路径费用<br>$D_y(x )&#x3D;min{c(y,x)+ D_x(x), c(y,z)+ D_z(x)}&#x3D;min{60+0,1+7}&#x3D;8$<br>经节点 z 到 x 费用最低，发给节点 z。<br>……<br>节点 y 或 z 的最低费用不断更新。<br>产生<strong>选路回环</strong>(routing loop)：为到达 x， y 通过 z 选路，z 又通过 y 选路。即目的地为 x 的分组到达 y 或 z 后，将在这两个节点之间不停地来回反复，直到转发表发生改变为止。上述循环将持续 44 次迭代 (y 与 z 之间的报文交换)，直到 z 最终算出它经由 y 的路径费用大于 50 为止。并确定：z 到 x 的最低费用路径：zxy 到 x 的最低费用路径：yzx<br>说明：链路费用增加的“坏消息”传播很慢,即 <em>bad news travels slow</em><br>当链路费用增加很大，会出现<strong>无穷计数</strong>(count-to-infinity)问题。如链路费用 c(y，x)变为 10000，c(z，x)变为 9999 时。</li>
</ul>
</li>
</ul>
<h4 id="Distance-Vector-Algorithm-Adding-Poisoned-Reverse"><a href="#Distance-Vector-Algorithm-Adding-Poisoned-Reverse" class="headerlink" title="Distance-Vector Algorithm: Adding Poisoned Reverse"></a>Distance-Vector Algorithm: Adding Poisoned Reverse</h4><p>针对上面的问题，引出<strong>毒性逆转（poisoned reverse）</strong>思想：如果 z 通过 y 路由选择目的地 x，则 z 将通告 y，它到 x 的距离是无穷大，也就是 z 将通告$D_z(x)&#x3D;\infty$。毒性逆转可以完全解决计数到无穷的问题吗？不能，如果三个以上节点的环路，则不能被毒性逆转技术检测</p>
<h3 id="A-Comparison-of-LS-and-DV-Routing-Algorithms"><a href="#A-Comparison-of-LS-and-DV-Routing-Algorithms" class="headerlink" title="A Comparison of LS and DV Routing Algorithms"></a>A Comparison of LS and DV Routing Algorithms</h3><p><strong>消息复杂度</strong><br>LS 算法：知道网络每条链路的费用，需发送 $O(nE)$个报文；当一条链路的费用变化时，必须通知所有节点<br>DV 算法：迭代时，仅在两个直接相连邻居之间交换报文；当链路费用改变时，只有该链路相连的节点的最低费用路径发生改变时，才传播已改变的链路费用<br><strong>收敛速度</strong><br>LS 算法：需要 $O(nE)$个报文和 $O(n^2)$的搜寻，可能会振荡<br>DV 算法：收敛较慢。可能会遇到选路回环，或计数到无穷的问题。<br><strong>健壮性</strong><br>当一台路由器发生故障、操作错误或受到破坏时，会发生什么情况?<br>LS 算法：路由器向其连接的一条链路广播不正确费用，路由计算基本独立（仅计算自己的转发表），有一定健壮性。<br>DV 算法：一个节点可向任意或所有目的节点发布其不正确的最低费用路径，一个节点的计算值会传递给它的邻居，并间接地传递给邻居的邻居。一个不正确的计算值会扩散到整个网络。</p>
<h2 id="Intra-AS-Routing-in-the-Internet-OSPF"><a href="#Intra-AS-Routing-in-the-Internet-OSPF" class="headerlink" title="Intra-AS Routing in the Internet: OSPF"></a>Intra-AS Routing in the Internet: OSPF</h2><p>迄今为止，我们的路由研究都是理想化的： 所有路由器一样的 网络是 “平面的” 实际中并不是这样的。互联网在规模上具有 20 亿个节点，路由表中不可能存储所有的节点而路由表的信息交换也将淹没数据链路</p>
<p>随着路由器规模增大和管理自治的要求，可以通过将路由器组织进<strong>自治系统（Autonomous System，AS）</strong>来解决。在一个自治系统内运行的路由算法叫做<strong>自治系统内部路由选择协议（intra-autonomous system routing protocol）</strong>，不同自治系统内的路由器可以运行不同的区域内路由协议</p>
<p><strong>网关路由器</strong>（gateway router）</p>
<ul>
<li>和其他自治系统内的路由器直接相连的路由器。运行域间路由协议，与其他网关路由器交互</li>
<li>同自治系统内的所有其他路由器一样也运行域内路由协议</li>
</ul>
<p>域（自治系统）内路由选择</p>
<ul>
<li>使用域内路由协议，也被称作内部网关协议 (IGP)</li>
<li>标准的域内路由协议:<ul>
<li>RIP: 路由信息协议</li>
<li>OSPF: 开放式最短路径优先</li>
<li>IGRP: 内部网关路由协议 (Cisco 所有)</li>
</ul>
</li>
</ul>
<h3 id="RIP-Routing-Information-Protocol"><a href="#RIP-Routing-Information-Protocol" class="headerlink" title="RIP ( Routing Information Protocol)"></a>RIP ( Routing Information Protocol)</h3><ul>
<li>属于距离向量算法，包含在 1982 年发布的 BSD-UNIX 版本中。</li>
<li>距离衡量: 跳数 (max &#x3D; 15 hops)</li>
<li>RIP 通告<ul>
<li>每隔 30 秒,通过响应报文在邻居间交换距离向量 (也被称为 RIP 通告, advertisement)</li>
<li>每个通告包含了多达 25 个 AS 内的目的子网的列表</li>
</ul>
</li>
<li>RIP 链路失败及恢复<br>若 180 秒后没有收到通告，则认为邻居死机或链路中断：<ul>
<li>通过故障邻居的路由失败</li>
<li>新的公告发送给其他邻居</li>
<li>邻居然后再发送新的公告 (如果转发表发生变化)</li>
<li>链路故障信息快速传播到整个网络</li>
<li>毒性逆转用于防止乒乓循环 (无限距离 &#x3D; 16 跳)</li>
</ul>
</li>
</ul>
<h3 id="OSPF-Open-Shortest-Path-First"><a href="#OSPF-Open-Shortest-Path-First" class="headerlink" title="OSPF (Open Shortest Path First)"></a>OSPF (Open Shortest Path First)</h3><p>OSPF 是一种链路状态协议，它使用洪泛链路状态信息和 Dijkstra 最低开销路径算法。使用 OSPF，一台路由器构建了一幅关于整个自治系统的完整拓扑图。于是，每台路由器在本地运行 Dijkstra 的最短路径算法，以确定一个自身为根节点到所有子网的最短路径树。</p>
<p>使用 OSPF 时，路由器向自治系统内所有其他路由器广播路由选择信息，而不仅仅是向其相邻路由器广播。每当一条链路的状态发生变化时，路由器就会广播链路状态信息。</p>
<ul>
<li>属于链路状态算法<ul>
<li>分发 LS 分组</li>
<li>每个节点具有拓扑图</li>
<li>路由计算使用 Dijkstra 算法</li>
</ul>
</li>
<li>每个 router 都广播 OSPF 通告，OSPF 通告里为每个邻居路由器设一个表项（记录每个邻居的链路特征和费用）</li>
<li>通告会散布到 整个 自治系统 (通过洪泛法)<ul>
<li>OSPF 信息直接通过 IP 传输 （不是 TCP 或 UDP）</li>
</ul>
</li>
</ul>
<p><strong>OSPF 相比 RIP 的优点</strong></p>
<ul>
<li>安全: 所有 OSPF 消息需要认证 (防止恶意入侵)</li>
<li>允许多个相同开销的路径 (在 RIP 中只有一条路径)</li>
<li>对于每个链路, 有多个消费尺度用于不同的服务类型 TOS (例如在尽力转发时卫星链路代价设置为 “低” ，而对实时应用设置为高)</li>
<li>对单播与多播路由选择的综合支持（Integrated support for unicast and multicast routing）；</li>
<li>在大的区域中使用层次 OSPF</li>
</ul>
<p><strong>层次 OSPF</strong></p>
<ul>
<li>两级层次: 本地区域, 主干区域（这些区域都是在一个自治系统内）<ul>
<li>只在区域内发送链路状态通告</li>
<li>每个节点有详细的区域拓扑; 仅知道到达其他区域内网络的方向（即最短路径）</li>
</ul>
</li>
<li>区域边界路由器（同时属于本地区域和主干区域）:“汇总”了到本区域内部网络的路径, 并通告给其他区域边界路由器.</li>
<li>主干路由器：限于在主干区域内运行 OSPF 路由协议（本身不是区域边界路由器）</li>
<li>边界路由器: 连接到其他自治系统</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-10-17-41-40.png" style="zoom:50%;">

<h2 id="Routing-Among-the-ISPs-BGP"><a href="#Routing-Among-the-ISPs-BGP" class="headerlink" title="Routing Among the ISPs:BGP"></a>Routing Among the ISPs:BGP</h2><p>当分组跨越多个 AS 进行路由时，我们需要一个<strong>自治系统间路由协议（inter-autonomous system routing protocol）</strong>。在因特网中，所有的 AS 运行相同的 AS 间路由选择协议，称为<strong>边界网关协议（Broder Gateway Protocol，BGP）</strong>。</p>
<h3 id="The-Role-of-BGP"><a href="#The-Role-of-BGP" class="headerlink" title="The Role of BGP"></a>The Role of BGP</h3><p>BGP 是事实上的标准，它为每个 AS 提供了一种手段</p>
<ul>
<li>从相邻 AS 获取子网的可达性信息 Obtain prefix reachability information from neighboring ASs，向该 AS 内部的所有路由器传播这些可达性信息 Advertising BGP Route Information。</li>
<li>基于该可达信息和 AS 策略，决定到达子网的“最好”路由 Determine the “best” routes to the prefixes.</li>
</ul>
<blockquote>
<p>In BGP, packets are not routed to a specific destination address, but instead to CIDRized prefixes, with each prefix representing a subnet or a collection of subnets.</p>
</blockquote>
<p>BGP 是一种 AS(自治区域)外部路由协议，主要负责本自治区域和外部的自治区域间的路由<strong>可达信息的交换</strong>。因此，它所关心的拓扑结构是 AS(自治区域)的拓扑结构。转发表根据 AS 内和 AS 间选路算法而配置；AS 域内和 AS 域间的选路项用于目的端在域外的选路，AS 域内的选路项用于目的端在域内的选路。</p>
<p>假设 AS1 中的路由器接收到了目的端是 AS1 外的分组。路由器将把这个分组转发到网关路由器，但是是哪个网关路由器呢？<br>AS1 需要知道:</p>
<ul>
<li>通过 AS2 和 AS3 可以到达哪些目的端</li>
<li>将这些可达信息传播给 AS1 内的所有路由器</li>
</ul>
<p>这就是<strong>域间选路</strong>的任务</p>
<h3 id="Advertising-BGP-Route-Information"><a href="#Advertising-BGP-Route-Information" class="headerlink" title="Advertising BGP Route Information"></a>Advertising BGP Route Information</h3><p>对于每个 AS，路由器可分为<strong>网关路由器 gateway router</strong>及<strong>内部路由器 internal router</strong>。在 BGP 中，每对路由器通过使用<code>179</code>端口的半永久 TCP 连接(semi-permanent TCP connections)交换路由选择信息,TCP 连接携带着 BGP message，因此其也称作<strong>BGP Connection</strong>。其中跨越两个 AS 的 BGP 连接称为<strong>eBGP</strong> connection，而在相同 AS 中的两台路由器之间的 BGP 会话称为<strong>iBGP</strong> connection。</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-10-18-44-42.png" style="zoom:80%;">

<p>以上图为例，具体传播过程如下：当需要将前缀 x 的可达性信息传播至 AS1 和 AS2 的所有路由器时，首先，AS3 的网关路由器 3a 通过 eBGP 发送消息<code>AS3 x</code>给 AS2 的网关路由器 2c。接着，路由器 2c 利用 iBGP 将此消息<code>AS3 x</code>转发给 AS2 内的所有其他路由器，包括路由器 2a。然后，路由器 2a 通过 eBGP 发出更新的消息<code>AS2 AS3 x</code>至 AS1 的网关路由器 1c。最后，路由器 1c 使用 iBGP 将这条包含路径信息的消息<code>AS2 AS3 x</code>广播给 AS1 内的所有路由器。完成这一过程后，AS1 和 AS2 中的每一台路由器都知晓了前缀 x 的存在及其可达的 AS 路径。</p>
<p>可达性信息通过 iBGP 和 eBGP 的协作，在自治系统内外进行传播，确保网络中的每个关键节点都能够了解到目标前缀的存在及其可达路径。</p>
<h3 id="Determining-the-Best-Routes"><a href="#Determining-the-Best-Routes" class="headerlink" title="Determining the Best Routes"></a>Determining the Best Routes</h3><p>当通告前缀时，通告包含了 BGP 属性(BGP attribute),<code>前缀+属性</code>称为路由 route<br>两个重要的属性:1</p>
<ul>
<li>AS-PATH: 包含了前缀的通告已经通告过的那些 AS,如 <code>AS 67 AS 17</code>,BGP 也会根据 AS-PATH 属性来检测并避免循环通告</li>
<li>NEXT-HOP: 指出到达下一个 AS 的具体 AS 间边界路由器（可能存在多条从当前 AS 到达下一个 AS 的链路）</li>
</ul>
<p>当网关路由器接收到路由通告时，使用输入策略来决定接收&#x2F;舍弃该通告。</p>
<h4 id="Hot-potato-routing"><a href="#Hot-potato-routing" class="headerlink" title="Hot potato routing"></a>Hot potato routing</h4><p>热土豆(烫手山芋)路由选择的基本思想是：在多个 NEXT-HOP 路由器中，选择到 NEXT-HOP 开销最低的路径。<br>热土豆的思想：尽可能块地将分组送出其 AS（最低开销），而不担心其 AS 外部到目的地的余下部分的开销(贪心策略)</p>
<p>在路由器转发表中增加 AS 外部目的地的步骤：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-11-19-26-10.png" style="zoom:50%;"></p>
<h4 id="Route-Selection-Algorithm"><a href="#Route-Selection-Algorithm" class="headerlink" title="Route-Selection Algorithm"></a>Route-Selection Algorithm</h4><p>路由器可能知道到相同前缀的多条路由，路由器必须从中选择。该种情况下会顺序地匹配下列消除规则</p>
<ol>
<li>路由被指派一个本地偏好（local preference）值作为其属性值之一，具有最高本地偏好值的将被选择；</li>
<li>如果本地偏好值相同，则选择具有最短 AS-PATH 属性值的路由；</li>
<li>如果 AS-PATH 属性值相同，则选择具有最短 NEXT-HOP 属性值的路由；(Hot potato routing)</li>
<li>根据 BGP identifiers， 匹配其它标准</li>
</ol>
<h4 id="IP-Anycast"><a href="#IP-Anycast" class="headerlink" title="IP-Anycast"></a>IP-Anycast</h4><p>除了作为 Internet 的 AS 间路由协议外，BGP 还经常用于实现 IP 任播服务，该服务通常用于 DNS。</p>
<p>常见的应用场景可抽象为：在许多不同的分散地理位置的不同服务器上复制相同的内容，并让每个用户从最近的服务器访问内容。<br>具体的例子包括： CDN 可以在不同国家&#x2F;地区的服务器上复制视频和其他对象。DNS 系统可以在世界各地的 DNS 服务器上复制 DNS 记录。</p>
<article class="message is-info">
        
        <div class="message-body">
            <p><strong>How does Anycast work?</strong><br>Anycast network routing is able to route incoming connection requests across multiple data centers. When requests come into a single IP address associated with the Anycast network, the network distributes the data based on some prioritization methodology. The selection process behind choosing a particular data center will typically be optimized to reduce latency by selecting the data center with the shortest distance from the requester. Anycast is characterized by a 1-to-1 of many association, and is one of the 5 main network protocol methods used in the Internet protocol.<br><strong>What is the difference between Anycast and Unicast?</strong><br>Most of the Internet works via a routing scheme called Unicast. Under Unicast, every node on the network gets a unique IP address. Home and office networks use Unicast; when a computer is connected to a wireless network and gets a message saying the IP address is already in use, an IP address conflict has occurred because another computer on the same Unicast network is already using the same IP. In most cases, that isn’t allowed.<br>Using Anycast means the network can be extremely resilient. Because traffic will find the best path, an entire data center can be taken offline and traffic will automatically flow to a proximal data center.</p>
<p><a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/cdn/glossary/anycast-network/">What is Anycast? | How does Anycast work?</a></p>

        </div>
    </article>

<h4 id="Routing-Policy"><a href="#Routing-Policy" class="headerlink" title="Routing Policy"></a>Routing Policy</h4><p>X 是一个<strong>多宿主接入 ISP（multi-homed access ISP）</strong>,它经由两个不同提供商连接到两个网络</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-11-20-01-40.png" style="zoom:100%;" alt="ABCXYW 均表示 AS 而非 routers">
 
<ul>
<li>B 向X通告路由BAW </li>
<li>A 向B通告路径 AW <ul>
<li>B 会向C通告路由BAW吗?</li>
<li>W和C都不是B的customer，B希望C通过A路由到W（CAW），自己只负责路由自己的客户<blockquote>
<p>ISP遵循的法则：任何穿越某ISP主干网的流量必须是其源或者目的位于该ISP的某个客户网络中</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><strong>为什么 AS 内选路和 AS 间选路采用不同的协议?</strong></p>
<ul>
<li><strong>策略 Policy</strong>:<ul>
<li>AS 间: 管理员想控制本 AS 内产生的通信流怎样选路，以及什么通信流穿过自己的网络</li>
<li>AS 内:单个管理者, 因此不需要策略</li>
</ul>
</li>
<li><strong>规模 Scale</strong>:<ul>
<li>层次路由节省了转发表的大小空间，减少了路由更新的流量</li>
</ul>
</li>
<li><strong>性能 Performance</strong>:<ul>
<li>AS 内: 集中在性能上</li>
<li>AS 间: 策略可能比性能更加重要</li>
</ul>
</li>
</ul>
<h2 id="The-SDN-Control-Plane"><a href="#The-SDN-Control-Plane" class="headerlink" title="The SDN Control Plane"></a>The SDN Control Plane</h2><p>软件定义网络（SDN，SoftwareDefinedNetwork）源自美国斯坦福大学 CLeanState 研究组提出的一种新型网络创新架构，可通过软件编程的形式定义和控制网络，具有控制平面和转发平面分离及开放性可编程的特点。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-11-20-47-27.png" style="zoom:70%;"><br>SDN 的核心理念是，希望应用软件可以参与对网络的控制管理，满足上层业务需求，通过自动化业务部署，简化网络运维。如果把现有的网络看成手机，那 SDN 的目标就是做出一个网络界的 Android 系统，可以在手机上安装升级，同时还能安装更多更强大的手机 APP。</p>
<p>SDN 并不是一个具体的技术，它是一种网络设计理念，规划了网络的各个组成部分（软件、硬件、转发面和控制面）及相互之间的互动关系。</p>
<article class="message is-info">
        
        <div class="message-body">
            <p>过去几十年里，IP 网络一直是全分布式的，战功卓著，解决了各种客户需求。今天 SDN 是为了未来更好更快的实现用户需求。并不是有什么需求通过传统方法不能做到，只是 SDN 做得更快、更好、更简单。</p>
<p>IP 网络的生存能力很强，得益于其分布式架构。当年美国军方希望在遭受核打击后，整个网络能够自主恢复，这样就不能允许网络集中控制，不能存在中心结点，否则在这个中心节点丢一颗核弹，整个网络就瘫痪了，由此才导致了互联网的研究和诞生。</p>
<p>但正是这种全分布式架构导致了许多问题：看看现在的 IP 网络管理多复杂，举个运营商部署 VPN 的例子：要配置 MPLS、BFD、IGP、BGP、VPNV4、要绑定接口…且需要在每个 PE 上配置；当新增加一个 PE 时，还需要回去修改每个涉及到的 PE。现在各厂家的网络设备都太复杂了。如果您准备成为某个厂商设备的百事通，你需要掌握的命令行超过 10000 条，而其数量还在增加。 如果你准备成为 IP 骨灰级专家，你需要阅读网络设备相关 RFC 2500 篇，如果一天阅读一篇，你知道要看多久能看完？6 年多！而这只是整个 RFC 的 1&#x2F;3，其数量还在增加。此外，这些协议标准都是在解决各种各样的控制面需求，而这些需求都是需要经过需求提出、定义标准、互通测试、现网设备升级来完成部署，一般要个 3~5 年才能完成部署。这样的速度，已经 Hold 不住网络上运营业务的 OTT 们的各种快速网络调整需求，必须想办法解决这个问题。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-11-20-46-59.png" style="zoom:80%;"><br>Google 的网络分为数据中心内部网络（IDC Network）及骨干网（Backbone Network，也可以称为 WAN 网）。其中 WAN 网按照流量方向由两张骨干网构成，分别为：第一，数据中心之间互联的网络（Inter-DC WAN，即 G-scale Network），用来连接 Google 位于世界各地之间的数据中心，属于内部网络 Google 选择使用 SDN 来改造数据中心之间互联的 WAN 网（即 G-scale Network）<br>促使 Google 使用 SDN 改造 WAN 网的最大原因是 当前连接 WAN 网的链路带宽利用率很低。GoogleWAN 网的出口设备有上百条对外链路，分成很多的 ECMP 负载均衡组，在这些均衡组内的多条链路之间 用的是基于静态 Hash 的负载均衡方式, ，最主要的应用是流量工程，最主要的控制手段是软件应用程序。</p>

        </div>
    </article>

<p><strong>SDN 的发展驱动力和优势</strong><br>驱动力：</p>
<ul>
<li>计算虚拟化驱动：静态到动态的网络变化。虚拟机迁移改变了原有静态的网络部署模式，需要网络开放出来，能与虚拟化业务互通起来随需而动，动态调整网络的策略的扩展性</li>
<li>云计算对资源的垂直整合：独立演进到协同。网络作为一种资源被云计算整合到基础架构中，提供快速连接的服务</li>
<li>云计算时代 IT 业务的发展，驱动由固定到可编程网络的快速变化</li>
<li>数据中心资源：需要随业务跨地域整合，并使数据中心间广域流量增大。而现状是数据中心资源分散，广域成本高且利用率低</li>
</ul>
<p>优势：</p>
<ul>
<li>统一便捷的管理，解决网络中设备越来越多样化问题</li>
<li>无缝的版本升级，解决设备版本升级对业务的影响</li>
<li>网络数据可视化</li>
<li>整体的流量调度</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-11-20-51-15.png" style="zoom:100%;">

<p>SDN 体系结构具有四个关键特征：</p>
<ul>
<li>基于流的转发（Flow-based forwarding）；</li>
<li>数据平面与控制平面分离（Separation of data plane and control plane）；</li>
<li>网络控制功能位于数据平面交换机外部（Network control functions: external to data-plane switches）；</li>
<li>可编程网络（A programmable network）；</li>
</ul>
<p>SDN 的核心思想是建立一个通用转发体系。每个交换设备包含一个流表(flow table). 流表由一个逻辑上中心化的控制器（远程控制器）来计算和分发</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-2NetworkLayer-2024-06-11-20-56-23.png" style="zoom:50%;">

<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/cdn/glossary/anycast-network/">What is Anycast? | How does Anycast work?</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>网络层控制平面 Network Layer:Control Plane</p><p><a href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-2NetworkLayer/">https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-2NetworkLayer/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Efterklang</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-04-27</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-06-16</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/UESTC/DataBase/Ch6-DbPrograming/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">ChⅥ 数据库应用编程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Dev/Git/rebase-and-quash/"><span class="level-item">Using Git Rebase to Manage Commit History</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.30/dist/twikoo.all.min.js"></script><script>twikoo.init({
            envId: 'https://efterklang-twikoo.hf.space',
            
            lang: "en",
            onCommentLoaded: function () {
              var commentContents = document.getElementsByClassName('tk-content');
              for (var i = 0; i < commentContents.length; i++) {
                var commentItem = commentContents[i];
                var imgEls = commentItem.getElementsByTagName('img');
                if (imgEls.length > 0) {
                  for (var j = 0; j < imgEls.length; j++) {
                    var imgEl = imgEls[j];
                    var aEl = document.createElement('a');
                    aEl.setAttribute('class', 'tk-lg-link');
                    aEl.setAttribute('href', imgEl.getAttribute('src'));
                    aEl.setAttribute('data-src', imgEl.getAttribute('src'));
                    aEl.appendChild(imgEl.cloneNode(false));
                    imgEl.parentNode.insertBefore(aEl, imgEl.nextSibling);
                    imgEl.remove();
                  }
                  if (typeof $.fn.lightGallery === 'function') {
                    $(commentItem).lightGallery({
                      selector: '.tk-lg-link'
                    });
                  }
                }
              }
            }
        });</script></div></div></div><style>.column.column-left,.column.column-right{display:none}</style><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Introduction"><span class="level-left"><span class="level-item">1</span><span class="level-item">Introduction</span></span></a></li><li><a class="level is-mobile" href="#Routing-Algorithms"><span class="level-left"><span class="level-item">2</span><span class="level-item">Routing Algorithms</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Routing-Algorithms-Classification"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Routing Algorithms Classification</span></span></a></li><li><a class="level is-mobile" href="#Link-State-Routing-Algorithms"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Link State Routing Algorithms</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Link-State-LS-Algorithm-for-Source-Node-u"><span class="level-left"><span class="level-item">2.2.1</span><span class="level-item">Link-State (LS) Algorithm for Source Node u</span></span></a></li></ul></li><li><a class="level is-mobile" href="#The-Distance-Vector（DV）Routing-Algorithm"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">The Distance-Vector（DV）Routing Algorithm</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Distance-Vector-DV-Algorithm"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">Distance-Vector (DV) Algorithm</span></span></a></li><li><a class="level is-mobile" href="#Distance-Vector-Algorithm-Link-Cost-Changes-and-Link-Failure"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">Distance-Vector Algorithm: Link-Cost Changes and Link Failure</span></span></a></li><li><a class="level is-mobile" href="#Distance-Vector-Algorithm-Adding-Poisoned-Reverse"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">Distance-Vector Algorithm: Adding Poisoned Reverse</span></span></a></li></ul></li><li><a class="level is-mobile" href="#A-Comparison-of-LS-and-DV-Routing-Algorithms"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">A Comparison of LS and DV Routing Algorithms</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Intra-AS-Routing-in-the-Internet-OSPF"><span class="level-left"><span class="level-item">3</span><span class="level-item">Intra-AS Routing in the Internet: OSPF</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#RIP-Routing-Information-Protocol"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">RIP ( Routing Information Protocol)</span></span></a></li><li><a class="level is-mobile" href="#OSPF-Open-Shortest-Path-First"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">OSPF (Open Shortest Path First)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Routing-Among-the-ISPs-BGP"><span class="level-left"><span class="level-item">4</span><span class="level-item">Routing Among the ISPs:BGP</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#The-Role-of-BGP"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">The Role of BGP</span></span></a></li><li><a class="level is-mobile" href="#Advertising-BGP-Route-Information"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">Advertising BGP Route Information</span></span></a></li><li><a class="level is-mobile" href="#Determining-the-Best-Routes"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">Determining the Best Routes</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Hot-potato-routing"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">Hot potato routing</span></span></a></li><li><a class="level is-mobile" href="#Route-Selection-Algorithm"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">Route-Selection Algorithm</span></span></a></li><li><a class="level is-mobile" href="#IP-Anycast"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">IP-Anycast</span></span></a></li><li><a class="level is-mobile" href="#Routing-Policy"><span class="level-left"><span class="level-item">4.3.4</span><span class="level-item">Routing Policy</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#The-SDN-Control-Plane"><span class="level-left"><span class="level-item">5</span><span class="level-item">The SDN Control Plane</span></span></a></li><li><a class="level is-mobile" href="#Ref"><span class="level-left"><span class="level-item">6</span><span class="level-item">Ref</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Dev/"><span class="level-start"><span class="level-item">Dev</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/Dev/DataBase/"><span class="level-start"><span class="level-item">DataBase</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Others/"><span class="level-start"><span class="level-item">Others</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Essay/"><span class="level-start"><span class="level-item">Essay</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Essay/Game/"><span class="level-start"><span class="level-item">Game</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Essay/Poems/"><span class="level-start"><span class="level-item">Poems</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/UESTC/"><span class="level-start"><span class="level-item">UESTC</span></span><span class="level-end"><span class="level-item tag">39</span></span></a><ul><li><a class="level is-mobile" href="/categories/UESTC/ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">ARM处理器体系结构及应用</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">数据库原理及应用</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">April 2024</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a><p class="is-size-7"><span>&copy; 2024 Efterklang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>
<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>网络层数据平面 Network Layer:Data Plane - Efterklang</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Efterklang"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Efterklang"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="介绍网络层的主要功能——转发与路由，这两大核心方面分别由数据平面和控制平面负责，该篇主要介绍Data Plane,对比了传统的路由管理方式与SDN（软件定义网络）方法。阐述了网络服务模型的基本概念及路由器内部工作原理，包括输入输出端口处理、交换机制、排队策略及包调度等关键流程。此外，介绍互联网协议(IP)，涉及IPv4的数据报结构、地址分配，动态主机配置协议(DHCP)、网络地址转换(NAT)、I"><meta property="og:type" content="article"><meta property="og:title" content="网络层数据平面 Network Layer:Data Plane"><meta property="og:url" content="https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-1NetworkLayer/"><meta property="og:site_name" content="Efterklang"><meta property="og:description" content="介绍网络层的主要功能——转发与路由，这两大核心方面分别由数据平面和控制平面负责，该篇主要介绍Data Plane,对比了传统的路由管理方式与SDN（软件定义网络）方法。阐述了网络服务模型的基本概念及路由器内部工作原理，包括输入输出端口处理、交换机制、排队策略及包调度等关键流程。此外，介绍互联网协议(IP)，涉及IPv4的数据报结构、地址分配，动态主机配置协议(DHCP)、网络地址转换(NAT)、I"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://efterklang.github.io/img/thumbnails/Networks/network_layer1.jpg"><meta property="article:published_time" content="2024-03-27T05:33:20.000Z"><meta property="article:modified_time" content="2024-06-16T07:44:50.986Z"><meta property="article:author" content="Efterklang"><meta property="article:tag" content="计算机网络"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://efterklang.github.io/img/thumbnails/Networks/network_layer1.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://efterklang.github.io/"},"headline":"网络层数据平面 Network Layer:Data Plane","image":["https://efterklang.github.io/img/thumbnails/Networks/network_layer1.jpg"],"datePublished":"2024-03-27T05:33:20.000Z","dateModified":"2024-06-16T07:44:50.986Z","author":{"@type":"Person","name":"efterklang"},"publisher":{"@type":"Organization","name":"Efterklang","logo":{"@type":"ImageObject","url":{"light":"/img/sunflower.png","dark":"/img/sunflower.png"}}},"description":"介绍网络层的主要功能——转发与路由，这两大核心方面分别由数据平面和控制平面负责，该篇主要介绍Data Plane,对比了传统的路由管理方式与SDN（软件定义网络）方法。阐述了网络服务模型的基本概念及路由器内部工作原理，包括输入输出端口处理、交换机制、排队策略及包调度等关键流程。此外，介绍互联网协议(IP)，涉及IPv4的数据报结构、地址分配，动态主机配置协议(DHCP)、网络地址转换(NAT)、I"}</script><link rel="canonical" href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-1NetworkLayer/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/tokyo-night-dark.css"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><meta name="msvalidate.01" content="039770FFD6F5D1B53B42B9D3271EA9B9"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-HKYTDLW5FP" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-HKYTDLW5FP');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Efterklang" type="application/atom+xml">
</head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/gallery">Gallery</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/onedrive">Onedrive</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="github" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/thumbnails/Networks/network_layer1.jpg" alt="网络层数据平面 Network Layer:Data Plane" referrerpolicy="no-referrer"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-03-27T05:33:20.000Z" title="3/27/2024, 1:33:20 PM">2024-03-27</time></span><span class="level-item"><a class="link-muted" href="/categories/UESTC/">UESTC</a><span> / </span><a class="link-muted" href="/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="level-item">an hour read (About 10065 words)</span><span class="level-item leancloud_visitors" id="/UESTC/ComputerNetworking/Ch4-1NetworkLayer/" data-flag-title="网络层数据平面 Network Layer:Data Plane"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">网络层数据平面 Network Layer:Data Plane</h1><div class="content"><h2 id="Overview-of-Network-Layer"><a href="#Overview-of-Network-Layer" class="headerlink" title="Overview of Network Layer"></a>Overview of Network Layer</h2><p><strong>网络层提供的功能</strong><br>从发送方主机传输报文段到接收方主机<br>发送方主机封装报文段(segments)为数据报(datagrams)给链路层<br>接收方主机递交报文段给传输层<br>在每个主机、路由器上都需要运行网络层协议<br>路由器会检查通过它的所有 IP 数据报的头部字段，然后根据目的 IP 地址对数据报进行转发</p>
<h3 id="Forwarding-and-Routing-The-Data-Plane-and-Control-Plane"><a href="#Forwarding-and-Routing-The-Data-Plane-and-Control-Plane" class="headerlink" title="Forwarding and Routing: The Data Plane and Control Plane"></a>Forwarding and Routing: The Data Plane and Control Plane</h3><ul>
<li><strong>转发</strong>(forwarding): 当数据包到达路由器的输入链路时，路由器必须将数据包移动到适当的输出链路。例如，从主机 H1 到路由器 R1 的数据包必须被转发到通往 H2 的路径上的下一个路由器。将分组从路由器的输入端口转移到正确的路由器输出端口(主要利用硬件)</li>
<li><strong>路由</strong>(routing): 网络层必须确定数据包从发送者流向接收者时所走的路由 route 或路径 path,计算这些路径的算法被称为路由算法。例如，路由算法会确定数据包从 Host1 流向 Host2 的路径。路由在网络层的控制平面 Control Plane 中实现(主要利用软件)</li>
</ul>
<blockquote>
<p>转发指的是路由器在本地将数据包从输入链路接口转移到适当的输出链路接口的动作。转发在非常短的时间范围内发生（通常是几纳秒），因此通常在硬件中实现。路由指的是确定数据包从源到目的地的端到端路径的网络范围内的过程。路由在更长的时间范围内发生（通常是几秒钟），通常在软件中实现。</p>
</blockquote>
<h4 id="Control-Plane-The-Traditional-Approach"><a href="#Control-Plane-The-Traditional-Approach" class="headerlink" title="Control Plane: The Traditional Approach"></a>Control Plane: The Traditional Approach</h4><p>每个路由器都有单独的路由算法组件，路由器之间通过交互来实现控制平面<br>由路由算法决定了路由器转发表的内容<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-05-14-15-19-16.png" style="zoom:100%;"></p>
<h4 id="Control-Plane-The-SDN-Approach"><a href="#Control-Plane-The-SDN-Approach" class="headerlink" title="Control Plane: The SDN Approach"></a>Control Plane: The SDN Approach</h4><p>一个分离的（通常是远程的）控制器和路由器本地的控制代理 (local control agents，CAs) 交互，由 remote controller 计算并分发每个路由器要使用的转发表<br>远程控制器可能在具有高可靠性和冗余的远程数据中心中实现，并可能由 ISP 或某第三方管理，因为计算转发表并与路由器交互的控制器是在软件中实现的，故被称为软件定义网络(Software Defined Networking, SDN)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-05-14-15-51-29.png" style="zoom:100%;"></p>
<h3 id="Network-Service-Model"><a href="#Network-Service-Model" class="headerlink" title="Network Service Model"></a>Network Service Model</h3><p><strong>网络服务模型（network service model）</strong>定义了分组在发送与接收端系统之间的端到端运输特性。</p>
<p>某些分组交换机称为<strong>链路层交换机</strong>（link-layer switch），基于链路层帧中的字段值做出转发决定，这些交换机因此被称为链路层设备；其他分组交换机称为<strong>路由器</strong>（router），基于网络层数据报中的首部字段值做出转发决定，路由器因此是网络层设备。</p>
<p><strong>网络层可能提供的服务</strong></p>
<p>针对单个的数据报 datagram，可提供以下服务</p>
<ul>
<li>Guaranteed delivery 确保交付：确保分组到达目的地。</li>
<li>Guaranteed delivery with bounded delay：最大时延的保证，例如确保主机到主机的时延不超过 40ms</li>
</ul>
<p>针对数据包流(flow of datagrams)，可提供的服务有</p>
<ul>
<li>In-order packet delivery 有序分组交付：按发送顺序到达。</li>
<li>Guaranteed minimal bandwidth 确保最小带宽：当发送主机以低于特定比特率的速率发送比特，分组不会丢失，在一定时延到达。</li>
<li>Security 安全性：网络层可以在源端对所有数据报进行加密，并在目的端进行解密，从而为所有传输层的段提供保密性。</li>
</ul>
<p>互联网的网络层提供了一种单一的服务，称为<strong>尽力而为服务</strong>(best-effort service)。在尽力而为服务中，数据包既不能保证按照发送的顺序被接收，也不能保证最终被送达。没有对端到端延迟的保证，也没有最小带宽的保证。</p>
<article class="message is-info">
        <div class="message-header"><p>QOS</p>
</div>
        <div class="message-body">
            <table>
<thead>
<tr>
<th>QoS 模型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Best Effort</td>
<td>1. 简单，不需要复杂的网络策略或协议。<br>2. 允许数据包在网络中自由流动，无需预设路径。<br>3. 在无拥塞的情况下，可以提供可靠的服务。<br>4. 允许最大的网络效率和成本效益。</td>
<td>1. 不允许资源预留或任何其他与网络特殊处理相关的机制。<br>2. 对于实时（RT）流量需求的新兴应用，表现不佳。<br>3. 当网络资源不足以满足 QoS 应用程序的需求时，不应使用此模型。</td>
</tr>
<tr>
<td>Integrated Services (IntServ)</td>
<td>1. 允许网络流量的个性化处理。<br>2. 使用服务特定的预留协议为特定的数据流预留资源。<br>3. 可以准确预测并保证定义的性能水平。</td>
<td>1. 不可扩展，需要比其他 QoS 模型（如 DiffServ）更多的管理控制。<br>2. 实施此模型需要网络中存在 IntServ 能力的路由器，并使用 RSVP 进行端到端的资源预留。<br>3. 由于 RSVP 是一个软状态协议，持续的信令负载只会加剧可扩展性问题。</td>
</tr>
<tr>
<td>Differentiated Services (DiffServ)</td>
<td>1. 提供一种基于类别的服务，某些类别的流量可以优先于其他流量类别得到处理。<br>2. 适用于大型网络，因为它不需要为每个流量保留网络资源。</td>
<td>1. 不能为每个流量提供精确的 QoS 保证。<br>2. 对于需要高精度 QoS 保证的应用，可能不是最佳选择。</td>
</tr>
</tbody></table>

        </div>
    </article>

<article class="message is-info">
        <div class="message-header"><p>虚电路</p>
</div>
        <div class="message-body">
            <ul>
<li>数据报 网络提供网络层的无连接 服务</li>
<li>虚电路 网络提供网络层的 连接 服务</li>
<li>类比于 TCP&#x2F;UDP 的面向连接&#x2F; 无连接的传输层服务：<ul>
<li>任何网络中的网络层只提供两种服务之一，不会同时提供。</li>
<li>虚电路网络：提供连接服务。</li>
<li>数据报网络：提供无连接服务。</li>
<li>传输层：面向连接服务在网络边缘的端系统中实现。</li>
<li>网络层：面向连接服务在端系统及网络核心的路由器中实现。</li>
</ul>
</li>
</ul>
<p><strong>定义</strong><br><strong>虚电路</strong>(Virtual Circuits)“源主机-目的主机路径的行为类似于电话网络的行为”,性能上类似,沿着源-目的路径的网络行为类似。</p>
<ul>
<li>在数据传输之前，需要为每个呼叫建立连接</li>
<li>每个分组携带 VC 标识符(不是目的主机地址)</li>
<li>位于“源-目的路径”上的每个路由器会维护经过它的每条连接的“状态”</li>
<li>链路和路由器的资源(带宽、缓存)可以被分配给 VC(专用资源)</li>
</ul>
<p><strong>特点</strong><br>虚电路网络源于电话产业界（采用“真正”电路）。<br>呼叫建立及每次呼叫的状态要在网络中的路由器上维持，比面向数据报的网络要复杂。<br>网络功能复杂，端系统设备简单</p>

        </div>
    </article>

<h2 id="What’s-Inside-a-Router"><a href="#What’s-Inside-a-Router" class="headerlink" title="What’s Inside a Router?"></a>What’s Inside a Router?</h2><p>对于一般的路由器来说，它主要包含四个部分<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-06-18-12-09.png" style="zoom:100%;"></p>
<ul>
<li><p><strong>输入端口</strong> (Input Ports)</p>
<ul>
<li>执行物理层功能，终止路由器上的入站物理链接。</li>
<li>执行链路层功能，与入站链接另一侧的链路层进行互操作。</li>
<li>在输入端口执行查找功能，这将在输入端口的最右侧的框中发生。在这里，将查询转发表以确定将通过交换结构转发到哪个路由器输出端口的到达数据包。</li>
<li>控制数据包（例如，携带路由协议信息的数据包）从输入端口转发到路由处理器。</li>
</ul>
</li>
<li><p><strong>交换结构</strong> (Switching Fabric)</p>
<ul>
<li>连接路由器的输入端口和输出端口。</li>
</ul>
</li>
<li><p><strong>输出端口</strong> (Output Ports)</p>
<ul>
<li>存储从交换结构接收的数据包，并执行必要的链路层和物理层功能在出站链接上传输这些数据包。</li>
<li>当链接是双向的时，输出端口通常会与同一线卡上的该链接的输入端口配对。</li>
</ul>
</li>
<li><p><strong>路由处理器</strong> (Routing Processor)</p>
<ul>
<li>执行控制平面 Data Plane 功能</li>
<li>在传统路由器中，它执行路由协议，维护路由表和附加的链路状态信息，并为路由器计算转发表。</li>
<li>在 SDN 路由器中，路由处理器负责与远程控制器通信，以便（在其他活动中）接收由远程控制器计算的转发表条目，并将这些条目安装在路由器的输入端口中。</li>
<li>执行网络管理功能。</li>
</ul>
</li>
</ul>
<h3 id="Input-Port-Processing-and-Destination-Based-Forwarding"><a href="#Input-Port-Processing-and-Destination-Based-Forwarding" class="headerlink" title="Input Port Processing and Destination-Based Forwarding"></a>Input Port Processing and Destination-Based Forwarding</h3><p>路由器输入端口处理的工作流程可以概括如下：</p>
<ol>
<li><p><strong>输入端口处理</strong> 终止路由器上的入站物理链接。路由器根据 forwarding table 来查找输出端口，到达的数据包将通过交换结构转发到该端口。</p>
</li>
<li><p><strong>转发表的更新</strong>：通过路由处理器计算和更新转发表，或者从远程 SDN 控制器接收。</p>
<blockquote>
<p>转发表是通过一个单独的总线（例如，PCI 总线）从路由处理器复制到线卡(line card)上的，每个线卡都有一个转发表的副本，可以在每个输入端口本地做出转发决策，无需在每个数据包都要调用路由处理器，从而避免了集中处理的瓶颈。</p>
</blockquote>
</li>
<li><p><strong>基于目标地址的转发</strong>：在最简单的情况下，即将到达的数据包将被转发到的输出端口是基于数据包的目标地址的。在 32 位 IP 地址的情况下，转发表的暴力实现将为每个可能的目标地址有一个条目。由于可能的地址超过 40 亿个，这个选项完全不可能。</p>
</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-06-18-25-58.png" style="zoom:50%;" alt="Input port processing">

<p>实际上路由器中使用分组目的地址的<strong>前缀</strong>（prefix）与该表中的表项进行匹配，如下图所示：</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-06-18-28-54.png" style="zoom:80%;">

<p>当有多个匹配项目时，该路由器使用<strong>最长前缀匹配规则</strong>（longest prefix matching rule），即在该表中寻找最长的匹配项，并向与最长的前缀匹配先关联的链路接口转发分组。</p>
<table>
<thead>
<tr>
<th align="center">prefix</th>
<th align="center">Link Interface</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>11001000 00010111 00010</code></td>
<td align="center">0</td>
</tr>
<tr>
<td align="center"><code>11001000 00010111 00011000</code></td>
<td align="center">1</td>
</tr>
<tr>
<td align="center"><code>11001000 00010111 00011</code></td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">Otherwise</td>
<td align="center">3</td>
</tr>
</tbody></table>
<blockquote>
<p>一个端系统发送给另一个端系统的一批分组可能在网络中选择不同的路径，到达的顺序可能不一致</p>
</blockquote>
<p>鉴于转发表的存在，查找在概念上很简单 - 硬件逻辑只是在转发表中搜索最长的前缀匹配。在千兆传输速率下，这种查找必须在纳秒内执行,因此，不仅必须在硬件中执行查找，而且需要对大表进行快速查找的算法;还必须特别注意内存访问时间，从而在设计中嵌入式片上 DRAM 和更快的 SRAM（用作 DRAM 缓存）存储器。实践中经常使用<strong>三态内容可寻址存储器</strong>（Tenary Content Address Memory，TCAM）来查找</p>
<h3 id="Switching"><a href="#Switching" class="headerlink" title="Switching"></a>Switching</h3><p>Switch fabric 负责转发功能，完成交换的方式有很多，主要包括下面几种</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-06-21-07-17.png" style="zoom:100%;">

<ul>
<li>Memory<ul>
<li>在 CPU 直接控制下交换的传统计算机,数据交换的执行与传统 IO 设备一致；</li>
<li>数据包复制到 processor memory，processor 从 header 中提取目标地址；</li>
<li>速度受内存带宽限制，交换速度受总线带宽的速度限制 (每个分组穿过两次总线:<code>Input&gt;Memory&gt;Output</code>),故若总线带宽为每秒写入或读出 B 个分组，则总的转发吞吐量 (分组从输入端口被传送到输出端口的总速率)小于 B&#x2F;2</li>
</ul>
</li>
<li>Bus<ul>
<li>输入端口通过一条共享总线将分组直接传送到输出端口，不需要选路处理器的干预。</li>
<li>每次只能有一个分组通过总线传送。<br>分组到达一个输入端口时，若总线正忙，会被暂时阻塞，在输入端口排队</li>
<li>路由器交换带宽受总线速率限制。</li>
</ul>
</li>
<li>Interconnection network<ul>
<li>数据报分割成固定长度信元, 通过交换矩阵来交换信元。到达输入端口的分组沿水平总线穿行，直至与所希望的输出端口的垂直总线交叉点：<ul>
<li>若该条垂直总线空闲，则分组被传送到输出端口；</li>
<li>否则，该到达的分组被阻塞，必须在输入端口排队。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Output-port-processing"><a href="#Output-port-processing" class="headerlink" title="Output port processing"></a>Output port processing</h3><p>取出存放在输出端口内存中的分组，并将其传输到输出链路上。<br>当交换结构将分组交付给输出端口的速率超过输出链路速率，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包。</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-06-21-25-01.png" style="zoom:100%;">

<h3 id="When-Does-Queuing-Occur"><a href="#When-Does-Queuing-Occur" class="headerlink" title="When Does Queuing Occur"></a>When Does Queuing Occur</h3><p>在输入端口和输出端口都可以形成分组队列，随着这些队列的增长，路由器的缓存空间最终将会耗尽，并且当无内存可用于存储到达的分组时将会出现丢包（packet loss）</p>
<h4 id="Input-Queueing"><a href="#Input-Queueing" class="headerlink" title="Input Queueing"></a>Input Queueing</h4><p>当交换结构的速度慢于输入端口的速度，就会在输入端口的缓冲区发生排队,会导致排队延时和由于输入缓冲区溢出导致的丢包<br>线头阻塞（Head-of-the-Line (HOL) blocking）: 在队列前面的被阻塞的数据报会阻止队列中的其他数据报被转发</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-13-26-52.png" style="zoom:100%;">

<h4 id="Output-Queueing"><a href="#Output-Queueing" class="headerlink" title="Output Queueing"></a>Output Queueing</h4><p>当经过交换结构到达的速度超过了输出端口的处理线速就会发生排队,当输出端口的缓冲区溢出时就会发生丢包</p>
<h4 id="Packet-Scheduling"><a href="#Packet-Scheduling" class="headerlink" title="Packet Scheduling"></a>Packet Scheduling</h4><p><strong>FCFS</strong>(FIFO)<br>维护一个 Queue，按照到达顺序依次处理分组</p>
<p><strong>Priority Queuing</strong><br>通常每个 Packet 都有一个优先级，不同优先级的 Packet 被分配到不同的队列中，然后按照优先级顺序处理<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-15-08-43.png" style="zoom:100%;"></p>
<p><strong>Round Robin</strong> and <strong>Weighted Fari Queuing</strong>(WFQ)</p>
<p>Round Robin 轮流服务将需要路由发送的资源进行分类，为每种类别生成自有的一个队列，发送时轮流从队列中选取队首的文件包进行发送。如果轮到某个队列时，该队列为空，则跳过该队列。</p>
<p>这样的服务能保障在各不同类型的网络服务中合理分配资源，不会让某一网络服务占用过大的带宽以至于影响其他的网络服务。比如某个下载程序占用过多网速，致使视频浏览出现卡顿或打开网页速度过慢。</p>
<p>WFQ 是基于 Round Robin 方法改进后而成的。对于某些网络服务，如网络电话或视频直播，为了保障能流畅进行，总是需要保留一定的优先带宽。这样情况下就可以使用 Round Robin 轮流服务的升级版本 Weighted Fair Quequing(WFQ)加权公平队列。其中的思想很简单，轮流服务中已经有了各个公平队列，需要做的就是对一些带宽敏感型服务进行标记并附以相应权重 $w_i$，服务时进行侧重就可以。</p>
<p>WFQ 在发送时仍然轮流从队列中选取队首文件包，但选取的数量根据权重 $w_i$ 确定，权重大的服务在一次发送循环中就能多发送文件包，从而确保相应的服务带宽，保证网络的服务质量。</p>
<h2 id="The-Internet-Protocol-IP-IPv4-Addressing-IPv6-and-More"><a href="#The-Internet-Protocol-IP-IPv4-Addressing-IPv6-and-More" class="headerlink" title="The Internet Protocol (IP): IPv4, Addressing, IPv6, and More"></a>The Internet Protocol (IP): IPv4, Addressing, IPv6, and More</h2><h3 id="IPV4-Datagram-Format"><a href="#IPV4-Datagram-Format" class="headerlink" title="IPV4 Datagram Format"></a>IPV4 Datagram Format</h3><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-15-17-12.png" style="zoom:100%;">

<ul>
<li><strong>版本号</strong>（Version）：4bit。指定了数据报的 IP 协议版本。通过查看版本号，路由器可以确定如何解释 IP 数据报的其余部分。不同版本的 IP 使用不同的数据报格式。</li>
<li><strong>首部长度</strong>（Header length）：确定 IP 数据报中有效载荷,在无选项（Options）首部时，IP 具有 20Byte 的首部；</li>
<li><strong>服务类型</strong>（Type of service）：不同类型的数据报可以相互区分；</li>
<li><strong>数据报长度</strong>（Datagram length）：IP 数据报的总长度（首部加上数据），以字节计数；</li>
<li><strong>标识</strong>（Identifier）、<strong>标志</strong>（Flags）、<strong>分片偏移</strong>（Fragmentation offset）：一个链路层帧能承载的最大数据量叫作最大传送单元（Maximum Transmission Unit，MTU）。每个数据链路有自己的 MTU，链路类型不同，MTU 的值也不同，用于 IP 分片；在因特网中一个大的分组可能在路由器中被分割为几个分片，然后独立转发到目的地，在目的地将它们重新组装，然后将其有效载荷数据。IPV6 不允许分片</li>
<li><strong>生存时间</strong>（Time-to-live，TTL）：确保数据段不会永远在网络中循环；每次数据报被路由器处理时，这个字段就会减 1。如果 TTL 字段达到 0，路由器必须丢弃该数据报。</li>
<li><strong>上层协议</strong>（Upper-layer protocol）：IP 数据报到达最终目的地时使用。这个字段的值指示应该将该 IP 数据报的数据部分传递给特定的传输层协议。例如，值 6 表示数据部分传递给 TCP，而值 17 表示数据传递给 UDP。</li>
<li><strong>首部检验和</strong>（Header checksum）：帮助路由器检测收到的 IP 数据报中的比特错误；</li>
<li><strong>源和目的 IP 地址</strong>（Source and Destination IP address）；</li>
<li><strong>选项</strong>（Options）：允许 IP 首部被扩展；</li>
<li><strong>数据</strong>（Data）：一般为运输层报文段；</li>
</ul>
<h3 id="IPV4-Addressing"><a href="#IPV4-Addressing" class="headerlink" title="IPV4 Addressing"></a>IPV4 Addressing</h3><ul>
<li><strong>IP</strong> 地址: 分配给主机或路由器接口的标识符</li>
<li><strong>接口</strong>: 主机&#x2F;路由器与物理链路之间的边界<ul>
<li>路由器有多个接口</li>
<li>主机可以有多个接口</li>
<li>每个接口有一个 IP 地址</li>
</ul>
</li>
<li><strong>IPV4 和 IPV6</strong><ul>
<li>IPV4：32 bits(4 Bytes)常用点分十进制(dotted-decimal notation)表示；</li>
<li>IPV6：128 bits(16 Bytes)常用冒号分隔表示</li>
</ul>
</li>
</ul>
<p>32 比特的二进制表示和点分十进制表示法<br>将 4 个字节中的每一个字节分别用十进制数来表示，4 个十进制数之间用 <code>.</code> 分隔。<br>例如<code>223.1.1.1 = 11011111 00000001 00000001 00000001</code><br>根据不同的取值范围，早期将 IP 地址分为五类。IP 地址中前 5 位用于标识 IP 地址的类别，A 类地址的第一位为“0”，B 类地址的前两位为“10”，C 类地址的前三位为“110”，D 类地址的前四位为“1110”，E 类地址的前五位为“11110”。其中，A 类、B 类与 C 类地址为基本的 IP 地址。</p>
<ul>
<li>A 类地址：地址范围为 <code>1. 0. 0. 1－127.255.255.254</code>全 0 表示本地地址，全 1 表示在本地网络中向所有机广播</li>
<li>B 类地址：地址范围为 <code>128.0.0.1－191.255.255.254</code></li>
<li>C 类地址：地址范围为 <code>192.0.0.1－223.255.255.254</code></li>
</ul>
<hr>
<p>特殊 IP 地址段</p>
<ul>
<li>本地回环地址<br><code>127.0.0.1-127.255.255.254</code>是预留的一组 IP 地址，主要是用来识别主机本身的地址。也叫做“localhost”，一般用来测试。</li>
<li>私有地址（Private address）<br><code>10.x.x.x,  172.16.x.x-172.31.x.x,  192.168.x.x</code>三个地址段被称为私有 IP 地址段，也就是局域网所使用的地址段，在公网上不能被路由</li>
<li><code>0.0.0.0</code><br>这个地址严格上来说都不是真正意义上的 IP 地址。主要是用来标识不清楚的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到这个地址</li>
<li><code>255.255.255.255</code><br>这个地址是受限的广播地址。主要指一个网段内的所有主机</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-16-18-59.png" style="zoom:80%;">

<p>IP 地址:<br>网络号 (高位 bits):指明主机所在网络的编号<br>主机号 (低位 bits):作为主机在网络中的编号。</p>
<p>网络号相同的 IP 地址属于同一个网络。而网络还可以划分为若干子网（subnet），划分子网的方法是从主机号借用若干个比特作为子网号，剩下的主机位为主机号。</p>
<p>子网 Subnet: 设备接口的 IP 地址具有同样的网络部分;没有路由器的介入，物理上能够相互到达<br>子网掩码 Subnet Mask,子网掩码用来确定网络地址（包括网络号和子网号）和主机地址的长度。子网掩码长为 32 位比特，其中的 1 对应于 IP 地址中的网络号和子网号，而子网掩码中的 0 对应于主机号。有公式</p>
<p>$$ip_address &amp; subnet_mask &#x3D; network_address$$</p>
<p>下图中，一台路由器（具有三个接口）用于互联 7 台主机。</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-17-38-17.png" style="zoom:80%;">

<p>图中左侧的 3 个主机和它们连接的路由器接口，都有一个形如<code>233.1.1.xxx</code>的 IP 地址。用 IP 的术语说，互联这 3 个主机接口与 1 个互联网接口的网络形成一个<strong>子网</strong>（subnet）。IP 编址为这个子网分配一个地址<code>233.1.1.0/24</code>，其中<code>/24</code>记法，指示 32 比特中的最左侧 24 比特定义了子网地址。</p>
<p><strong>使用子网掩码的分组转发</strong><br>不划分子网时，路由表只有两项：目的网络地址和下一跳地址。使用子网划分后，路由表中将包括三项：目的网络地址、子网掩码和下一跳地址。</p>
<p>一个 A 类的 IP 地址，可以有 24bit 用于分配主机地址，因此可以支持$2^24$个主机(注意，实际上可接入主机要-2，因为有 2 个要留给 localhost 和广播地址)，但是一个家庭或者组织往往不需要这么多的地址空间，造成浪费。<br>一个 C 类的 IP 地址，只有 8bit 用于分配主机地址，因此只能支持 256 个主机，又不太够用。因此，按传统 IP 地址分类方式分配 IP 被 CIDR 技术取代</p>
<p>CIDR，也被称为<strong>无类别域间路由选择</strong>（Classless Interdomain Routing，CIDR）, 消除了传统的 A 类、B 类和 C 类地址的概念。使用斜线记法，又称为 CIDR 记法来区分网络前缀和主机号，即在 IP 地址后面加上一个斜线<code>/</code>，斜线后面用一个数字指定网络前缀的长度。CIDR 将网络前缀都相同的连续的 IP 地址组成 CIDR 地址块。<br>一个 CIDR 地址块可以表示分类 IP 的多个分类地址，这种地址的聚合称为路由聚合，又称为<strong>构造超网</strong>(superneting)。</p>
<p>下图为一个示例，</p>
<ul>
<li>ISP 获得地址块的方法——从 <a target="_blank" rel="noopener" href="http://www.icann.org/">ICANN（Internet Corporation for Assigned Names and Numbers）</a><ul>
<li>分配 IP 地址</li>
<li>管理 DNS</li>
<li>分配域名，解决纠纷</li>
</ul>
</li>
<li>组织机构如何获取 IP 地址? 从 ISP 的地址空间中划分一块给申请者</li>
</ul>
<blockquote>
<p>所有的 IP 地址都由 ICANN 规划，然后主要由国际组织 NIC（Network Information Center）具体负责统一分配。<br>目前全世界共有五个这样的网络信息中心(ARIN,LACNIC,RIPE NCC,AFRINIC,APNIC)<br>我国申请 IP 地址要通过 APNIC，APNIC 的总部设在日本东京大学。申请时要考虑申请哪一类的 IP 地址，然后向国内的代理机构提出。</p>
</blockquote>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-18-04-57.png" style="zoom:50%;">

<br>

<article class="message is-info">
        <div class="message-header"><p>隋唐小练</p>
</div>
        <div class="message-body">
            <p><strong>Q</strong><br>现有一公司已获得网络号为 202.1.1.0&#x2F;24,如果该公司有 3 个部门,<br>（1）如果第 1 个部门有 60 台计算机，第二个部门有 20 台计算机，第三个部门有 16 台计算机，问如何分配地址?<br>（2）如果第 1 个部门有 120 台计算机，第 2 个部门有 60 台计算机，第 3 个部门有 60 台计算机，使用上述方法可以分配地址吗？使用 CIDR 方法如何分配地址?<br><strong>A</strong><br>（1）以最多台数的部门（60 台）为准，需要的最接近数为 2^6&#x3D;64，故要从最后个字节借 8-6&#x3D;2 位，<br>子网分别为 <code>202.1.1.0, 202.1.1.64, 202.1.1.128, 202.1.1.192</code>，在这 4 个其中任选 3 个即可。掩码均为 <code>255.255.255.192</code>。<br>（2）部门 1 有 120 台主机，需要用 7bit 表示 subnet host id，这样只剩下 1bit 表示子网。而 TCP&#x2F;IP 协议不允许 subnet id 为全 1 或全 0，因此该策略无法满足。应采用 CIDR 法</p>
<p>首先以最小需求台数部门为准（60 台），此时主机号位数需要 6 位（因为 $60&#x3D;&lt;2^6-2$），则 subnet id 的位数为 8-6&#x3D;2 位，然后将子网划分出来，子网分别为 <code>202.1.1.0, 202.1.1.64, 202.1.1.128, 202.1.1.192</code><br>接下来，部门 2、3 可以直接在 4 个子网中任选两个，部门 1 选剩下 2 个以满足 120 台的要求（但这两个子网要连续，以便用 CIDR 法合并之，做超网）。比如 <code>202.1.1.128、202.1.1.192</code> 分别给部门 2、3，部门 1 用 <code>202.1.1.0、202.1.1.64</code></p>
<p>最后将各部门 IP 段用 CIDR 超网形式描述，以便对外发布：<br>部门 1：202.1.1.0&#x2F;25; (注意含义：表示前 25 位是网络号，且最后一个字节最高位为 0，后面 7 位是主机号)<br>部门 2：202.1.1.128&#x2F;26; (最后一个字节最高两位为 10，后面 6 位是主机号)<br>部门 3：202.1.1.192&#x2F;26; (最后一个字节最高两位为 11，后面 6 位是主机号)</p>
<p>将 202.1.1.128、202.1.1.192 给部门 1，202.1.1.0、202.1.1.64 分别给部门 2、3 亦可。此时答案为：<br>部门 1：202.1.1.0&#x2F;26;<br>部门 2：202.1.1.64&#x2F;26;<br>部门 3：202.1.1.128&#x2F;25</p>

        </div>
    </article>

<article class="message is-danger">
        
        <div class="message-body">
            <p>RFC950 参考规定：第一个子网（也就是“全 0 子网”）和最后一个子网（也就是“全 1 子网”）不可用，为的就是避免全 0 子网的网络地址和全 1 子网的广播地址分别与没有划分子网前的网络地址和广播地址相冲突，按照这种旧规定，2 个子网就要借 2 位，00,11 不能用。  但是在后来 RFC1878 中（CIDR），该项规定已被废止了，现在的设备基本上都普遍支持 RFC1878。尼电课程实验&#x2F;作业&#x2F;考试都基于新标准<br>对于第一个子网，网络地址和主网络的网络地址是重叠的，对于最后一个子网，广播地址和主网络的广播地址也是重叠的。即地址有二义性。因此 RFC950 规定 subnet id 不能全 1 或全 0，但如此一来子网划分的 IP 地址浪费严重。<br>后来 IETF 就研究出了其他一些技术，比如可变长子网掩码 VLSM，该技术是在子网上进一步划分子网，可提高 IP 地址资源的利用率；后来在此基础上研究出了无类别域间路由 CIDR，即消除了传统的 A&#x2F;B&#x2F;C 等分类以及划分子网，才是采用网络前缀和主机号的方式来分配 IP 地址，这使得 IP 地址的利用率更好。</p>

        </div>
    </article>

<h3 id="Obtaining-a-Host-Address-The-Dynamic-Host-Configuration-Protocol"><a href="#Obtaining-a-Host-Address-The-Dynamic-Host-Configuration-Protocol" class="headerlink" title="Obtaining a Host Address: The Dynamic Host Configuration Protocol"></a>Obtaining a Host Address: The Dynamic Host Configuration Protocol</h3><p>主机如何得到 IP 地址?</p>
<ul>
<li>手工指定（保存在系统配置中）<ul>
<li>Windows: 控制面板-&gt;网络</li>
<li>UNIX&#x2F;LINUX: 在&#x2F;etc&#x2F;rc.config 中，可使用 ifconfig 命令配置</li>
</ul>
</li>
<li>DHCP: Dynamic Host Configuration Protocol,自动从一个 DHCP 服务器得到 IP 地址,方便灵活</li>
</ul>
<p><strong>DHCP</strong></p>
<p>DHCP 是应用层协议。其分配的不仅仅是 IP 地址，还可分配：</p>
<ul>
<li>客户的第一跳路由器的地址（网关）</li>
<li>DNS 服务器的 IP 地址或域名</li>
<li>子网掩码</li>
</ul>
<p><strong>报文格式</strong></p>
<ul>
<li><code>OP</code> 若是 client 送给 server 的封包，设为 1，反向为 2；</li>
<li><code>Htype</code> 硬件类别，ethernet 为 1；</li>
<li><code>Hlen</code> 硬件长度，ethernet 为 6；</li>
<li><code>Hops</code> 若数据包需经过 router 传送，每站加 1，若在同一网内，为 0；</li>
<li><code>Transaction</code> ID：事务 ID，是个随机数，用于客户和服务器之间匹配请求和相应消息；</li>
<li><code>Seconds</code> 由用户指定的时间，指开始地址获取和更新进行后的时间；</li>
<li><code>Flags</code> 从 0-15bits，最左一 bit 为 1 时表示 server 将以广播方式传送封包给 client，其余尚未使用；</li>
<li><code>Ciaddr</code> 用户 IP 地址；</li>
<li><code>Yiaddr</code> 客户 IP 地址；</li>
<li><code>Siaddr</code> 用于 bootstrap 过程中的 IP 地址；</li>
<li><code>Giaddr</code> 转发代理（网关）IP 地址；</li>
<li><code>Chaddr</code> client 的硬件地址；</li>
<li><code>Sname</code> 可选 server 的名称，以 0x00 结尾；</li>
<li><code>File</code> 启动文件名；</li>
<li><code>Options</code> ，厂商标识，可选的参数字段</li>
</ul>
<p><strong>Steps</strong></p>
<ol>
<li><p>DHCP 服务器被动打开 UDP 端口 67，等待客户端发来的报文。DHCP 客户端启动时,由于其还未配置 IP 地址,因此只能使用广播方式发送 Dhcpdiscover 包,即该数据包的源地址为 0.0.0.0,目标地址为 255.255.255.255</p>
</li>
<li><p>DHCP 客户从 UDP 端口 68 发送 DHCP Discover 报文。</p>
</li>
<li><p>凡收到 DHCP discover 报文的 DHCP 服务器 都发出 DHCP offer 报文，因此 DHCP 客户 可能收到多个 DHCP offer 报文</p>
</li>
<li><p>DHCP 客户从几个 DHCP 服务器中选择 其中的一个，并向所选择的 DHCP 服务 器发送 DHCP request 报文</p>
</li>
<li><p>被选择的 DHCP 服务器发送确认报文 DHCPACK，客户进入已绑定状态，并可 开始使用得到的临时 IP 地址了<br>DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。</p>
</li>
<li><p>租用期过了一半（T1 时间到），DHCP 发送 request 报文 DHCPREQUEST 要求更新租用期。</p>
</li>
<li><p>DHCP 服务器若不同意，则发回否认报文 DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址（回到步骤 2）</p>
</li>
<li><p>DHCP 服务器若同意，则发回确认报文 DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。若 DHCP 服务器不响应步骤 6 的 request 报文 DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤 6），然后又继续后面的步骤。</p>
</li>
<li><p>DHCP 客户可随时提前终止服务器所提供的 租用期，这时只需向 DHCP 服务器发送释 放报文 DHCPRELEASE 即可。</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-18-50-12.png" style="zoom:50%;"></li>
</ol>
<h3 id="Network-Address-Translation-NAT"><a href="#Network-Address-Translation-NAT" class="headerlink" title="Network Address Translation (NAT)"></a>Network Address Translation (NAT)</h3><p>对于外部网络而言，本地网络中的所有设备只共享一个 IPv4 地址。这样做有以下几点好处：</p>
<ul>
<li>不需要从 ISP 分配一系列地址—— 只要一个 IP 地址用于所有设备</li>
<li>在本地网络，改变设备的 IP 地址不用通知外部世界</li>
<li>可以变更 ISP ，不用改变本地网络的设备的地址</li>
<li>本地网络内部设备不能被外部世界明确寻址，或是不可见 (增加了安全性)</li>
</ul>
<p>但同时，为与外部网络交互，需进行网络地址转换(NAT)，执行 NAT，路由器</p>
<ul>
<li>外出的分组: 把每个外出的分组的 (源 IP 地址, 端口号) 替换为 (NAT IP 地址, 新端口号)</li>
<li>在 NAT 转换表(NAT Translation Table)中记录每个(源 IP 地址, 端口号)到 (NAT IP 地址, 新端口号) 转换配对</li>
<li>进来的分组: 对每个进来的分组，用保存在 NAT 表中的对应的(源 IP 地址, 端口号) 替换分组中的目的域 （NAT IP 地址, 新端口号）</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-19-21-55.png" style="zoom:100%;">

<p>Nat 的一些局限——16bit 端口号使得一个局域网地址可以同时支持 60,000 个并发连接!</p>
<p>NAT 存在争议</p>
<ul>
<li>路由器只应该处理到第三层</li>
<li>违反了端到端主张</li>
<li>应用程序设计者在设计时不得不将 NAT 加以考虑</li>
<li>如 P2P 应用程序</li>
<li>应使用 IPv6 来解决地址短缺问题</li>
</ul>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>Internet Control Message Protocol（ICMP，互联网控制消息协议），负责在网络设备间传递控制与错误信息，确保数据包能够顺利抵达目的地。互联网中丢包、路由错误、网络拥塞等状况时有发生。这时，ICMP 便如同一位经验丰富的“诊断医生”，通过发送特定的消息类型，帮助识别并报告这些网络问题。</p>
<p><strong>ICMP 的基本运作原理</strong><br>ICMP 位于 Internet 协议（IP）之上，属于 TCP&#x2F;IP 协议栈的网络层。它并不直接参与数据的传输，而是作为 IP 协议的一个辅助工具，通过差错报告和询问机制来实现其功能。ICMP 报文通常封装在 IP 数据包内，包含类型、代码和校验和等字段，用以区分不同的消息类型和提供完整性检查。</p>
<p>差错报告：当数据包无法到达目标或遇到其他传输问题时，路由器或主机可以通过发送 ICMP 错误消息（如“目标不可达”、“超时”等）给源主机，告知发生了什么问题。</p>
<table>
<thead>
<tr>
<th>ICMP type</th>
<th>Code</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>echo reply (ping)</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>destination network unreachable</td>
</tr>
<tr>
<td>3</td>
<td>1</td>
<td>destination host unreachable</td>
</tr>
<tr>
<td>3</td>
<td>2</td>
<td>destination protocol unreachable</td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td>destination port unreachable</td>
</tr>
<tr>
<td>3</td>
<td>6</td>
<td>destination network unknown</td>
</tr>
<tr>
<td>3</td>
<td>7</td>
<td>destination host unknown</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>源端抑制 source quench(congestion control)</td>
</tr>
<tr>
<td>8</td>
<td>0</td>
<td>echo request (ping)</td>
</tr>
<tr>
<td>9</td>
<td>0</td>
<td>router advertisement</td>
</tr>
<tr>
<td>10</td>
<td>0</td>
<td>router discovery</td>
</tr>
<tr>
<td>11</td>
<td>0</td>
<td>TTL expired</td>
</tr>
<tr>
<td>12</td>
<td>0</td>
<td>IP header bad</td>
</tr>
</tbody></table>
<p><strong>ICMP 的实用价值</strong><br>网络故障排除：对于网络管理员而言，通过分析 ICMP 反馈的信息，可以迅速定位网络故障，比如判断是网络拥塞还是链路故障导致的数据包丢失。</p>
<p>路径监测与测量：“Traceroute”利用 ICMP 的 TTL（Time to Live）字段递减特性，逐跳追踪数据包的传输路径，帮助理解网络拓扑结构及延迟情况。</p>
<p>可用性检查：“Ping”命令简单有效，成为检测远程主机是否可达的日常工具，广泛应用于网络维护和服务器监控中。</p>
<p>安全考量与限制<br>尽管 ICMP 对网络运维至关重要，但它也存在被滥用的风险，例如用于 DDoS 攻击中的 Smurf 攻击或放大攻击。因此，合理配置防火墙策略，对 ICMP 流量进行适当限制和监控，是保障网络安全的必要措施。</p>
<h3 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h3><ul>
<li>初始动机：<ul>
<li>32-bit IPv4 地址空间即将用尽</li>
</ul>
</li>
<li>其他动机：<ul>
<li>首部格式可帮助加速处理&#x2F;转发</li>
<li>改变首部利于 QoS 要求</li>
</ul>
</li>
<li>IPv6 数据报格式<ul>
<li>固定长度的 40 字节首部</li>
<li>不允许分片</li>
</ul>
</li>
</ul>
<p><strong>IPV6 报文格式</strong><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-20-22-25.png" style="zoom:80%;"></p>
<p>Priority: 表示流中分组的优先级<br>Flowlabel: 表示分组在同一个“stream”中 (“流”的概念尚未完全定义)<br>next hdr(header): 表示数据的上层协议</p>
<p><strong>与 IPv4 区别</strong></p>
<ul>
<li>删掉分片&#x2F;重新组装；</li>
<li>校验和: 全部去掉，减少每一跳的处理时间</li>
<li>虽允许 Option 字段, 但是不是标准首部的一部分，而是用下一个首部域指出</li>
<li>ICMPv6:新版本的 ICMP<br>增加消息类型, 例如“分组太大”<br>多播组管理功能</li>
</ul>
<article class="message is-info">
        
        <div class="message-body">
            <p><strong>IPv4</strong></p>
<p>Pros<br>广泛兼容性：目前互联网上的大多数系统和设备都支持 IPv4，具有极高的兼容性。<br>NAT（网络地址转换）：通过 NAT 技术，多个设备可以共享一个公共 IPv4 地址，缓解了地址不足的问题。<br>成熟度：作为长期使用的标准，IPv4 的技术支持、文档和工具都非常成熟。<br>Cons<br>地址空间有限：只有大约 43 亿个地址，随着互联网设备的激增，地址资源已接近枯竭。<br>复杂的 NAT 使用：虽然 NAT 有助于缓解地址短缺，但它增加了网络的复杂性，可能影响某些应用的端到端通信。<br>安全性：IPv4 本身并未内置强大的安全机制，依赖于外部解决方案如防火墙和 IPsec 来增强安全性。</p>
<hr>
<p><strong>IPv6</strong></p>
<p>Pros<br>巨大的地址空间：拥有 2^128 个地址，几乎解决了地址耗尽的问题，可以为每一台设备分配一个全球唯一的 IP 地址。<br>内置安全：IPv6 集成了 IPsec，提供了端到端的安全性和数据隐私保护，增强了网络通信的安全性。<br>简化网络：减少了对 NAT 的依赖，简化了路由和网络配置，提高了网络的透明度和效率。<br>改进的报头和性能：IPv6 的报头设计更简洁，提高了数据包处理效率；同时，它支持更高效的路由和自动配置功能。<br>Cons<br>普及率：尽管 IPv6 已经存在多年，其在全球范围内的普及和部署速度较慢，部分原因是设备升级和兼容性问题。<br>过渡成本：从 IPv4 向 IPv6 迁移需要投入成本，包括硬件升级、软件改造和人员培训。<br>兼容性问题：早期的设备和一些老旧应用可能不支持 IPv6，需要额外的努力来确保兼容性。</p>

        </div>
    </article>

<p><strong>IPV6 地址表示</strong></p>
<p>在 IPv6 中，地址分为 8 个段来表示，每段共 4 个字符</p>
<ul>
<li><strong>冒号十六进制表示法</strong><br><code>104.220.136.100.255.255.255.255.0.0.18.128.140.10.255.255</code>用冒号十六进制表示为：<br><code>69DC:8864:FFFF:FFFF:0:1280:8C0A:FFFF</code></li>
<li><strong>零压缩表示法</strong><br>多个连续的<code>0</code>可用<code>::</code>替换;当计算机拿到这个压缩后的地址，发现比正常的 128 位少了 n 位，计算机就会试图在::的地方补上 n 个 0，从结果中可以发现，当一个 IPv6 地址被压缩后，如果计算机出现两个或多个::的时候，计算机在将地址还原时，就可能出现多种情况。这将导致计算机还原后的地址不是压缩之前的地址，将导致地址错误，最终通信失败。所以在压缩 IPv6 地址时，<strong>一个地址中只能出现一个</strong><code>::</code><br><code>FF0C:0:0:0:0:0:B1</code>零压缩表示为：<br><code>FF0C::B1</code></li>
</ul>
<p><strong>从 IPV4 到 IPV6 过渡</strong><br>两种推荐方法:<br>双栈：一些路由器具有双重栈 (v6, v4) 能够在两种格式中转换<br>隧道: 在穿过 IPv4 路由器时，IPv6 分组作为 IPv4 分组的负载<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Network/NetworkLayer/Ch4-1NetworkLayer-2024-06-07-20-33-49.png" style="zoom:50%;"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lzr5350109/p/15265403.html">流量控制的相关算法与数据结构——Round Robin 轮流服务，Weighted Fair Quequing(WFQ)加权公平队列与 Leaky Bucket 漏桶限流</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43378689/article/details/111434104">关于子网划分—为什么全 0 全 1 子网号不能使用</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>网络层数据平面 Network Layer:Data Plane</p><p><a href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-1NetworkLayer/">https://efterklang.github.io/UESTC/ComputerNetworking/Ch4-1NetworkLayer/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Efterklang</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-03-27</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-06-16</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/UESTC/DataBase/Ch3-DbSQL/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">ChⅢ-数据库操作SQL语言</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Dev/Java/Java%20Reflection/"><span class="level-item">Java Reflection</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.30/dist/twikoo.all.min.js"></script><script>twikoo.init({
            envId: 'https://efterklang-twikoo.hf.space',
            
            lang: "en",
            onCommentLoaded: function () {
              var commentContents = document.getElementsByClassName('tk-content');
              for (var i = 0; i < commentContents.length; i++) {
                var commentItem = commentContents[i];
                var imgEls = commentItem.getElementsByTagName('img');
                if (imgEls.length > 0) {
                  for (var j = 0; j < imgEls.length; j++) {
                    var imgEl = imgEls[j];
                    var aEl = document.createElement('a');
                    aEl.setAttribute('class', 'tk-lg-link');
                    aEl.setAttribute('href', imgEl.getAttribute('src'));
                    aEl.setAttribute('data-src', imgEl.getAttribute('src'));
                    aEl.appendChild(imgEl.cloneNode(false));
                    imgEl.parentNode.insertBefore(aEl, imgEl.nextSibling);
                    imgEl.remove();
                  }
                  if (typeof $.fn.lightGallery === 'function') {
                    $(commentItem).lightGallery({
                      selector: '.tk-lg-link'
                    });
                  }
                }
              }
            }
        });</script></div></div></div><style>.column.column-left,.column.column-right{display:none}</style><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Overview-of-Network-Layer"><span class="level-left"><span class="level-item">1</span><span class="level-item">Overview of Network Layer</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Forwarding-and-Routing-The-Data-Plane-and-Control-Plane"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Forwarding and Routing: The Data Plane and Control Plane</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Control-Plane-The-Traditional-Approach"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">Control Plane: The Traditional Approach</span></span></a></li><li><a class="level is-mobile" href="#Control-Plane-The-SDN-Approach"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">Control Plane: The SDN Approach</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Network-Service-Model"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Network Service Model</span></span></a></li></ul></li><li><a class="level is-mobile" href="#What’s-Inside-a-Router"><span class="level-left"><span class="level-item">2</span><span class="level-item">What’s Inside a Router?</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Input-Port-Processing-and-Destination-Based-Forwarding"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">Input Port Processing and Destination-Based Forwarding</span></span></a></li><li><a class="level is-mobile" href="#Switching"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Switching</span></span></a></li><li><a class="level is-mobile" href="#Output-port-processing"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Output port processing</span></span></a></li><li><a class="level is-mobile" href="#When-Does-Queuing-Occur"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">When Does Queuing Occur</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Input-Queueing"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">Input Queueing</span></span></a></li><li><a class="level is-mobile" href="#Output-Queueing"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">Output Queueing</span></span></a></li><li><a class="level is-mobile" href="#Packet-Scheduling"><span class="level-left"><span class="level-item">2.4.3</span><span class="level-item">Packet Scheduling</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#The-Internet-Protocol-IP-IPv4-Addressing-IPv6-and-More"><span class="level-left"><span class="level-item">3</span><span class="level-item">The Internet Protocol (IP): IPv4, Addressing, IPv6, and More</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#IPV4-Datagram-Format"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">IPV4 Datagram Format</span></span></a></li><li><a class="level is-mobile" href="#IPV4-Addressing"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">IPV4 Addressing</span></span></a></li><li><a class="level is-mobile" href="#Obtaining-a-Host-Address-The-Dynamic-Host-Configuration-Protocol"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Obtaining a Host Address: The Dynamic Host Configuration Protocol</span></span></a></li><li><a class="level is-mobile" href="#Network-Address-Translation-NAT"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Network Address Translation (NAT)</span></span></a></li><li><a class="level is-mobile" href="#ICMP"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">ICMP</span></span></a></li><li><a class="level is-mobile" href="#IPV6"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">IPV6</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Ref"><span class="level-left"><span class="level-item">4</span><span class="level-item">Ref</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Dev/"><span class="level-start"><span class="level-item">Dev</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/Dev/DataBase/"><span class="level-start"><span class="level-item">DataBase</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Others/"><span class="level-start"><span class="level-item">Others</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Essay/"><span class="level-start"><span class="level-item">Essay</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Essay/Game/"><span class="level-start"><span class="level-item">Game</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Essay/Poems/"><span class="level-start"><span class="level-item">Poems</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/UESTC/"><span class="level-start"><span class="level-item">UESTC</span></span><span class="level-end"><span class="level-item tag">39</span></span></a><ul><li><a class="level is-mobile" href="/categories/UESTC/ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">ARM处理器体系结构及应用</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">数据库原理及应用</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">April 2024</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a><p class="is-size-7"><span>&copy; 2024 Efterklang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>
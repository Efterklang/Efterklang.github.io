<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>套接字编程 Socket Programming - Efterklang</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Efterklang"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Efterklang"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="掌握字节序、内存对齐等计算机网络编程相关基础知识 理解Socket基本概念以及TCP&amp;#x2F;UDP Socket编程基本模式 理解客户端、服务器程序设计的核心问题与解决思路 能够按需设计实现简单循环服务器、多进程、多线程以及基于I&amp;#x2F;O复用的并发服务器。"><meta property="og:type" content="article"><meta property="og:title" content="套接字编程 Socket Programming"><meta property="og:url" content="https://efterklang.github.io/UESTC/ComputerNetworking/Ch7-SocketProgramming/"><meta property="og:site_name" content="Efterklang"><meta property="og:description" content="掌握字节序、内存对齐等计算机网络编程相关基础知识 理解Socket基本概念以及TCP&amp;#x2F;UDP Socket编程基本模式 理解客户端、服务器程序设计的核心问题与解决思路 能够按需设计实现简单循环服务器、多进程、多线程以及基于I&amp;#x2F;O复用的并发服务器。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://efterklang.github.io/img/thumbnails/Networks/socket_programming.png"><meta property="article:published_time" content="2024-06-15T05:18:50.000Z"><meta property="article:modified_time" content="2024-06-16T08:53:32.036Z"><meta property="article:author" content="Efterklang"><meta property="article:tag" content="Linux"><meta property="article:tag" content="计算机网络"><meta property="article:tag" content="OS"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://efterklang.github.io/img/thumbnails/Networks/socket_programming.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://efterklang.github.io/"},"headline":"套接字编程 Socket Programming","image":["https://efterklang.github.io/img/thumbnails/Networks/socket_programming.png"],"datePublished":"2024-06-15T05:18:50.000Z","dateModified":"2024-06-16T08:53:32.036Z","author":{"@type":"Person","name":"efterklang"},"publisher":{"@type":"Organization","name":"Efterklang","logo":{"@type":"ImageObject","url":{"light":"/img/sunflower.png","dark":"/img/sunflower.png"}}},"description":"掌握字节序、内存对齐等计算机网络编程相关基础知识 理解Socket基本概念以及TCP&#x2F;UDP Socket编程基本模式 理解客户端、服务器程序设计的核心问题与解决思路 能够按需设计实现简单循环服务器、多进程、多线程以及基于I&#x2F;O复用的并发服务器。"}</script><link rel="canonical" href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch7-SocketProgramming/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/tokyo-night-dark.css"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><meta name="msvalidate.01" content="039770FFD6F5D1B53B42B9D3271EA9B9"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-HKYTDLW5FP" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-HKYTDLW5FP');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Efterklang" type="application/atom+xml">
</head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/gallery">Gallery</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a><a class="navbar-item" href="/onedrive">Onedrive</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="github" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/thumbnails/Networks/socket_programming.png" alt="套接字编程 Socket Programming" referrerpolicy="no-referrer"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-06-15T05:18:50.000Z" title="6/15/2024, 1:18:50 PM">2024-06-15</time></span><span class="level-item"><a class="link-muted" href="/categories/UESTC/">UESTC</a><span> / </span><a class="link-muted" href="/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="level-item">36 minutes read (About 5393 words)</span><span class="level-item leancloud_visitors" id="/UESTC/ComputerNetworking/Ch7-SocketProgramming/" data-flag-title="套接字编程 Socket Programming"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">套接字编程 Socket Programming</h1><div class="content"><h2 id="网络编程相关基础知识"><a href="#网络编程相关基础知识" class="headerlink" title="网络编程相关基础知识"></a>网络编程相关基础知识</h2><h3 id="Endianness"><a href="#Endianness" class="headerlink" title="Endianness"></a>Endianness</h3><p><strong>字节</strong>(Byte) 传输和存储信息的最小单位。各种数据类型，都是由字节构成。</p>
<p><strong>字节序</strong>（Endianness）是指在计算机内存中多字节数据类型的存储方式，主要涉及到高位字节和低位字节的排列顺序。字节序主要分为两大类：大端字节序（Big-Endian）和小端字节序（Little-Endian），另外还有较少使用的中端字节序（Middle-Endian）</p>
<h4 id="Big-Endian"><a href="#Big-Endian" class="headerlink" title="Big-Endian"></a>Big-Endian</h4><p>在大端字节序中，数据的高位字节存储在内存的低地址处，而低位字节存储在高地址处。这种存储方式与我们日常书写数字的习惯相匹配，即从左至右，高位在前，低位在后。例如，对于 32 位整数 0x12345678，在大端字节序下的内存布局为：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址递增方向 --&gt;</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">| 0x12   | 0x34   | 0x56   | 0x78   |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure>

<h4 id="Little-Endian"><a href="#Little-Endian" class="headerlink" title="Little-Endian"></a>Little-Endian</h4><p>小端字节序则相反，低位字节存储在内存的低地址处，高位字节存储在高地址处。这是大多数现代个人电脑和嵌入式系统的处理器所采用的方式，如 x86 架构。对于同样的 32 位整数 0x12345678，在小端字节序下的内存布局为：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址递增方向 --&gt;</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">| 0x78   | 0x56   | 0x34   | 0x12   |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure>

<h4 id="Network-Endian"><a href="#Network-Endian" class="headerlink" title="Network-Endian"></a>Network-Endian</h4><p>由于不同机器可能采用不同的字节序，为了正确的传输数据，需要一个统一的标准。因此数据在网络中传输时，需要转换为<strong>网络字节序 Network-Endian</strong>。</p>
<ul>
<li>网络字节顺序是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。</li>
<li>网络字节顺序采用 Big-Endian 排序方式，总是从低位地址开始传输。</li>
<li>发送数据包时，程序将主机字节序转换为网络字节序；接受收数据包时，则将网络字节序转换为主机字节序。</li>
</ul>
<h4 id="字节序变换"><a href="#字节序变换" class="headerlink" title="字节序变换"></a>字节序变换</h4><p>如何检查主机字节序？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">short</span>   s;</span><br><span class="line">        <span class="type">char</span>    c[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125; un;</span><br><span class="line">    un.s = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">short</span>) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (un.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;big-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (un.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;little-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknown\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sizeof(short) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节序的变换函数<br>为了保持源代码的可移植性，提供了字节序变换函数<a target="_blank" rel="noopener" href="https://linux.die.net/man/3/htons">htons(3) - Linux man page</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 主机字节序变为网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span>  <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span><br><span class="line"><span class="comment">// 网络字节序变为主机字节序</span></span><br><span class="line"><span class="type">uint16_t</span>  <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">ntohl</span><span class="params">(<span class="type">uint16_t</span> netlong)</span></span><br></pre></td></tr></table></figure>

<article class="message is-info">
        
        <div class="message-body">
            <p><span class="heimu">C 函数库特有高浓度缩写，初见实在令人发指</span></p>
<p><code>htons</code> : host to network short<br><code>htonl</code> : host to network long<br><code>ntohs</code> : network to host short<br><code>ntohl</code> : network to host long</p>

        </div>
    </article>

<p>标准库中通常只提供 16 位（htons）和 32 位（htonl）字节序转换函数的实现,下面是<code>long long</code>的字节序转换函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//htonll,ntohll</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">htonll</span><span class="params">(<span class="type">uint64_t</span> hostlonglong)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="type">uint64_t</span>) htonl(hostlonglong)) &lt;&lt; <span class="number">32</span>) + htonl(hostlonglong &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">ntohll</span><span class="params">(<span class="type">uint64_t</span> networklonglong)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="type">uint64_t</span>) ntohl(networklonglong)) &lt;&lt; <span class="number">32</span>) + ntohl(networklonglong &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处以一个实例演示<code>htonll</code>的工作流程，假设本地为小段模式，<code>12 34 56 78</code>存储形式为<code>78,56,34,12</code><br><code>htonl(hostlonglong)</code>即<code>htonl(78563412)</code>，参数为 long long 越界，返回结果为 1234，转成 long long 后左移 32 位<br><code>htonl(hostlonglong &gt;&gt; 32)</code>即<code>htonl(7856)</code>，返回 5678<br>两者相加得到<code>12 34 56 78</code>，成功转为大端模式，即网络序</p>
<h3 id="Data-Alignment"><a href="#Data-Alignment" class="headerlink" title="Data Alignment"></a>Data Alignment</h3><p><strong>数据结构对齐</strong>是操作系统为了快速访问内存⽽采取的⼀种策略，简单来说，就是为了防止内存的⼆次访问。操作系统在访问内存时，每次读取⼀定的长度（这个长度就是操作系统的默认对齐系数，或者是默认对齐系数的整数倍）。如果没有内存对齐时，为了读取⼀个变量，会产⽣内存的⼆次访问。<br>平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的。<br>数据结构对齐，是由编译器对代码进行处理来实现。<br>计算机网络编程中，要合理设计数据结构，保证必要的对齐。</p>
<p><strong>对齐系数</strong></p>
<ul>
<li>每个特定平台的编译器都有自己的默认“对齐系数” 。</li>
<li>通过预编译命令<code>#pragma pack(n)</code>，n&#x3D;1,2,4,8,16 来改变这一系数，其中的 n 就是指定的“对齐系数”。</li>
</ul>
<p><strong>结构体对齐规则</strong>：<br>结构体变量的首地址能够被其<em>最宽基本类型成员</em>的大小所整除；<br>结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；<br>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</p>
<article class="message is-info">
        
        <div class="message-body">
            <p>在 64 位的 Linux 机器上，以下结构到底 size 多少？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X2</span> &#123;</span> <span class="type">char</span> a; <span class="type">int</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X3</span> &#123;</span> <span class="type">int</span> a; <span class="type">char</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X4</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X5</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X6</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X7</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X8</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> <span class="type">long</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X9</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> <span class="type">long</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X10</span> &#123;</span> <span class="type">char</span> a; <span class="type">int</span> b; <span class="type">short</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X11</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; <span class="type">char</span> c; <span class="type">int</span> d; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>struct X2: 包含 1 字节的 char，4 字节的 int，和 1 字节的 char。整体需要 4 字节对齐（因为 int），所以 char a 之后会有 3 字节填充。总大小 &#x3D; 1 (a) + 3 (padding for a) + 4 (b) + 1 (c) &#x3D; 9 字节，但为了满足 4 字节对齐，末尾还需补足到 4 字节的倍数，最终大小为 12 字节。</p>
<p>struct X3: 包含 4 字节的 int 和 1 字节的 char。整体需要 4 字节对齐，char b 之后会有 3 字节填充。总大小 &#x3D; 4 (a) + 1 (b) + 3 (padding for b) &#x3D; 8 字节。</p>
<p>…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X2</span> &#123;</span> <span class="type">char</span> a; <span class="type">int</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X3</span> &#123;</span> <span class="type">int</span> a; <span class="type">char</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X4</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X5</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X6</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X7</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X8</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> <span class="type">long</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X9</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> <span class="type">long</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X10</span> &#123;</span> <span class="type">char</span> a; <span class="type">int</span> b; <span class="type">short</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X11</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; <span class="type">char</span> c; <span class="type">int</span> d; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X2: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X3: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X3));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X4: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X4));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X5: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X5));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X6: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X6));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X7: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X7));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X8: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X8));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X9: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X9));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X10: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X10));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X11: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X11));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~&gt; ./a.out</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X2</span>:</span> <span class="number">12</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X3</span>:</span> <span class="number">8</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X4</span>:</span> <span class="number">4</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X5</span>:</span> <span class="number">6</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X6</span>:</span> <span class="number">16</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X7</span>:</span> <span class="number">24</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X8</span>:</span> <span class="number">16</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X9</span>:</span> <span class="number">24</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X10</span>:</span> <span class="number">12</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X11</span>:</span> <span class="number">12</span> bytes</span><br></pre></td></tr></table></figure>

        </div>
    </article>

<h3 id="接口协议"><a href="#接口协议" class="headerlink" title="接口协议"></a>接口协议</h3><ul>
<li>TCP&#x2F;IP 协议存在于 OS 中，网络服务通过 OS 提供</li>
<li>TCP&#x2F;IP 要尽量避免让接口使用某一个厂商的 OS 中特有的特征（而其他厂商没有）</li>
<li>TCP&#x2F;IP 和应用程序之间的接口应该不精确指明：<ul>
<li>不规定接口的细节</li>
<li>只建议需要的功能集</li>
<li>允许系统设计者选择有关 API 的具体实现细节</li>
</ul>
</li>
</ul>
<p>不精确指明的协议接口有以下 Pros&amp;Cons</p>
<ul>
<li>优点：提供了灵活性和容错能力<ul>
<li>便于各种 OS 实现 TCP&#x2F;IP</li>
<li>接口可以是过程的，也可以是消息的</li>
</ul>
</li>
<li>缺点：不同的 OS 中的接口细节不同<ul>
<li>移植性差</li>
<li>程序员需要重新学习接口知识</li>
</ul>
</li>
<li>接口协议举例：<ul>
<li>Berkeley UNIX 中的套接字接口</li>
<li>Microsoft Windows 中的 Windows Socket</li>
</ul>
</li>
</ul>
<p><strong>接口协议的功能</strong></p>
<ul>
<li>分配用于通信的本地资源</li>
<li>指定本地和远程通信端点</li>
<li>（客户端）启动连接</li>
<li>（客户端）发送数据报</li>
<li>（服务器端）等待连接到来</li>
<li>发送或者接收数据</li>
<li>判断数据何时达</li>
<li>产生紧急数据</li>
<li>处理到来的紧急数据</li>
<li>从容终止连接</li>
<li>处理来自远程端点的连接终止</li>
<li>异常终止通信</li>
<li>处理错误条件或者连接异常终止</li>
<li>连接结束后释放本地资源</li>
</ul>
<h4 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h4><ul>
<li>POSIX 表示可移植操作系统接口<ul>
<li>Portable Operating System Interface of UNIX（缩写为 POSIX ）</li>
<li>POSIX 标准定义了操作系统应该为应用程序提供的接口标准，是 IEEE 为要在各种 UNIX 操作系统上运行的软件而定义的一系列 API 标准的总称，其正式称呼为 IEEE 1003，而国际标准名称为 ISO&#x2F;IEC 9945。</li>
</ul>
</li>
<li>POSIX 标准意在期望获得源代码级别的软件可移植性。<ul>
<li>为一个 POSIX 兼容的操作系统编写的程序，应该可以在任何其它的 POSIX 操作系统（即使是来自另一个厂商）上编译执行。</li>
</ul>
</li>
<li>POSIX 并不局限于 UNIX<ul>
<li>许多其它的操作系统，例如 DEC OpenVMS 也支持 POSIX 标准。</li>
</ul>
</li>
</ul>
<h4 id="System-Call"><a href="#System-Call" class="headerlink" title="System Call"></a>System Call</h4><ul>
<li>操作系统内核提供一系列具备预定功能的内核函数，通过称为系统调用(System Call)的接口呈现给用户。</li>
<li>为安全考量，诸如 I&#x2F;O 操作等特权指令被限制在内核态模式执行</li>
<li>系统调用使得应用程序从操作系统获得服务。</li>
</ul>
<h4 id="LINUX-中提供的基本-I-O-功能"><a href="#LINUX-中提供的基本-I-O-功能" class="headerlink" title="LINUX 中提供的基本 I&#x2F;O 功能"></a>LINUX 中提供的基本 I&#x2F;O 功能</h4><article class="message is-info">
        
        <div class="message-body">
            <p>六个基本的系统 I&#x2F;O 函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Open</td>
<td>为输入或输出操作准备一个设备或者文件</td>
</tr>
<tr>
<td>Close</td>
<td>终止使用以前已打开的设备或者文件</td>
</tr>
<tr>
<td>Read</td>
<td>从输入设备或者文件中得到数据</td>
</tr>
<tr>
<td>Write</td>
<td>数据从应用程序存储器传到设备或文件中</td>
</tr>
<tr>
<td>Lseek</td>
<td>转到文件或者设备中的某个指定位置</td>
</tr>
<tr>
<td>loctl</td>
<td>控制设备或者用于访问该设备的软件</td>
</tr>
</tbody></table>

        </div>
    </article>

<p>[[Ch7-1LinuxUnix#文件 I&#x2F;O]]</p>
<ul>
<li>扩展文件描述符，可用于网络通信</li>
<li>扩展 read,write，可用于操作网络标识符</li>
<li>额外功能的处理，通过增加新系统调用实现：<ul>
<li>使用 TCP 还是 UDP</li>
<li>指明本地和远端的端口，远程 IP 地址</li>
<li>启动传输还是等待传入连接</li>
<li>可以接受多少传入连接</li>
<li>传输 UDP 数据</li>
</ul>
</li>
</ul>
<h3 id="Socket-基本概念"><a href="#Socket-基本概念" class="headerlink" title="Socket 基本概念"></a>Socket 基本概念</h3><p><strong>协议操作接口，而非协议本身</strong><br>Socket 是一个主机本地应用程序所创建的, 为操作系统所控制的接口， Client&#x2F;server 模式的通信接口。<br>应用进程通过这个接口,使用传输层提供的服务, 跨网络发送(&#x2F;接收)消息到(&#x2F;从)其他应用进程</p>
<blockquote>
<p><strong>Berkeley UNIX Sockets API</strong><br>ARPA 要求伯克利分校将 TCP&#x2F;IP 移植到 UNIX 中，需要创建一个接口，便于应用程序使用这个接口进行网络通信尽可能使用现有的系统调用，称为 BSD UNIX 套接字，成为事实上的标准<br><em>BSD，Berkeley Software Distribution</em></p>
</blockquote>
<h4 id="主动-Socket-和被动-Socket"><a href="#主动-Socket-和被动-Socket" class="headerlink" title="主动 Socket 和被动 Socket"></a>主动 Socket 和被动 Socket</h4><ul>
<li>创建方式相同，使用方式不同<ul>
<li>被动：等待传入连接的套接字，如服务器套接字</li>
<li>主动：发起连接的套接字，如客户端套接字</li>
</ul>
</li>
<li>指明端到端地址：创建时不指定，使用时指明（TCP&#x2F;IP 需要指明协议端口号和 IP 地址）<ul>
<li>TCP&#x2F;IP 协议族：PF_INET</li>
<li>TCP&#x2F;IP 地址族：AF_INET<br>（PF 是 protocol family，AF 是 address family，TCP&#x2F;IP 套接字设计者认为可能某个协议族有多种形式的地址，所以在 API 上把它们分开了，创建 socket 用 PF，bind&#x2F;connect 用 AF。但如今一个 PF 只有一个 AF，从来没有过例外，所以可混用）</li>
</ul>
</li>
</ul>
<h4 id="Socket-类型"><a href="#Socket-类型" class="headerlink" title="Socket 类型"></a>Socket 类型</h4><ul>
<li>套接字支持多种通信协议：<ul>
<li>Unix： Unix 系统内部协议</li>
<li>INET： IP 版本 4</li>
<li>INET6：IP 版本 6</li>
</ul>
</li>
<li>套接字类型，即应用程序希望的通信服务类型<ul>
<li>SOCKET_DGRAM： 双向不可靠数据报，对应 UDP；DGRAM 即 datagram</li>
<li>SOCKET_STREAM：双向可靠数据流，对应 TCP</li>
<li>SOCKET_RAW：低于传输层的低级协议或物理网络提供的套接字类型，可以访问内部网络接口。</li>
</ul>
</li>
</ul>
<h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p><strong>Socket 通用地址结构 sockaddr</strong></p>
<ul>
<li>Socket 是传输层&#x2F;网络层编程接口，由于传输层&#x2F;网络层的各种实现不同，可能会有不同的编址方案。通用地址为了适应这种需求而定义。</li>
<li>通用地址有很大局限性，实际并不具有通用性，例如针对 AF_INET6&#x2F;AF_LOCAL 类型的 Socket 地址，sockaddr 结构实际上只能标识出这个地址的类型。</li>
</ul>
<p><strong>Socket IPv4 IPv6 地址结构与通用结构</strong></p>
<ul>
<li>早期 sockaddr 只包含 2 个字节的 sa_family 和后面的 14 个字节的 data，后来为了 OSI 兼容性，第一个字节变为长度 len，值为 16，相应的，sa_family 变为 1 个字节；</li>
<li>如今 sockaddr 仅在 bind 等函数里，传递参数时强制类型转换使用，其它没啥用途（因为早期的 C 没有 void 指针，即通用指针，所以搞得那么麻烦）；</li>
<li>Ipv4 用的是 sockaddr_in，里面的 len 和 sockaddr 的 len 一样含义；sa_family 改名为 sin_family，值为 AF_INET 了</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-15-16-55-31.png" style="zoom:80%;">

<p><strong>地址转换函数</strong></p>
<p>人们习惯使用 202.112.14.151 表示地址（点分十进制），但是这个本质是一个字符串而不是数值，因此在 socket 编程时，需要进行转换。此外还要考虑字节序的问题，为此可以使用如下一些函数：</p>
<blockquote>
<p>inet_aton 这堆函数，仅在处理网络参数时使用，比如 IP 地址，端口等。而在用 I&#x2F;O 函数接收发送数据时，不用考虑字节序问题，OS 自动处理。</p>
</blockquote>
<article class="message is-info">
        
        <div class="message-body">
            <p>函数中的 Aton 指阿托恩，是古埃及信奉的太阳神 <span class="heimu"> address to network address</span><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-15-17-16-24.png" style="zoom:50%;"></p>

        </div>
    </article>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回：1-串有效，0-串有错</span></span><br><span class="line"><span class="comment">// inet_aton函数将cp所指的字符串转换成32位的网络字节序二进制，并通过指针inp来存储。这个函数需要对字符串所指的地址进行有效性验证。但如果cp为空，函数仍然成功，但不存储任何结果。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span></span><br><span class="line"><span class="comment">//inet_addr进行相同的转换，但不进行有效性验证，也就是说，所有232种可能的二进制值对inet_addr函数都是有效的——过时函数，不应再使用</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：指向点分十进制数串的指针</span></span><br><span class="line"><span class="comment">// 函数inet_ntoa将32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。但由于返回值所指向的串留在静态内存中，这意味着函数是不可重入的。</span></span><br><span class="line"><span class="comment">// 需要注意的是这个函数是以结构为参数，而不是指针。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span><br></pre></td></tr></table></figure>

<p>上述三个地址转换函数都只能处理 IPv4 协议，而不能处理 IPv6 地址。在同时要处理 IPv4 和 v6 的程序中，建议使用以下两个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回：1-成功，0－输入无效，-1:出错</span></span><br><span class="line"><span class="comment">// 将src指向的字符串转换成二进制地址数值放到dst中。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span><br><span class="line"><span class="title function_">inet_pton</span><span class="params">(AF_INET, <span class="string">&quot;192.168.1.1&quot;</span>, &amp;srv_addr.sin_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：指向结果的指针－－成功，NULL－出错</span></span><br><span class="line"><span class="comment">// 和pton做相反的操作。</span></span><br><span class="line"><span class="comment">// family参数可以是AF_INET,也可以是AF_INET6。</span></span><br><span class="line"><span class="comment">// 如果长度参数cnt太小，无法容纳表达式格式结果，则返回一个空串。另外，目标指针dst调用前必须先由调用者分配空间。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">size_t</span> cnt)</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;[srv] server[%s:%d] is initializing!\n&quot;</span>, inet_ntoa(srv_addr.sin_addr),</span></span><br><span class="line"><span class="params">            ntohs(srv_addr.sin_port))</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面两个函数名称可以分解为两部分来理解其含义<br><code>inet</code>: 这个前缀来源于“Internet”，表明这个函数是与互联网相关的，特别是与 IP 地址处理有关。在套接字编程的上下文中，“inet”通常指代与互联网协议相关的函数或操作。<br><code>pton</code>: 是“Presentation to Network”的缩写，意味着该函数将人类可读的表示形式（即“Presentation”层的数据，如 IP 地址的点分十进制字符串形式）转换为适合在网络上传输的二进制格式（即“Network”层的数据）。简而言之，“pton”类型的函数负责从应用层的表示形式转换到网络层的传输格式。</p>
</blockquote>
<h2 id="Socket-套接字与循环服务器"><a href="#Socket-套接字与循环服务器" class="headerlink" title="Socket 套接字与循环服务器"></a>Socket 套接字与循环服务器</h2><h3 id="简单-TCP-循环服务器-Socket-编程基本步骤"><a href="#简单-TCP-循环服务器-Socket-编程基本步骤" class="headerlink" title="简单 TCP 循环服务器 Socket 编程基本步骤"></a>简单 TCP 循环服务器 Socket 编程基本步骤</h3><div class="tabs my-3 is-small is-fullwidth">
        <ul class="mx-0 my-0">
            <li class="is-active">
          <a href="#1">
              <p>Server</p>

          </a>
      </li><li>
          <a href="#2">
              <p>Client</p>

          </a>
      </li>
        </ul>
    </div>
    <div id="1" class="tab-content">
          <ol>
<li>创建套接字</li>
<li>绑定套接字</li>
<li>设置套接字为监听模式，进入被动接受连接状态</li>
<li>接受请求，建立连接</li>
<li>读写数据</li>
<li>终止连接</li>
</ol>

      </div><div id="2" class="tab-content is-hidden">
          <ol>
<li>创建套接字</li>
<li>与远程服务器建立连接</li>
<li>读写数据</li>
<li>终止连接</li>
</ol>

      </div>

<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-15-18-47-00.png" style="zoom:50%;">

<h3 id="简单-UDP-循环服务器-Socket-编程基本步骤"><a href="#简单-UDP-循环服务器-Socket-编程基本步骤" class="headerlink" title="简单 UDP 循环服务器 Socket 编程基本步骤"></a>简单 UDP 循环服务器 Socket 编程基本步骤</h3><div class="tabs my-3 is-small is-fullwidth">
        <ul class="mx-0 my-0">
            <li class="is-active">
          <a href="#3">
              <p>server</p>

          </a>
      </li><li>
          <a href="#4">
              <p>client</p>

          </a>
      </li>
        </ul>
    </div>
    <div id="3" class="tab-content">
          <ol>
<li>建立 UDP 套接字；</li>
<li>绑定套接字到特定地址；</li>
<li>等待并接收客户端信息；</li>
<li>处理客户端请求；</li>
<li>发送信息回客户端；</li>
<li>关闭套接字；</li>
</ol>

      </div><div id="4" class="tab-content is-hidden">
          <ol>
<li>建立 UDP 套接字；</li>
<li>发送信息给服务器；</li>
<li>接收来自服务器的信息；</li>
<li>关闭套接字</li>
</ol>

      </div>

<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-15-18-59-34.png" style="zoom:50%;">

<h3 id="Socket-核心函数"><a href="#Socket-核心函数" class="headerlink" title="Socket 核心函数"></a>Socket 核心函数</h3><h4 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h4><p>功能：创建一个新的套接字，返回套接字描述符<br>参数：</p>
<ul>
<li><code>family</code>：指明使用的协议栈，如 TCP&#x2F;IP 使用的是 PF_INET 或 AF_INET</li>
<li><code>type</code>: 指明需要的服务类型, 如：</li>
<li><code>SOCK_DGRAM</code>，数据报服务，UDP 协议</li>
<li><code>SOCK_STREAM </code>，流服务，TCP 协议</li>
<li><code>protocol</code>：IP 报头中的协议字段，一般取 0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span> <span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">// returns: non-negative descriptor if OK, -1 on error</span></span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>功能：将 socket 与本地 address 关联，指定这个套接字应该监听哪个 IP 地址上的哪个端口传入的连接请求<br>TCP&#x2F;IP 协议使用 sockaddr_in 结构，包含 IP 地址和端口号,服务器使用它来指明 Well Known 端口号，然后等待连接<br>参数：</p>
<ul>
<li><code>sockfd</code>，Socket File Descriptor，套接字描述符，指明创建连接的套接字</li>
<li><code>myaddr</code>，本地地址，IP 地址和端口号</li>
<li><code>addrlen</code> ，地址长度</li>
</ul>
<blockquote>
<p><span class="heimu">你可能会疑惑，fd 是什么鬼(╬▔ 皿 ▔)╯</span><br>缩写 fd: file descriptor，文件描述符，在 linux 中，文件描述符是代表一个打开的文件的数字，通过文件描述符，可以操作文件，例如读写文件，关闭文件等。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *myaddr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">// returns: 0 OK, -1 on error</span></span><br></pre></td></tr></table></figure>

<div class="tabs my-3 is-small is-fullwidth">
        <ul class="mx-0 my-0">
            <li class="is-active">
          <a href="#code1">
              <p>server</p>

          </a>
      </li><li>
          <a href="#code2">
              <p>client</p>

          </a>
      </li>
        </ul>
    </div>
    <div id="code1" class="tab-content">
          <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="comment">// allocate address struct</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;srv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span></span><br><span class="line">  <span class="comment">// init socket file descriptor</span></span><br><span class="line">  <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// Socket File Descriptor</span></span><br><span class="line">  <span class="comment">// 为服务器地址指明TCP/IP 地址族 family,port,address</span></span><br><span class="line">  srv_addr.sin_family = AF_INET; <span class="comment">// TCP/IP地址族，可以为AF_INET,PF_INET</span></span><br><span class="line">  inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;srv_addr.sin_addr); <span class="comment">// init ip_addr</span></span><br><span class="line">  srv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));<span class="comment">// init port</span></span><br><span class="line">  <span class="comment">// bind()为socket指明一个本地端点地址(ip&amp;port)</span></span><br><span class="line">  bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;srv_addr, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">  <span class="comment">// 开始监听</span></span><br><span class="line">  listen(listenfd, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[srv] server[%s:%d] is initializing!\n&quot;</span>, inet_ntoa(srv_addr.sin_addr),</span><br><span class="line">            ntohs(srv_addr.sin_port));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      </div><div id="code2" class="tab-content is-hidden">
          <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;srv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">  srv_addr.sin_family = AF_INET;</span><br><span class="line">  srv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));         <span class="comment">// port</span></span><br><span class="line">  inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;srv_addr.sin_addr);  <span class="comment">// ip</span></span><br><span class="line">  connfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  connect(connfd, (<span class="keyword">struct</span> sockaddr *)&amp;srv_addr, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[cli] server[%s:%d] is connected!\n&quot;</span>, inet_ntoa(srv_addr.sin_addr),</span><br><span class="line">         ntohs(srv_addr.sin_port));</span><br><span class="line">  send_requests(connfd);</span><br><span class="line">  close(connfd);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[cli] connfd is closed!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[cli] client is going to exit!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      </div>

<h2 id="多进程、多线程并发服务器设计"><a href="#多进程、多线程并发服务器设计" class="headerlink" title="多进程、多线程并发服务器设计"></a>多进程、多线程并发服务器设计</h2><h2 id="I-O-模型以及基于-I-O-复用的并发服务器设计"><a href="#I-O-模型以及基于-I-O-复用的并发服务器设计" class="headerlink" title="I&#x2F;O 模型以及基于 I&#x2F;O 复用的并发服务器设计"></a>I&#x2F;O 模型以及基于 I&#x2F;O 复用的并发服务器设计</h2><h2 id="客户端、服务器程序设计-核心问题解析：以仿-QQ-的多人即时通信网络应用为例"><a href="#客户端、服务器程序设计-核心问题解析：以仿-QQ-的多人即时通信网络应用为例" class="headerlink" title="客户端、服务器程序设计 核心问题解析：以仿 QQ 的多人即时通信网络应用为例"></a>客户端、服务器程序设计 核心问题解析：以仿 QQ 的多人即时通信网络应用为例</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>扩展了解：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiongmaojiayou/article/details/7584211">关于 PF_INET 和 AF_INET 的区别</a> （AF 是 BSD 规范，PF 是 posix 规范）<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/heluan/p/10937098.html">Socket 通信中 AF_INET 和 AF_UNIX 域的区别</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tnt_xixixi/article/details/86728525">浅谈 uint8_t 等以_t 结尾的数据类型</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/280711576">一文理解可重入函数</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>套接字编程 Socket Programming</p><p><a href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch7-SocketProgramming/">https://efterklang.github.io/UESTC/ComputerNetworking/Ch7-SocketProgramming/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Efterklang</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-06-15</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-06-16</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Linux/">Linux</a><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a><a class="link-muted mr-2" rel="tag" href="/tags/OS/">OS</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Essay/Poems/%E3%80%8A%E5%94%90%E5%A4%9A%E4%BB%A4%C2%B7%E8%8A%A6%E5%8F%B6%E6%BB%A1%E6%B1%80%E6%B4%B2%E3%80%8B/"><span class="level-item"> </span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.32/dist/twikoo.all.min.js"></script><script>twikoo.init({
      envId: 'https://efterklang-twikoo.hf.space',
      onCommentLoaded: function () {
        var commentContents = document.getElementsByClassName('tk-content');
        for (var i = 0; i < commentContents.length; i++) {
          var commentItem = commentContents[i];
          var imgEls = commentItem.getElementsByTagName('img');
          if (imgEls.length > 0) {
            for (var j = 0; j < imgEls.length; j++) {
              var imgEl = imgEls[j];
              var aEl = document.createElement('a');
              aEl.setAttribute('class', 'tk-lg-link');
              aEl.setAttribute('href', imgEl.getAttribute('src'));
              aEl.setAttribute('data-src', imgEl.getAttribute('src'));
              aEl.appendChild(imgEl.cloneNode(false));
              imgEl.parentNode.insertBefore(aEl, imgEl.nextSibling);
              imgEl.remove();
            }
            if (typeof $.fn.lightGallery === 'function') {
              $(commentItem).lightGallery({
                selector: '.tk-lg-link'
              });
            }
          }
        }
      }
    });</script></div></div></div><style>.column.column-left,.column.column-right{display:none}</style><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#网络编程相关基础知识"><span class="level-left"><span class="level-item">1</span><span class="level-item">网络编程相关基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Endianness"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Endianness</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Big-Endian"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">Big-Endian</span></span></a></li><li><a class="level is-mobile" href="#Little-Endian"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">Little-Endian</span></span></a></li><li><a class="level is-mobile" href="#Network-Endian"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">Network-Endian</span></span></a></li><li><a class="level is-mobile" href="#字节序变换"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">字节序变换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Data-Alignment"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Data Alignment</span></span></a></li><li><a class="level is-mobile" href="#接口协议"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">接口协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#POSIX"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">POSIX</span></span></a></li><li><a class="level is-mobile" href="#System-Call"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">System Call</span></span></a></li><li><a class="level is-mobile" href="#LINUX-中提供的基本-I-O-功能"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">LINUX 中提供的基本 I/O 功能</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Socket-基本概念"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Socket 基本概念</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#主动-Socket-和被动-Socket"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">主动 Socket 和被动 Socket</span></span></a></li><li><a class="level is-mobile" href="#Socket-类型"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">Socket 类型</span></span></a></li><li><a class="level is-mobile" href="#地址结构"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">地址结构</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Socket-套接字与循环服务器"><span class="level-left"><span class="level-item">2</span><span class="level-item">Socket 套接字与循环服务器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简单-TCP-循环服务器-Socket-编程基本步骤"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">简单 TCP 循环服务器 Socket 编程基本步骤</span></span></a></li><li><a class="level is-mobile" href="#简单-UDP-循环服务器-Socket-编程基本步骤"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">简单 UDP 循环服务器 Socket 编程基本步骤</span></span></a></li><li><a class="level is-mobile" href="#Socket-核心函数"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Socket 核心函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#socket"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">socket()</span></span></a></li><li><a class="level is-mobile" href="#bind"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">bind()</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#多进程、多线程并发服务器设计"><span class="level-left"><span class="level-item">3</span><span class="level-item">多进程、多线程并发服务器设计</span></span></a></li><li><a class="level is-mobile" href="#I-O-模型以及基于-I-O-复用的并发服务器设计"><span class="level-left"><span class="level-item">4</span><span class="level-item">I/O 模型以及基于 I/O 复用的并发服务器设计</span></span></a></li><li><a class="level is-mobile" href="#客户端、服务器程序设计-核心问题解析：以仿-QQ-的多人即时通信网络应用为例"><span class="level-left"><span class="level-item">5</span><span class="level-item">客户端、服务器程序设计 核心问题解析：以仿 QQ 的多人即时通信网络应用为例</span></span></a></li><li><a class="level is-mobile" href="#Ref"><span class="level-left"><span class="level-item">6</span><span class="level-item">Ref</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Dev/"><span class="level-start"><span class="level-item">Dev</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/Dev/DataBase/"><span class="level-start"><span class="level-item">DataBase</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Others/"><span class="level-start"><span class="level-item">Others</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Essay/"><span class="level-start"><span class="level-item">Essay</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Essay/Game/"><span class="level-start"><span class="level-item">Game</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Essay/Poems/"><span class="level-start"><span class="level-item">Poems</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/UESTC/"><span class="level-start"><span class="level-item">UESTC</span></span><span class="level-end"><span class="level-item tag">38</span></span></a><ul><li><a class="level is-mobile" href="/categories/UESTC/ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">ARM处理器体系结构及应用</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">数据库原理及应用</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">April 2024</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a><p class="is-size-7"><span>&copy; 2024 Efterklang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.32/dist/twikoo.all.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/live2d-widget/autoload.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>
<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>套接字编程 Socket Programming - Efterklang</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Efterklang"><meta name="msapplication-TileImage" content="/img/vultr.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Efterklang"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="掌握字节序、内存对齐等计算机网络编程相关基础知识 理解Socket基本概念以及TCP&amp;#x2F;UDP Socket编程基本模式 理解客户端、服务器程序设计的核心问题与解决思路 能够按需设计实现简单循环服务器、多进程、多线程以及基于I&amp;#x2F;O复用的并发服务器。"><meta property="og:type" content="article"><meta property="og:title" content="套接字编程 Socket Programming"><meta property="og:url" content="https://efterklang.github.io/UESTC/ComputerNetworking/Ch7-SocketProgramming/"><meta property="og:site_name" content="Efterklang"><meta property="og:description" content="掌握字节序、内存对齐等计算机网络编程相关基础知识 理解Socket基本概念以及TCP&amp;#x2F;UDP Socket编程基本模式 理解客户端、服务器程序设计的核心问题与解决思路 能够按需设计实现简单循环服务器、多进程、多线程以及基于I&amp;#x2F;O复用的并发服务器。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://efterklang.github.io/img/thumbnails/Networks/socket_programming.png"><meta property="article:published_time" content="2024-06-15T05:18:50.000Z"><meta property="article:modified_time" content="2024-06-26T13:50:21.200Z"><meta property="article:author" content="Efterklang"><meta property="article:tag" content="Linux"><meta property="article:tag" content="计算机网络"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://efterklang.github.io/img/thumbnails/Networks/socket_programming.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://efterklang.github.io/"},"headline":"套接字编程 Socket Programming","image":["https://efterklang.github.io/img/thumbnails/Networks/socket_programming.png"],"datePublished":"2024-06-15T05:18:50.000Z","dateModified":"2024-06-26T13:50:21.200Z","author":{"@type":"Person","name":"efterklang"},"publisher":{"@type":"Organization","name":"Efterklang","logo":{"@type":"ImageObject","url":{"light":"/img/vultr.svg","dark":"/img/vultr.svg"}}},"description":"掌握字节序、内存对齐等计算机网络编程相关基础知识 理解Socket基本概念以及TCP&#x2F;UDP Socket编程基本模式 理解客户端、服务器程序设计的核心问题与解决思路 能够按需设计实现简单循环服务器、多进程、多线程以及基于I&#x2F;O复用的并发服务器。"}</script><link rel="canonical" href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch7-SocketProgramming/"><link rel="icon" href="/img/vultr.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link data-pjax rel="stylesheet" href="/css/default.css"><link rel="dns-prefetch" href="https://efterklang.github.io"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><meta name="msvalidate.01" content="039770FFD6F5D1B53B42B9D3271EA9B9"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-HKYTDLW5FP" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-HKYTDLW5FP');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Efterklang" type="application/atom+xml">
</head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/vultr.svg" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/vultr.svg" alt="Efterklang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/gallery">Gallery</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/onedrive">Onedrive</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="github" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/thumbnails/Networks/socket_programming.png" alt="套接字编程 Socket Programming" referrerpolicy="no-referrer"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-06-15T05:18:50.000Z" title="6/15/2024, 1:18:50 PM">2024-06-15</time></span><span class="level-item"><a class="link-muted" href="/categories/UESTC/">UESTC</a><span> / </span><a class="link-muted" href="/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span><span class="level-item">an hour read (About 9246 words)</span><span class="level-item leancloud_visitors" id="/UESTC/ComputerNetworking/Ch7-SocketProgramming/" data-flag-title="套接字编程 Socket Programming"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">套接字编程 Socket Programming</h1><div class="content"><h2 id="网络编程相关基础知识"><a href="#网络编程相关基础知识" class="headerlink" title="网络编程相关基础知识"></a>网络编程相关基础知识</h2><h3 id="Endianness"><a href="#Endianness" class="headerlink" title="Endianness"></a>Endianness</h3><p><strong>字节</strong>(Byte) 传输和存储信息的最小单位。各种数据类型，都是由字节构成。</p>
<p><strong>字节序</strong>（Endianness）是指在计算机内存中多字节数据类型的存储方式，主要涉及到高位字节和低位字节的排列顺序。字节序主要分为两大类：大端字节序（Big-Endian）和小端字节序（Little-Endian），另外还有较少使用的中端字节序（Middle-Endian）</p>
<h4 id="Big-Endian"><a href="#Big-Endian" class="headerlink" title="Big-Endian"></a>Big-Endian</h4><p>在大端字节序中，数据的高位字节存储在内存的低地址处，而低位字节存储在高地址处。这种存储方式与我们日常书写数字的习惯相匹配，即从左至右，高位在前，低位在后。例如，对于 32 位整数 0x12345678，在大端字节序下的内存布局为：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址递增方向 --&gt;</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">| 0x12   | 0x34   | 0x56   | 0x78   |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure>

<h4 id="Little-Endian"><a href="#Little-Endian" class="headerlink" title="Little-Endian"></a>Little-Endian</h4><p>小端字节序则相反，低位字节存储在内存的低地址处，高位字节存储在高地址处。这是大多数现代个人电脑和嵌入式系统的处理器所采用的方式，如 x86 架构。对于同样的 32 位整数 0x12345678，在小端字节序下的内存布局为：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址递增方向 --&gt;</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">| 0x78   | 0x56   | 0x34   | 0x12   |</span><br><span class="line">+--------+--------+--------+--------+</span><br></pre></td></tr></table></figure>

<h4 id="Network-Endian"><a href="#Network-Endian" class="headerlink" title="Network-Endian"></a>Network-Endian</h4><p>由于不同机器可能采用不同的字节序，为了正确的传输数据，需要一个统一的标准。因此数据在网络中传输时，需要转换为<strong>网络字节序 Network-Endian</strong>。</p>
<ul>
<li>网络字节顺序是 TCP&#x2F;IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。</li>
<li>网络字节顺序采用 Big-Endian 排序方式，总是从低位地址开始传输。</li>
<li>发送数据包时，程序将主机字节序转换为网络字节序；接受收数据包时，则将网络字节序转换为主机字节序。</li>
</ul>
<h4 id="字节序变换"><a href="#字节序变换" class="headerlink" title="字节序变换"></a>字节序变换</h4><p>如何检查主机字节序？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="type">short</span>   s;</span><br><span class="line">        <span class="type">char</span>    c[<span class="keyword">sizeof</span>(<span class="type">short</span>)];</span><br><span class="line">    &#125; un;</span><br><span class="line">    un.s = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">sizeof</span>(<span class="type">short</span>) == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (un.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;big-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (un.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;little-endian\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknown\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sizeof(short) = %d\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节序的变换函数<br>为了保持源代码的可移植性，提供了字节序变换函数<a target="_blank" rel="noopener" href="https://linux.die.net/man/3/htons">htons(3) - Linux man page</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 主机字节序变为网络字节序</span></span><br><span class="line"><span class="type">uint16_t</span>  <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span><br><span class="line"><span class="comment">// 网络字节序变为主机字节序</span></span><br><span class="line"><span class="type">uint16_t</span>  <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span><br><span class="line"><span class="type">uint32_t</span>  <span class="title function_">ntohl</span><span class="params">(<span class="type">uint16_t</span> netlong)</span></span><br></pre></td></tr></table></figure>

<article class="message is-info">
        
        <div class="message-body">
            <p><span class="heimu">C 函数库特有高浓度缩写，初见实在令人发指</span></p>
<p><code>htons</code> : host to network short<br><code>htonl</code> : host to network long<br><code>ntohs</code> : network to host short<br><code>ntohl</code> : network to host long</p>

        </div>
    </article>

<p>标准库中通常只提供 16 位（htons）和 32 位（htonl）字节序转换函数的实现,下面是<code>long long</code>的字节序转换函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//htonll,ntohll</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">htonll</span><span class="params">(<span class="type">uint64_t</span> hostlonglong)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="type">uint64_t</span>) htonl(hostlonglong)) &lt;&lt; <span class="number">32</span>) + htonl(hostlonglong &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">ntohll</span><span class="params">(<span class="type">uint64_t</span> networklonglong)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (((<span class="type">uint64_t</span>) ntohl(networklonglong)) &lt;&lt; <span class="number">32</span>) + ntohl(networklonglong &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处以一个实例演示<code>htonll</code>的工作流程，假设本地为小段模式，<code>12 34 56 78</code>存储形式为<code>78,56,34,12</code><br><code>htonl(hostlonglong)</code>即<code>htonl(78563412)</code>，参数为 long long 越界，返回结果为 1234，转成 long long 后左移 32 位<br><code>htonl(hostlonglong &gt;&gt; 32)</code>即<code>htonl(7856)</code>，返回 5678<br>两者相加得到<code>12 34 56 78</code>，成功转为大端模式，即网络序</p>
<h3 id="Data-Alignment"><a href="#Data-Alignment" class="headerlink" title="Data Alignment"></a>Data Alignment</h3><p><strong>数据结构对齐</strong>是操作系统为了快速访问内存⽽采取的⼀种策略，简单来说，就是为了防止内存的⼆次访问。操作系统在访问内存时，每次读取⼀定的长度（这个长度就是操作系统的默认对齐系数，或者是默认对齐系数的整数倍）。如果没有内存对齐时，为了读取⼀个变量，会产⽣内存的⼆次访问。<br>平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的。<br>数据结构对齐，是由编译器对代码进行处理来实现。<br>计算机网络编程中，要合理设计数据结构，保证必要的对齐。</p>
<p><strong>对齐系数</strong></p>
<ul>
<li>每个特定平台的编译器都有自己的默认“对齐系数” 。</li>
<li>通过预编译命令<code>#pragma pack(n)</code>，n&#x3D;1,2,4,8,16 来改变这一系数，其中的 n 就是指定的“对齐系数”。</li>
</ul>
<p><strong>结构体对齐规则</strong>：<br>结构体变量的首地址能够被其<em>最宽基本类型成员</em>的大小所整除；<br>结构体每个成员相对结构体首地址的偏移量(offset)都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；<br>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。</p>
<article class="message is-info">
        
        <div class="message-body">
            <p>在 64 位的 Linux 机器上，以下结构到底 size 多少？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X2</span> &#123;</span> <span class="type">char</span> a; <span class="type">int</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X3</span> &#123;</span> <span class="type">int</span> a; <span class="type">char</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X4</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X5</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X6</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X7</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X8</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> <span class="type">long</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X9</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> <span class="type">long</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X10</span> &#123;</span> <span class="type">char</span> a; <span class="type">int</span> b; <span class="type">short</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X11</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; <span class="type">char</span> c; <span class="type">int</span> d; &#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>struct X2: 包含 1 字节的 char，4 字节的 int，和 1 字节的 char。整体需要 4 字节对齐（因为 int），所以 char a 之后会有 3 字节填充。总大小 &#x3D; 1 (a) + 3 (padding for a) + 4 (b) + 1 (c) &#x3D; 9 字节，但为了满足 4 字节对齐，末尾还需补足到 4 字节的倍数，最终大小为 12 字节。</p>
<p>struct X3: 包含 4 字节的 int 和 1 字节的 char。整体需要 4 字节对齐，char b 之后会有 3 字节填充。总大小 &#x3D; 4 (a) + 1 (b) + 3 (padding for b) &#x3D; 8 字节。</p>
<p>…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X2</span> &#123;</span> <span class="type">char</span> a; <span class="type">int</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X3</span> &#123;</span> <span class="type">int</span> a; <span class="type">char</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X4</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X5</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X6</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X7</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X8</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> <span class="type">long</span> b; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X9</span> &#123;</span> <span class="type">char</span> a; <span class="type">long</span> <span class="type">long</span> b; <span class="type">char</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X10</span> &#123;</span> <span class="type">char</span> a; <span class="type">int</span> b; <span class="type">short</span> c; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X11</span> &#123;</span> <span class="type">char</span> a; <span class="type">short</span> b; <span class="type">char</span> c; <span class="type">int</span> d; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X2: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X2));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X3: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X3));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X4: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X4));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X5: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X5));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X6: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X6));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X7: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X7));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X8: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X8));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X9: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X9));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X10: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X10));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct X11: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> X11));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~&gt; ./a.out</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X2</span>:</span> <span class="number">12</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X3</span>:</span> <span class="number">8</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X4</span>:</span> <span class="number">4</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X5</span>:</span> <span class="number">6</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X6</span>:</span> <span class="number">16</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X7</span>:</span> <span class="number">24</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X8</span>:</span> <span class="number">16</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X9</span>:</span> <span class="number">24</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X10</span>:</span> <span class="number">12</span> bytes</span><br><span class="line">Size of <span class="class"><span class="keyword">struct</span> <span class="title">X11</span>:</span> <span class="number">12</span> bytes</span><br></pre></td></tr></table></figure>

        </div>
    </article>

<h3 id="接口协议"><a href="#接口协议" class="headerlink" title="接口协议"></a>接口协议</h3><ul>
<li>TCP&#x2F;IP 协议存在于 OS 中，网络服务通过 OS 提供</li>
<li>TCP&#x2F;IP 要尽量避免让接口使用某一个厂商的 OS 中特有的特征（而其他厂商没有）</li>
<li>TCP&#x2F;IP 和应用程序之间的接口应该不精确指明：<ul>
<li>不规定接口的细节</li>
<li>只建议需要的功能集</li>
<li>允许系统设计者选择有关 API 的具体实现细节</li>
</ul>
</li>
</ul>
<p>不精确指明的协议接口有以下 Pros&amp;Cons</p>
<ul>
<li>优点：提供了灵活性和容错能力<ul>
<li>便于各种 OS 实现 TCP&#x2F;IP</li>
<li>接口可以是过程的，也可以是消息的</li>
</ul>
</li>
<li>缺点：不同的 OS 中的接口细节不同<ul>
<li>移植性差</li>
<li>程序员需要重新学习接口知识</li>
</ul>
</li>
<li>接口协议举例：<ul>
<li>Berkeley UNIX 中的套接字接口</li>
<li>Microsoft Windows 中的 Windows Socket</li>
</ul>
</li>
</ul>
<p><strong>接口协议的功能</strong></p>
<ul>
<li>分配用于通信的本地资源</li>
<li>指定本地和远程通信端点</li>
<li>（客户端）启动连接</li>
<li>（客户端）发送数据报</li>
<li>（服务器端）等待连接到来</li>
<li>发送或者接收数据</li>
<li>判断数据何时达</li>
<li>产生紧急数据</li>
<li>处理到来的紧急数据</li>
<li>从容终止连接</li>
<li>处理来自远程端点的连接终止</li>
<li>异常终止通信</li>
<li>处理错误条件或者连接异常终止</li>
<li>连接结束后释放本地资源</li>
</ul>
<h4 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h4><ul>
<li>POSIX 表示可移植操作系统接口<ul>
<li>Portable Operating System Interface of UNIX（缩写为 POSIX ）</li>
<li>POSIX 标准定义了操作系统应该为应用程序提供的接口标准，是 IEEE 为要在各种 UNIX 操作系统上运行的软件而定义的一系列 API 标准的总称，其正式称呼为 IEEE 1003，而国际标准名称为 ISO&#x2F;IEC 9945。</li>
</ul>
</li>
<li>POSIX 标准意在期望获得源代码级别的软件可移植性。<ul>
<li>为一个 POSIX 兼容的操作系统编写的程序，应该可以在任何其它的 POSIX 操作系统（即使是来自另一个厂商）上编译执行。</li>
</ul>
</li>
<li>POSIX 并不局限于 UNIX<ul>
<li>许多其它的操作系统，例如 DEC OpenVMS 也支持 POSIX 标准。</li>
</ul>
</li>
</ul>
<h4 id="System-Call"><a href="#System-Call" class="headerlink" title="System Call"></a>System Call</h4><ul>
<li>操作系统内核提供一系列具备预定功能的内核函数，通过称为系统调用(System Call)的接口呈现给用户。</li>
<li>为安全考量，诸如 I&#x2F;O 操作等特权指令被限制在内核态模式执行</li>
<li>系统调用使得应用程序从操作系统获得服务。</li>
</ul>
<h4 id="LINUX-中提供的基本-I-O-功能"><a href="#LINUX-中提供的基本-I-O-功能" class="headerlink" title="LINUX 中提供的基本 I&#x2F;O 功能"></a>LINUX 中提供的基本 I&#x2F;O 功能</h4><article class="message is-info">
        
        <div class="message-body">
            <p>六个基本的系统 I&#x2F;O 函数：</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Open</td>
<td>为输入或输出操作准备一个设备或者文件</td>
</tr>
<tr>
<td>Close</td>
<td>终止使用以前已打开的设备或者文件</td>
</tr>
<tr>
<td>Read</td>
<td>从输入设备或者文件中得到数据</td>
</tr>
<tr>
<td>Write</td>
<td>数据从应用程序存储器传到设备或文件中</td>
</tr>
<tr>
<td>Lseek</td>
<td>转到文件或者设备中的某个指定位置</td>
</tr>
<tr>
<td>loctl</td>
<td>控制设备或者用于访问该设备的软件</td>
</tr>
</tbody></table>

        </div>
    </article>

<p>[[Ch7-1LinuxUnix#文件 I&#x2F;O]]</p>
<ul>
<li>扩展文件描述符，可用于网络通信</li>
<li>扩展 read,write，可用于操作网络标识符</li>
<li>额外功能的处理，通过增加新系统调用实现：<ul>
<li>使用 TCP 还是 UDP</li>
<li>指明本地和远端的端口，远程 IP 地址</li>
<li>启动传输还是等待传入连接</li>
<li>可以接受多少传入连接</li>
<li>传输 UDP 数据</li>
</ul>
</li>
</ul>
<h3 id="Socket-基本概念"><a href="#Socket-基本概念" class="headerlink" title="Socket 基本概念"></a>Socket 基本概念</h3><p><strong>协议操作接口，而非协议本身</strong><br>Socket 是一个主机本地应用程序所创建的, 为操作系统所控制的接口， Client&#x2F;server 模式的通信接口。<br>应用进程通过这个接口,使用传输层提供的服务, 跨网络发送(&#x2F;接收)消息到(&#x2F;从)其他应用进程</p>
<blockquote>
<p><strong>Berkeley UNIX Sockets API</strong><br>ARPA 要求伯克利分校将 TCP&#x2F;IP 移植到 UNIX 中，需要创建一个接口，便于应用程序使用这个接口进行网络通信尽可能使用现有的系统调用，称为 BSD UNIX 套接字，成为事实上的标准<br><em>BSD，Berkeley Software Distribution</em></p>
</blockquote>
<h4 id="主动-Socket-和被动-Socket"><a href="#主动-Socket-和被动-Socket" class="headerlink" title="主动 Socket 和被动 Socket"></a>主动 Socket 和被动 Socket</h4><ul>
<li>创建方式相同，使用方式不同<ul>
<li>被动：等待传入连接的套接字，如服务器套接字</li>
<li>主动：发起连接的套接字，如客户端套接字</li>
</ul>
</li>
<li>指明端到端地址：创建时不指定，使用时指明（TCP&#x2F;IP 需要指明协议端口号和 IP 地址）<ul>
<li>TCP&#x2F;IP 协议族：PF_INET</li>
<li>TCP&#x2F;IP 地址族：AF_INET<br>（PF 是 protocol family，AF 是 address family，TCP&#x2F;IP 套接字设计者认为可能某个协议族有多种形式的地址，所以在 API 上把它们分开了，创建 socket 用 PF，bind&#x2F;connect 用 AF。但如今一个 PF 只有一个 AF，从来没有过例外，所以可混用）</li>
</ul>
</li>
</ul>
<h4 id="Socket-类型"><a href="#Socket-类型" class="headerlink" title="Socket 类型"></a>Socket 类型</h4><ul>
<li>套接字支持多种通信协议：<ul>
<li>Unix： Unix 系统内部协议</li>
<li>INET： IP 版本 4</li>
<li>INET6：IP 版本 6</li>
</ul>
</li>
<li>套接字类型，即应用程序希望的通信服务类型<ul>
<li>SOCKET_DGRAM： 双向不可靠数据报，对应 UDP；DGRAM 即 datagram</li>
<li>SOCKET_STREAM：双向可靠数据流，对应 TCP</li>
<li>SOCKET_RAW：低于传输层的低级协议或物理网络提供的套接字类型，可以访问内部网络接口。</li>
</ul>
</li>
</ul>
<h4 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h4><p><strong>Socket 通用地址结构 sockaddr</strong></p>
<ul>
<li>Socket 是传输层&#x2F;网络层编程接口，由于传输层&#x2F;网络层的各种实现不同，可能会有不同的编址方案。通用地址为了适应这种需求而定义。</li>
<li>通用地址有很大局限性，实际并不具有通用性，例如针对 AF_INET6&#x2F;AF_LOCAL 类型的 Socket 地址，sockaddr 结构实际上只能标识出这个地址的类型。</li>
</ul>
<p><strong>Socket IPv4 IPv6 地址结构与通用结构</strong></p>
<ul>
<li>早期 sockaddr 只包含 2 个字节的 sa_family 和后面的 14 个字节的 data，后来为了 OSI 兼容性，第一个字节变为长度 len，值为 16，相应的，sa_family 变为 1 个字节；</li>
<li>如今 sockaddr 仅在 bind 等函数里，传递参数时强制类型转换使用，其它没啥用途（因为早期的 C 没有 void 指针，即通用指针，所以搞得那么麻烦）；</li>
<li>Ipv4 用的是 sockaddr_in，里面的 len 和 sockaddr 的 len 一样含义；sa_family 改名为 sin_family，值为 AF_INET 了</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-15-16-55-31.png" style="zoom:80%;">

<p><strong>地址转换函数</strong></p>
<p>人们习惯使用 202.112.14.151 表示地址（点分十进制），但是这个本质是一个字符串而不是数值，因此在 socket 编程时，需要进行转换。此外还要考虑字节序的问题，为此可以使用如下一些函数：</p>
<blockquote>
<p>inet_aton 这堆函数，仅在处理网络参数时使用，比如 IP 地址，端口等。而在用 I&#x2F;O 函数接收发送数据时，不用考虑字节序问题，OS 自动处理。</p>
</blockquote>
<article class="message is-info">
        
        <div class="message-body">
            <p>函数中的 Aton 指阿托恩，是古埃及信奉的太阳神 <span class="heimu"> address to network address</span><br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-15-17-16-24.png" style="zoom:50%;"></p>

        </div>
    </article>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回：1-串有效，0-串有错</span></span><br><span class="line"><span class="comment">// inet_aton函数将cp所指的字符串转换成32位的网络字节序二进制，并通过指针inp来存储。这个函数需要对字符串所指的地址进行有效性验证。但如果cp为空，函数仍然成功，但不存储任何结果。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span></span><br><span class="line"><span class="comment">//inet_addr进行相同的转换，但不进行有效性验证，也就是说，所有232种可能的二进制值对inet_addr函数都是有效的——过时函数，不应再使用</span></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：指向点分十进制数串的指针</span></span><br><span class="line"><span class="comment">// 函数inet_ntoa将32位的网络字节序二进制IPv4地址转换成相应的点分十进制数串。但由于返回值所指向的串留在静态内存中，这意味着函数是不可重入的。</span></span><br><span class="line"><span class="comment">// 需要注意的是这个函数是以结构为参数，而不是指针。</span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span><br></pre></td></tr></table></figure>

<p>上述三个地址转换函数都只能处理 IPv4 协议，而不能处理 IPv6 地址。在同时要处理 IPv4 和 v6 的程序中，建议使用以下两个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回：1-成功，0－输入无效，-1:出错</span></span><br><span class="line"><span class="comment">// 将src指向的字符串转换成二进制地址数值放到dst中。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span><br><span class="line"><span class="title function_">inet_pton</span><span class="params">(AF_INET, <span class="string">&quot;192.168.1.1&quot;</span>, &amp;srv_addr.sin_addr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回：指向结果的指针－－成功，NULL－出错</span></span><br><span class="line"><span class="comment">// 和pton做相反的操作。</span></span><br><span class="line"><span class="comment">// family参数可以是AF_INET,也可以是AF_INET6。</span></span><br><span class="line"><span class="comment">// 如果长度参数cnt太小，无法容纳表达式格式结果，则返回一个空串。另外，目标指针dst调用前必须先由调用者分配空间。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> family, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">size_t</span> cnt)</span></span><br><span class="line"><span class="title function_">printf</span><span class="params">(<span class="string">&quot;[srv] server[%s:%d] is initializing!\n&quot;</span>, inet_ntoa(srv_addr.sin_addr),</span></span><br><span class="line"><span class="params">            ntohs(srv_addr.sin_port))</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面两个函数名称可以分解为两部分来理解其含义<br><code>inet</code>: 这个前缀来源于“Internet”，表明这个函数是与互联网相关的，特别是与 IP 地址处理有关。在套接字编程的上下文中，“inet”通常指代与互联网协议相关的函数或操作。<br><code>pton</code>: 是“Presentation to Network”的缩写，意味着该函数将人类可读的表示形式（即“Presentation”层的数据，如 IP 地址的点分十进制字符串形式）转换为适合在网络上传输的二进制格式（即“Network”层的数据）。简而言之，“pton”类型的函数负责从应用层的表示形式转换到网络层的传输格式。</p>
</blockquote>
<h2 id="Socket-套接字与循环服务器"><a href="#Socket-套接字与循环服务器" class="headerlink" title="Socket 套接字与循环服务器"></a>Socket 套接字与循环服务器</h2><h3 id="简单-TCP-循环服务器-Socket-编程基本步骤"><a href="#简单-TCP-循环服务器-Socket-编程基本步骤" class="headerlink" title="简单 TCP 循环服务器 Socket 编程基本步骤"></a>简单 TCP 循环服务器 Socket 编程基本步骤</h3><div class="tabs my-3 is-small is-fullwidth">
        <ul class="mx-0 my-0">
            <li class="is-active">
          <a href="#1">
              <p>Server</p>

          </a>
      </li><li>
          <a href="#2">
              <p>Client</p>

          </a>
      </li>
        </ul>
    </div>
    <div id="1" class="tab-content">
          <ol>
<li>创建套接字</li>
<li>绑定套接字</li>
<li>设置套接字为监听模式，进入被动接受连接状态</li>
<li>接受请求，建立连接</li>
<li>读写数据</li>
<li>终止连接</li>
</ol>

      </div><div id="2" class="tab-content is-hidden">
          <ol>
<li>创建套接字</li>
<li>与远程服务器建立连接</li>
<li>读写数据</li>
<li>终止连接</li>
</ol>

      </div>

<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-15-18-47-00.png" style="zoom:50%;">

<h3 id="简单-UDP-循环服务器-Socket-编程基本步骤"><a href="#简单-UDP-循环服务器-Socket-编程基本步骤" class="headerlink" title="简单 UDP 循环服务器 Socket 编程基本步骤"></a>简单 UDP 循环服务器 Socket 编程基本步骤</h3><div class="tabs my-3 is-small is-fullwidth">
        <ul class="mx-0 my-0">
            <li class="is-active">
          <a href="#3">
              <p>server</p>

          </a>
      </li><li>
          <a href="#4">
              <p>client</p>

          </a>
      </li>
        </ul>
    </div>
    <div id="3" class="tab-content">
          <ol>
<li>建立 UDP 套接字；</li>
<li>绑定套接字到特定地址；</li>
<li>等待并接收客户端信息；</li>
<li>处理客户端请求；</li>
<li>发送信息回客户端；</li>
<li>关闭套接字；</li>
</ol>

      </div><div id="4" class="tab-content is-hidden">
          <ol>
<li>建立 UDP 套接字；</li>
<li>发送信息给服务器；</li>
<li>接收来自服务器的信息；</li>
<li>关闭套接字</li>
</ol>

      </div>

<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-15-18-59-34.png" style="zoom:50%;">

<h3 id="Socket-核心函数"><a href="#Socket-核心函数" class="headerlink" title="Socket 核心函数"></a>Socket 核心函数</h3><h4 id="socket"><a href="#socket" class="headerlink" title="socket()"></a>socket()</h4><p>功能：创建一个套接字，返回套接字描述符</p>
<p>参数：</p>
<ul>
<li><code>family</code>：指明使用的协议栈，如 TCP&#x2F;IP 使用的是 PF_INET 或 AF_INET</li>
<li><code>type</code>: 指明需要的服务类型, 如：</li>
<li><code>SOCK_DGRAM</code>，数据报服务，UDP 协议</li>
<li><code>SOCK_STREAM </code>，流服务，TCP 协议</li>
<li><code>protocol</code>：IP 报头中的协议字段，一般取 0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span> <span class="params">(<span class="type">int</span> family, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"><span class="comment">// returns: non-negative descriptor if OK, -1 on error</span></span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>功能：将 socket 与本地 address 关联，指定这个套接字应该监听哪个 IP 地址上的哪个端口传入的连接请求<br>TCP&#x2F;IP 协议使用 sockaddr_in 结构，包含 IP 地址和端口号,服务器使用它来指明 Well Known 端口号，然后等待连接</p>
<p>参数：</p>
<ul>
<li><code>sockfd</code>，Socket File Descriptor，套接字描述符，指明创建连接的套接字</li>
<li><code>myaddr</code>，本地地址，IP 地址和端口号</li>
<li><code>addrlen</code> ，地址长度</li>
</ul>
<blockquote>
<p><span class="heimu">你可能会疑惑，fd 是什么鬼(╬▔ 皿 ▔)╯</span><br>缩写 fd: file descriptor，文件描述符，在 linux 中，文件描述符是代表一个打开的文件的数字，通过文件描述符，可以操作文件，例如读写文件，关闭文件等。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *myaddr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"><span class="comment">// returns: 0 OK, -1 on error</span></span><br></pre></td></tr></table></figure>

<h4 id="listen"><a href="#listen" class="headerlink" title="listen()"></a>listen()</h4><p>功能：用于服务器,指明某个套接字连接是被动的,并准备接收传入连接。</p>
<p>参数：</p>
<ul>
<li><code>Sockfd</code>:套接字描述符，指明创建连接的套接字</li>
<li><code>backlog</code>:该套接字使用的队列长度,指定在请求队列中允许的最大请求数</li>
</ul>
<p>TCP 为监听套接字维护的两个队列,已完成连接队列(ESTABLISHED 状态)和未完成连接队列(SYN_RCVD 状态)，已建立连接队列长度不能超过 backlog</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line">returns: <span class="number">0</span> OK, <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>

<h4 id="accept"><a href="#accept" class="headerlink" title="accept()"></a>accept()</h4><p>功能：<br>主要用于服务器端，其作用是从已建立的监听套接字上接受一个客户的连接请求，创建一个新的套接字来与该客户进行通信。当 accept()调用成功时，它会返回一个新的套接字描述符，这个描述符用于与刚刚接受的客户端通信。如果出现错误，如没有连接请求到达或者其他错误条件，它会返回-1，并且可以通过检查 errno 来获取具体的错误代码。</p>
<p>参数</p>
<ul>
<li><code>sockfd</code>: 这是通过 socket()函数创建并用 bind()函数绑定了特定地址，然后用 listen()函数设置为监听模式的套接字描述符。</li>
<li><code>cliaddr</code>: 这是一个指向 sockaddr 结构体的指针，用于接收客户端的地址信息。当函数返回时，这个结构体会被填充为客户机的地址信息。</li>
<li><code>addrlen</code>: 地址长度</li>
</ul>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>功能：<br>由客户端调用，同远程服务器建立主动连接</p>
<p>参数：</p>
<ul>
<li><code>sockfd</code>，套接字描述符，指明创建连接的套接字</li>
<li><code>servaddr</code>，指明远端 IP 地址和端口号</li>
<li><code>addrlen</code>，地址长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span> <span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *servaddr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line">returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>

<ul>
<li>客户端调用该函数发起向服务器的连接</li>
<li>客户端可以不必再调用 bind 来绑定地址</li>
<li>应用程序会阻塞，直到连接建立，或者出现异常：<ul>
<li>超时，6s&#x2F;24s&#x2F;75s，ETIMEOUT</li>
<li>RST，服务器没有开启服务，ECONNREFUSED</li>
<li>ICMP 错误，路由出错，EHOSTUNREACH&#x2F; ENETUNREACH</li>
<li>特别注意：connect 失效后，不能再次调用 connect 试图重建连接，而必须：调用 close()，socket()，connect()重连</li>
</ul>
</li>
</ul>
<h4 id="send-sendto"><a href="#send-sendto" class="headerlink" title="send() &amp; sendto()"></a>send() &amp; sendto()</h4><p><code>send()</code><br>功能：<br>在 TCP 连接上发送数据, 成功返回数据长度，出错返回－1。<br>参数：</p>
<ul>
<li><code>sockfd</code>，套接字描述符</li>
<li><code>data</code>，指向要发送数据的指针</li>
<li><code>data_len</code>，数据长度</li>
<li><code>flags</code>，一般为 0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> * data, <span class="type">int</span> data_len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br></pre></td></tr></table></figure>

<p><code>sendto()</code></p>
<p>功能：<br>基于 UDP 发送数据报，返回实发数据长度，出错返回－1。</p>
<p>参数：</p>
<ul>
<li><code>sockfd</code>，套接字描述符</li>
<li><code>data</code>，指向要发送数据的指针</li>
<li><code>data_len</code>，数据长度</li>
<li><code>flags</code>，一般为 0</li>
<li><code>remaddr</code>，远端地址：IP 地址和端口号</li>
<li><code>remaddr_len</code> ，地址长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> * data, <span class="type">int</span> data_len, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *remaddr, <span class="type">int</span> remaddr_len)</span></span><br></pre></td></tr></table></figure>

<h4 id="recv-recvfrom"><a href="#recv-recvfrom" class="headerlink" title="recv() &amp; recvfrom()"></a>recv() &amp; recvfrom()</h4><p><code>recv()</code><br>功能：<br>从 TCP 接收数据,返回实际接收数据长度，出错返回－1。<br>如果没有数据将阻塞，如果收到的数据大于缓存大小，多余数据将丢弃。</p>
<p>参数：</p>
<ul>
<li><code>Sockfd</code>:套接字描述符</li>
<li><code>Buf</code>:指向内存块的指针</li>
<li><code>Buf_len</code>:内存块大小，以字节为单位</li>
<li><code>flags</code>:一般为 0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">int</span> buf_len,<span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p><code>recvfrom()</code></p>
<p>功能：<br>从 UDP 接收数据，返回实际接收的字节数，失败返回－1</p>
<p>参数：</p>
<ul>
<li><code>Sockfd</code>:套接字描述符</li>
<li><code>buf</code>:指向内存块的指针</li>
<li><code>buf_len</code>:内存块大小，以字节为单位</li>
<li><code>flags</code>:一般为 0</li>
<li><code>from</code>:远端的地址，IP 地址和端口号</li>
<li><code>fromlen</code>:远端地址长度</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">int</span> buf_len, <span class="type">unsigned</span> <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr *from, <span class="type">int</span> fromlen)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><p>功能：<br>关闭 socket，实际上是关闭文件描述符<br>如果只有一个进程使用，立即终止连接并撤销该套接字，如果多个进程共享该套接字，将引用数减一，如果引用数降到零，则撤销它。</p>
<p>参数：<br><code>sockfd</code>:套接字描述符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">Int <span class="title function_">close</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br><span class="line">returns: <span class="number">0</span> <span class="keyword">if</span> OK, <span class="number">-1</span> on error</span><br></pre></td></tr></table></figure>

<h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><div class="tabs my-3 is-small is-fullwidth">
        <ul class="mx-0 my-0">
            <li class="is-active">
          <a href="#code1">
              <p>server</p>

          </a>
      </li><li>
          <a href="#code2">
              <p>client</p>

          </a>
      </li>
        </ul>
    </div>
    <div id="code1" class="tab-content">
          <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*==========================================</span></span><br><span class="line"><span class="comment"> * author: 高嘉兴                          *</span></span><br><span class="line"><span class="comment"> * date: 2024-05-16 16:37:30               *</span></span><br><span class="line"><span class="comment"> * version: 1.0                            *</span></span><br><span class="line"><span class="comment"> * c standard: gnu23                       *</span></span><br><span class="line"><span class="comment"> * gcc version: 13.2.0                     *</span></span><br><span class="line"><span class="comment"> * OS: Ubuntu-24.04                        *</span></span><br><span class="line"><span class="comment"> ==========================================*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_sigint</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_requests</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_result</span><span class="params">(<span class="type">char</span> *data, <span class="type">int64_t</span> *res)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">htonll</span><span class="params">(<span class="type">uint64_t</span> host_64)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">ntohll</span><span class="params">(<span class="type">uint64_t</span> net_64)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">htonll</span><span class="params">(<span class="type">uint64_t</span> val)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (((<span class="type">uint64_t</span>)htonl(val)) &lt;&lt; <span class="number">32</span>) + htonl(val &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">ntohll</span><span class="params">(<span class="type">uint64_t</span> val)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (((<span class="type">uint64_t</span>)ntohl(val)) &lt;&lt; <span class="number">32</span>) + ntohl(val &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> cli_addr_len = <span class="keyword">sizeof</span>(cli_addr);</span><br><span class="line"><span class="type">int</span> sigint_flag = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="comment">// init sigaction</span></span><br><span class="line">  signal(SIGPIPE, SIG_IGN);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">  sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">  sa.sa_handler = handle_sigint;</span><br><span class="line">  sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">  sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;srv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">  srv_addr.sin_family = AF_INET;</span><br><span class="line">  srv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));</span><br><span class="line">  inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;srv_addr.sin_addr);</span><br><span class="line">  bind(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;srv_addr, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">  listen(listenfd, <span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[srv] server[%s:%d] is initializing!\n&quot;</span>, inet_ntoa(srv_addr.sin_addr),</span><br><span class="line">         ntohs(srv_addr.sin_port));</span><br><span class="line">  <span class="keyword">while</span> (!sigint_flag) &#123;</span><br><span class="line">    <span class="type">int</span> connfd;</span><br><span class="line">    <span class="keyword">if</span> ((connfd = accept(listenfd, (<span class="keyword">struct</span> sockaddr *)&amp;cli_addr,</span><br><span class="line">                         &amp;cli_addr_len)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (errno == EINTR) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        perror(<span class="string">&quot;[debug] accept error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[srv] client[%s:%d] is accepted!\n&quot;</span>, inet_ntoa(cli_addr.sin_addr),</span><br><span class="line">           ntohs(cli_addr.sin_port));</span><br><span class="line">    parse_requests(connfd);</span><br><span class="line">    close(connfd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[srv] listenfd is closed!\n&quot;</span>);</span><br><span class="line">  close(listenfd);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[srv] server is going to exit!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">parse_requests</span><span class="params">(<span class="type">int</span> connfd)</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">24</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 对齐的逻辑放入print_results中</span></span><br><span class="line">    <span class="type">int</span> len = read(connfd, buffer, <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[srv] client[%s:%d] is closed!\n&quot;</span>, inet_ntoa(cli_addr.sin_addr),</span><br><span class="line">             ntohs(cli_addr.sin_port));</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int64_t</span> result;</span><br><span class="line">    print_result(buffer, &amp;result);</span><br><span class="line">    <span class="type">uint64_t</span> res_network = htonll(result);  <span class="comment">// network byte order</span></span><br><span class="line">    write(connfd, &amp;res_network, <span class="keyword">sizeof</span>(res_network));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_sigint</span><span class="params">(<span class="type">int</span> sig)</span> &#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[srv] SIGINT is coming!\n&quot;</span>);</span><br><span class="line">  sigint_flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_result</span><span class="params">(<span class="type">char</span> *data, <span class="type">int64_t</span> *res)</span> &#123;</span><br><span class="line">  <span class="type">int32_t</span> op_int = *(<span class="type">int32_t</span> *)data;</span><br><span class="line">  <span class="type">int32_t</span> op = ntohl(op_int);</span><br><span class="line">  <span class="type">uint64_t</span> a_net = *(<span class="type">uint64_t</span> *)(data + <span class="keyword">sizeof</span>(op_int));</span><br><span class="line">  <span class="type">int64_t</span> a = ntohll(a_net);</span><br><span class="line">  <span class="type">uint64_t</span> b_net = *(<span class="type">uint64_t</span> *)(data + <span class="keyword">sizeof</span>(op_int) + <span class="keyword">sizeof</span>(a));</span><br><span class="line">  <span class="type">int64_t</span> b = ntohll(b_net);</span><br><span class="line">  <span class="type">char</span> op_symbol;</span><br><span class="line">  <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00000001</span>:</span><br><span class="line">      op_symbol = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">      *res = a + b;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00000002</span>:</span><br><span class="line">      op_symbol = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">      *res = a - b;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00000004</span>:</span><br><span class="line">      op_symbol = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">      *res = a * b;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00000008</span>:</span><br><span class="line">      op_symbol = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">      *res = a / b;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0x00000010</span>:</span><br><span class="line">      op_symbol = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">      *res = a % b;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// considering for compatibility</span></span><br><span class="line">  <span class="comment">// ref: https://coderfan.net/c-c-cross-platform-printf-variables.html</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[rqt_res] %&quot;</span> PRId64 <span class="string">&quot; %c %&quot;</span> PRId64 <span class="string">&quot; = %&quot;</span> PRId64 <span class="string">&quot;\n&quot;</span>, a, op_symbol,</span><br><span class="line">         b, *res);&#125;</span><br></pre></td></tr></table></figure>


      </div><div id="code2" class="tab-content is-hidden">
          <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*==========================================</span></span><br><span class="line"><span class="comment">  * author: gaojiaxing                      *</span></span><br><span class="line"><span class="comment">  * date: 2024-05-16 21:15:59               *</span></span><br><span class="line"><span class="comment">  * version: 1.0                            *</span></span><br><span class="line"><span class="comment">  * c standard: gnu23                       *</span></span><br><span class="line"><span class="comment">  * gcc version: 13.2.0                     *</span></span><br><span class="line"><span class="comment">  * OS: Ubuntu-24.04                        *</span></span><br><span class="line"><span class="comment">  ==========================================*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">handle_sigint</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_requests</span><span class="params">(<span class="type">int</span> connfd)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">htonll</span><span class="params">(<span class="type">uint64_t</span> host_64)</span>;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">ntohll</span><span class="params">(<span class="type">uint64_t</span> net_64)</span>;</span><br><span class="line"><span class="type">int</span> connfd;</span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">htonll</span><span class="params">(<span class="type">uint64_t</span> val)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (((<span class="type">uint64_t</span>)htonl(val)) &lt;&lt; <span class="number">32</span>) + htonl(val &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> <span class="title function_">ntohll</span><span class="params">(<span class="type">uint64_t</span> val)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (((<span class="type">uint64_t</span>)ntohl(val)) &lt;&lt; <span class="number">32</span>) + ntohl(val &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  sigemptyset(&amp;sa.sa_mask);</span><br><span class="line">  sigaction(SIGINT, &amp;sa, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;srv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">  srv_addr.sin_family = AF_INET;</span><br><span class="line">  srv_addr.sin_port = htons(atoi(argv[<span class="number">2</span>]));         <span class="comment">// port</span></span><br><span class="line">  inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;srv_addr.sin_addr);  <span class="comment">// ip</span></span><br><span class="line">  connfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">  connect(connfd, (<span class="keyword">struct</span> sockaddr *)&amp;srv_addr, <span class="keyword">sizeof</span>(srv_addr));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[cli] server[%s:%d] is connected!\n&quot;</span>, inet_ntoa(srv_addr.sin_addr),</span><br><span class="line">         ntohs(srv_addr.sin_port));</span><br><span class="line">  send_requests(connfd);</span><br><span class="line">  close(connfd);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[cli] connfd is closed!\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;[cli] client is going to exit!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">send_requests</span><span class="params">(<span class="type">int</span> connfd)</span> &#123;</span><br><span class="line">  <span class="comment">// send msg to srv</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">50</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    fgets(data, <span class="number">50</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strncmp</span>(data, <span class="string">&quot;EXIT&quot;</span>, <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[cli] command EXIT received\n&quot;</span>);</span><br><span class="line">      close(connfd);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> op[<span class="number">5</span>], op_symbol;</span><br><span class="line">    <span class="type">int32_t</span> op_idx;</span><br><span class="line">    <span class="type">int64_t</span> a, b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sscanf</span>(data, <span class="string">&quot;%s %&quot;</span> PRId64 <span class="string">&quot; %&quot;</span> PRId64, op, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op, <span class="string">&quot;ADD&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      op_idx = <span class="number">0x00000001</span>;</span><br><span class="line">      op_symbol = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op, <span class="string">&quot;SUB&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      op_idx = <span class="number">0x00000002</span>;</span><br><span class="line">      op_symbol = <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op, <span class="string">&quot;MUL&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      op_idx = <span class="number">0x00000004</span>;</span><br><span class="line">      op_symbol = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op, <span class="string">&quot;DIV&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      op_idx = <span class="number">0x00000008</span>;</span><br><span class="line">      op_symbol = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(op, <span class="string">&quot;MOD&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      op_idx = <span class="number">0x00000010</span>;</span><br><span class="line">      op_symbol = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ;</span><br><span class="line">      <span class="comment">// printf(&quot;[debug] Client Invalid Input: %s\n&quot;, op);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *req_pdu = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">150</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> net_op_idx = htonl(op_idx);</span><br><span class="line">    <span class="type">uint64_t</span> net_a = htonll(a);</span><br><span class="line">    <span class="type">uint64_t</span> net_b = htonll(b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(req_pdu, &amp;net_op_idx, <span class="keyword">sizeof</span>(net_op_idx));</span><br><span class="line">    <span class="built_in">memcpy</span>(req_pdu + <span class="keyword">sizeof</span>(net_op_idx), &amp;net_a, <span class="keyword">sizeof</span>(net_a));</span><br><span class="line">    <span class="built_in">memcpy</span>(req_pdu + <span class="keyword">sizeof</span>(net_op_idx) + <span class="keyword">sizeof</span>(net_a), &amp;net_b, <span class="keyword">sizeof</span>(net_b));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write to server</span></span><br><span class="line">    write(connfd, req_pdu, <span class="keyword">sizeof</span>(net_op_idx) + <span class="keyword">sizeof</span>(net_a) + <span class="keyword">sizeof</span>(net_b));</span><br><span class="line">    <span class="built_in">free</span>(req_pdu);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// receive from server</span></span><br><span class="line">    <span class="type">uint64_t</span> result_net;</span><br><span class="line">    read(connfd, &amp;result_net, <span class="keyword">sizeof</span>(result_net));</span><br><span class="line">    <span class="type">int64_t</span> result;</span><br><span class="line">    result = ntohll(result_net);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[rep_rcv] %&quot;</span> PRId64 <span class="string">&quot; %c %&quot;</span> PRId64 <span class="string">&quot; = %&quot;</span> PRId64 <span class="string">&quot;\n&quot;</span>, a, op_symbol,</span><br><span class="line">            b, result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      </div>

<h2 id="多进程、多线程并发服务器设计"><a href="#多进程、多线程并发服务器设计" class="headerlink" title="多进程、多线程并发服务器设计"></a>多进程、多线程并发服务器设计</h2><p>迭代服务器的特点</p>
<ul>
<li>多用户的情况下，连接建立后，若没有 accept，连接存放在 listen 函数队列</li>
<li>accept 从已完成队列的对头摘取新套接字</li>
<li>对客户端的服务是一个串行(serial)的过程</li>
</ul>
<p>采用多进程的方式引入并行<br>目的：使得每个客户端都能够得到一个进程的服务</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-16-17-24-48.png" style="zoom:80%;">

<p>可用 fork()实现多进程并发，或用 Pthreads 库实现多线程并发</p>
<h2 id="I-O-模型以及基于-I-O-复用的并发服务器设计"><a href="#I-O-模型以及基于-I-O-复用的并发服务器设计" class="headerlink" title="I&#x2F;O 模型以及基于 I&#x2F;O 复用的并发服务器设计"></a>I&#x2F;O 模型以及基于 I&#x2F;O 复用的并发服务器设计</h2><h3 id="五种-I-O-模式"><a href="#五种-I-O-模式" class="headerlink" title="五种 I&#x2F;O 模式"></a>五种 I&#x2F;O 模式</h3><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-16-17-49-19.png" style="zoom:100%;">

<ul>
<li>阻塞 I&#x2F;O (Linux 下的 I&#x2F;O 操作默认是阻塞 I&#x2F;O，即 open 和 socket 创建的 I&#x2F;O 都是阻塞 I&#x2F;O)</li>
<li>非阻塞 I&#x2F;O (可以通过 fcntl 或者 open 时使用 O_NONBLOCK 参数，将 fd 设置为非阻塞的 I&#x2F;O)</li>
<li>I&#x2F;O 多路复用 (I&#x2F;O 多路复用，通常需要非阻塞 I&#x2F;O 配合使用)—select，poll，epoll</li>
<li>信号驱动 I&#x2F;O (SIGIO)</li>
<li>异步 I&#x2F;O</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-16-17-57-56.png" style="zoom:100%;">

<p><strong>同步 IO 和异步 IO</strong><br>POSIX 定义这两个术语如下：<br>同步 I&#x2F;O 操作引起请求进程阻塞，直到 I&#x2F;O 操作完成；<br>异步 I&#x2F;O 操作不引起请求进程阻塞；</p>
<p>IO 的两个阶段都没有被阻塞，才能被称为异步 IO<br>因此，阻塞 I&#x2F;O 模型、非阻塞 I&#x2F;O 模型、 I&#x2F;O 复用模型和信号驱动模型都是同步 I&#x2F;O 模型；最后一种才是异步 IO<br>实际编程中，这几种 IO 模型经常根据需要混用<br>首先要避免被阻塞，但是阻塞并非都不好<br>在事件的检查点要阻塞<br>避免大量采用信号机制，主要原因是信号是异步的，将使程序变得很难编写。</p>
<h3 id="阻塞-I-O-模式"><a href="#阻塞-I-O-模式" class="headerlink" title="阻塞 I&#x2F;O 模式"></a>阻塞 I&#x2F;O 模式</h3><p>阻塞 IO 是最通用的 IO 类型，使用这种模型进行数据接收的时候，在数据没有到之前程序会一直等待。例如对于函数 recvfrom()，内核会一直阻塞该请求直到有数据到来才返回。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-16-17-50-45.png" style="zoom:80%;"><br>一个进程调用 recvfrom ，然后系统调用并不返回知道有数据报到达本地系统，然后系统将数据拷贝到进程的缓存中。<br>我们称这个进程在调用 recvfrom 一直到从 recvfrom 返回这段时间是阻塞的。当 recvfrom 正常返回时，我们的进程继续它的操作。<br>–阻塞 I&#x2F;O 模式下，一个进程只能处理一个流的 I&#x2F;O 事件。</p>
<h3 id="非阻塞-I-O-模式"><a href="#非阻塞-I-O-模式" class="headerlink" title="非阻塞 I&#x2F;O 模式"></a>非阻塞 I&#x2F;O 模式</h3><p>当把套接字设置成非阻塞的 IO，则对每次请求，内核都不会阻塞，会立即返回；当没有数据的时候，会返回一个错误。例如对 recvfrom()函数，前几次都没有数据返回，直到最后内核才向用户层的空间复制数据。</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-16-17-53-16.png" style="zoom:80%;">

<ol>
<li>非阻塞模式的使用并不普遍，因为非阻塞模式会浪费大量的 CPU 资源。</li>
<li>当我们将一个套接字设置为非阻塞模式，我们相当于告诉了系统内核： “当我请求的 I&#x2F;O 操作不能够马上完成，你想让我的进程进行休眠等待的时候，不要这么做，请马上返回一个错误给我。”</li>
<li>我们开始对 recvfrom 的第二次调用，因为系统还没有接收到网络数据，所以内核马上返回一个 EWOULDBLOCK 的错误。</li>
<li>第三次我们调用 recvfrom 函数，一个数据报已经到达了，内核将它拷贝到我们的应用程序的缓冲区中，然后 recvfrom 正常返回，我们就可以对接收到的数据进行处理了。</li>
<li>当一个应用程序使用了非阻塞模式的套接字，它需要使用一个循环，以监听测试是否一个文件描述符有数据可读(称做 polling，轮询)。应用程序不停的 polling 内核来检查是否 I&#x2F;O 操作已经就绪。这将是一个极浪费 CPU 资源的操作。这种模式使用中不是很普遍。</li>
</ol>
<h3 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h3><p>I&#x2F;O 多路复用的原理是为了避免 CPU 空转，使用一个代理（<code>select/poll/epoll..</code>）同时观察许多流的 I&#x2F;O 事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I&#x2F;O 事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流。例如 select()函数按照一定的超时时间轮询，直到需要等待的套接字有数据到来，利用 recvfrom()函数，将数据复制到应用层。</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-16-17-54-23.png" style="zoom:80%;">

<ol>
<li>为了避免 CPU 空转，可以引进了一个代理（一开始有一位叫做 select 的代理，后来又有一位叫做 poll 的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的 I&#x2F;O 事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I&#x2F;O 事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流。</li>
<li>select 能等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</li>
<li>但是使用 select，有 <code>O(n)</code>的无差别轮询复杂度，同时处理的流越多，轮询时间就越长。</li>
<li>epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 之会把哪个流发生了怎样的 I&#x2F;O 事件通知我们。此时我们对这些流的操作都是有意义的。（复杂度降低到了<code>O(1)</code>）</li>
</ol>
<h4 id="信号驱动-IO-模型"><a href="#信号驱动-IO-模型" class="headerlink" title="信号驱动 IO 模型"></a>信号驱动 IO 模型</h4><p>信号驱动的 IO 在进程开始的时候注册一个信号处理的回调函数，进程继续执行，当信号发生时，即有了 IO 的时间，这里即有数据到来，利用注册的回调函数将到来的数据用 recvfrom()接收到。</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-16-17-56-27.png" style="zoom:80%;">

<p>所谓信号驱动，就是利用信号机制，安装信号 SIGIO 的处理函数（进行 IO 相关操作），通过监控文件描述符，当其就绪时，通知目标进程进行 IO 操作（signal handler）</p>
<h4 id="异步-IO-模型"><a href="#异步-IO-模型" class="headerlink" title="异步 IO 模型"></a>异步 IO 模型</h4><p>异步 IO 与前面的信号驱动 IO 相似，其区别在于信号驱动 IO 当数据到来的时候，使用信号通知注册的信号处理函数，而异步 IO 则在数据复制完成的时候才发送信号通知注册的信号处理函数。</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch7-SocketProgramming-2024-06-16-17-57-09.png" style="zoom:80%;">

<p>Linux 上异步 IO 有一组 POSIX 规定的接口，以 aio 开头的几个 SYSCALL。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aio_read</span><span class="params">(<span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">aio_write</span><span class="params">(<span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">aio_return</span><span class="params">(<span class="keyword">struct</span> aiocb *aiocbp)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="客户端-服务器程序设计-核心问题解析"><a href="#客户端-服务器程序设计-核心问题解析" class="headerlink" title="客户端&amp;服务器程序设计&amp;核心问题解析"></a>客户端&amp;服务器程序设计&amp;核心问题解析</h2><h3 id="服务器特权和复杂性"><a href="#服务器特权和复杂性" class="headerlink" title="服务器特权和复杂性"></a>服务器特权和复杂性</h3><ul>
<li>服务器经常需要访问受操作系统保护的资源：需要系统特权</li>
<li>服务器不能把特权传递给使用服务的客户</li>
<li>服务器需要处理的安全问题：<ul>
<li>鉴别：验证客户身份</li>
<li>授权：判断某个客户是否可以使用服务器提供的服务</li>
<li>数据安全：确保数据不被无意泄漏或者损坏</li>
<li>保密：防止未经授权访问信息</li>
<li>保护：确保网络程序不能滥用系统资源</li>
</ul>
</li>
<li>特权和并发导致了服务器软件的复杂性</li>
</ul>
<h3 id="核心设计问题"><a href="#核心设计问题" class="headerlink" title="核心设计问题"></a>核心设计问题</h3><ul>
<li><strong>通信模式与协议</strong><ul>
<li>C&#x2F;S vs. P2P</li>
<li>传输层 UDP vs.TCP</li>
<li>应用层协议交互流程</li>
<li>应用层协议 PDU 设计</li>
</ul>
</li>
<li><strong>客户端程序设计</strong><ul>
<li>如何指定服务器</li>
<li>PDU 的解析处理与构建</li>
<li>是否需要多进程或多线程设计</li>
<li>如何结束通信</li>
</ul>
</li>
<li><strong>服务器程序设计</strong><ul>
<li>如何指定监听地址</li>
<li>PDU 的解析处理与构建</li>
<li>循环 vs. 并发？若并发：多进程 vs. 多线程 vs. I&#x2F;O 复用</li>
<li>注册登录用户如何管理</li>
<li>数据如何转发</li>
</ul>
</li>
</ul>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p>扩展了解：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiongmaojiayou/article/details/7584211">关于 PF_INET 和 AF_INET 的区别</a> （AF 是 BSD 规范，PF 是 posix 规范）<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/heluan/p/10937098.html">Socket 通信中 AF_INET 和 AF_UNIX 域的区别</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/tnt_xixixi/article/details/86728525">浅谈 uint8_t 等以_t 结尾的数据类型</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/280711576">一文理解可重入函数</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>套接字编程 Socket Programming</p><p><a href="https://efterklang.github.io/UESTC/ComputerNetworking/Ch7-SocketProgramming/">https://efterklang.github.io/UESTC/ComputerNetworking/Ch7-SocketProgramming/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Efterklang</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-06-15</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-06-26</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Linux/">Linux</a><a class="link-muted mr-2" rel="tag" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/UESTC/OS/Ch8-Shell/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Shell 编程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/Essay/Poems/%E3%80%8A%E5%94%90%E5%A4%9A%E4%BB%A4%C2%B7%E8%8A%A6%E5%8F%B6%E6%BB%A1%E6%B1%80%E6%B4%B2%E3%80%8B/"><span class="level-item"> </span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.30/dist/twikoo.all.min.js"></script><script>twikoo.init({
            envId: 'https://efterklang-twikoo.hf.space',
            
            lang: "en",
            onCommentLoaded: function () {
              var commentContents = document.getElementsByClassName('tk-content');
              for (var i = 0; i < commentContents.length; i++) {
                var commentItem = commentContents[i];
                var imgEls = commentItem.getElementsByTagName('img');
                if (imgEls.length > 0) {
                  for (var j = 0; j < imgEls.length; j++) {
                    var imgEl = imgEls[j];
                    var aEl = document.createElement('a');
                    aEl.setAttribute('class', 'tk-lg-link');
                    aEl.setAttribute('href', imgEl.getAttribute('src'));
                    aEl.setAttribute('data-src', imgEl.getAttribute('src'));
                    aEl.appendChild(imgEl.cloneNode(false));
                    imgEl.parentNode.insertBefore(aEl, imgEl.nextSibling);
                    imgEl.remove();
                  }
                  if (typeof $.fn.lightGallery === 'function') {
                    $(commentItem).lightGallery({
                      selector: '.tk-lg-link'
                    });
                  }
                }
              }
            }
        });</script></div></div></div><style>.column.column-left,.column.column-right{display:none}</style><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#网络编程相关基础知识"><span class="level-left"><span class="level-item">1</span><span class="level-item">网络编程相关基础知识</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Endianness"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Endianness</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Big-Endian"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">Big-Endian</span></span></a></li><li><a class="level is-mobile" href="#Little-Endian"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">Little-Endian</span></span></a></li><li><a class="level is-mobile" href="#Network-Endian"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">Network-Endian</span></span></a></li><li><a class="level is-mobile" href="#字节序变换"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">字节序变换</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Data-Alignment"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Data Alignment</span></span></a></li><li><a class="level is-mobile" href="#接口协议"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">接口协议</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#POSIX"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">POSIX</span></span></a></li><li><a class="level is-mobile" href="#System-Call"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">System Call</span></span></a></li><li><a class="level is-mobile" href="#LINUX-中提供的基本-I-O-功能"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">LINUX 中提供的基本 I/O 功能</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Socket-基本概念"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Socket 基本概念</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#主动-Socket-和被动-Socket"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">主动 Socket 和被动 Socket</span></span></a></li><li><a class="level is-mobile" href="#Socket-类型"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">Socket 类型</span></span></a></li><li><a class="level is-mobile" href="#地址结构"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">地址结构</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Socket-套接字与循环服务器"><span class="level-left"><span class="level-item">2</span><span class="level-item">Socket 套接字与循环服务器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简单-TCP-循环服务器-Socket-编程基本步骤"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">简单 TCP 循环服务器 Socket 编程基本步骤</span></span></a></li><li><a class="level is-mobile" href="#简单-UDP-循环服务器-Socket-编程基本步骤"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">简单 UDP 循环服务器 Socket 编程基本步骤</span></span></a></li><li><a class="level is-mobile" href="#Socket-核心函数"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Socket 核心函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#socket"><span class="level-left"><span class="level-item">2.3.1</span><span class="level-item">socket()</span></span></a></li><li><a class="level is-mobile" href="#bind"><span class="level-left"><span class="level-item">2.3.2</span><span class="level-item">bind()</span></span></a></li><li><a class="level is-mobile" href="#listen"><span class="level-left"><span class="level-item">2.3.3</span><span class="level-item">listen()</span></span></a></li><li><a class="level is-mobile" href="#accept"><span class="level-left"><span class="level-item">2.3.4</span><span class="level-item">accept()</span></span></a></li><li><a class="level is-mobile" href="#connect"><span class="level-left"><span class="level-item">2.3.5</span><span class="level-item">connect()</span></span></a></li><li><a class="level is-mobile" href="#send-sendto"><span class="level-left"><span class="level-item">2.3.6</span><span class="level-item">send() &amp; sendto()</span></span></a></li><li><a class="level is-mobile" href="#recv-recvfrom"><span class="level-left"><span class="level-item">2.3.7</span><span class="level-item">recv() &amp; recvfrom()</span></span></a></li><li><a class="level is-mobile" href="#close"><span class="level-left"><span class="level-item">2.3.8</span><span class="level-item">close()</span></span></a></li><li><a class="level is-mobile" href="#Example"><span class="level-left"><span class="level-item">2.3.9</span><span class="level-item">Example</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#多进程、多线程并发服务器设计"><span class="level-left"><span class="level-item">3</span><span class="level-item">多进程、多线程并发服务器设计</span></span></a></li><li><a class="level is-mobile" href="#I-O-模型以及基于-I-O-复用的并发服务器设计"><span class="level-left"><span class="level-item">4</span><span class="level-item">I/O 模型以及基于 I/O 复用的并发服务器设计</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#五种-I-O-模式"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">五种 I/O 模式</span></span></a></li><li><a class="level is-mobile" href="#阻塞-I-O-模式"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">阻塞 I/O 模式</span></span></a></li><li><a class="level is-mobile" href="#非阻塞-I-O-模式"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">非阻塞 I/O 模式</span></span></a></li><li><a class="level is-mobile" href="#I-O-多路复用"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">I/O 多路复用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#信号驱动-IO-模型"><span class="level-left"><span class="level-item">4.4.1</span><span class="level-item">信号驱动 IO 模型</span></span></a></li><li><a class="level is-mobile" href="#异步-IO-模型"><span class="level-left"><span class="level-item">4.4.2</span><span class="level-item">异步 IO 模型</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#客户端-服务器程序设计-核心问题解析"><span class="level-left"><span class="level-item">5</span><span class="level-item">客户端&amp;服务器程序设计&amp;核心问题解析</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#服务器特权和复杂性"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">服务器特权和复杂性</span></span></a></li><li><a class="level is-mobile" href="#核心设计问题"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">核心设计问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Ref"><span class="level-left"><span class="level-item">6</span><span class="level-item">Ref</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Dev/"><span class="level-start"><span class="level-item">Dev</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/Dev/DataBase/"><span class="level-start"><span class="level-item">DataBase</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Others/"><span class="level-start"><span class="level-item">Others</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Essay/"><span class="level-start"><span class="level-item">Essay</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Essay/Game/"><span class="level-start"><span class="level-item">Game</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Essay/Poems/"><span class="level-start"><span class="level-item">Poems</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/UESTC/"><span class="level-start"><span class="level-item">UESTC</span></span><span class="level-end"><span class="level-item tag">40</span></span></a><ul><li><a class="level is-mobile" href="/categories/UESTC/ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">ARM处理器体系结构及应用</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">数据库原理及应用</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">April 2024</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/vultr.svg" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/vultr.svg" alt="Efterklang" height="28"></a><p class="is-size-7"><span>&copy; 2024 Efterklang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>
<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Storage Management Part Ⅰ - Efterklang</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Efterklang"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Efterklang"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="介绍存储管理第一部分。包括存储器的层次结构、程序的装入和链接、连续分配存储管理方式三大部分。"><meta property="og:type" content="article"><meta property="og:title" content="Storage Management Part Ⅰ"><meta property="og:url" content="https://efterklang.github.io/UESTC/OS/Ch4-1StorageManagement/"><meta property="og:site_name" content="Efterklang"><meta property="og:description" content="介绍存储管理第一部分。包括存储器的层次结构、程序的装入和链接、连续分配存储管理方式三大部分。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://efterklang.github.io/img/thumbnails/OS/Ch4-1Storage.jpg"><meta property="article:published_time" content="2024-04-18T13:19:38.000Z"><meta property="article:modified_time" content="2024-06-12T09:26:01.297Z"><meta property="article:author" content="Efterklang"><meta property="article:tag" content="OS"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://efterklang.github.io/img/thumbnails/OS/Ch4-1Storage.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://efterklang.github.io/"},"headline":"Storage Management Part Ⅰ","image":["https://efterklang.github.io/img/thumbnails/OS/Ch4-1Storage.jpg"],"datePublished":"2024-04-18T13:19:38.000Z","dateModified":"2024-06-12T09:26:01.297Z","author":{"@type":"Person","name":"efterklang"},"publisher":{"@type":"Organization","name":"Efterklang","logo":{"@type":"ImageObject","url":{"light":"/img/sunflower.png","dark":"/img/sunflower.png"}}},"description":"介绍存储管理第一部分。包括存储器的层次结构、程序的装入和链接、连续分配存储管理方式三大部分。"}</script><link rel="canonical" href="https://efterklang.github.io/UESTC/OS/Ch4-1StorageManagement/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/tokyo-night-dark.css"><link data-pjax rel="stylesheet" href="/css/default.css"><link rel="dns-prefetch" href="https://efterklang.github.io"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><meta name="msvalidate.01" content="039770FFD6F5D1B53B42B9D3271EA9B9"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-HKYTDLW5FP" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-HKYTDLW5FP');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"><link rel="alternate" href="/atom.xml" title="Efterklang" type="application/atom+xml">
</head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/gallery">Gallery</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/onedrive">Onedrive</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="github" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/thumbnails/OS/Ch4-1Storage.jpg" alt="Storage Management Part Ⅰ" referrerpolicy="no-referrer"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-04-18T13:19:38.000Z" title="4/18/2024, 9:19:38 PM">2024-04-18</time></span><span class="level-item"><a class="link-muted" href="/categories/UESTC/">UESTC</a><span> / </span><a class="link-muted" href="/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span><span class="level-item">an hour read (About 10664 words)</span><span class="level-item leancloud_visitors" id="/UESTC/OS/Ch4-1StorageManagement/" data-flag-title="Storage Management Part Ⅰ"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">Storage Management Part Ⅰ</h1><div class="content"><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><h3 id="存储器层次结构概述"><a href="#存储器层次结构概述" class="headerlink" title="存储器层次结构概述"></a>存储器层次结构概述</h3><p>为能更多的存放并更快地处理用户信息，目前许多计算机把存储器分为三级。</p>
<ul>
<li><strong>高速缓存</strong> Cache：K 字节、高速、昂贵、易变的</li>
<li><strong>内存</strong> RAM： M 或 G 字节、中速、中等价格、易变的</li>
<li><strong>磁盘</strong>：G 或 T 字节、低速、价廉、不易变的</li>
</ul>
<blockquote>
<p>寄存器、高速缓存、主存储器和磁盘缓存均属于操作系统存储管理的管辖范畴，掉电后它们存储的信息不再存在。<br>磁盘和可移动存储介质属于设备管理的管辖范畴，它们存储的信息将被长期保存。</p>
</blockquote>
<h4 id="主存储器与寄存器"><a href="#主存储器与寄存器" class="headerlink" title="主存储器与寄存器"></a>主存储器与寄存器</h4><ol>
<li><p><strong>主存储器</strong>（内存，主存，可执行存储器）<br>用于保存进程运行时的程序和数据。CPU 的控制部件只能从主存中取得指令和数据到 CPU 寄存器，同样，CPU 寄存器中的数据可存入主存。<br>CPU 与外设交换数据必须依托于主存。</p>
</li>
<li><p><strong>寄存器</strong><br>寄存器访问速度最快，与 CPU 协调工作。<br>高速缓存与磁盘缓存<br>CPU 对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。<br>根据程序执行的<strong>局部性原理</strong>，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。<br>有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。</p>
<blockquote>
<p>局部性原理（Locality Principle）指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，时间局部性是指一个数据项或指令在一段时间内被反复使用的特点，空间局部性是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。<br>在分页机制中，页表的作用是将虚拟地址转换为物理地址，从而完成内存访问。在这个过程中，局部性原理的作用体现在两个方面：<br>时间局部性：由于程序中存在一定的循环或者重复操作，因此会反复访问同一个页或一些特定的页，这就体现了时间局部性的特点。为了利用时间局部性，分页机制中通常采用缓存机制来提高页面的命中率，即将最近访问过的一些页放入缓存中，如果下一次访问的页已经在缓存中，就不需要再次访问内存，而是直接从缓存中读取。<br>空间局部性：由于程序中数据和指令的访问通常是具有一定的空间连续性的，因此当访问某个页时，往往会顺带访问其相邻的一些页。为了利用空间局部性，分页机制中通常采用预取技术来预先将相邻的一些页读入内存缓存中，以便在未来访问时能够直接使用，从而提高访问速度。总之，局部性原理是计算机体系结构设计的重要原则之一，也是许多优化算法的基础。在分页机制中，利用时间局部性和空间局部性，采用缓存和预取技术，可以提高页面的命中率，从而提高内存访问效率</p>
</blockquote>
</li>
</ol>
<h4 id="高速缓存与磁盘缓存"><a href="#高速缓存与磁盘缓存" class="headerlink" title="高速缓存与磁盘缓存"></a>高速缓存与磁盘缓存</h4><ol>
<li><strong>高速缓存</strong><br>CPU 对高速缓存的访问，其速度比访问主存快，比访问寄存器慢。<br>根据程序执行的局部性原理，将主存中一些经常访问的数据存放在高速缓存中，减少访问主存的次数，提高程序的执行速度。<br>有些计算机系统设置了两级高速缓存，即，一级高速缓存与二级高速缓存。</li>
<li><strong>磁盘缓存</strong><br>内存中一块存储区，对应于某固定磁盘，临时存储磁盘数据（如，数据预取）</li>
</ol>
<h3 id="存储器管理的目的和功能"><a href="#存储器管理的目的和功能" class="headerlink" title="存储器管理的目的和功能"></a>存储器管理的目的和功能</h3><p>操作系统负责协调这些存储器的使用<br>三级存储器，从缓存到内存到外存，其容量愈来愈大，而访问数据的速度则愈来愈慢，价格也愈来愈便宜。<br>用户的程序在运行时应存放在主存中，以便处理机访问。<br>为尽可能利用 CPU，要求直接存取内存的速度尽量快到与 CPU 取指速度相匹配，容量大到能装下当前运行的程序与数据<br>由于主存容量和速度有限。所以把那些不马上使用的程序、数据放在外部存储器(又称辅存)中。当用到时再把它们读入主存。</p>
<ol>
<li><strong>主存储器的分配和管理</strong>：按用户要求把适当的存储空间分配给相应的作业。一个有效的存储分配机制，应在用户请求时能作出快速的响应，分配相应的存储空间；在用户不再使用它时，应立即回收，以供其他用户使用。为此，这个存储分配机制应具有如下功能：<br>(1)记住每个存储区域的状态：哪些是已分配的，哪些是可以用作分配的。<br>(2)实施分配：在系统程序或用户提出申请时，按所需的量给予分配；修改相应的分配记录表。<br>(3)接受系统或用户释放的存储区域：并相应地修改分配记录表。</li>
<li><strong>提高主存储器的利用率</strong>：使多道程序能动态地共享主存，最好能共享主存中的信息</li>
<li><strong>“扩充”主存容量</strong>：这是借助于提供虚拟存储器或其它自动覆盖技术来达到的。即为用户提供比主存的存储空间还大的地址空间</li>
<li><strong>存储保护</strong>：确保各道用户作业都在所分配的存储区内操作，互不干扰。即要防止一道作业由于发生错误而损害其它作业，特别需要防止破坏其中的系统程序。这个问题不能用特权指令来加以解决，而必须由硬件提供保护功能，并由软件配合实现</li>
</ol>
<h3 id="存储分配的三种方式"><a href="#存储分配的三种方式" class="headerlink" title="存储分配的三种方式"></a>存储分配的三种方式</h3><p>存储分配，解决多道作业之间共享主存的问题。确定什么时候，以什么方式，把一个作业的全部信息或作业运行时首先需要的信息分配到主存中，并使这些问题对用户来说尽可能是<strong>透明</strong>的。</p>
<blockquote>
<p>“对用户透明”（User Transparency）是一种计算术语，它指的是用户在使用系统或服务时，不需要关心或理解其背后的复杂实现细节。换句话说，系统或服务的复杂性对用户是”透明”的。</p>
</blockquote>
<p>解决存储分配问题的三种方式：</p>
<blockquote>
<p>目前，绝大多数计算机系统都采用静态或动态存储分配方式</p>
</blockquote>
<ol>
<li><strong>直接指定方式</strong>：程序员在编程序时，或编译程序(汇编程序)对源程序进行编译(汇编)时，使用实际存储地址。<ul>
<li>在多道程序环境下，应保证各作业所用的地址互不重叠。在多道程序发展的初期，通常把存储空间划分成若干个固定的不同大小分区，并对不同的作业指定相应的分区。因此，对编程人员或对编译程序而言，存储器的可用空间是可知的</li>
<li>采用直接指定方式分配的前提是：存储器的可用容量(空间)已经给定或者可以指定，这对单用户计算机系统是不成问题的</li>
<li>这种分配方式的实质是：由编程人员在编写程序时，或由编译程序编译源程序时，对一个作业的所有信息确定在主存存储空间中的位置。因此，这种直接指定方式的存储分配方案，不仅用户感到不便，而且存储空间的利用也不那么有效</li>
</ul>
</li>
<li><strong>静态分配方式</strong>(Static Allocation)<br>用户在编程时，或由编译程序产生的目的程序，均可从其地址空间的零地址开始；当<strong>装配程序</strong>对其进行连接装入时才确定它们在主存中的相应位置，从而生成可执行程序。也就是说，存储分配是在装入时实现的。静态分配策略的存储管理很简单，但在多道程序系统中不能有效地共享存储器资源<br>这种静态存储分配方式的特点是：<ul>
<li>在一个作业装入时必须分配其要求的全部存储量；</li>
<li>如果没有足够的存储空间，就不能装入该作业；</li>
<li>一旦一个作业进入内存后，在其退出系统之前，它一直占用着分配给它的全部存储空间；</li>
<li>作业在整个运行过程中不能在内存中“搬家”、也不能再申请存储量。</li>
</ul>
</li>
<li><strong>动态分配方式</strong>(Dynamic Allocation)：<br>动态分配是一种更加有效的使用主存储器的方法。这种动态存储分配方式的特点是：<ul>
<li>作业在存储空间中的位置，也是在其装入时确定的；</li>
<li>在其执行过程中可根据需要申请附加的存储空间；</li>
<li>一个作业已占用的部分存储区域不再需要时，可以要求归还给系统。即：这种存储分配机制能接受不可预测的分配和释放存储区域的请求，实现个别存储区域的分配和回收；</li>
<li>存储区域的大小是可变的；</li>
<li>允许作业在内存中“搬家”。</li>
</ul>
</li>
</ol>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>逻辑地址</strong>（相对地址，虚地址） Logical Address<br>用户的程序经过汇编或编译后形成目标代码，目标代码通常采用相对地址的形式，其首地址为 0，其余指令中的地址都相对于首地址而编址。不能用逻辑地址在内存中读取信息<br><strong>物理地址</strong>（绝对地址，实地址）Physical Address<br>内存中存储单元的地址，可直接寻址<br><strong>名空间</strong> namespace<br>是一种封装或组织代码的方式，它可以将一组标识符（如变量、函数、类、模块等）包含在一个名为命名空间的范围内<br><strong>地址空间</strong> Address Space<br>程序用来访问信息所用地址单元的集合，是逻辑（相对）地址的集合，由编译程序生成。<br><strong>存储空间</strong> Storage Space<br>主存中物理单元的集合。这些单元的编号称物理地址或绝对地址。存储空间的大小是由主存的实际容量决定的。</p>
<blockquote>
<p>地址空间是逻辑地址的集合；存储空间是物理地址的集合。一个是“虚”的概念，一个是“实”的物体。<br>一个编译好的目标程序存在于它自己的地址空间中，当要它在计算机上运行时，才把它装入存储空间。<br>一个作业在编译、装入前后存在于不同的空间。</p>
</blockquote>
<h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>将一个用户源程序变为一个可在内存中执行的程序，通常要经过下列几步：</p>
<ul>
<li><strong>预处理</strong>（Preprocessing）：这是编译过程的第一步，主要处理源代码中的预处理器指令。例如，C 和 C++语言中的<code>#include</code>和<code>#define</code>等。预处理器将处理这些指令，如扩展包含文件，替换宏定义等，生成一个预处理后的源代码文件。</li>
<li><strong>编译</strong>（Compilation）：在这个阶段，编译器将预处理后的源代码转换为汇编语言。编译器在这个过程中会进行词法分析、语法分析、语义分析和优化等操作。编译器还会检查源代码中的错误，并生成对应的错误和警告信息。</li>
<li><strong>汇编</strong>（Assembly）：汇编阶段将编译阶段生成的汇编代码转换为机器语言代码，也就是目标代码。这个过程是由汇编器完成的。每一条汇编语言指令通常会被转换为一条机器语言指令。</li>
<li><strong>链接</strong>（Linking）：链接阶段是将所有的目标代码和必要的库函数链接在一起，生成一个可执行文件。链接器会处理源代码中的外部符号引用，将它们与正确的地址或者符号绑定在一起。</li>
<li><strong>装入</strong>（Loading）：当程序运行时，加载器（Loader）的任务是将可执行文件从硬盘加载到内存中，然后开始执行。加载器还负责解析程序对动态库的依赖，并将这些库加载到内存中。</li>
</ul>
<h3 id="程序的装入"><a href="#程序的装入" class="headerlink" title="程序的装入"></a>程序的装入</h3><p>根据存储空间的分配方式，将一个装入模块装入内存时，可采用三种方式：</p>
<ol>
<li><strong>绝对装入方式</strong>Absolute Loading Mode：<br>在编译时，如果知道程序将驻留在内存的具体位置，那么编译程序将产生**实际存储地址(绝对地址)**的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。<ul>
<li>装入模块被装入内存后，由于程序中的逻辑地址与实际内存地址完全相同，故不需对程序和数据的地址进行修改。</li>
<li>通常在程序中采用符号地址，然后在编译或汇编时，再将这些符号地址转换为绝对地址。</li>
</ul>
</li>
<li><strong>静态重定位装入方式</strong>Static Relocation Loading Mode：<br>地址变换是在装入内存时一次完成的，且以后不能移动。<br>一般情况下,物理地址&#x3D;相对地址+内存中的起始地址<br>适用于多道程序环境，可以将装入模块装入到内存中任何允许的位置。<ul>
<li>优点：不需硬件支持，可以装入有限多道程序。</li>
<li>缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动，不易实现共享。</li>
</ul>
</li>
<li><strong>动态重定位装入方式&#x2F;动态运行时装入方式</strong>Dynamic Run-time Loading<br>装入程序将装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是<strong>把地址转换推迟到程序执行时进行</strong>。在硬件地址变换机构的支持下，随着对每条指令或数据的访问自动进行地址变换，故称为<strong>动态重定位</strong><br>最简单的办法是利用一个重定位寄存器(RR)。该寄存器的值是由进程调度程序根据作业分配到的存储空间起始地址来设定的。<br>在具有这种地址变换机构的计算机系统中，当执行作业时，不是根据 CPU 给出的有效地址去访问主存，而是将有效地址与重定位寄存器中的内容相加后得到的地址作为访问主存的地址<br>采用动态重定位技术后，程序中所有指令和数据的实际地址是在运行过程中最后访问的时刻确定的。也就是说，在作业运行过程中临时申请分配附加的存储区域或释放已占用的部分存储空间是允许的。<ul>
<li><strong>主要优点</strong><br>① 主存的使用更加灵活有效。这里，一个用户的作业不一定要分配在一个连续的存储区，因而可以使用较小的分配单位。而且，在作业开始之前也不一定把它的地址空间全部装入主存，而可以在作业执行期间响应请求动态地进行分配。<br>② 几个作业共享一程序段的单个副本比较容易。<br>③ 有可能向用户提供一个比主存的存储空间大得多的地址空间。因而无需用户来考虑覆盖结构，而由系统来负责全部的存储管理。</li>
<li><strong>主要缺点</strong><br>① 需要附加硬件支持；<br>② 实现存储器管理的软件比较复杂。</li>
</ul>
</li>
</ol>
<h3 id="程序的链接"><a href="#程序的链接" class="headerlink" title="程序的链接"></a>程序的链接</h3><p>链接程序的功能，是将经过编译后所得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。<br>连接程序按各个模块的相对地址依次构成统一的从 0 号单元开始编址的逻辑地址空间<br>根据链接时间的不同，可把链接分成如下三种：</p>
<ol>
<li><p><strong>静态链接</strong> Static Linking<br>在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开。<br>将几个目标链接装配成一个装入模块时，需解决以下两个问题：</p>
<ul>
<li>将相对地址进行修改。即将除第一个模块外的相对地址修改成装入模块中的相应的相对地址</li>
<li>变换外部调用符号。即将每个模块中所用的外部调用符号，都变换为相对地址。<br>这种先进行链接所形成的一个完整的装入模块，又称为可执行文件<br>Pros：适用范围广，不必担心用户机器缺少某个库函数<br>Cons：修改或更新某个目标模块时，需要重新打开装入模块，效率低且很多时候不可行；静态链接的每个模块都要有目标模块的副本，无法实现共享，浪费空间</li>
</ul>
</li>
<li><p><strong>装入时动态链接</strong>Load-Time Dynamic Linking<br>用户源程序经编译后所得到的目标模块，是在装入内存时，边装入边链接的。即在装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将其装入内存。<br>Pros：便于软件版本的修改和更新,只需修改各个目标模块，不必将装入模块拆开，非常方便;便于实现目标模块共享。即可以将一个目标模块链接到几个应用模块中，从而实现多个应用程序对该模块的共享。</p>
</li>
<li><p><strong>运行时动态链接</strong>(Run-Time Dynamic Linking)<br>目前最常使用的链接方式,采用装入时动态链接方式，虽然可将一个装入模块装入到内存的任何地方，但装入模块的结构是静态的，表现在：</p>
<ul>
<li>进程（程序）在整个执行期间，装入模块是不改变的；</li>
<li>每次运行时的装入模块是相同的。并且事先无法知道本次要运行哪些模块，只能将所有可能要运行的模块在装入时全部链接在一起，而实际上往往有些目标模块根本不会运行。<br>采用运行时动态链接可<strong>将某些目标模块的链接推迟到执行时才进行</strong>，即在执行过程中，若发现一个被调用模块尚未装入内存时，由 OS 去找到该模块，将它装入内存，并链接到调用模块上。<blockquote>
<p>运行时动态链接的工作原理如下：</p>
<ol>
<li><strong>加载阶段</strong>：当程序启动时，动态链接器（在 Unix-like 系统中通常是 ld.so 或 ld-linux.so，在 Windows 系统中是 kernel32.dll）会加载程序需要的动态链接库（DLL）或共享对象（SO）文件。这些库文件包含程序需要的函数和数据。</li>
<li><strong>链接阶段</strong>：在程序运行时，当程序第一次调用某个库函数时，动态链接器会查找这个函数在内存中的实际地址，并将这个地址写入程序的全局偏移表（GOT）或程序查找表（PLT）。这个过程被称为“解析”。</li>
<li><strong>运行阶段</strong>：一旦函数地址被解析，程序就可以直接调用这个函数，而不需要再次通过动态链接器。如果程序再次调用这个函数，它会直接从 GOT 或 PLT 中获取函数的地址。</li>
</ol>
<p>运行时动态链接的优点包括：</p>
<ul>
<li><strong>主要优点</strong>:凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</li>
<li><strong>节省内存</strong>：因为多个程序可以共享同一个库的单个副本。</li>
<li><strong>模块化</strong>：程序可以在运行时加载和卸载模块，这使得程序更加灵活和可扩展。</li>
<li><strong>版本控制</strong>：可以在不重新编译程序的情况下更新库。</li>
</ul>
<p>运行时动态链接的缺点包括：</p>
<ul>
<li><strong>性能开销</strong>：动态链接和解析需要时间，尤其是在程序第一次调用库函数时。</li>
<li><strong>兼容性问题</strong>：如果库的新版本和旧版本不兼容，那么使用这个库的程序可能会出错。</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>连续分配指为用户程序分配一个连续的内存空间。<br>程序空间本来就是连续的,用连续的内存装入连续的程序，减少管理工作的难度<br>连续分配有三种方式：</p>
<ol>
<li><strong>单一连续分配方式</strong><br>单用户系统在一段时间内，只有一个进程在内存，故内存分配管理十分简单，内存利用率低。内存分为两个区域，一个供操作系统使用，一个供用户使用.</li>
<li><strong>分区式分配方式</strong><br>系统把内存用户区划分为若干分区，分区大小可以相等，也可以不等。一个进程占据一个分区。这是早期用于多道程序的一种较简单的存储管理方式。它又可以分为：<ul>
<li>固定分区</li>
<li>动态（可变）分区</li>
</ul>
</li>
<li><strong>可重定位分区分配</strong>(汤子瀛)</li>
</ol>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>内存中仅驻留一道用户程序，整个用户区为一个用户独占。<br>内存分为两个区域：系统区，用户区。应用程序装入到用户区，可使用用户区全部空间。<br>最简单，适用于单用户、单任务的 OS。</p>
<ul>
<li>优点：易于管理。</li>
<li>缺点：对要求内存空间少的程序，造成内存浪费；程序全部装入，很少使用的程序部分也占用内存。<br>例如：DOS 2.0 以下的 DOS 操作系统采用单一连续区域主存管理方法。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-10-51-38.png"></li>
</ul>
<blockquote>
<p><strong>🌟 内存碎片</strong><br>内部碎片 Internal Fragment：分配给用户但用户没有使用的空间，即多分配的空间。分配给进程的内存空间比进程所需的内存空间大，但未使用的部分不能再分配给其他进程，造成内部碎片。<br>外部碎片 External Fragment：没有分配但无法分配的空间，即太小而无法分配的空间。相邻已分配内存空间的空闲区域太小，不能分配给需要的进程，造成外部碎片。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-05-05-11-34-52.png" style="zoom:50%;"></p>
</blockquote>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p><strong>固定分区分配思想</strong>：将内存用户空间划分为若干个固定大小的区域，每个区域称为一个分区（region），在每个分区中只装入一道作业 ，从而支持多道程序并发设计。<br>由于这些存储区域是在系统启动时划定的，在用户作业装入及运行过程中，其区域的大小和边界是不能改变的。<br>固定式分区的划分方法有两种：<br>(1)分区大小相等<br>(2)分区大小不等<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-10-54-48.png"><br>为了实现这种固定分区的分配，系统需要建立一张<strong>分区说明表</strong>。这个分区说明表指出可用于分配的分区数以及每个区的大小、起始地址及状态(是否已被分配)<br><strong>内存分配过程</strong><br>当有作业要装入内存时，内存分配程序检索分区说明表，从中找出一个尚未使用的满足大小要求的分区分配给该作业，然后修改分区的状态；如果找不到合适的分区就拒绝为该作业分配内存。</p>
<blockquote>
<p>内存中已分配给用户但未被利用的区域称为 “内零头”（内部碎片，内碎片）;固定分区分配有内零头产生</p>
</blockquote>
<ul>
<li>优点：易于实现，开销小</li>
<li>缺点：内碎片造成浪费；分区总数固定，限制了并发执行的程序数目；存储空间的利用率太低。现在的操作系统几乎不用它了。</li>
</ul>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>动态分区分配是指根据进程的实际需要，动态地为之分配连续的内存空间。即分区的边界可以移动，分区的大小是可变的。<br>动态分区又有两种不同选择，一种是分区的<strong>数目固定大小可变</strong>，而另一种则允许分区的<strong>数目和大小都可变</strong>。 为了说明它们之间的重要差异，我们考虑一个具有 256K 字节存储器的系统。</p>
<p><strong>第一种方案</strong>(分区数目固定)：假定系统初始化时规定把存储空间划分为 8 个分区;在下图(a)中用问号(?)来表示它们。在系统运行一段时间后，已有 192K 存储空间分配给 7 个作业，剩下 64K 还未分配，如下图(b)所示。<br>现在，又有两个作业 P 和 Q 准备调入，它们每个需要 32K 存储空间。显然，我们有足够的存储空间。却没有足够数的存储区域(目前只有一个可用)。因此，只能允许一个作业(如 P)被调入，如下图(c)所示。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-11-20-19.png"><br><strong>第二种方案</strong>(分区数目可变)：最初，没有建立任何分区，整个可用的存储空间用一个问号来表示；之后，发生上述所说在系统运行一段时间后，已有 192K 存储空间分配给 7 个作业，剩下 64K 还未分配的情况，如图(b)；<br>现在，我们在剩下的 64K 存储空间中，可以创建两个分区，分别装入作业 P 和 Q，如图(c)。显然，此方案比第一个方案更灵活，内存利用率更高。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-11-21-13.png"></p>
<h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p>实现动态分区分配，通常有两种数据结构：空闲分区表和空闲分区链。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-10-11-45-01.png"></p>
<p><strong>算法</strong></p>
<p>系统运行一段时间后，在整个存储空间内将出现许多大小不等的区域，有的仍被作业进程占用，有的则因作业已退出系统而成为可用于再分配的区域。现在假设有一个新的作业需调入主存，如何为其选择一个合适的区域？</p>
<ul>
<li><strong>基于顺序搜索</strong><ul>
<li>最佳适应算法(Best Fit)</li>
<li>最坏适应算法(Worst Fit)</li>
<li>首次适应算法(First Fit)</li>
<li>循环首次适应算法(Next Fit)</li>
</ul>
</li>
<li><strong>基于索引搜索</strong><ul>
<li>快速适应算法(Quick Fit)</li>
<li>伙伴系统</li>
</ul>
</li>
</ul>
<hr>
<h5 id="最佳适应算法-Best-fit-BF"><a href="#最佳适应算法-Best-fit-BF" class="headerlink" title="最佳适应算法 Best fit: BF"></a>最佳适应算法 Best fit: BF</h5><p>就是为一作业选择分区时总是寻找其大小最接近作业所要求的存储区域。即：把作业放入这样的分区后剩下的内部碎片最小。为了加快查找速度，应将存储空间中所有的空白区按其大小递增的顺序链接起来，组成一空白区链(Free List)。<br><strong>优点</strong>：</p>
<ul>
<li>如果存储空间中具有正好是所要求大小的存储空白区，则必然被选中；</li>
<li>如果不存在这样的空白区，也只对比要求稍大的空白区进行划分，而绝不会去划分一个更大的空白区。因此，其后遇到大作业到来时，作业要求的存储区域就比较容易得到满足。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>采用最佳适应算法，在每次分配时，总是产生最小的空白区。因此，经过一段时期后，存储空间中可能留许多这样的空白区，由于其太小而无法使用。为了改善这种情况，在该算法中设置一参数 G，用它来确定最小分区的大小。当选择一个分区时，如果选中的空白区与要求的大小之差小于 G，则不再对它划分，而把整个这个空白区分配给申请的作业。</li>
<li>在回收一个分区时，为了把它插入到空白区链中合适的位置上也颇为费时。所以，这种算法乍看起来是最佳的，其实则不然。</li>
</ul>
<hr>
<h5 id="最坏适应算法-Worst-fit-WF"><a href="#最坏适应算法-Worst-fit-WF" class="headerlink" title="最坏适应算法 Worst fit: WF"></a>最坏适应算法 Worst fit: WF</h5><p>与最佳适应算法相反，它在为作业选择存储区域时，总是寻找最大的空白区。在划分后剩下的空白区也是最大的，因而对以后的分配很可能仍然是有用的，这是该算法的一个优点。但是，由于最大的空白块总是首先被分配而进行划分，当有大的作业时，其存储空间的申请往往得不到满足，这是该算法的一个缺点。<br>为了支持这个算法的实现，空白块应以大小递减的顺序链接起来。</p>
<hr>
<h5 id="首次适应算法-First-fit-FF"><a href="#首次适应算法-First-fit-FF" class="headerlink" title="首次适应算法 First fit: FF"></a>首次适应算法 First fit: FF</h5><p>BF 和 WF 各有其利弊。首次适应算法是对它们进行折衷考虑后设计出来的。<br>每个空白区按其在存储空间中地址递增的顺序链在一起，即每个后继空白区的起始地址总是比前者的大。在为作业分配存储区域时，从这个空白区链的始端开始查找，选择第一个足以满足请求的空白块，而不管它究竟有多大。<br>和上述算法一样，这个选择的空白区被分成两部分。一部分与请求的大小相等，分配给作业；剩下的部分留在空白区链中。显然，这个算法倾向于优先利用存储空间中低址部分的空白区。</p>
<p><strong>主要优点</strong><br>算法简单，查找速度快；留在高址部分的大的空白区被划分的机会较少，因而在大作业到来时也比较容易得到满足。<br><strong>主要缺点</strong>：<br>这种算法常常利用一个大的空白区适应小作业的请求，从而留下一些较小的无法用的空白区(外部碎片)，存储空间利用率不高；而且，由于所有的请求都是从空白区链的始端开始查找，因而这些小而无用的空白区集中在这个链的前端，相应地，一些较大空白区在链的尾端才能发现，这种情况将使找到合适空白区的速度降低。</p>
<hr>
<h5 id="下次-循环首次-适应算法-Next-fit-NF"><a href="#下次-循环首次-适应算法-Next-fit-NF" class="headerlink" title="下次(循环首次)适应算法 Next fit: NF"></a>下次(循环首次)适应算法 Next fit: NF</h5><p>为了克服上述缺点，又设计了一种称为“下次”适应的算法，它实际上是首次适应算法的一种变形，故也被称为<strong>带旋转指针的首次适应算法(Next Fit with Roving Pointer)</strong><br>为此，我们把存储空间中空白区构成一个循环链。每次为存储请求查找合适的分区时，总是从上次查找结束的地方开始，只要找到一个足够大的空白区，就将它划分后分配出去。显然，采用这一策略后，存储空间的利用更加均衡，而不至于使小的空白区集中于存储器的一端。但是，在存储器的另一端也不可能保留大的空白块，因此，当需要获得相当大的空白区时，能满足的可能性减少了。</p>
<hr>
<h5 id="快速适应算法-Quik-fit-QF"><a href="#快速适应算法-Quik-fit-QF" class="headerlink" title="快速适应算法 Quik fit:QF"></a>快速适应算法 Quik fit:QF</h5><p>将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表。<br>这样，系统中存在多个空闲分区链表；<br>同时，在内存中设立一张管理分区类型，并记录了该类型空闲分区链表表头的索引表，该表的每一个表项记录了对应类型空闲分区链表表头的指针。<br>分配过程：根据进程的长度，寻找到能容纳它的最小空闲分区链表，并取下第一块进行分配即可<br><strong>优点</strong></p>
<ul>
<li>查找效率高。</li>
<li>该算法在进行空闲分区分配时，不会对任何分区产生分割，所以能保留大的分区，满足对大空间的需求，也不会产生内存碎片。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>在分区归还主存时算法复杂，系统开销较大。</li>
<li>该算法在分配空闲分区时是以进程为单位，一个分区只属于一个进程，因此在为进程所分配的一个分区中，或多或少地存在一定的浪费。空闲分区划分越细，浪费则越严重，</li>
</ul>
<h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-17-11-39-39.png" style="zoom:100%;">

<hr>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-17-11-39-20.png" style="zoom:100%;">

<h4 id="分区分配操作"><a href="#分区分配操作" class="headerlink" title="分区分配操作"></a>分区分配操作</h4><p>涉及动态分区的主要操作有<strong>分配内存</strong>和<strong>回收内存</strong>。这些操作是在程序接口中通过系统调用发出的。</p>
<ol>
<li><p><strong>分配内存</strong>：<br>向操作系统提出一特定存储量的请求。通常，它并不要求这个分配的存储区域限于特定的位置，但是，这个区域必须是连续的。OS 利用某种分配算法，从空闲分区链(表)中找到所需大小的分区。</p>
<ul>
<li>请求的分区大小为 u.size</li>
<li>表中每个空闲分区的大小为 m.size</li>
<li>size 是事先规定的不再切割的剩余分区的大小<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-17-11-47-18.png" style="zoom:100%;"></li>
</ul>
</li>
<li><p><strong>回收内存</strong><br>进程用于归还一个不再需用的存储区域。</p>
<ul>
<li>当进程运行完毕释放内存时，系统根据回收区的首址，从空闲区链(表)中找到相应的插入点。</li>
<li>在回收一个分区时，一个回收的分区与空白区邻接的情况有四种，对这四种情况分别作如下处理：<ul>
<li>回收区与插入点的前一个空闲分区 F1 相邻接。此时应将回收区与插入点的前一分区合并(通过修改其前一分区 F1 的大小，不必为回收区分配新表现)</li>
<li>回收区仅与下面的空白区邻接，合并后仍为空白区 F2，但其起始地址和大小均需改变。用回收区的首址作为新空闲区的首址，大小为两者之和</li>
<li>回收区与上、下面的空白区邻接此时将三个分区合并，使用 F1 的表项和 F1 的首址，取消 F2 的表项，大小为三者之和。</li>
<li>回收区与上、下面的空白区均不邻接，在这种情况下，应为回收区单独建立一新表项，填写回收区的首址和大小，并根据首地址插入到空闲链中的适当位置。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="伙伴系统-Buddy-System"><a href="#伙伴系统-Buddy-System" class="headerlink" title="伙伴系统 Buddy System"></a>伙伴系统 Buddy System</h3><p>固定分区和动态分区都存在内部碎片和外部碎片的问题。伙伴系统是一种解决内部碎片问题的方法。</p>
<p>在伙伴系统中，可用内存块的大小为$2^k (1\le k\le m)$<br>其中$2^1$表示分配的最小块尺寸，$2^m$表示分配的最大块尺寸，通常是可供分配的整个内存空间大小。<br>对空闲区按照大小分类，相同大小的分区链接为一个双向空闲链表；最多可形成 k 个链表。</p>
<p>进程请求大小为 n 的存储空间：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-18-21-01-37.png" style="zoom:100%;"></p>
<ol>
<li>找到 i，使得$2^{i-1}\lq n &lt; 2^i$</li>
<li>在空闲分区大小为$2^i$的链表中查找，若找到，则分配；</li>
<li>如果没找到，从$2^{i+1}$的链表中查找，找到后，将其分裂为两个大小相等的伙伴，其中一个分配给进程，另一个插入到$2^i$相应的链表中。</li>
<li>如果仍然没找到，则继续查找更大的链表，直到找到或者查找完所有链表。</li>
</ol>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-18-21-02-46.png" style="zoom:100%;">
> 分割及回收合并分区需要时间开销，多用于多处理机系统中。

<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>利用哈希快速查找的优点，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一张哈希表，以空闲分区大小为关键字，每一个表项记录了一个对应的空闲分区链表表头指针。<br>当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最佳分配策略。</p>
<h4 id="可重定位分区分配"><a href="#可重定位分区分配" class="headerlink" title="可重定位分区分配"></a>可重定位分区分配</h4><h5 id="紧凑-Compaction"><a href="#紧凑-Compaction" class="headerlink" title="紧凑 Compaction"></a>紧凑 Compaction</h5><p>可变式分区分配策略是在装入作业时根据其要求量为其划定相应的区域。这种分配策略，消除了固定式分区分配造成的“内零头”，但不可避免地在存储空间中造成“外零头”，为了进一步提高存储器的利用率，必须设法减少由于外零头造成的浪费。</p>
<p>一个最简单而直观的解决零头问题的办法是，定时地或者在内存紧张时，把存储空间中的空白区合并为一个大的连续区。<br>实现方法将内存中的所有作业进行移动，使它们全都相邻接，这样，可把原来分散的多个小分区合成一个大分区。这种技术称为存储器的<strong>紧凑</strong>Compaction。<br>把一个作业从一个存储区域移动到另一个存储区域，需要对作业中的某些地址部分和地址常数等进行调整。一个较实用且可行的办法是采用动态重定位技术。一个作业在主存中移动后，只要改变重定位寄存器中的内容即可。</p>
<hr>
<h5 id="动态重定位-Dynamic-Relocation"><a href="#动态重定位-Dynamic-Relocation" class="headerlink" title="动态重定位 Dynamic Relocation"></a>动态重定位 Dynamic Relocation</h5><p>在动态运行时装入的方式中，作业装入内存后的所有地址都仍然是相对地址，将相对地址转换为物理地址的工作，被推迟到程序指令要真正执行时进行。<br>程序在执行时，真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-1StorageManagement-2024-04-18-21-09-58.png" style="zoom:100%;"></p>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a target="_blank" rel="noopener" href="https://data-flair.training/blogs/memory-management-in-computer/">data-flair memory-management-in-computer</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Storage Management Part Ⅰ</p><p><a href="https://efterklang.github.io/UESTC/OS/Ch4-1StorageManagement/">https://efterklang.github.io/UESTC/OS/Ch4-1StorageManagement/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Efterklang</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-04-18</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-06-12</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/OS/">OS</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Dev/FrontEnd/Live2d/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Hexo添加Live2d模型</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/UESTC/DataBase/Ch5-DbManagement/"><span class="level-item">ChⅤ 数据库系统管理</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.30/dist/twikoo.all.min.js"></script><script>twikoo.init({
            envId: 'https://efterklang-twikoo.hf.space',
            
            lang: "en",
            onCommentLoaded: function () {
              var commentContents = document.getElementsByClassName('tk-content');
              for (var i = 0; i < commentContents.length; i++) {
                var commentItem = commentContents[i];
                var imgEls = commentItem.getElementsByTagName('img');
                if (imgEls.length > 0) {
                  for (var j = 0; j < imgEls.length; j++) {
                    var imgEl = imgEls[j];
                    var aEl = document.createElement('a');
                    aEl.setAttribute('class', 'tk-lg-link');
                    aEl.setAttribute('href', imgEl.getAttribute('src'));
                    aEl.setAttribute('data-src', imgEl.getAttribute('src'));
                    aEl.appendChild(imgEl.cloneNode(false));
                    imgEl.parentNode.insertBefore(aEl, imgEl.nextSibling);
                    imgEl.remove();
                  }
                  if (typeof $.fn.lightGallery === 'function') {
                    $(commentItem).lightGallery({
                      selector: '.tk-lg-link'
                    });
                  }
                }
              }
            }
        });</script></div></div></div><style>.column.column-left,.column.column-right{display:none}</style><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#存储器的层次结构"><span class="level-left"><span class="level-item">1</span><span class="level-item">存储器的层次结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#存储器层次结构概述"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">存储器层次结构概述</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#主存储器与寄存器"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">主存储器与寄存器</span></span></a></li><li><a class="level is-mobile" href="#高速缓存与磁盘缓存"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">高速缓存与磁盘缓存</span></span></a></li></ul></li><li><a class="level is-mobile" href="#存储器管理的目的和功能"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">存储器管理的目的和功能</span></span></a></li><li><a class="level is-mobile" href="#存储分配的三种方式"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">存储分配的三种方式</span></span></a></li><li><a class="level is-mobile" href="#基本概念"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">基本概念</span></span></a></li></ul></li><li><a class="level is-mobile" href="#程序的装入和链接"><span class="level-left"><span class="level-item">2</span><span class="level-item">程序的装入和链接</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#程序的装入"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">程序的装入</span></span></a></li><li><a class="level is-mobile" href="#程序的链接"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">程序的链接</span></span></a></li></ul></li><li><a class="level is-mobile" href="#连续分配存储管理方式"><span class="level-left"><span class="level-item">3</span><span class="level-item">连续分配存储管理方式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#单一连续分配"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">单一连续分配</span></span></a></li><li><a class="level is-mobile" href="#固定分区分配"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">固定分区分配</span></span></a></li><li><a class="level is-mobile" href="#动态分区分配"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">动态分区分配</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#动态分区分配算法"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">动态分区分配算法</span></span></a></li><li><a class="level is-mobile" href="#分区分配操作"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">分区分配操作</span></span></a></li></ul></li><li><a class="level is-mobile" href="#伙伴系统-Buddy-System"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">伙伴系统 Buddy System</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#哈希算法"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">哈希算法</span></span></a></li><li><a class="level is-mobile" href="#可重定位分区分配"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">可重定位分区分配</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Ref"><span class="level-left"><span class="level-item">4</span><span class="level-item">Ref</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Dev/"><span class="level-start"><span class="level-item">Dev</span></span><span class="level-end"><span class="level-item tag">28</span></span></a><ul><li><a class="level is-mobile" href="/categories/Dev/DataBase/"><span class="level-start"><span class="level-item">DataBase</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Others/"><span class="level-start"><span class="level-item">Others</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Essay/"><span class="level-start"><span class="level-item">Essay</span></span><span class="level-end"><span class="level-item tag">7</span></span></a><ul><li><a class="level is-mobile" href="/categories/Essay/Game/"><span class="level-start"><span class="level-item">Game</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Essay/Poems/"><span class="level-start"><span class="level-item">Poems</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/UESTC/"><span class="level-start"><span class="level-item">UESTC</span></span><span class="level-end"><span class="level-item tag">39</span></span></a><ul><li><a class="level is-mobile" href="/categories/UESTC/ARM%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">ARM处理器体系结构及应用</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/"><span class="level-start"><span class="level-item">数据库原理及应用</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/06/"><span class="level-start"><span class="level-item">June 2024</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">April 2024</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a><p class="is-size-7"><span>&copy; 2024 Efterklang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>
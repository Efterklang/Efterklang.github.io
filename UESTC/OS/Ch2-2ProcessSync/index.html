<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>ProcessSync - Efterklang</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Efterklang"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Efterklang"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="进程同步"><meta property="og:type" content="article"><meta property="og:title" content="ProcessSync"><meta property="og:url" content="https://efterklang.github.io/UESTC/OS/Ch2-2ProcessSync/"><meta property="og:site_name" content="Efterklang"><meta property="og:description" content="进程同步"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://efterklang.github.io/img/thumbnails/OS/Ch2-2ProcessSync.jpg"><meta property="article:published_time" content="2024-03-08T03:42:42.000Z"><meta property="article:modified_time" content="2024-04-06T08:04:02.377Z"><meta property="article:author" content="Efterklang"><meta property="article:tag" content="OS"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://efterklang.github.io/img/thumbnails/OS/Ch2-2ProcessSync.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://efterklang.github.io/"},"headline":"ProcessSync","image":["https://efterklang.github.io/img/thumbnails/OS/Ch2-2ProcessSync.jpg"],"datePublished":"2024-03-08T03:42:42.000Z","dateModified":"2024-04-06T08:04:02.377Z","author":{"@type":"Person","name":"efterklang"},"publisher":{"@type":"Organization","name":"Efterklang","logo":{"@type":"ImageObject","url":{"light":"/img/sunflower.png","dark":"/img/sunflower.png"}}},"description":"进程同步"}</script><link rel="canonical" href="https://efterklang.github.io/UESTC/OS/Ch2-2ProcessSync/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/tokyo-night-dark.css"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><meta name="msvalidate.01" content="039770FFD6F5D1B53B42B9D3271EA9B9"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-HKYTDLW5FP" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-HKYTDLW5FP');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Efterklang" type="application/atom+xml">
</head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/gallery">Gallery</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="github" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/thumbnails/OS/Ch2-2ProcessSync.jpg" alt="ProcessSync" referrerpolicy="no-referrer"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-03-08T03:42:42.000Z" title="3/8/2024, 11:42:42 AM">2024-03-08</time></span><span class="level-item"><a class="link-muted" href="/categories/UESTC/">UESTC</a><span> / </span><a class="link-muted" href="/categories/UESTC/OS/">OS</a></span><span class="level-item">an hour read (About 7072 words)</span><span class="level-item leancloud_visitors" id="/UESTC/OS/Ch2-2ProcessSync/" data-flag-title="ProcessSync"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">ProcessSync</h1><div class="content"><h2 id="进程的同步"><a href="#进程的同步" class="headerlink" title="进程的同步"></a>进程的同步</h2><h3 id="定义-Definition"><a href="#定义-Definition" class="headerlink" title="定义 Definition"></a>定义 Definition</h3><p>每一个进程具有<strong>顺序性</strong>，但是在多道程序设计系统中，多个进程要<strong>竞争</strong>，<strong>轮流占用</strong>处理器。<br>有两个进程 A 和 B，它们各自顺序执行时的操作序列如下：<br>进程 A ： <code>a1，a2，a3，…，am</code><br>进程 B ： <code>b1，b2，b3，…，bm</code><br>在多道程序设计系统中，处理器可能执行的操作序列<br><code>a1， b1 ，a2， b2 ，a3， b3 …</code><br><code>a1， a2， b1 ，a3 ，b2 ，b3 …</code></p>
<p>进程的并发性:在一个进程的工作没有完成之前，另一个进程就可以开始工作，这些进程就称为可同时执行的。或者称它们<strong>具有并发性</strong>，并且把可同时执行的进程称为<strong>并发进程</strong>。</p>
<ul>
<li>如果一个进程的执行不影响另一个进程的执行结果，也不依赖另一个进程的进展情况，即它们是各自独立的，则称这些进程相互之间是<strong>无关</strong>的。</li>
<li>如果一个进程的执行要依赖其他进程的进展状况，或者可能会影响其他进程的执行结果，则说这些进程是有<strong>交互</strong>的。<ul>
<li>对于有交互的并发进程来说，并发会破坏“封闭性”和“可再现性”</li>
</ul>
</li>
</ul>
<p><strong>进程互斥</strong>:多个进程不能同时使用同一个资源，某个进程使用该资源时，其他进程必须等待。<br><strong>进程同步</strong>:多个进程的调用存在时序关系，某些进程的执行必须先于另一些进程。<br><strong>进程通信</strong>:多个进程之间传递消息。</p>
<h3 id="问题引入-Intro"><a href="#问题引入-Intro" class="headerlink" title="问题引入 Intro"></a>问题引入 Intro</h3><p>由于进程交替修改了共享变量造成结果可能不正确。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">     生产者                           消费者</span><br><span class="line"> register1∶ = counter;             register2∶= counter;</span><br><span class="line"> register1∶= register1+1;         register2∶ = register2-1;</span><br><span class="line"> counter∶= register1;               counter∶ = register2;</span><br><span class="line">假设：counter的当前值是5。</span><br><span class="line">无论生产者先执行，还是消费者先执行，结果都是5.</span><br><span class="line">但是，如果按下述顺序执行：</span><br><span class="line">         register1 ∶  = counter;               (register1 = 5)</span><br><span class="line">         register1 ∶  = register1 + 1;        (register1 =6)</span><br><span class="line">         register2 ∶  = counter;               (register2 = 5)</span><br><span class="line">         register2 ∶  = register2 - 1;         (register2=4)</span><br><span class="line">         counter  ∶  = register 1;             (counter=6)</span><br><span class="line">         counter  ∶  = register2;               (counter=4)</span><br><span class="line">Counter的值最终为4。</span><br><span class="line">两次结果不一致，程序执行失去了再现性</span><br></pre></td></tr></table></figure>

<p>有交互的并发进程执行时出现<strong>与时间有关</strong>(time-dependent,即与进程调度的顺序有关)的错误，其根本原因是<strong>对共享资源（变量）的使用不受限</strong>，为了使并发进程能正确地执行，必须对共享变量的使用加以限制。</p>
<p>进程竞争资源首先必须解决“互斥”问题。某些资源必须互斥使用，如打印机、共享变量、表格、文件等。这类资源又称为<strong>临界资源 critical resource</strong>，访问临界资源的那段代码称为<strong>临界区 critical section</strong>。<br>任何时刻，只允许一个进程进入临界区，以此实现进程对临界资源的互斥访问。</p>
<p>可把一个访问临界资源的循环进程描述如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">repeat</span><br><span class="line">    entry section</span><br><span class="line">    critical section</span><br><span class="line">    exit section</span><br><span class="line">    remainder section</span><br><span class="line">until false</span><br><span class="line"></span><br><span class="line">&lt;entry section&gt;:判断是否可以进入临界区，如果可以进入，则必须设置临界区使用标志，</span><br><span class="line">阻止其它后来的进程进入临界区。</span><br><span class="line">&lt;critical section&gt;:进入临界区，使用临界资源。</span><br><span class="line">&lt;exit section&gt;:当临界区内的进程执行完毕并退出临界区时，在“退出区”修改临界区使用标志，</span><br><span class="line">并负责唤醒阻塞队列中的一个进程，让其进入临界区。</span><br><span class="line">&lt;remainder section&gt;:其它代码</span><br></pre></td></tr></table></figure>

<p><strong>阻塞队列 Blocking Queue</strong>:当一个进程试图进入临界区，而临界区已经被其它进程占用时，该进程必须等待，直到临界区空闲为止。这些等待进程的队列称为阻塞队列。<br><strong>死锁 Deadlock</strong>:当两个或多个进程互相等待对方释放资源，而导致它们都无法继续执行时，称为死锁。</p>
<p><strong>临界区使用原则</strong>(互斥条件)</p>
<ol>
<li><strong>空闲让进Entry Allowed WHen Free</strong>:如果临界区空闲，则只要有进程申请就立即让其进入 </li>
<li><strong>忙则等待Bust Then Wait</strong>:每次仅允许一个进程处于临界区 </li>
<li><strong>有限等待Limited Waiting</strong>:进程只能在临界区内逗留有限时间，不得使其他进程在临界区外无限期等待 </li>
<li><strong>让权等待Yeilding While Waiting</strong>:当进程不能进入自己的临界区时，应立即释放处理机，以免进程处于“忙等”状态</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-06-15-40-04.png" alt="Critical Section"></p>
<h3 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量 Semaphore"></a>信号量 Semaphore</h3><p>1965 年，荷兰的 E.W.Dijkstra 提出了信号量同步机制用于进程同步,现广泛应用于存在临界资源和临界区控制的场合<br>信号量是一个一般的锁,信号量即信号的数量;开锁实际上就是发一个信号,等待锁打开就是等待一个信号<br><code>锁: &#123;0,1&#125;  信号量: &#123;-∞, … , -2, -1, 0, 1, 2, … , ∞&#125;</code></p>
<p>信号量按照<strong>功能</strong>来分：</p>
<ul>
<li>互斥信号量：用于申请或释放资源的使用权，常初始化为 1。</li>
<li>资源信号量：用于申请或归还资源，可以初始化为大于 1 的正整数，表示系统中某类资源的可用个数。<br>按照<strong>信号量机制的发展</strong>分为：</li>
<li>整形信号量</li>
<li>记录型信号量</li>
<li>AND 型信号量</li>
<li>信号量集</li>
</ul>
<blockquote>
<p>In computer science, a semaphore is a variable or abstract data type used to control access to a common resource by multiple threads and avoid critical section problems in a concurrent system such as a multitasking operating system. Semaphores are a type of synchronization primitive. A trivial semaphore is a plain variable that is changed (for example, incremented or decremented, or toggled) depending on programmer-defined conditions.<br>The semaphore concept was invented by Dutch computer scientist Edsger Dijkstra in 1962 or 1963, when Dijkstra and his team were developing an operating system for the Electrologica X8. That system eventually became known as the THE multiprogramming system.</p>
</blockquote>
<p>两个或多个进程可以通过传递信号进行合作，可以迫使进程在某个位置暂时停止执行（阻塞等待），直到它收到一个可以“向前推进”的信号（被唤醒）。相应地，将实现信号灯作用的变量称为信号量。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-13-57-59.png"></p>
<h4 id="整形信号量-Integer-Semaphore"><a href="#整形信号量-Integer-Semaphore" class="headerlink" title="整形信号量 Integer Semaphore"></a>整形信号量 Integer Semaphore</h4><p>定义为一个整形量, 用来表示空闲资源的数目;仅能通过两个标准的原子操作 <code>wait(s),signal(s)</code>来访问它,又称为<strong>P 操作和 V 操作</strong></p>
<ul>
<li><em>Proberen</em>(荷兰语，意为“尝试”): <code>wait(s)</code> 操作用于申请资源（或使用权），进程执行 wait 原语时，可能会阻塞自己；<br><code>while S &lt;= 0 do no-op; S--; // 申请资源</code></li>
<li><em>Verhogen</em>(荷兰语，意为“增加”): <code>signal(s)</code>操作用于释放资源（或归还资源使用权），进程执行 signal 原语时，有责任唤醒一个阻塞进程。<br><code>S++; // 释放资源</code></li>
</ul>
<p><strong>Note</strong></p>
<ol>
<li>必须成对使用 <code>wait</code>和 <code>signal</code>原语</li>
<li>wait、signal 原语不能出现次序错误、重复或遗漏<ul>
<li>遗漏 wait 原语则不能保证互斥访问</li>
<li>遗漏 signal 原语则不能在使用临界资源之后将其释放</li>
</ul>
</li>
</ol>
<h4 id="记录型信号量-Record-Semaphore"><a href="#记录型信号量-Record-Semaphore" class="headerlink" title="记录型信号量 Record Semaphore"></a>记录型信号量 Record Semaphore</h4><p>记录型信号量机制，是一种不存在<strong>忙等现象</strong>的进程同步机制。<br>操作系统内核以系统调用形式提供 <code>wait</code>和 <code>signal</code>原语，应用程序通过该系统调用实现进程间的互斥。<br>工程实践证明，利用信号量方法实现进程互斥是高效的，一直被广泛采用。</p>
<p>记录型信号量的数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表节点，用于表示等待队列中的进程</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> pid;  <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span>  <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录型信号量</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="comment">// value的初值表示系统中某类资源的数目， value的初始值&gt;1时，称为资源信号量， value的初始值=1时，称为互斥信号量</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node* listOfProcess;  <span class="comment">// 信号量的阻塞队列</span></span><br><span class="line">&#125; RecordSemaphore;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>“忙等”（Busy Waiting）是一种进程同步策略中的现象，也被称为”自旋等待”。当一个进程试图进入一个被其他进程占用的临界区时，如果使用了忙等策略，那么这个进程会在一个循环中不断检查临界区是否可用，直到它变为可用状态。换句话说，进程在等待期间保持活跃，并消耗 CPU 时间，而不是被挂起或转移到等待状态。<br>虽然忙等可以在某些情况下（如等待时间预期非常短）提供很好的响应时间，但它通常被视为一种效率低下的策略，因为它浪费了 CPU 的计算能力，尤其是在等待时间较长的情况下。<br>与此相反，记录型信号量机制（Blocking or Sleeping Semaphore Mechanism）允许进程在等待进入临界区时进入睡眠状态，从而不消耗 CPU 时间。当临界区可用时，进程会被唤醒。这种方法更有效，但可能导致上下文切换的开销，因为系统需要在运行和等待的进程之间切换。</p>
</blockquote>
<p>记录型信号量的 P，V 操作 wait(s)和 signal(s)<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/cProcessSync-2024-03-06-22-28-32.png"></p>
<p><code>s.value&gt;=0</code> 时，<code>s.queue</code> 为空；<br><code>s.value&lt;0</code> 时，<code>s.value</code> 的 绝对值为 <code>s.queue</code> 中等待进程的个数<br><code>s.value</code> 初始值为 1 时，称为互斥信号量；<code>s.value</code> 初始值&gt;1 时，称为资源信号量。<br>当仅有两个并发进程共享临界资源时，互斥信号量仅能取值 1、0、－1。其中，</p>
<ul>
<li><code>s.value=1</code>, 表示无进程进入临界区</li>
<li><code>s.value=0</code>，表示已有一个进程进入临界区</li>
<li><code>s.value=-1</code>,则表示已有一进程正在等待进入临界区<br>当用 s 来实现 n 个进程的互斥时，<code>s.value</code> 的取值范围为 1 ～-(n-1)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">wait</span><span class="params">(RecordSemaphore* s)</span> &#123;</span><br><span class="line">    s-&gt;value--;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        block(s-&gt;listOfProcess); <span class="comment">//进程阻塞, 进入S.L队列；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">singal</span><span class="params">(RecordSemaphore* s)</span> &#123;</span><br><span class="line">    s-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;value &lt;= <span class="number">0</span>) &#123; <span class="comment">// s-&gt;value=0时,则在s-&gt;value++之前value=-1,即有1个进程在等待</span></span><br><span class="line">        wakeup(s-&gt;listOfProcess); <span class="comment">// 唤醒阻塞队列中的一个进程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AND-型信号量-AND-Semaphore"><a href="#AND-型信号量-AND-Semaphore" class="headerlink" title="AND 型信号量 AND Semaphore"></a>AND 型信号量 AND Semaphore</h4><p>如果一个进程需要事先获得一个或多个共享资源后才能执行任务。例如：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process A:                 process B:</span><br><span class="line">wait(Dmutex);            wait(Emutex);</span><br><span class="line">wait(Emutex);             wait(Dmutex);</span><br></pre></td></tr></table></figure>

<p>最后，进程 A 和 B 就处于僵持状态，在无外力作用下，两个进程都无法从僵持状态中解脱出来，这此 A 和 B 进入<strong>死锁</strong>状态。</p>
<center>

<p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-10-25-04.png" alt="DeadLock"></p>
</center>

<p>AND 同步机制的基本思想：将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。<br>原子操作：所有资源要么全部分配到进程，要么一个也不分配 .<br>在 wait 操作中，增加了一个“AND”条件，故称为 <code>AND同步</code>，或称为 <code>同时wait</code>操作.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swait</span><span class="params">(S1, S2, …, Sn)</span>	&#123; <span class="comment">//P原语；</span></span><br><span class="line">  <span class="keyword">if</span> (S1 ≥<span class="number">1</span> and S2 ≥ <span class="number">1</span> … Sn ≥ <span class="number">1</span>) &#123;<span class="comment">//满足资源要求时的处理；</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">      <span class="comment">// wait的处理是s先减1，再判断是否&lt;0，若是就进入阻塞队列。如果要不阻塞，则s的初始值需要&gt;=1</span></span><br><span class="line">      <span class="comment">// Swait与wait的处理不同，这里是在确信可满足资源要求时，才进行减1操作</span></span><br><span class="line">      Si=Si<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*某些资源不够时的处理；</span></span><br><span class="line"><span class="comment">    进程进入第一个小于1的信号量的阻塞队列 ;</span></span><br><span class="line"><span class="comment">    恢复PC寄存器为Swait开始时的状态；*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span>  Ssignal(S1, S2, …, Sn)&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    Si++; <span class="comment">//释放占用的资源；</span></span><br><span class="line">    <span class="keyword">for</span> (each process P waiting in Si.L)&#123;</span><br><span class="line">      <span class="comment">//检查每种资源的阻塞队列中的所有进程；</span></span><br><span class="line">      <span class="comment">//从阻塞队列Si.queue中取出进程P;</span></span><br><span class="line">      P = Si.<span class="built_in">queue</span>.getHead();</span><br><span class="line">      <span class="keyword">if</span>(判断P是否通过Swait中的测试)&#123;<span class="comment">//注:与signal不同，需重新判断进程P进入就绪队列;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123; <span class="comment">//未通过检查（资源不够用）时的处理；</span></span><br><span class="line">        进程P进入某阻塞队列；<span class="comment">//然后继续循环判断下一个进程</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量集-Semaphore-Set"><a href="#信号量集-Semaphore-Set" class="headerlink" title="信号量集 Semaphore Set"></a>信号量集 Semaphore Set</h4><p>在记录型信号量机制中，<code>wait(S)</code>或 <code>signal(S)</code>操作仅能对信号量施以加 1 或减 1 操作，意味着每次只能获得或释放一个单位的临界资源。<br>在每次分配时，采用信号量集来控制，可以分配多个单位的资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Si—i 类资源现有数量；ti—i 类资源的分配下限值；di—申请i 类资源数量;</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Swait</span> <span class="params">( S1, t1, d1; ... ; Sn, tn, dn )</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (S1 ≥ t1 and S2 ≥ t2 … Sn ≥ tn) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      Si=Si-di;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//假设首先发现 Sj &lt; tj，进程进入Sj.L队列；</span></span><br><span class="line">    <span class="comment">//进程投入与Sj相关的阻塞队列</span></span><br><span class="line">    <span class="comment">//恢复PC寄存器为Swait开始时的状态；</span></span><br><span class="line">    <span class="comment">//启动进程调度程序，调度其它进程执行；</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//si—i 类资源现有数；di—i 类资源释放数量 ;</span></span><br><span class="line"><span class="type">void</span> Ssignal ( S1, d1; ... ; Sn, dn )&#123;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    Si=Si+di;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//把与Si有关队列中的进程移入就绪队列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“信号量集机制”可以用于各种情况的资源分配和释放，几种特殊情况：</p>
<ul>
<li><code>Swait(S, d, d)</code>表示每次申请 d 个资源，当少于 d 个时，便不分配</li>
<li><code>Swait(S, 1, 1)</code>表示一般的记录型互斥信号量（S&#x3D;1 时）或资源信号量（S&gt;1 时）</li>
<li><code>Swait(S, 1, 0)</code>可作为一个可控开关（当 S1 时，允许多个进程进入临界区；当 S&#x3D;0 时，禁止任何进程进入临界区）</li>
</ul>
<h4 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h4><p><strong>利用信号量实现进程互斥</strong><br>为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量 mutex，并设其初始值为 1，然后将各进程访问该资源的临界区 CS 置于 wait（mutex）和 signal（mutex）操作之间即可。<br><strong>利用信号量来描述前趋（合作）关系</strong><br>假设我们有两个任务 A 和 B，其中任务 B 依赖于任务 A 的完成。我们可以使用一个初始值为 0 的信号量来描述这种前驱关系。具体的操作步骤如下：<br>任务 A 在完成后，执行一个信号量的 V 操作（signal），将信号量的值加 1。<br>任务 B 在开始前，执行一个信号量的 P 操作（wait）。如果信号量的值大于 0，那么将信号量的值减 1 并继续执行。如果信号量的值等于 0，那么任务 B 将阻塞，直到信号量的值大于 0。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-14-10-39.png"></p>
<blockquote>
<p><code>parbegin</code> 和 <code>parend</code> 是并发编程中用来表示并行开始和并行结束的关键字</p>
</blockquote>
<p>例：用 And 信号量来描述如下的前趋图<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/ProcessSync-2024-03-07-14-12-29.png" alt="Precedence Graph"></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Var a,<span class="keyword">b,c,d,e,f,g: </span>semaphore: <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;</span><br><span class="line">Parbegin</span><br><span class="line">       <span class="keyword">begin </span><span class="built_in">S1</span><span class="comment">; Ssignal(a,b); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(a); </span><span class="built_in">S2</span><span class="comment">; Ssignal(c,d); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(b); </span><span class="built_in">S3</span><span class="comment">; signal(e); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(c); </span><span class="built_in">S4</span><span class="comment">; signal(f); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">wait(d); </span><span class="built_in">S5</span><span class="comment">; signal(g); end;</span></span><br><span class="line">       <span class="keyword">begin </span><span class="keyword">Swait(e,f,g); </span><span class="built_in">S6</span><span class="comment">; end;</span></span><br><span class="line">Parend;</span><br></pre></td></tr></table></figure>

<h3 id="硬件同步机制-Hardware-Synchronization-Mechanism"><a href="#硬件同步机制-Hardware-Synchronization-Mechanism" class="headerlink" title="硬件同步机制 Hardware Synchronization Mechanism"></a>硬件同步机制 Hardware Synchronization Mechanism</h3><p><strong>利用计算机硬件指令解决临界区问题</strong><br>对临界区管理将标识看做一个锁，“锁开”进入，“锁关”等待。<br>初始打开，每个进入临界区的进程必须对锁进行测试。<br>测试和关锁操作必须连续（原子操作）</p>
<blockquote>
<p>虽然可以利用软件方法解决诸进程互斥进入临界区的问题，但有一定难度，并且存在很大的局限性，因而现在已很少采用。相应地，目前许多计算机已提供了一些特殊的硬件指令，允许对一个字中的内容进行检测和修正，或者是对两个字的内容进行交换等。可利用这些特殊的指令来解决临界区问题。</p>
</blockquote>
<ol>
<li>关中断</li>
<li>利用 Test-and-Set 指令实现互斥</li>
<li>利用 Swap 指令实现进程互斥</li>
</ol>
<h4 id="关中断实现互斥-Disable-Interrupts"><a href="#关中断实现互斥-Disable-Interrupts" class="headerlink" title="关中断实现互斥 Disable Interrupts"></a>关中断实现互斥 Disable Interrupts</h4><p><strong>中断</strong>是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得 CPU 暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。<br><strong>中断处理</strong>是指 CPU 响应中断，转入中断处理程序，系统开始处理中断。<br><strong>中断响应</strong>是指 CPU 收到中断请求后转向相应的事件处理程序。<br><strong>开中断</strong>就是指系统可以在连续运行时中断，去运行中断服务函数<br><strong>关中断</strong>就是指关闭系统中断，系统不响应其他的中断，不允许系统打断连续的运行</p>
<p><strong>关中断</strong><br>进入锁测试前关闭中断，完成锁测试并上锁后打开中断<br>进程在临界区时计算机系统不响应中断，不会引发调度</p>
<p><strong>Pros And Cons</strong></p>
<ul>
<li>关中断是实现互斥的最简单的方法之一。</li>
</ul>
<hr>
<ul>
<li>滥用关中断权力可能导致严重后果；</li>
<li>关中断时间过长，会影响系统效率，限制了处理器交叉执行程序的能力；</li>
<li>关中断方法也不适用于多 CPU 系统，因为在一个处理器上关中断并不能防止进程在其它处理器上执行相同的临界段代码。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">bool</span> <span class="title function_">are_interrupts_enabled</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">atomic_operation</span><span class="params">(<span class="type">void</span> (*operation)())</span> &#123;</span><br><span class="line">    start_atomic_operation();</span><br><span class="line">    operation();</span><br><span class="line">    end_atomic_operation(are_interrupts_enabled());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">start_atomic_operation</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果中断是开启的，那么关闭中断</span></span><br><span class="line">    <span class="keyword">if</span> (are_interrupts_enabled()) &#123;</span><br><span class="line">        disable_interrupts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">end_atomic_operation</span><span class="params">(<span class="type">bool</span> were_interrupts_enabled)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果在原子操作开始之前中断是开启的，那么重新开启中断</span></span><br><span class="line">    <span class="keyword">if</span> (were_interrupts_enabled) &#123;</span><br><span class="line">        enable_interrupts();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    enable_interrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Test-And-Set-指令实现互斥"><a href="#Test-And-Set-指令实现互斥" class="headerlink" title="Test And Set 指令实现互斥"></a>Test And Set 指令实现互斥</h4><p>这是一种借助 TS(Test-and-Set)硬件指令以实现互斥的方法。在许多计算机中都提供了这种指令。</p>
<p><code>lock=false</code>表示资源空闲，<code>*lock=TURE</code>表示资源正在被使用。<br>当资源被使用时，TS 返回 ture，则 <code>while TS（&amp;lock)</code>；语句条件为真会一直循环等待。</p>
<p>这段代码是一个实现了简单的自旋锁（spinlock）的例子，使用了一个称为 Test-and-Set（TS）的原子操作。自旋锁是一种用于同步的低级别的原子操作，通常用于保护短期的临界区（critical section）。<br>自旋锁可能会导致资源浪费，因为在等待获取锁的过程中，线程并不会释放 CPU，而是会一直忙等待。因此，自旋锁通常只用于保护非常短期的临界区。对于保护长期的临界区，通常会使用其他的同步机制，如互斥锁（mutex）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">boolen <span class="title function_">TS</span><span class="params">(boolen *lock)</span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock =TURE;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">while</span> <span class="title function_">TS</span><span class="params">( &amp;lock)</span>;</span><br><span class="line">    critical section;</span><br><span class="line">    lock :=FALSE;</span><br><span class="line">    remainder section;</span><br><span class="line">&#125;<span class="keyword">while</span>(TRUE);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="利用-Swap-指令实现进程互斥"><a href="#利用-Swap-指令实现进程互斥" class="headerlink" title="利用 Swap 指令实现进程互斥"></a>利用 Swap 指令实现进程互斥</h4><p>该指令称为对换指令，在 <code>Intel 80x86</code>中又称为 <code>XCHG</code>指令，用于交换两个字的内容。</p>
<h4 id="管程-Moniter"><a href="#管程-Moniter" class="headerlink" title="管程 Moniter"></a>管程 Moniter</h4><p>虽然信号量机制是一种既方便、又有效的进程同步机制，但每个要访问临界资源的进程都必须自备同步操作 wait（S）和 signal（s）。这就使大量的同步操作分散在各个进程中。这不仅给系统的管理带来了麻烦，而且还会因同步操作的使用不当而导致系统死锁。这样，在解决上述问题的过程中，便产生了一种新的进程同步工具——管程 。</p>
<blockquote>
<p>Monitors are a higher-level synchronization construct that simplifies process synchronization by providing a high-level abstraction for data access and synchronization. Monitors are implemented as programming language constructs, typically in object-oriented languages, and provide mutual exclusion, condition variables, and data encapsulation in a single construct.<br><a href="#ref">Moniter-Ref</a></p>
</blockquote>
<h3 id="经典同步问题-Classic-Synchronization-Problems"><a href="#经典同步问题-Classic-Synchronization-Problems" class="headerlink" title="经典同步问题 Classic Synchronization Problems"></a>经典同步问题 Classic Synchronization Problems</h3><ul>
<li>生产者&#x2F;消费者问题 Producer-Consumer Problem</li>
<li>哲学家进餐问题 Dining Philosophers Problem</li>
<li>读者&#x2F;写者问题 Readers-Writers Problem</li>
</ul>
<h4 id="Producer-Consumer-Problem"><a href="#Producer-Consumer-Problem" class="headerlink" title="Producer-Consumer Problem"></a>Producer-Consumer Problem</h4><p>生产者与消费者是一个广义的概念，可以代表一类具有相同属性的进程。生产者和消费者进程共享一个大小固定的缓冲池;一个或多个生产者生产数据，并将生产的数据存入缓冲池;一个或多个消费者从缓冲池中取数据。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ProcessSync-2024-03-08-11-03-26.png" alt="Producer-Consumer Problem"></p>
<p>必须使生产者和消费者互斥进入缓冲区。即，某时刻只允许一个实体（生产者或消费者）访问缓冲区，生产者互斥消费者和其它任何生产者。<br>生产者不能向满缓冲池写数据，消费者也不能在空缓冲池中取数据，即生产者与消费者必须同步。</p>
<p><strong>涉及两类进程</strong>：<br>生产者进程和消费者进程<br><strong>需要保证以下同步关系</strong>：</p>
<ol>
<li>多个进程互斥地访问公共缓冲池；互斥信号量 mutex</li>
<li>不能向满的缓冲池中添加产品；可用的空资源信号量 empty</li>
<li>不能从空的缓冲池中提取产品。可用的满资源信号量 full<br>full + empty&#x3D;N</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ProcessSync-2024-03-08-11-9-11.png"></p>
<blockquote>
<p>每个进程中各个 wait 操作的次序是重要的：先检查资源数目，再检查是否互斥.否则可能死锁<br>如：producer 先申请互斥，进入后，申请空资源，发现空资源不可用，必须等待 comsumer 先申请满资源，使用后释放出来。但此时，由于 producer 占用了互斥资源，因此 consumer 无法进入。故而陷入死锁状态</p>
</blockquote>
<h4 id="Dining-Philosophers-Problem"><a href="#Dining-Philosophers-Problem" class="headerlink" title="Dining Philosophers Problem"></a>Dining Philosophers Problem</h4><p>五个哲学家五只筷子，哲学家循环做着思考和吃饭的动作，吃饭程序是：先取左边筷子，再取右边筷子，再吃饭，再放筷子。</p>
<ol>
<li>至多只允许四个哲学家同时进餐,以保证至少有一个哲学家能够进餐,最终总会释放出他所使用过的两支筷子,从而可使更多的哲学家进餐。</li>
<li>在哲学家进餐问题中，要求每个哲学家先获得两个临界资源(筷子)后方能进餐，这在本质上就是前面所介绍的 AND 同步问题，故用 AND 信号量机制可获得最简洁的解法,且可避免死锁。</li>
<li>规定奇数号的哲学家先拿起他左边的筷子,然后再去拿他右边的筷子;而偶数号的哲学家则相反.按此规定,将是 2,3 号哲学家竞争 3 号筷子,4,5 号哲学家竞争 5 号筷子.即三个哲学家都  竞争奇数号筷子,获得后,再去竞争偶数号筷子,最后总会 1 个哲学家能获得两支筷子而进餐.</li>
</ol>
<h4 id="Readers-Writers-Problem"><a href="#Readers-Writers-Problem" class="headerlink" title="Readers-Writers Problem"></a>Readers-Writers Problem</h4><p>该问题为多个进程访问一个共享数据区建立了一个通用模型，如数据库、文件、内存区及一组寄存器等数据。若干读进程只能读数据，若干写进程只能写数据。</p>
<p>例如，一个联网售票系统，数据的查询和更新非常频繁，不可避免会出现多个进程试图查询或修改（读&#x2F;写）其中某一条数据的情形。多个进程同时读一条记录是可以的。如果一个进程正在更新数据库中的某条记录，则所有其他进程都不能访问（读或写）该记录，否则可能会将同一个座位销售多次。</p>
<p><strong>读者&#x2F;写者进程满足的条件</strong></p>
<ol>
<li>允许多个读者进程可以同时读数据；</li>
<li>不允许多个写者进程同时写数据，即只能互斥写数据；</li>
<li>若有写者进程正在写数据，则不允许读者进程读数据。</li>
</ol>
<p><strong>Sol</strong><br>利用记录型信号量解决读者-写者问题<br>利用信号量集解决读者-写者问题</p>
<h4 id="Exercies"><a href="#Exercies" class="headerlink" title="Exercies"></a>Exercies</h4><blockquote>
<p><strong>EX1</strong><br>三个进程 P1，P2，P3 协作解决文件打印问题，P1 将文件记录从磁盘读入内存的缓冲区 1，每执行一次读一个记录；P2 将缓冲区 1 的内容取出放到缓冲区 2 中；P3 将缓冲区 2 的内容打印出来，每执行一次打印一个记录。缓冲区的大小和一个记录大小一样。<br>用 P、V 操作来保证文件的正确打印。<br><strong>引申</strong><br>有三个进程 A1、A2、A3，它们共享两个缓冲区 B1 和 B2。缓冲区 B1 中可以存放 n 件产品，缓冲区 B2 中可以存放 m 件产品。进程 A1 每次生产一件产品，并把产品存入缓冲区 B1。进程 A2 每次生产一件产品，并把产品存入缓冲区 B2。进程 A3 每次从缓冲区 B2 中取一件产品区消费。为了防止把产品存入已满的缓冲，或者从空缓冲中取产品，或重复取一产品，用 PV 操作实现它们的相互制约关系。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch2-2ProcessSync-2024-03-08-11-24-27.png" alt="ex"></p>
<hr>
<p><strong>EX2</strong><br>某工厂有一个可以存放设备的仓库，总共可以存放 8 台设备。生产部门生产的每一台设备都必须入库，销售部门可以从仓库中提出设备供应客户。设备出&#x2F;入库需要借助运输工具，现只有一套运输工具，每次只能运一台设备<br>请设计生产部门和销售部门进程。</p>
<hr>
<p><strong>EX3</strong><br>桌上放一个盘子，每次只能放一个水果，爸爸像盘子里放苹果，妈妈向盘子里放橘子，女儿专吃苹果,儿子专吃橘子。盘子空的时候爸爸或妈妈才能向盘子里面放一个水果，仅当盘子里有自己需要的水果时才可取一个水果。把爸爸、妈妈、儿子、女儿看做四个进程，用 PV 操作进行管理，使这四个进程能正确地并发执行。<br><strong>引申</strong><br>如果盘子的容量改为 2，且任何时刻只允许爸爸、妈妈、女儿、儿子中的一个进程去访问盘子（放或者取）。</p>
</blockquote>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Semaphore_(programming)">Semaphore-wikipedia</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/youxin/p/3586577.html">https://www.cnblogs.com/youxin/p/3586577.html</a><br><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/monitors-in-process-synchronization/">Moniter</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>ProcessSync</p><p><a href="https://efterklang.github.io/UESTC/OS/Ch2-2ProcessSync/">https://efterklang.github.io/UESTC/OS/Ch2-2ProcessSync/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Efterklang</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-03-08</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-04-06</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/OS/">OS</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Dev/Git/GitForAndroid/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Git for Android</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/UESTC/OS/Ch2-1ProcessContorl/"><span class="level-item">进程的描述及控制</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.32/dist/twikoo.all.min.js"></script><script>twikoo.init({
      envId: 'https://efterklang-twikoo.hf.space',
      onCommentLoaded: function () {
        var commentContents = document.getElementsByClassName('tk-content');
        for (var i = 0; i < commentContents.length; i++) {
          var commentItem = commentContents[i];
          var imgEls = commentItem.getElementsByTagName('img');
          if (imgEls.length > 0) {
            for (var j = 0; j < imgEls.length; j++) {
              var imgEl = imgEls[j];
              var aEl = document.createElement('a');
              aEl.setAttribute('class', 'tk-lg-link');
              aEl.setAttribute('href', imgEl.getAttribute('src'));
              aEl.setAttribute('data-src', imgEl.getAttribute('src'));
              aEl.appendChild(imgEl.cloneNode(false));
              imgEl.parentNode.insertBefore(aEl, imgEl.nextSibling);
              imgEl.remove();
            }
            if (typeof $.fn.lightGallery === 'function') {
              $(commentItem).lightGallery({
                selector: '.tk-lg-link'
              });
            }
          }
        }
      }
    });</script></div></div></div><style>.column.column-left,.column.column-right{display:none}</style><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#进程的同步"><span class="level-left"><span class="level-item">1</span><span class="level-item">进程的同步</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#定义-Definition"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">定义 Definition</span></span></a></li><li><a class="level is-mobile" href="#问题引入-Intro"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">问题引入 Intro</span></span></a></li><li><a class="level is-mobile" href="#信号量-Semaphore"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">信号量 Semaphore</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#整形信号量-Integer-Semaphore"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">整形信号量 Integer Semaphore</span></span></a></li><li><a class="level is-mobile" href="#记录型信号量-Record-Semaphore"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">记录型信号量 Record Semaphore</span></span></a></li><li><a class="level is-mobile" href="#AND-型信号量-AND-Semaphore"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">AND 型信号量 AND Semaphore</span></span></a></li><li><a class="level is-mobile" href="#信号量集-Semaphore-Set"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">信号量集 Semaphore Set</span></span></a></li><li><a class="level is-mobile" href="#信号量的应用"><span class="level-left"><span class="level-item">1.3.5</span><span class="level-item">信号量的应用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#硬件同步机制-Hardware-Synchronization-Mechanism"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">硬件同步机制 Hardware Synchronization Mechanism</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关中断实现互斥-Disable-Interrupts"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">关中断实现互斥 Disable Interrupts</span></span></a></li><li><a class="level is-mobile" href="#Test-And-Set-指令实现互斥"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">Test And Set 指令实现互斥</span></span></a></li><li><a class="level is-mobile" href="#利用-Swap-指令实现进程互斥"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">利用 Swap 指令实现进程互斥</span></span></a></li><li><a class="level is-mobile" href="#管程-Moniter"><span class="level-left"><span class="level-item">1.4.4</span><span class="level-item">管程 Moniter</span></span></a></li></ul></li><li><a class="level is-mobile" href="#经典同步问题-Classic-Synchronization-Problems"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">经典同步问题 Classic Synchronization Problems</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Producer-Consumer-Problem"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">Producer-Consumer Problem</span></span></a></li><li><a class="level is-mobile" href="#Dining-Philosophers-Problem"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">Dining Philosophers Problem</span></span></a></li><li><a class="level is-mobile" href="#Readers-Writers-Problem"><span class="level-left"><span class="level-item">1.5.3</span><span class="level-item">Readers-Writers Problem</span></span></a></li><li><a class="level is-mobile" href="#Exercies"><span class="level-left"><span class="level-item">1.5.4</span><span class="level-item">Exercies</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Ref"><span class="level-left"><span class="level-item">2</span><span class="level-item">Ref</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Dev/"><span class="level-start"><span class="level-item">Dev</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Dev/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Game/"><span class="level-start"><span class="level-item">Game</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Reading/"><span class="level-start"><span class="level-item">Reading</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Reading/Poems/"><span class="level-start"><span class="level-item">Poems</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Tech/"><span class="level-start"><span class="level-item">Tech</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tech/DataBase/"><span class="level-start"><span class="level-item">DataBase</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Tech/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Tech/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tech/Others/"><span class="level-start"><span class="level-item">Others</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Tech/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/UESTC/"><span class="level-start"><span class="level-item">UESTC</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/UESTC/ARM-Processor/"><span class="level-start"><span class="level-item">ARM-Processor</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/Computer-Networking/"><span class="level-start"><span class="level-item">Computer Networking</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">April 2024</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">December 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a><p class="is-size-7"><span>&copy; 2024 Efterklang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.32/dist/twikoo.all.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/live2d-widget/autoload.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>
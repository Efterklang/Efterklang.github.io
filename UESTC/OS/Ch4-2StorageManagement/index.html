<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Storage Management PartⅡ - Efterklang</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Efterklang"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Efterklang"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="基本分页存储管理方式，基本分段存储管理方式"><meta property="og:type" content="article"><meta property="og:title" content="Storage Management PartⅡ"><meta property="og:url" content="https://efterklang.github.io/UESTC/OS/Ch4-2StorageManagement/"><meta property="og:site_name" content="Efterklang"><meta property="og:description" content="基本分页存储管理方式，基本分段存储管理方式"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://efterklang.github.io/img/thumbnails/OS/Ch4-2Storage.webp"><meta property="article:published_time" content="2024-05-03T13:44:20.000Z"><meta property="article:modified_time" content="2024-05-10T13:01:53.699Z"><meta property="article:author" content="Efterklang"><meta property="article:tag" content="OS"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://efterklang.github.io/img/thumbnails/OS/Ch4-2Storage.webp"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://efterklang.github.io/"},"headline":"Storage Management PartⅡ","image":["https://efterklang.github.io/img/thumbnails/OS/Ch4-2Storage.webp"],"datePublished":"2024-05-03T13:44:20.000Z","dateModified":"2024-05-10T13:01:53.699Z","author":{"@type":"Person","name":"efterklang"},"publisher":{"@type":"Organization","name":"Efterklang","logo":{"@type":"ImageObject","url":{"light":"/img/sunflower.png","dark":"/img/sunflower.png"}}},"description":"基本分页存储管理方式，基本分段存储管理方式"}</script><link rel="canonical" href="https://efterklang.github.io/UESTC/OS/Ch4-2StorageManagement/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/tokyo-night-dark.css"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><meta name="msvalidate.01" content="039770FFD6F5D1B53B42B9D3271EA9B9"><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=G-HKYTDLW5FP" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'G-HKYTDLW5FP');</script><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Efterklang" type="application/atom+xml">
</head><body class="is-2-column"><script type="text/javascript" src="/js/imaegoo/night.js"></script><canvas id="universe"></canvas><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/gallery">Gallery</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i><span>  目录</span></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="github" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/thumbnails/OS/Ch4-2Storage.webp" alt="Storage Management PartⅡ" referrerpolicy="no-referrer"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2024-05-03T13:44:20.000Z" title="5/3/2024, 9:44:20 PM">2024-05-03</time></span><span class="level-item"><a class="link-muted" href="/categories/UESTC/">UESTC</a><span> / </span><a class="link-muted" href="/categories/UESTC/OS/">OS</a></span><span class="level-item">34 minutes read (About 5125 words)</span><span class="level-item leancloud_visitors" id="/UESTC/OS/Ch4-2StorageManagement/" data-flag-title="Storage Management PartⅡ"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="twikoo_visitors"><i class="fa fa-spinner fa-spin"></i></span>&nbsp;visits</span></div></div><h1 class="title is-3 is-size-4-mobile">Storage Management PartⅡ</h1><div class="content"><p>4.4 基本分页存储管理方式<br>4.5 基本分段存储管理方式<br>4.6 虚拟存储器的基本概念<br>4.7 请求分页存储管理方式</p>
<h2 id="基本分页存储管理方式-Paged-Storage-Management"><a href="#基本分页存储管理方式-Paged-Storage-Management" class="headerlink" title="基本分页存储管理方式 Paged Storage Management"></a>基本分页存储管理方式 Paged Storage Management</h2><h3 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h3><p>前面介绍的分区存储管理，一般都要求把一个作业的地址空间装入到连续的存储区域内。因此，在动态分区的存储空间中，常常由于存在着一些不足以装入任何作业的小的分区而浪费掉部分存储资源，这就是所谓存储器的零头问题。<br>尽管采用“紧凑”技术可以解决这个问题，但要为移动大量信息花去不少处理机时间，代价较高。<br>如果我们能取消对其存储区域的连续性要求，必然会进一步提高主存空间的利用率，又无需为移动信息付出代价。</p>
<p><strong>离散分配</strong> 即程序在内存中不一定连续存放<br>根据离散时的基本单位不同，可分为三种：</p>
<ul>
<li>分页存储管理</li>
<li>分段存储管理</li>
<li>段页式存储管理</li>
</ul>
<p><strong>离散的基础</strong></p>
<p>分页(Pages)：将程序地址空间分页<br>分块(Frames)：将内存空间分块</p>
<p><strong>离散分配的体现</strong><br>内存一块可以装入程序一页<br>连续的多个页不一定装入连续的多个块中<br>注：系统中页块的大小是不变的。</p>
<p><strong>离散分配的优点</strong><br>没有外零头。不受连续空间限制，每块都能分出去<br>仅有小于一个页面的内零头。由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”或称为“内零头”。</p>
<p><strong>定义</strong></p>
<ul>
<li>页面&#x2F;页 Page: 作业的逻辑地址空间被分割成固定大小的片，称为页面</li>
<li>物理块&#x2F;页框 Page Frame：内存空间也分成与页相同大小的若干存储块。在为进程分配存储空间时，总是以页框为单位。<blockquote>
<p>Page 从 0 开始编号，页内地址是相对于 0 编址；<br>在进程调度时，必须把它所有的 Page 一次装入到主存的 Page Frame 内；如果当时 Page Frame 不足，则该进程必须等待，系统再调度另外的进程。（纯分页方式）</p>
</blockquote>
</li>
</ul>
<h3 id="分页存储管理的基本方法"><a href="#分页存储管理的基本方法" class="headerlink" title="分页存储管理的基本方法"></a>分页存储管理的基本方法</h3><p><strong>需解决的两个基本问题:</strong></p>
<ul>
<li>如何建立程序空间与主存空间的映射</li>
<li>如何进行地址变换(从程序逻辑地址到内存物理地址)<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-05-11-38-50.png" style="zoom:50%;"></li>
</ul>
<p><strong>页面大小的选择</strong><br>页面大小由机器的地址结构决定。某一机器只能采用一种大小的页面。页面的大小通常在 1KB~8KB 之间。</p>
<ul>
<li>小页面</li>
<li>大页面</li>
</ul>
<p><strong>实现分页存储管理的数据结构</strong><br>1）页表Page Table：每个进程对应 1 个页表，由各个页表项(Page Table Entry，PTE)描述该进程的各页面在内存中对应的物理块号。<br>页表项中包括页号、物理块号、存储控制字段<br>状态位：这些位提供了关于页面的额外信息，例如该页面是否在内存中（有效位），是否可以写入（写保护位），是否被访问过（访问位），是否被修改过（脏位）等<br>注意：全部页表集中存放在主存的系统专用区中，只有系统有权访问页表，保证安全。<br>2）作业表Job Table：整个系统 1 张，记录作业的页表情况，包含进程号、页表长度、页表始址等信息。<br>3）空闲块表：整个系统 1 张，记录主存当前空闲块。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-08-18-08-43.png" style="zoom:50%;"></p>
<p>某一作业被分成若干个Page，每个Page可以去进程对应的页表中查找对应的物理块号，然后再去主存中找到对应的物理块(Page Frame)。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-08-18-12-27.png" style="zoom:50%;"></p>
<h3 id="分页存储管理的逻辑地址表示"><a href="#分页存储管理的逻辑地址表示" class="headerlink" title="分页存储管理的逻辑地址表示"></a>分页存储管理的逻辑地址表示</h3><h4 id="逻辑地址结构"><a href="#逻辑地址结构" class="headerlink" title="逻辑地址结构"></a>逻辑地址结构</h4><p>地址空间为程序限定的空间。物理空间为内存限定空间。<br>在页式管理系统中将地址空间分成大小相同的页面Page。将内存空间分成与页面相同大小的存储块Page Frame。<br>分页存储管理方式中，任何一个逻辑地址都可转变为：页号+页内位移量。<br>页号、位移量的划分是由系统自动完成的，对用户是透明的。</p>
<p>设有一逻辑地址A，页面大小为L，则在分页存储管理方式中，它的地址被转换：</p>
<div>
$$
Page Number = INT(\frac{A}{L}) \\
Offset In Page = A \ mod \ L
$$
</div>

<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-08-18-17-40.png" style="zoom:100%;">

<p>0～11位表示页内位移量，则每页的大小为212 &#x3D; 4KB。<br>12 ～ 31位表示页号，220&#x3D;1M，即最多允许有1M个页面。</p>
<p>如有逻辑地址为：2170，页面大小为1KB，则<code>P=INT[2170/1024]=2</code>；<code>W=2170 MOD 1024=122</code><br>这个地址的变换通常由系统中的某些硬件完成。</p>
<h4 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h4><p><strong>地址变换机构</strong>的功能是将用户的逻辑地址转变为内存中的物理地址。<br>逻辑地址由页号和页内位移量组成。页(Page)的大小和内存物理块(Pageframe)的大小是相同的，所以页内位移量即为物理块内位移量。<br>关键是页号到物理块号的转换，由页表完成。</p>
<p><strong>基本的地址变换机构</strong></p>
<ul>
<li>使用寄存器存放页表<br>速度快，成本高。特别对于大的系统，页表很长，不可能都用寄存器实现。</li>
<li>一般系统，将页表存储在内存中<br>设置一个页表寄存器（PTR），记录当前运行的进程的页表在内存中的始址和页表长度。（平时存于PCB中，要运行时才装入PTR中）</li>
</ul>
<p><strong>分页系统中的地址变换过程：</strong><br>（1）根据逻辑地址,计算出页号和页内偏移量；<br>（2）从PTR中得到页表首址，然后检索页表，查找指定页面对应的页框号；<br>（3）用页框号乘以页面大小获得其对应的起始地址，并将其送入物理地址的高端。<br>（4）将页内偏移量送入物理地址低端，形成完整的物理地址。</p>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-09-52-23.png" style="zoom:100%;">


<p><strong>具有快表的地址变换机构</strong></p>
<p>分页系统中处理机每次存取指令或数据至少需要访问两次物理内存：</p>
<ul>
<li>第一次访问页表，以得到物理地址</li>
<li>第二次访问物理地址，以得到数据。<br>存取速度几乎降低了一倍，代价太高。为了提高地址变换速度，为进程页表设置一个专用的高速缓冲存储器，称为快表TLB(Translation Lookaside Buffer)或联想存储器（Associative Memory） 。</li>
</ul>
<blockquote>
<p>Lookaside buffer是一种硬件缓存机制，用于加速对特定类型数据的访问。这种缓存机制通常在CPU或其他硬件组件中实现，例如网络接口卡或硬盘控制器。<br>Lookaside buffer的工作原理是将最近或最常访问的数据存储在一个快速访问的缓存中，以减少对慢速内存的访问。当CPU或其他硬件组件需要访问数据时，它们首先查看lookaside buffer。如果所需的数据在缓存中，那么就可以快速地从缓存中获取，而无需访问慢速的内存。这被称为缓存命中。如果数据不在缓存中，那么就需要访问慢速的内存，并将数据放入缓存中以备后用。这被称为缓存未命中。</p>
</blockquote>
<p>进程最近访问过的页面在不久的将来还可能被访问。快表的工作原理类似于系统中的数据高速缓存(cache)，其中专门保存当前进程最近访问过的一组页表项。</p>
<p><strong>快表地址转换过程</strong></p>
<ul>
<li>根据逻辑地址中的页号，查找快表中是否存在对应的页表项。</li>
<li>若快表中存在该表项，称为命中（hit），取出其中的页框号，加上页内偏移量，计算出物理地址。</li>
<li>若快表中不存在该页表项，称为命中失败，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，更新快表，将该表项插入快表中。并计算物理地址.</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-13-47-15.png" style="zoom:100%;">

<h4 id="访问内存有效时间-EAT"><a href="#访问内存有效时间-EAT" class="headerlink" title="访问内存有效时间 EAT"></a>访问内存有效时间 EAT</h4><p>**访问内存有效时间EAT(Effective Access Time)**：从进程发出指定逻辑地址的访问请求，经过地址变换，再到内存中找到对应的物理单元并取出数据，所花费的总时间。</p>
<p>如检索快表时间为20 ns，访问内存为100 ns。<br>若能在快表中检索到CPU给出的页号，则CPU存取一个数据共需120 ns；否则，需要220 ns的时间。<br>如果不设置快表，CPU存取一个数据需要200 ns。快表(TLB)命中时效率会很高，未命中效率会降低，但平均后仍表现良好</p>
<p>$$<br>EAT_{average} &#x3D; HitR \times (TLB_{time} + Memory_{time}) + (1-HitR) \times (TLB_{time} + 2 \times Memory_{time})<br>$$</p>
<blockquote>
<p>$EAT_{average}$ 为平均有效访问时间<br>$HitR$ 为命中率<br>$TLB_{time}$ 为快表访问时间，$Memory_{time}$ 为内存访问时间</p>
</blockquote>
<h4 id="两级和多级页表"><a href="#两级和多级页表" class="headerlink" title="两级和多级页表"></a>两级和多级页表</h4><p><strong>问题引入</strong><br>32位逻辑地址空间，假设页面大小为4KB（212），则4GB（232）的逻辑地址空间将被划分成220个页面。<br>若采用一级页表，则该表将包含1M（220）个页表项。若按字节寻址，一个页表项占4B，则一级页表需要占用4MB（222）内存空间。不可能将4MB的页表保存在一个连续区中。<br>那么，如何处理大页表的存储与检索呢？ </p>
<p>可以采用这样两个方法来解决这一问题：<br>① 采用离散分配方式来解决难以找到一块连续的大内存空间的问题，（即引入两级页表）；<br>② 只将当前需要的部分页表项调入内存， 其余的页表项仍驻留在磁盘上，需要时再调入。 </p>
<h5 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h5><p>对于要求连续的内存空间来存放页表的问题：</p>
<ul>
<li>可将页表进行分页，并离散地将各个页面分别存放在不同的物理块中，</li>
<li>同样也要为离散分配的页表再建立一张页表，称为外层页表(Outer Page Table)，在每个页表项中记录了页表分页的物理块号。</li>
</ul>
<p>对于4GB($2^{32} Byte$)的进程，页面大小为4KB($2^12 Byte$) ,若采用二级页表，则对应的二级页表结构设计如下(假定每个页表项4B)：<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-17-27-34.png" style="zoom:100%;"></p>
<ol>
<li>页面大小4KB，故32位逻辑地址中要用12位表示页内偏移量。</li>
<li>4GB的逻辑地址空间被分成$4GB \div 4KB&#x3D; 2^{20}$个页面，内层页表大小为$2^{20} \times 4B &#x3D; 4MB$。</li>
<li>外层页表的表项记录的是某页在内存中的物理块号。外层页表个数为$4MB \div 4KB &#x3D; 2^{10}$个，大小为$2^{10} \times 4B &#x3D; 4KB$。</li>
<li>前10位表示外层页表的页号，后10位表示内层页表的页号，最后12位表示页内偏移量。</li>
</ol>
<p>变换机构：先在外层页表寄存器中找到外层页表的起始地址，根据逻辑地址中的外层页号找到对应的内层页表的起始地址，再根据逻辑地址中的内层页号找到对应的物理块号。</p>
<p>利用离散分配方法实现的两级页表只是解决了大页表无需大片连续存储空间问题，但并未解决用较少内存去存放大页表问题，有关此类问题的成功解决方案放在虚拟存储器管理中。</p>
<h5 id="多级页表机构"><a href="#多级页表机构" class="headerlink" title="多级页表机构"></a>多级页表机构</h5><p><strong>Intro</strong><br>对于64位的机器，采用两级页表结构是否合适?</p>
<p>使用4KB的页面，剩52位。若按4KB来划分页表，还剩42位用于外层页表，因而外层页表有4KG个页表项,占16KGB的空间<br>使用1MB的页面(220)，剩44位。若按1MB来划分页表，还剩26位用于外层页表，外层页表有64M个页表项，占256MB空间<br>显然这是不现实的，外层页表过大无法装入一个物理块中</p>
<blockquote>
<p>64位的机器，采用的是多级（4级以上）页表结构。<br>电脑的位数通常指的是其CPU的位数，这是指CPU一次能处理的数据的位数，也就是其寄存器的宽度。例如，32位的CPU一次可以处理32位（4字节）的数据，而64位的CPU一次可以处理64位（8字节）的数据。<br>这个位数也决定了CPU可以直接寻址的内存空间的大小。32位的CPU可以直接寻址$2^{32}个位置，也就是4GB的内存空间。同样，64位的CPU可以直接寻址\2^{64}$个位置，这是一个非常大的空间，远远超过了现在的计算机所装配的实际物理内存。<br>然而，实际上，操作系统通常会使用虚拟内存系统，这允许每个进程都有自己的地址空间，并且这个地址空间的大小可以超过实际的物理内存。例如，每个进程在64位的Linux系统中都有一个$2^{48}$字节的虚拟地址空间，虽然实际的物理内存可能只有几GB。<br>所以，电脑的位数决定了CPU的寄存器宽度，一次可以处理的数据的位数，以及可以直接寻址的内存空间的大小。但是实际可用的地址空间可能会因为虚拟内存系统和操作系统的设计而变化。</p>
</blockquote>
<p><strong>多级页表实现</strong><br>通过间接引用将页号分成k级，建立页表“树”，减少每级页表的长度<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-21-38-01.png" style="zoom:100%;"><br>CPU得到逻辑地址后，先从最高级的页表开始，逐级查找，直到找到最低级的页表，再根据页表项找到物理块号。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-09-21-39-01.png" style="zoom:100%;"></p>
<h5 id="反置页表-IPT-Inverted-Page-Table"><a href="#反置页表-IPT-Inverted-Page-Table" class="headerlink" title="反置页表 IPT Inverted Page Table"></a>反置页表 IPT Inverted Page Table</h5><p><strong>Intro</strong></p>
<p>可以得出结论，对于在OS中同时运行的多个进程，相当大的一部分内存仅被页表占用。操作系统还结合了多级分页方案，这进一步增加了存储页表所需的空间，并且在存储页表时投入了大量的存储器。页表占用的内存量可能会成为一个巨大的开销。为了有效地利用存储器，引入了反置页表。</p>
<ul>
<li>IPT要解决的问题<br>逻辑空间越来越大，页表占内存也越来越大，为了解决大页表问题占内存多现象，减少内存开销，避免一个进程一个页表</li>
<li>IPT思想：<br>IPT是为主存中的每一个物理块建立一个页表项并按照块号排序；<br>该表每个表项Entry包含正在访问该物理块的进程标识Pid、页面号Page number及特征位Control bits,用来完成主存物理块到访问进程的页号的转换</li>
</ul>
<p>IPT Entry Struct</p>
<ul>
<li>Page number: It specifies the page number range of the logical address.</li>
<li>Process id: An inverted page table contains the address space information of all the processes in execution. Since two different processes can have a similar set of virtual addresses, it becomes necessary in the Inverted Page Table to store a process Id of each process to identify its address space uniquely. This is done by using the combination of PID and Page Number. So this Process Id acts as an address space identifier and ensures that a virtual page for a particular process is mapped correctly to the corresponding physical frame.</li>
<li>Control bits: These bits are used to store extra paging-related information. These include the valid bit, dirty bit, reference bits, protection, and locking information bits.</li>
<li>Chained pointer: It may be possible sometimes that two or more processes share a part of the main memory. In this case, two or more logical pages map to the same Page Table Entry then a chaining pointer is used to map the details of these logical pages to the root page table.<br>Note: Number of Entries in Inverted page table &#x3D; Number of frames in Physical Address Space(PAS).</li>
</ul>
<p><strong>IPT地址转换过程</strong></p>
<p>给出进程标识和页号,用它们去比较IPT,若整个反置页表中未能找到匹配的页表项,说明该页不在主存,产生请求调页中断,请求操作系统调入;否则，该表项的序号便是物理块号,块号加上位移,便形成物理地址。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-10-20-50-53.png" style="zoom:100%;"></p>
<p>然而，反置页表也有其缺点，比如查找特定虚拟地址对应的物理地址可能会更复杂，因为反置页表不是按照虚拟地址排序的。这可能会导致查找时间增加，尤其是在页表变得非常大的时候。为了解决这个问题，一些系统会使用额外的数据结构，如哈希表，基于Hash映射值查找对应页表项中的帧号<br>倒排页表（Inverted Page Table，IPT）使用哈希表来改进查找性能，这是由于在一个大的倒排页表中直接查找特定的页表项可能会非常耗时。倒排页表和哈希表的组合可以更有效地将虚拟地址（或逻辑地址）转换为物理地址。</p>
<p>以下是倒排页表（IPT）在引入哈希表后如何转换逻辑地址的过程：</p>
<ol>
<li><p>逻辑地址由两部分组成：虚拟页号（Virtual Page Number，VPN）和页内偏移（Offset）。</p>
</li>
<li><p>当需要访问内存时，操作系统或硬件会使用VPN作为哈希函数的输入，计算出哈希值。</p>
</li>
<li><p>这个哈希值用于在哈希表中查找相应的页表项。如果存在冲突（即多个VPN哈希到同一位置），则使用链接（链表）的方式解决冲突。</p>
</li>
<li><p>一旦找到了对应的页表项，就可以得到物理页框号（Physical Frame Number，PFN）。这个PFN就是物理地址的一部分。</p>
</li>
<li><p>最后，物理地址由PFN和原始的页内偏移组成。</p>
</li>
</ol>
<p>通过这种方式，倒排页表结合哈希表可以有效地将逻辑地址转换为物理地址，同时保持查找时间的效率。<br><img src="https://cdn.jsdelivr.net/gh/Efterklang/imageBed@master/Ch4-2StorageManagement-2024-05-10-21-00-23.png" style="zoom:100%;"></p>
<p><strong>Pros</strong><br>Reduced Memory Space: Inverted Page Tables typically reduce the amount of memory required to store the page tables to a size bound of physical memory. The maximum number of entries could be the number of page frames in the physical memory.<br>Longer Lookup Time: Inverted Page tables are sorted in order of frame number but the memory look-up takes place concerning the virtual address, so, it usually takes a longer time to find the appropriate entry often these page tables are implemented using hash data structures for a faster lookup.<br>Difficult Shared Memory Implementation: As the Inverted Page Table stores a single entry for each frame, it becomes difficult to implement the shared memory in the page tables. Chaining techniques are used to map more than one virtual address to the entry specified in the order of frame number.<br>Optimal and Less Complex: it is better than a simple paging process and has less complexity.<br>Simplified Page Swapping: When a process needs to be swapped out of memory, the IPT can be used to quickly identify all the physical pages that are associated with the process. This can simplify the process of swapping pages and reduce the overall overhead of memory management.<br>Improved Cache Performance: Because the IPT is smaller than a Page Table, it can be more easily stored in the CPU cache, which can improve the performance of memory access operations.</p>
<h2 id="基本分段存储管理方式-Segmented-Storage-Management"><a href="#基本分段存储管理方式-Segmented-Storage-Management" class="headerlink" title="基本分段存储管理方式 Segmented Storage Management"></a>基本分段存储管理方式 Segmented Storage Management</h2><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><p><a target="_blank" rel="noopener" href="https://data-flair.training/blogs/memory-management-in-computer/">data-flair memory-management-in-computer</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Storage Management PartⅡ</p><p><a href="https://efterklang.github.io/UESTC/OS/Ch4-2StorageManagement/">https://efterklang.github.io/UESTC/OS/Ch4-2StorageManagement/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Efterklang</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2024-05-03</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-05-10</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/OS/">OS</a></div><!--!--></article></div><!--!--><div class="card"><nav class="post-navigation mt-4 level is-mobile card-content"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/Dev/Git/reset-and-revert/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Understanding Git Reset and Revert</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/UESTC/OS/Ch4-3StorageManagement/"><span class="level-item">Storage Management PartⅢ</span><i class="level-item fas fa-chevron-right"></i></a></div></nav></div><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="content twikoo" id="twikoo"></div><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.32/dist/twikoo.all.min.js"></script><script>twikoo.init({
      envId: 'https://efterklang-twikoo.hf.space',
      onCommentLoaded: function () {
        var commentContents = document.getElementsByClassName('tk-content');
        for (var i = 0; i < commentContents.length; i++) {
          var commentItem = commentContents[i];
          var imgEls = commentItem.getElementsByTagName('img');
          if (imgEls.length > 0) {
            for (var j = 0; j < imgEls.length; j++) {
              var imgEl = imgEls[j];
              var aEl = document.createElement('a');
              aEl.setAttribute('class', 'tk-lg-link');
              aEl.setAttribute('href', imgEl.getAttribute('src'));
              aEl.setAttribute('data-src', imgEl.getAttribute('src'));
              aEl.appendChild(imgEl.cloneNode(false));
              imgEl.parentNode.insertBefore(aEl, imgEl.nextSibling);
              imgEl.remove();
            }
            if (typeof $.fn.lightGallery === 'function') {
              $(commentItem).lightGallery({
                selector: '.tk-lg-link'
              });
            }
          }
        }
      }
    });</script></div></div></div><style>.column.column-left,.column.column-right{display:none}</style><!--!--><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#基本分页存储管理方式-Paged-Storage-Management"><span class="level-left"><span class="level-item">1</span><span class="level-item">基本分页存储管理方式 Paged Storage Management</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Intro"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Intro</span></span></a></li><li><a class="level is-mobile" href="#分页存储管理的基本方法"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">分页存储管理的基本方法</span></span></a></li><li><a class="level is-mobile" href="#分页存储管理的逻辑地址表示"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">分页存储管理的逻辑地址表示</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#逻辑地址结构"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">逻辑地址结构</span></span></a></li><li><a class="level is-mobile" href="#地址变换机构"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">地址变换机构</span></span></a></li><li><a class="level is-mobile" href="#访问内存有效时间-EAT"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">访问内存有效时间 EAT</span></span></a></li><li><a class="level is-mobile" href="#两级和多级页表"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">两级和多级页表</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#基本分段存储管理方式-Segmented-Storage-Management"><span class="level-left"><span class="level-item">2</span><span class="level-item">基本分段存储管理方式 Segmented Storage Management</span></span></a></li><li><a class="level is-mobile" href="#Ref"><span class="level-left"><span class="level-item">3</span><span class="level-item">Ref</span></span></a></li></ul></div></div><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Dev/"><span class="level-start"><span class="level-item">Dev</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Dev/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Dev/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Game/"><span class="level-start"><span class="level-item">Game</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Reading/"><span class="level-start"><span class="level-item">Reading</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Reading/Poems/"><span class="level-start"><span class="level-item">Poems</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Tech/"><span class="level-start"><span class="level-item">Tech</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul><li><a class="level is-mobile" href="/categories/Tech/DataBase/"><span class="level-start"><span class="level-item">DataBase</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/categories/Tech/FrontEnd/"><span class="level-start"><span class="level-item">FrontEnd</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Tech/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/Tech/Others/"><span class="level-start"><span class="level-item">Others</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Tech/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/UESTC/"><span class="level-start"><span class="level-item">UESTC</span></span><span class="level-end"><span class="level-item tag">27</span></span></a><ul><li><a class="level is-mobile" href="/categories/UESTC/ARM-Processor/"><span class="level-start"><span class="level-item">ARM-Processor</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/Computer-Networking/"><span class="level-start"><span class="level-item">Computer Networking</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/categories/UESTC/OS/"><span class="level-start"><span class="level-item">OS</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li></ul></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2024/05/"><span class="level-start"><span class="level-item">May 2024</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/04/"><span class="level-start"><span class="level-item">April 2024</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/03/"><span class="level-start"><span class="level-item">March 2024</span></span><span class="level-end"><span class="level-item tag">20</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/02/"><span class="level-start"><span class="level-item">February 2024</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile" href="/archives/2024/01/"><span class="level-start"><span class="level-item">January 2024</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile" href="/archives/2023/12/"><span class="level-start"><span class="level-item">December 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div></div><style>.column.column-left,.column.column-right{display:block}</style></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img class="logo-img" src="/img/sunflower.png" alt="Efterklang" height="28"><img class="logo-img-dark" src="/img/sunflower.png" alt="Efterklang" height="28"></a><p class="is-size-7"><span>&copy; 2024 Efterklang</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/imaegoo/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="GitHub" href="https://github.com/Efterklang"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/twikoo@1.6.32/dist/twikoo.all.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/live2d-widget/autoload.js"></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><div class="searchbox-pinyin"><label class="checkbox"><input id="search-by-pinyin" type="checkbox" checked="checked"><span> 拼音检索</span></label></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/imaegoo/pinyin.js" defer></script><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script><script type="text/javascript" src="/js/imaegoo/imaegoo.js"></script><script type="text/javascript" src="/js/imaegoo/universe.js"></script></body></html>
{"posts":[{"title":"","text":"h1 { font-family: Consolas; color: #426cc2; text-align: center; font-style: bold; /* font-size: 3em; */ } .title_card { display: flex; /* 使用flex布局 */ position: relative; /* 添加relative定位 */ box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2); transition: 0.3s; width: 100%; height: 100%; border-radius: 5px; overflow: hidden; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ } .title_card:hover { box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2); } .title_card_text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ color: white; /* 将文字颜色设置为白色 */ opacity: 0; transition: opacity 0.3s; font-family: 'Trebuchet MS'; /* 将字体设置为Arial */ text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* 添加文字阴影 */ } .title_card:hover .title_card_text { opacity: 0.9; animation: jelly 0.5s; } @keyframes jelly { 0%, 100% { transform: scale(1, 1); } 25% { transform: scale(0.9, 1.1); } 50% { transform: scale(1.1, 0.9); } 75% { transform: scale(0.95, 1.05); } } HOME 🔭About Me 1234567891011121314151617181920212223242526272829// =========================================================// * aboutme.json *// ========================================================={ &quot;Name&quot;: &quot;gjx&quot;, &quot;Age&quot;: 19, &quot;Gender&quot;: &quot;Male&quot;, &quot;School&quot;: &quot;UESTC&quot;, &quot;Skills&quot;: [&quot;Copy&quot;, &quot;Paste&quot;], &quot;Major&quot;: &quot;Software Engineering&quot;, &quot;Occupation&quot;: &quot;Undergraduate&quot;, &quot;Home&quot;: &quot;TsingTao, Shandong, CN&quot;, &quot;Email-Address&quot;: &quot;gaojiaxing2004@qq.com&quot;, &quot;Achievement&quot;: &quot;NULL&quot;, &quot;Author.hobbies&quot;: [ &quot;🕹️Immersing in Diverse Gaming Universes&quot;, &quot;🎼Harmonizing with the Rhythm of Music&quot;, &quot;🪁Exploring the World of Literature&quot;, &quot;🧑🏻‍🎨Enjoy the Journey of Beautification&quot;, &quot;🔦Unearthing Productivity Tools&quot;, &quot;📚Learning New Things About SE&quot;, &quot;📸Collecting Beautiful Pictures&quot; ], &quot;Author.achievements&quot;: [ &quot;2006年《时代周刊》年度风云人物&quot;, &quot;2008年《感动中国》年度人物&quot;, &quot;联合国2019年度地球卫士奖联合获奖人&quot; ]} 🌃How To Reach Me 😼Github 🐧QQ 📺Bilibili","link":"/Home/hello-world/"},{"title":"2077任务名中的彩蛋","text":"中文再见杰克|再见杰克 痛仰乐队飞翔鸟|飞翔鸟 唐朝乐队杀死那个石家庄人|直到大厦崩塌 万能青年旅店黑梦|黑梦,高级动物 窦唯梦缠绕的时候|梦缠绕的时侯 超载乐队火车驶向云外，梦安魂于九霄|梦安眠于九霄 刺猬乐队白日梦蓝|伤害的比赛 刺猬乐队公路之歌|公路之歌 痛仰乐队快让我再雪地上撒点野|让我们在云顶撒点野,我的病就是没有感觉 崔健垃圾场|垃圾场 何勇没有理想的人不伤心|没有理想不伤心 新裤子乐队别来纠缠我|别来纠缠我 黑豹乐队一万次悲伤|一万次悲伤 逃跑计划花火|没有结局的表演 汪峰钟鼓楼|全都是正确答案 何勇花|根已经枯萎 花儿乐队山雀|不息的身体 万能青年旅店两天|一天用来希望,一天用来绝望 许巍火车快开|生活往哪开 二手玫瑰 英文《All Along the Watchtower》 Bob Dylan《A Little Help From My Friends》 The Beatles《A Like Supreme》 A Like Supreme 《Beat on the Brat》 Ramones《Belly Of The Beast》 Anthrax《Boat Drinks》 Jimmy Buffett《Both Sides Now》 Joni Mitchell 《Disasterpiece》 Slipknot《(Don’t Fear) The Reaper》 Blue Oyster Cult《Down on the Street》 The Stooges 《Every Breath You Take》 The Police《Ex-Factor》 Lauryn Hill 《Following the River》 The Rolling Stones《Forward to Death》 Dead Kennedy《Fourtunate Son》 Creedence Clearwater Revival 《Gimme Danger》 The Stooges《Ghost Town》 The Specials 《I Fought the Law》 The Clash《I Don’t Wanna Hear It》 Minor Threat《I Walk The Line》 Jonny Cash《Imagine》 John Lennon 《Killing In The Name》 Rage Against the Machine《Knockin’ on Heaven’s Door》 Bob Dylan 《Last Caress》 Misfits《Life During Wartime》 Talking Heads《Love Like Fire》 Generation X《Lightening Breaks》 Plasmatics 《Meeting Alone the Edge》 Pink Floyd 《Nocturnes Op.55 No.1》 Chopin《New Dawn Fades》 Joy Division 《Pyramid song》 Radiohead《Psycho Killer》 Talking Heads《Playing For Time》 Madleen Kane《Play it Safe》 Iggy Pop《Path of Glory》 Plasmatics《Paid in Full》 Fire B. &amp; Rakim《Pisces》 JINJER 《Riders On the Storm》 The Doors《Rebel Rebel》 David Bowie 《Space Oddity》 David Bowie《Serach&amp;Destroy》 The Stooges《Smoke On The Water》 Deep Purple《Stairway to Heaven》 Led Zeppelin 《Tapeworm》 Pigface《The Beast In Me》 Jonny Cash《Transmission》 Joy Division《Totalimmortal》 A.F.I《The Fool On The Hill》 The Beatles《Talkin’ about a Revolution》 Tracy Chapman《The Space In Between》 How To Destroy Angels 《Venus in Furs》 The Velvet Underground 《We Gotta Live Together》 Dead Kennedys《Where is My Mind》 Pixies 文学作品For Whom the Bell Tolls 海明威的长篇小说,丧钟为谁而鸣;以美国人参加西班牙人民反法西斯战争为题材,1940 年首次出版 比远方更远,只身打马 海子诗作,九月 目击众神死亡的草原上野花一片远在远方的风比远方更远我的琴声呜咽 泪水全无我把这远方的远归还草原一个叫马头 一个叫马尾我的琴声呜咽 泪水全无远方只有在死亡中凝聚野花一片明月如镜高悬草原映照千年岁月我的琴声呜咽 泪水全无只身打马过草原","link":"/Gaming/CyberPunk2077/2077%E4%BB%BB%E5%8A%A1%E5%90%8D%E4%B8%AD%E7%9A%84%E5%BD%A9%E8%9B%8B/"},{"title":"Phantom Liberty","text":"Lyricsby CD PROJEKT RED, Dawid Podsiadło, P.T. Adamczyk Album Cyberpunk 2077: Phantom Liberty (Original Score - Deluxe Edition) CD PROJEKT RED, Dawid Podsiadło, P.T. Adamczyk – Phantom Liberty lyrics | Matchlyric Verse 1Found outTreasures are always lostPleasures and rage combinedI’m watchin’ youBe careful with your movesTonight, I think the time is rightI think the blood has driedIt cries for moreSo what are we waiting for? Chorus 1Wires and chains(I’m just tired of lookin’ the other way)Starting to fade(I’m just tired of lookin’ the other way)It feels like a game(I’m just tired of lookin’ the other way)You have to play(I’m just tired of lookin’ the other way) Verse 2Lights out, is this who you really are?Can’t look into your eyesYour twisted mindIt’s dark, so darkWe end it nowIt ends right here, right nowPlease tell me you brought the ironLet’s light up the skyAnd fade into the night Chorus 1Wires and chains(I’m just tired of lookin’ the other way)Starting to fade(I’m just tired of lookin’ the other way)It feels like a game(I’m just tired of lookin’ the other way)You have to play(I’m just tired of lookin’ the other way) BridgeThe days when it was good are gone (*Nah-nah-nah, nah-nah, nah*)I’m tryna see what it was for, but I’ll never know (*Nah-nah-nah, nah-nah, nah*)And though it’s dead, I hear the call (*Nah-nah-nah, nah-nah, nah*)Ooh-ooh-ooh-ooh-ooh Chorus 2Wires and chains(I’m just tired of lookin’ the other way)Starting to fade(I’m just tired of lookin’ the other way)Feels like a game(I’m just tired of lookin’ the other way)You can’t escape(I’m just tired of lookin’ the other way)Wires and chains(I’m just tired of lookin’ the other way)Starting to fade(I’m just tired of lookin’ the other way)Feels like a game(I’m just tired of lookin’ the other way)You can’t escape(I’m just tired of lookin’ the other way) OutroI found outTreasures are always lostPleasures are long forgottenWho are you now? Appreciation“Phantom Liberty” by Dawid Podsiadło &amp; P.T. Adamczyk explores themes of lost treasures, suppressed emotions, and the feeling of being trapped. The lyrics suggest a sense of danger and caution, urging the listener to be careful with their actions and movements. The line “I think the blood is dried, it cries for more” implies a craving for intensity and stimulation. There is an underlying desire to break free from a stagnant and monotonous existence. The chorus of the song emphasizes the feeling of being stuck and unable to escape. Wires and chains symbolize constraints and limitations, while the mention of fading suggests a loss of vitality or passion. The lyrics portray life as a game that one must play, even if it feels repetitive and meaningless. It hints at the idea that one may feel trapped by circumstances beyond their control. In the second verse, the lyrics delve into the darkness within someone’s mind. The narrator’s inability to look into the eyes of another person suggests a lack of trust or fear of confronting their true intentions. There is a desire to bring an end to this twisted and oppressive situation, as indicated by the line “We end it now, it ends right here, right now.” The idea of fading into the moon signifies a longing for escape or transcendence. The bridge reflects on the loss of better days and the frustration of not fully understanding the purpose behind certain experiences. The mention of hearing the clock suggests an awareness of time passing and the need to take action. Overall, “Phantom Liberty” depicts a struggle with confinement, questioning the meaning of existence, and a yearning for freedom and liberation. 流行音乐常用的歌曲结构一般是ABABCB，也就是Verse-Chorus-Verse-Chorus-Bridge-Chorus， VERSE 是主歌， CHORUS 是副歌(chorus有合唱，副歌的意思)。 Bridge是经常出现在第二段副歌之后的乐段，为歌曲提供一些变化、增加张力等。 长度一般是4或8小节，也被称为“middle 8”，具体时长取决于歌曲需要","link":"/Gaming/CyberPunk2077/Phantom-Liberty/"},{"title":"Letter From Olgierd von Everec","text":"Letter from Olgierd von Everec My Dearest Wife, Were I only as skilled with words as I am with my blade. Especially now, when an icy void grips my heart. I see how you look at me, and I see how you wither. I cannot help you, but I believe I can cease harming you. This letter and this rose are my farewell. May you live in health and remember but the good times. Olgierd The Painted World​ Geralt finds himself in the surreal painted world reminiscent of the estate. The dog and cat, who apparently exist simultaneously in both worlds, informing him that in order to truly awaken Iris, Geralt has to complete the memories she has been denying, and destroy the fears and nightmares that bind her. ​ As you reenact the memories, Geralt will see how the couple’s marriage began to deteriorate over time, how Iris’ family didn’t approve of Olgierd as her husband, and how Olgierd tried to use magic to summon Gaunter O’Dimm to try and break the pact he forged, but it ultimately failed and set fire to the manor. Eventually, it leads to a scene where, having grown indifferent to Iris and only remembering that he was supposed to love her, Olgierd gave her the strange cat and dog for company and the Caretaker for protection. Video","link":"/Gaming/The%20Witcher%203/Letter-From-Olgierd-von-Everec/"},{"title":"《二子乘舟》","text":"p { text-indent: 2em; } 诗经·国风·邶风 二子乘舟 泛泛其景 愿言思子 中心养养 二子乘舟 泛泛其逝 愿言思子 不瑕有害 注释 二子: 卫宣公的两个异母子，公子伋和公子寿 泛泛: 飘荡貌。王先谦《集疏》：“泛，浮貌。重言之曰泛泛。” 景: 通憬，远行貌 闻一多《诗经通义》“景读为‘迥’，言漂流渐远也”。 愿：思念貌 中心: 心中 养(yáng 羊) 心中烦躁不安。 瑕：训“胡”，通“无”。 不瑕，犹言“不无”，疑惑、揣测之词 译文两人乘一叶孤舟，渐渐向远处漂流。深深思念你们俩，我心中充满忧愁。 两人乘一叶小船，渐渐地越行越远。深深思念你们俩，愿你们顺利平安。 鉴赏《毛诗序》云：“《二子乘舟》，思伋、寿也。卫宣公之二子，争相为死，国人伤而思之，作是诗也。宣公为伋取于齐女而美，公夺之，生寿及朔。朔与其母诉伋于公，公令伋使齐，使贼先待于隘而杀之。寿知之，以告伋，使去之。伋曰：‘君命也，不可以逃。’寿窃其节而先往，贼杀之。伋至，曰：‘君命杀我，寿有何罪？’又杀之。”。 刘向《新序·节士》云:“寿知其母阴谋，遂与伋同舟，使舟人不得杀伋，方乘舟时，伋傅母恐其死也，闵而作诗”。 轶事典故卫宣公，姬姓卫氏名晋，为卫庄公之子。卫庄公死后，公子晋的哥哥太子完继位，是为卫桓公。卫桓公十六年，卫宣公的另一个兄弟公子州吁聚集从卫国逃走的流民袭击杀害卫桓公，自立为君，史称卫前废公。卫国人因卫前废公杀害卫桓公，而且喜好打仗，所以都不拥护他。同年九月，卫国大臣石碏联合陈桓公杀死卫前废公。十二月，石碏将公子晋从邢国迎回卫国，并拥立公子晋继位，是为卫宣公。 卫宣公和父亲卫庄公的姬妾夷姜私通，生子名伋，卫宣公把公子伋托给右公子。卫宣公很宠爱夷姜，因此将公子伋立为太子，并让右公子教导他。伋长大成人后，卫宣公为他聘娶齐女，只因新娘子是个大美人，便改变主意，在河上高筑新台，把齐女截留下来，霸为己有，就是后来的宣姜。国人恶之而作《新台》p> 卫宣公得到宣姜后，宣姜生下两个儿子公子寿和公子朔，卫宣公让左公子教导他们。夷姜自缢。宣姜与公子朔在宣公跟前诬陷急子。宣公派遣急子出使齐国，派人伪装强盗等在莘地，准备杀死他。 太子伋将要动身时，公子寿知道公子朔仇恨太子伋，而卫宣公想杀掉太子伋，于是对太子伋说：“边境上的强盗看见你手中的白色旄节，就会杀死你，你可不要前去。”并让太子伋赶快逃走。太子伋不同意说：“弃父之命，恶用子矣！有无父之国则可也。”等到太子伋临走时，公子寿用酒把太子伋灌醉，然后偷走太子伋的白色旄节。公子寿车上插着白色旄节奔驰到莘地，莘地的强盗看见来人果真手持白色旄节，就杀死公子寿。公子寿死后，太子伋赶到，对强盗说：“我之求也，此何罪？请杀我乎！”强盗一并杀掉太子伋，然后报告卫宣公。卫宣公于是立公子朔为太子，即后来的卫惠公。","link":"/Reading/Poems/%E3%80%8A%E4%BA%8C%E5%AD%90%E4%B9%98%E8%88%9F%E3%80%8B/"},{"title":"《新台》","text":"p { text-indent: 2em; } 诗经·国风·邶风 新台有泚 河水弥弥 燕婉之求 蘧篨不鲜 新台有洒 河水浼浼 燕婉之求 蘧篨不殄 鱼网之设 鸿则离之 燕婉之求 得此戚施 注释 新台：台名，卫宣公为纳宣姜所筑，故址在今山东省甄城县黄河北岸。台：台基，宫基，新建的房子。 有：语助词，做形容词词头，无实义。 有泚（cǐ）：鲜明的样子。 河：指黄河。弥（mí）弥：水盛大的样子。 燕婉：指夫妇和好。燕，安；婉，顺。 籧（qú）篨（chú）：不能俯者。古代钟鼓架下兽形的柎，其兽似豕，蹲其后足，以前足据持其身，仰首不能俯视。喻身有残疾不能俯视之人，此处讥讽卫宣公年老体衰腰脊僵硬状。一说指癞蛤蟆一类的东西。鲜（xiǎn）：少，指年少。一说善。 洒（cuǐ）：高峻的样子。 浼（měi）浼：水盛大的样子。 殄（tiǎn）：通“腆”，丰厚，美好。 设：设置。 鸿：蛤蟆，一说大雁。离：离开。一说离通“丽”，附着，遭遇。一说离通“罹”，遭受，遭遇，这里指落网。 戚施（shī）：蟾蜍，蛤蟆，其四足据地，无须，不能仰视，喻貌丑驼背之人 译文新台明丽又辉煌，河水洋洋东流淌。本想嫁个如意郎，却是丑得蛤蟆样。 新台高大又壮丽，河水漫漫东流去。本想嫁个如意郎，却是丑得不成样。 设好鱼网把鱼捕，没想蛤蟆网中游。本想嫁个如意郎，得到却是如此丑。 鉴赏此诗若按旧说理解，一、二章赋陈其事，第三章起兴以比。诗开篇即夸耀卫宣公建造的新台是多么宏伟华丽，其下奔流的淇河之水是多么丰盈浩瀚。这都是极力渲染卫宣公的赫赫威势和装点门面，也可以看作是姜氏（宣姜）眼中所见，已被宣公的表面现象迷惑了。她本为是嫁过来追求燕婉之好，想过一种郎才女貌、琴瑟和谐的幸福生活的，却不料成了一个糟老头子的掌中玩物。 全诗三章，前两章叠咏。叠咏的两章前二句是兴语，但兴中有赋：卫宣公欲夺未婚之儿媳，先造“新台”，来表示事件的合法性，其实是障眼法。好比唐明皇欲夺其子寿王妃即杨玉环，先让她入道观做女观一样，好像这一来，一切就合理合法了。然而丑行就是丑行，丑行是欲盖弥彰的。诗人大赞“新台有泚”“新台有洒”，正言欲反，其兴味在于，新台是美的，但遮不住老头子干的丑事。这里是运用反形（或反衬）的修辞手法，使美愈美，丑愈丑。 “新台”之事的直接受害者是宣姜：美丽的少女配了个糟老头，而且还是个驼背鸡胸，本来该做她老公公的人。“鱼网之设，鸿则离之。”打鱼打个癞虾蟆，是非常倒楣，非常丧气，又非常无奈的事。按照闻一多《诗经通义》中的说法：“《国风》中凡言鱼者，皆两性间互称其对方之虞语（隐语），无一实拾鱼者。”古今诗歌中以捕鱼、钓鱼喻男女求偶之事的民歌很多。例如汉乐府民歌《江南曲》：“江南可采莲，莲叶何田田，鱼戏莲叶间。鱼戏莲叶东，鱼戏莲叶西，鱼戏莲叶南，鱼戏莲叶北。”《僮人情歌》：“天上无风燕子飞，江河无水现沙磊。鱼在深塘空得见，哄哥空把网来围。”即是显例。此诗中所写的就是女子对婚姻的幻想和现实的相悖，构成异常强烈的对比，产生了异乎寻常的艺术效果。这里强烈地表明：宣姜可真是倒楣透了。诗中“河水弥弥”“河水浼浼”，亦似有暗喻宣姜泪流不止之意，就如《卫风·氓》“淇水汤汤，渐车帷裳”以及辛弃疾《菩萨蛮·书江西造口壁》“郁孤台下清江水，中间多少行人泪”所表现的那样，渲染出一种浓厚的悲剧氛围","link":"/Reading/Poems/%E3%80%8A%E6%96%B0%E5%8F%B0%E3%80%8B/"},{"title":"《过松原晨炊漆公店六首》","text":"[宋] 杨万里 侧塞千山缝也无，上天下井万崎岖。 昨朝曾过芙蓉渡，寻到溪源一线初。 山北溪声一路迎，山南溪响送人行。 也知流向金陵去，若过金陵莫寄声。 后山勒水向东驰，却被前山勒向西。 道是水柔无性气，急声声怒慢声悲。 日高谷底始微暄，岚翠依然透骨寒。 说与行人忙底事？金鸡声里促银鞍。 莫言下岭便无难，赚得行人错喜欢。 政入万山围子里，一山放出一山拦。 政是行人肠断时，子规得得向人啼。 若能泪得居人脸，始信春愁总为伊。 注释 松源、漆公店：地名，当今在今皖南山区（在今江西弋阳与余江之间） 侧塞：积满充塞貌（积满充塞的样子） 昨朝：昨天 寄声：托人传话 勒：约束 暄：温暖 岚翠：苍翠色的山雾(三十六峰晴，雪销岚翠生——白居易《早春题少华东岩》) 底事：何事 银鞍：银饰的马鞍。代指骏马 政入：恰好进入 子规：杜鹃鸟的别名。传说为蜀帝杜宇的魂魄所化。常夜鸣，声音凄切，故借以抒悲苦哀怨之情 得得：频频，频仍 居人：家居的人，留居的人(妻子) 伊：第三人称代词，它 创作背景 杨万里一生力主抗战，反对屈膝投降，所以一直不得重用。宋孝宗登基后，便被外放做官。宋光宗绍熙元年（1190）十一月，杨万里以直龙图阁出为江东转运副使，权领淮西、江东军马钱粮，治所在建康（今江苏南京）。绍熙三年（1192）八月，改知赣州，不赴，乞祠。《过松源晨炊漆公店六首》这组诗第六首中“政是行人肠断时，子规得得向人啼”与《午憩马家店》中“生衣兼草靸，年例试春风”正相合，既称“年例”（每年如此），可知非绍熙二年事，当作于绍熙三年春，诗人时年六十六岁。他外出途经松源时，见群山环绕，感慨不已，于是写下《过松源晨炊漆公店六首》这组诗。 作者介绍 杨万里（1127年10月29日－1206年6月15日），字廷秀，号诚斋。吉州吉水（今江西省吉水县黄桥镇湴塘村）人。南宋著名诗人、大臣，与陆游、尤袤、范成大并称为“中兴四大诗人”。因宋光宗曾为其亲书“诚斋”二字，故学者称其为“诚斋先生”。杨万里一生作诗两万多首，传世作品有四千二百首，被誉为一代诗宗。他创造了语言浅近明白、清新自然，富有幽默情趣的“诚斋体”。杨万里的诗歌大多描写自然景物，且以此见长。他也有不少篇章反映民间疾苦、抒发爱国感情的作品。著有《诚斋集》等","link":"/Reading/Poems/%E3%80%8A%E8%BF%87%E6%9D%BE%E5%8E%9F%E6%99%A8%E7%82%8A%E6%BC%86%E5%85%AC%E5%BA%97%E5%85%AD%E9%A6%96%E3%80%8B/"},{"title":"DataBase Base_基础概念&amp;SQL语法","text":"MySQL Overview数据库相关概念[Glossary Of SQL]-&gt;SeeMore 数据库 : 数据库(DataBase,Scheme)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。 数据库管理系统 : 数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。 数据库系统 : 数据库系统(Database System)通常由软件、数据库和数据管理员(DBA)组成。 数据库管理员 : 数据库管理员(Database Administrator)负责全面管理和控制数据库系统。 启动 &amp; 客户端连接MySQL80 服务将开始监听特定的端口（默认是 3306），等待客户端的连接请求。一旦接收到请求，它就会处理这些请求，执行 SQL 查询，返回查询结果 123# 启动&amp;停止 Servicenet start mysql80net stop mysql80 客户端连接数据库的方式： 命令行：mysql -h 主机名 -P 端口号 -u 用户名 -p 密码 图形化工具：Navicat、SQLyog、SQL Server Management Studio 数据模型数据模型可以分为两种.关系型数据模型和非关系型数据模型 关系型数据模型关系型数据模型（RDBMS,Relational Database Management System）：关系型数据库模型是基于关系（表）的数据模型，使用表格来组织和存储数据。最常见的关系型数据库是 MySQL、Oracle、SQL Server 等。 ps:table 是关系型数据库的术语，对应的中文是表，也可以称为关系，由行和列组成。在 SQL 中，”record”和”field”是两个基本的概念，它们分别对应于数据库表中的行和列。 Record：在数据库中，一个 record（也被称为 row 或 tuple）代表一组相关的数据，例如一个用户的信息或一个订单的详情。一个 record 包含了一组 field，每个 field 存储了一项特定的信息，例如用户的名字或订单的价格。 Field：在数据库中，一个 field（也被称为 field 或 attribute）代表一种类型的数据，例如所有用户的名字或所有订单的价格。一个 field 在一个表中是垂直的，它包含了一个特定类型的所有值。 例如，考虑一个简单的 table，它有两个 field（”User ID”和”User Name”）和两个 record： User ID User Name 1 Alice 2 Bob 在这个例子中，”1”和”Alice”是第一个 record，”2”和”Bob”是第二个 record。”User ID”和”User Name”是两个 field。 非关系型数据模型非关系型数据模型（NoSQL）：非关系型数据库模型是一种非结构化的数据模型，不使用表格来组织和存储数据。它们可以是键值对存储、文档存储、列存储、图形数据库等。常见的非关系型数据库有 MongoDB、Redis、Cassandra 等。 SQL GrammerOverview 单行或多行书写，以分号结尾SQL 语句可以用空格和缩进来增强可读性SQL 语句不区分大小写，关键字建议使用大写Comment：单行注释（– comment）；多行注释（/_ comment _/）Category：DDL,DML,DQL,DCL Data type数值类型 数据类型 内存大小(Byte) TINYINT 1 SMALLINT 2 MEDIUMINT 3 INT 4 BIGINT 8 FLOAT 4 DOUBLE 8 DECIMAL(M, N) 取决于M和N 数据类型后面可加UNSIGNED修饰，例如age TINYINT UNSIGNED 对于DECIMAL(M, N)类型，M是数字的最大总位数，N是小数点后的位数。数值范围取决于M和N的值。如123.45，M=5,N=2 字符串类型 数据类型 大小 描述 CHAR 0-255Bytes 定长字符串 VARCHAR 0-65535Bytes 变长字符串 BLOB 0-65535Bytes 二进制形式的长文本数据 TEXT 0-65535Bytes 长文本数据 char(10) 会占用 10 个字符的存储空间，不足 10 个字符会使用空格补齐；性能高于 varcharvarchar(10) 会根据实际存储的字符数来占用存储空间，不会浪费空间 Date &amp; Time 类型 格式 范围 DATE YYYY-MM-DD 1000-01-01 到 9999-12-31 TIME HH:MM:SS -838:59:59 到 838:59:59 YEAR YYYY 1901 到 2155, 以及 0000 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 到 9999-12-31 23:59:59 TIMESTAMP YYYY-MM-DD HH:MM:SS 1970-01-01 00:00:01 UTC 到 2038-01-19 03:14:07 UTC SQL SyntaxCATEGORY 分类 全称 说明 DDL Data Definition Language 定义数据库对象（数据库，表，字段） DML Data Manipulation Language 对数据表中的数据进行增删改 DQL Data Query Language 查询数据库中表的记录 DCL Data Control Language 创建数据库用户，控制数据库的访问权限 TCL Transaction Control Language 用于保存或恢复对数据库对象执行的操作 [Glossary Of SQL#Basic Structure of SQL Server syntax]-&gt;SeeMore DML 语句和 DDL 语句区别：DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。另外，由于 select 不会对表进行破坏，所以有的地方也会把 select 单独区分开叫做数据库查询语言 DQL（Data Query Language）。# 执行速度不同节选自 JavaGuide——SnailClimb DDLDatabase Manipulation 创建：CREATE DATABASE &lt;DATABASE_NAME&gt;; 删除：DROP DATABASE &lt;DATABASE_NAME&gt;; 查看：SHOW DATABASES; 使用：USE &lt;DATABASE_NAME&gt;; 查询当前数据库： SELECT DATABASE(); Table Manipulation 删除：DROP TABLE &lt;TABLE_NAME&gt;; 创建：CREATE TABLE &lt;TABLE_NAME&gt; (field_name field_type, ...); 重命名：ALTER TABLE &lt;TABLE_NAME&gt; RENAME TO &lt;NEW_TABLE_NAME&gt;; 删除重建：TRUNCATE TABLE &lt;TABLE_NAME&gt;; 描述表结构：DESC &lt;TABLE_NAME&gt;; 查询当前数据库中的表：SHOW TABLES; 查看表的创建语句：SHOW CREATE TABLE &lt;TABLE_NAME&gt;; 12345678CREATE TABLE student( id int, name varchar(32), age int);DESC student;ALTER TABLE student RENAME TO student_info;DROP student_info; Add/Modify Field： ALETR TABLE &lt;TABLE_NAME&gt; &lt;ADD|MODIFY&gt; &lt;FIELD_NAME&gt; &lt;FIELD_TYPE&gt;; Change Field：ALTER TABLE &lt;TABLE_NAME&gt; CHANGE &lt;FIELD_NAME&gt; &lt;NEW_FIELD_NAME&gt; &lt;FIELD_TYPE&gt;; Drop Field：ALTER TABLE &lt;TABLE_NAME&gt; DROP &lt;FIELD_NAME&gt;; 1234-- Field Manipulation ExamplesALTER TABLE student ADD age int UNSIGNED;ALTER TABLE student MODIFY age tinyint UNSIGNED;ALTER TABLE student CHANGE nickname username tinyint UNSIGNED; DMLINSERT基本的 INSERT 语句的语法如下： 1INSERT INTO table_name (field1, field2, field3, ...) VALUES (value1, value2, value3, ...); 例如，如果你有一个名为 users 的表，它有 id，name 和 email,gender 四个 field，你可以使用以下的 INSERT 语句来插入数据： 1INSERT INTO users (id, name, email) VALUES (1, 'John Doe', '123@gmail.com'); 可以省略列的名称，但必须提供所有 field的值，并且顺序必须与表中的列的顺序相同： 1INSERT INTO users VALUES (1, 'John Doe', '222@gmail.com','男'); 批量插入数据： 12345INSERT INTO users (id, name, email)VALUES(1, 'Alice', 'alice@example.com'),(2, 'Bob', 'bob@example.com'),(3, 'Charlie', 'charlie@example.com'); DELETE123DELETE FROM student; -- 删除表中所有数据DELETE FROM student where id = 1; -- 删除id为1的数据TRUNCATE TABLE student; -- 删除表中所有数据，但不删除表结构 🪧drop,delete,truncate的区别： DROP TABLE is a DDL command. It is used to delete a table and free space associated with the table. It also deletes the table structure. TRUNCATE TABLE is a DDL command. It is used to delete all the rows from a table and free the space used by those rows. It does not generate any undo logs, so it is faster than the DELETE command. However, you CANNOT roll back a TRUNCATE operation. Also, TRUNCATE TABLE resets the identity of the table. DELETE FROM is a DML command. It is used to delete all the rows from a table or certain rows that match a condition. It generates undo logs for every deleted row, so you CAN roll back a DELETE operation. It does not reset the identity of the table. DELETE FROM without a WHERE clause behaves like TRUNCATE TABLE. PS:identity is a property of a column that is used to generate a sequence of numbers(id e.g.). The identity column is commonly used as a primary key. 可参考如下文章补充学习JavaGuide &gt; ZhiHu UPDATE12UPDATE student SET age = 18; -- Note:affects all rows in the table.UPDATE student SET age = 18 WHERE id = 1; DQLOVERVIEW数据查询语言（Data Query Language）用于从数据库中检索数据。 Sequence Of DQL 编写顺序： SELECT-&gt;FROM-&gt;WHERE-&gt;GROUP BY-&gt;HAVING-&gt;ORDER BY-&gt;LIMIT&gt;执行顺序： FROM-&gt;WHERE-&gt;GROUP BY-&gt;HAVING-&gt;SELECT-&gt;ORDER BY-&gt;LIMIT 练习Example 1234567891011-- table name: emp-- 1.查询年龄为20，21，22，23的女性员工信息SELECT * FROM emp WHERE gender='女' &amp;&amp; age IN (20,21,22,23);-- 2.查询性别为男，并且年属于[20,40]，名字为3个字的员工。SELECT * FROM emp WHERE gender='男' &amp;&amp; age BETWEEN 20 AND 40 &amp;&amp; name LIKE '___';-- 3.查询年龄小于60岁的男员工人数和女员工人数SELECT gender,count(*) FROM emp GROUP BY gender-- 4.查询所有年小于等于 35 员工的姓名和年龄，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序SELECT name,age,entrydate FROM emp WHERE age &lt;= 35 ORDER BY age ASC,entrydate DESC;-- 5.查询性别为男，且年龄属于[20,40]的前5个员工，并对查询结果按年龄升序排序，如果年龄相同按入职时间降序排序SELECT name,age,entrydate FROM emp WHERE gender='男' &amp;&amp; age BETWEEN 20 AND 40 ORDER BY age ASC,entrydate DESC LIMIT 5; 基础查询12345678910111213table: student+-----+-------+-----------+------+| Sid | Sname | Sage | Ssex |+-----+-------+-----------+------+| 01 | 赵雷 | 1/1/1990 | 男 || 02 | 钱电 | 21/12/1990| 男 || 03 | 孙风 | 20/5/1990 | 男 || 04 | 李云 | 6/8/1990 | 男 || 05 | 周梅 | 1/12/1991 | 女 || 06 | 吴兰 | 1/3/1992 | 女 || 07 | 郑竹 | 1/7/1989 | 女 || 08 | 王菊 | 20/1/1990 | 女 |+-----+-------+-----------+------+ Basic Syntax 查询指定字段SELECT field1, field2, ... FROM table_name; 查询所有字段SELECT * FROM table_name; 指定条件查询SELECT field1, field2, ... FROM table_name WHERE condition; 查询结果去重SELECT DISTINCT field1, field2, ... FROM table_name; Condition SyntaxList of Comparison Operators =, !=,&lt;&gt;, &lt; &lt;=, &gt;, &gt;= 🪧Note:&lt;&gt; is the same as != BETWEEN ... AND ... IN(...) LIKE 🪧Note:pattern matching,placeholders:%,_ IS NULL,IS NOT NULL List of Logical Operators AND,&amp;&amp;,OR,||,NOT,! 12345678910111213141516SELECT * FROM student; -- 查询表中所有field数据SELECT id,name FROM student; -- 查询表中指定field的数据SELECT * FROM student WHERE id = 1 &amp;&amp; age &lt;=30; -- &amp;&amp; 可以用 AND 代替SELECT * FROM student WHERE id = 1 || age &lt;=30; -- || 可以用 OR 代替SELECT * FROM student WHERE Sid BETWEEN 01 AND 20; -- BETWEEN 用于范围查询[01,20]SELECT * FROM student WHERE Sid IN (01,02,03); -- IN 用于范围查询SELECT DISTINCT Ssex FROM student; -- DISTINCT 用于去重SELECT * FROM student WHERE enligh IS NOT NULL; -- IS NULL 用于判断是否为空-- =================================-- * LIKE *-- =================================SELECT * FROM student WHERE Sname LIKE '赵%'; -- % 多个任意字符SELECT * FROM student WHERE Sname LIKE '赵_'; -- _ 单个任意字符SELECT * FROM student WHERE Sname LIKE '赵__'; -- __ 两个任意字符SELECT * FROM student WHERE Sname LIKE '%子%'; -- Sname中包含子的record Examples 123456789101112131415161718-- example 1SELECT Sid,Sname FROM student WHERE Ssex='男';+-----+-------+| Sid | Sname |+-----+-------+| 01 | 赵雷 || 02 | 钱电 || 03 | 孙风 || 04 | 李云 |+-----+-------+-- example 2SELECT DISTINCT Ssex FROM student;+------+| Ssex |+------+| 男 || 女 |+------+ 聚合函数聚合函数（Aggregate Functions）用于计算表中列的值(如果为 NULL，则不参与计算)，返回一个单一的值。常用的聚合函数有： AVG()：返回某列的平均值 COUNT()：返回某列的行数 MAX()：返回某列的最大值 MIN()：返回某列的最小值 SUM()：返回某列值之和 COUNT(*) 表示计算所有行的数量，包括 NULL 值COUNT(field) 表示计算指定列的行数，不包括 NULL 值COUNT(DISTINCT field) 表示计算指定列的不同值的数量，不包括 NULL 值[database02#AggregateFunction]-&gt;See more Examples 123456789101112131415161718SELECT count(Sid) FROM student;+------------+| count(Sid) |+------------+| 8 |+------------+SELECT avg(Sage) FROM student;+---------------+| avg(Sage) |+---------------+| 19903121.3750 |+---------------+SELECT avg(Sage) FROM student WHERE Ssex='男';+---------------+| avg(Sage) |+---------------+| 19900662.0000 |+---------------+ 分组查询分组查询（Group By）用于结合聚合函数，根据一个或多个列对结果集进行分组。 Syntax:SELECT field1, field2, ... FROM table_name GROUP BY field1, field2, ... HAVE condition; Difference between WHERE and HAVING 执行时机不同：WHERE 在数据分组前的 record 进行过滤，HAVING 在数据分组后的 record 进行过滤执行顺序：where -&gt; aggregate -&gt; having 可选参数不同：WHERE 后面只能跟条件表达式，HAVING 后面可以跟条件表达式和聚合函数 WHERE is used to filter records before any groupings take place.HAVING is used to filter values after they have been grouped. Examples 12345678910111213141516171819202122232425262728293031-- 查询男女生的max/min age;SELECT Ssex,max(Sage),min(Sage) FROM student GROUP BY Ssex;+------+------------+------------+| Ssex | max(Sage) | min(Sage) |+------+------------+------------+| 男 | 1990-12-21 | 1990-01-01 || 女 | 1992-03-01 | 1989-07-01 |+------+------------+------------+-- 查询Sid&gt;2的男女生的max/min ageSELECT Ssex,max(Sage),min(Sage) from student WHERE Sid&gt;2 GROUP BY Ssex;+------+------------+------------+| Ssex | max(Sage) | min(Sage) |+------+------------+------------+| 男 | 1990-08-06 | 1990-05-20 || 女 | 1992-03-01 | 1989-07-01 |+------+------------+------------+-- 查询男女生的max/min age，分组结果只显示为Ssex=男的recordSELECT Ssex,max(Sage),min(Sage) from student GROUP BY Ssex HAVING Ssex='男';+------+------------+------------+| Ssex | max(Sage) | min(Sage) |+------+------------+------------+| 男 | 1990-12-21 | 1990-01-01 |+------+------------+------------+-- 查询年龄 &lt; 45 的employee，并根据workaddress分组，显示分组结果中address_count&gt;3的分组SELECT workaddress,count(*) AS address_count FROM employee WHERE age &lt; 45 GROUP BY workaddress HAVING address_count&gt;3;+--------------+----------------+| workaddress | address_count |+--------------+----------------+| Beijing | 4 || Shanghai | 5 |+--------------+----------------+ 排序查询Syntax SELECT field1, field2, ... FROM table_name ORDER BY field1 [ASC|DESC], field2 [ASC|DESC], ...; ASC: ascending order 升序 DESC: descending order 降序 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件 123456789101112131415SELECT * FROM student ORDER BY Sage ASC;+-----+-------+------------+------+| Sid | Sname | Sage | Ssex |+-----+-------+------------+------+| 07 | 郑竹 | 1989-07-01 | 女 || 01 | 赵雷 | 1990-01-01 | 男 || 08 | 王菊 | 1990-01-20 | 女 || 03 | 孙风 | 1990-05-20 | 男 || 04 | 李云 | 1990-08-06 | 男 || 02 | 钱电 | 1990-12-21 | 男 || 05 | 周梅 | 1991-12-01 | 女 || 06 | 吴兰 | 1992-03-01 | 女 |+-----+-------+------------+------+-- 按照age升序排序，如果age相同，则再按照entrydate降序排序SELECT * FROM emp ORDER BY age ASC,entrydate DESC; 分页查询Syntax SELECT field1, field2, ... FROM table_name LIMIT offset, count;offset表示偏移量，count表示查询的记录数offset = (pageNo - 1) * pageSize分页查询属于 MySQL 的扩展语法，不是 SQL 标准语法，不同的数据库有不同的实现方式 12345678910111213141516171819202122232425262728SELECT * FROM student LIMIT 0,3; -- 第1页SELECT * FROM student LIMIT 3,3; -- 第2页SELECT * FROM student LIMIT 6,2; -- 第3页+-----+-------+------------+------+| Sid | Sname | Sage | Ssex |+-----+-------+------------+------+| 01 | 赵雷 | 1990-01-01 | 男 || 02 | 钱电 | 1990-12-21 | 男 || 03 | 孙风 | 1990-05-20 | 男 |+-----+-------+------------+------+3 rows in set (0.27 sec)+-----+-------+------------+------+| Sid | Sname | Sage | Ssex |+-----+-------+------------+------+| 04 | 李云 | 1990-08-06 | 男 || 05 | 周梅 | 1991-12-01 | 女 || 06 | 吴兰 | 1992-03-01 | 女 |+-----+-------+------------+------+3 rows in set (0.23 sec)+-----+-------+------------+------+| Sid | Sname | Sage | Ssex |+-----+-------+------------+------+| 07 | 郑竹 | 1989-07-01 | 女 || 08 | 王菊 | 1990-01-20 | 女 |+-----+-------+------------+------+2 rows in set (0.22 sec) DCL用户管理CREATE用于创建一个新的用户，并设置其密码ALTER用于修改一个已存在的用户的密码DROP用于删除一个已存在的用户 %：表示用户可以从任何主机连接到数据库 localhost：表示用户只能从本地主机连接到数据库 192.168.1.1：表示用户只能从指定的 IP 地址连接到数据库 %.example.com：表示用户可以从 example.com 域名下的任何主机连接到数据库 1234CREATE USER 'Jason'@'xxx.xxx.x.x' IDENTIFIED BY 'password'; -- 可从指定主机连接到数据库CREATE USER 'Jason'@'%' IDENTIFIED BY 'JasonPassword'; -- 可从任何主机连接到数据库ALTER USER 'Jason'@'%' IDENTIFIED BY 'NewJasonPassword';DROP USER 'username'@'host'; 权限管理GRANT：用于授予用户数据库的访问权限REVOKE：用于撤销用户的数据库访问权限。例如： 1234-- 授予 user 在 database.table 上执行 SELECT，INSERT 和 DELETE 操作的权限。GRANT SELECT, INSERT, DELETE ON database.table TO 'user'@'host';-- 撤销了 user 在 database.table 上执行 INSERT 和 DELETE 操作的权限。REVOKE INSERT, DELETE ON database.table FROM 'user'@'host'; 常用权限 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表","link":"/Tech/DataBase/DataBase01/"},{"title":"DataBase Base 多表查询&amp;事务","text":"多表查询多表关系项目开发中,在进行数据库表结构设计时,会根据业务需求及业务模块之间的关系,分析并设计表结构,由于业务之间相互关联所以各个表结构之间也存在着各种联系,基本上分为三种：一对一如用户与用户详情的关系多用于单表拆分,将一张表的基础字段和扩展字段分开存储,减少数据冗余,提高数据库性能.可在任意一方添加外键关联另一方的主键,并且外键字段设置UNIQUE约束.一对多(多对一)如一个部门对应多个员工,一个员工只能对应一个部门.这种关系一般是通过在多的一方添加外键来实现的.(员工表中设置部门id作为外键,指向部门表中的主键)多对多如一个学生可以选择多个课程,一个课程也可以被多个学生选择.这种关系一般是通过添加第三张表来实现的.(学生表,课程表,学生课程表),中间表中设置学生id和课程id作为外键,指向学生表和课程表的主键. 多表查询概述合并查询(笛卡尔积,显示所有组合结果,不常用)SELECT * FROM table1,table2;消除无效组合(内连接,常用)SELECT * FROM employee, department WHERE employee.dept_id = department.id; 内连接查询内连接查询的是两张表交集的部分 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;显式内连接(性能较高)SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 1234-- 查询员工姓名,以及对应的部门名称-- 隐式SELECT e.name, d.name FROM employee as e,dept as d WHERE e.dept_id = d.id;-- 显式 事务","link":"/Tech/DataBase/DataBase03/"},{"title":"DataBase Base_函数&amp;约束","text":"函数AggregateFunctionOverview An SQL aggregate function calculates on a set of values and returns a single valueBecause an aggregate function operates on a set of values, it is often used with the GROUP BY clause of the SELECT statement. The GROUP BY clause divides the result set into groups of values and the aggregate function returns a single value for each group.SQL Tutorial The following are the commonly used SQL aggregate functions: AVG() – returns the average of a set COUNT() – returns the number of items in a set COUNT(*) – returns the number of items in a set (including NULL values) MAX() – returns the maximum value in a set MIN() – returns the minimum value in a set SUM() – returns the sum of all or distinct values in a set Except for the COUNT() function, SQL aggregate functions ignore null. You can use aggregate functions as expressions only in the following: The select list of a SELECT statement, either a subquery or an outer query. A HAVING clause StringFunctionFunctions that allow you to manipulate string data more effectively. CONCAT(s1,s2,...,sn) – return the result of concatenation two strings together. LOWER(str),UPPER(str) – converts a string to lower case or upper case. LPAD(str,n,padstr),RPAD(str,n,padstr) – left/right pads a string with another string to a certain length. TRIM(str),LTRIM(str),RTRIM(str) – removes all spaces from a string or from the left or right side of a string. REPLACE(str,source,replace) – replaces all occurrences of a substring within a string with another substring. SUBSTRING(str,pos,len) – returns a substring from a string starting at a specified position with a specified length.Reference: 123456789101112131415161718192021222324252627282930313233343536SELECT CONCAT('SQL',' is',' fun!');+-------------------------+| CONCAT(&quot;HELLO&quot;,&quot;WORLD&quot;) |+-------------------------+| HELLOWORLD |+-------------------------+SELECT LOWER(&quot;Hello,World&quot;);+----------------------+| LOWER(&quot;Hello,World&quot;) |+----------------------+| hello,world |+----------------------+SELECT RPAD(&quot;1&quot;,5,&quot;Z&quot;);+-----------------+| RPAD(&quot;1&quot;,5,&quot;Z&quot;) |+-----------------+| 1ZZZZ |+-----------------+SELECT RTRIM(&quot; HELLO &quot;);+---------------------+| RTRIM(&quot; HELLO &quot;) |+---------------------+| HELLO |+---------------------+SELECT REPLACE(&quot;Hello,World&quot;,&quot;World&quot;,&quot;SQL&quot;);+--------------------------------------+| REPLACE(&quot;Hello,World&quot;,&quot;World&quot;,&quot;SQL&quot;) |+--------------------------------------+| Hello,SQL |+--------------------------------------+SELECT SUBSTRING(&quot;Hello,World&quot;,1,5);+------------------------------+| SUBSTRING(&quot;Hello,World&quot;,1,5) |+------------------------------+| Hello |+------------------------------+ Math FunctionsSQL has many mathematical functions that allow you to perform business and engineering calculations. ABS(x) – returns the absolute value of x. CEIL(x) – returns the smallest integer that is greater than or equal to x. FLOOR(x) – returns the largest integer that is less than or equal to x. RAND() – returns a random floating-point value. MOD(x,y) – returns the remainder(modulo) of x divided by y, MOD(10,7) returns 3. e.g. ROUND(x,d) – returns a number rounded to d decimal places. ROUND(2.6666,3) returns 2.667 e.g. Exercise 1234567-- randomly generate 6 digitsSELECT SUBSTRING(ROUND(RAND(),6),3,6);+--------------------------------+| SUBSTRING(ROUND(RAND(),6),3,6) |+--------------------------------+| 578207 |+--------------------------------+ Date Functions123456789101112131415161718192021222324252627SELECT CURDATE(); -- YYYY-MM-DDSELECT CURTIME(); -- HH:MM:SSSELECT NOW(); -- YYYY-MM-DD HH:MM:SSYEAR(date); MONTH(date); DAY(date);SELECT YEAR(&quot;2023-1-2&quot;);+------------------+| YEAR(&quot;2023-1-2&quot;) |+------------------+| 2023 |+------------------+DATEADD(date,INTERVAL expr type);DATEDIFF(date1,date2); -- date1 - date2SELECT DATE_ADD(now(),INTERVAL 70 DAY);+---------------------------------+| DATE_ADD(now(),INTERVAL 70 DAY) |+---------------------------------+| 2024-04-06 20:09:20 |+---------------------------------+SELECT DATEDIFF(now(),&quot;2023-1-20&quot;);+-----------------------------+| DATEDIFF(now(),&quot;2023-1-20&quot;) |+-----------------------------+| 372 |+-----------------------------+ Exercises 12-- 查询每个员工的入职天数，并按照入职天数降序排列SELECT Name,DATEDIFF(now(),entrydate) AS days FROM emp ORDER BY days DESC; Control Flow Functions12345678-- if value is true, return if_true_expr, else return if_false_exprIF(value,if_true_expr,if_false_expr)-- if expr1 IS NULL, return expr2, else return expr1IFNULL(expr1,expr2)-- condition1为真，返回result1，condition2为真，返回result2，否则返回resultCASE WHEN &lt;condition1&gt; THEN &lt;result1&gt; WHEN &lt;condition2&gt; THEN &lt;result2&gt; ELSE &lt;result&gt; END-- expr = value1, return result1, expr = value2, return result2, else return resultCASE &lt;expr&gt; WHEN value1 THEN result1 WHEN value2 THEN result2 ELSE result END Exercises 123456789101112-- 查询emp表的员工的name,addr,如果addr为Beijing/Shanghai,则显示为一线城市，否则显示为二线城市SELECT name, (CASE addr WHEN 'Beijing' THEN '一线城市' WHEN &quot;Shanghai&quot; THEN &quot;一线城市&quot; ELSE '二线城市' END) AS addrTagFROM emp;-- 查询学生成绩表，如果成绩大于等于60，显示及格，否则显示不及格SELECT name. (CASE WHEN score &gt;= 60 THEN '及格' ELSE '不及格' END AS) math, (CASE WHEN english &gt;= 60 THEN '及格' ELSE '不及格' END AS) english,FROM score; 约束Overview概念: 约束是作用于表中字段上的规则,用于限制存储在表中的数据(类型、格式和范围等等)目的: 保证数据的正确性、有效性和完整性分类: 约束 描述 关键字 非空约束 限制该字段的数据不能为 null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1 版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY Example [DataBase01#DML] Review DML Syntax 123456CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, name VARCHAR(10) NOT NULL UNIQUE, age TINYINT UNSIGNED CHECK(age&gt;0 AND age&lt;120), gender ENUM('男','女','保密') DEFAULT '保密'); 外键约束概念 : 外键是表中的一个字段，它指向另一个表的主键，用来建立两张表之间的联系，保证数据的一致性和完整性 语法 : FOREIGN KEY (&lt;foreignKey&gt;) REFERENCES &lt;tableName&gt;(&lt;primaryKey&gt;) Example 12345678910111213141516171819-- 创建了两张表，Company表(主表,父表)中的Id字段是主键，Department表(子表,从表)中的depa_id字段是外键，指向Company表中的Id字CREATE TABLE Company ( Id int NOT NULL, name varchar(20) NOT NULL, PRIMARY KEY (Id));CREATE TABLE Department ( id int NOT NULL, name varchar(20) NOT NULL, salary decimal(10,2), depa_id int, PRIMARY KEY (id), FOREIGN KEY (depa_id) REFERENCES Company(Id));-- 添加外键约束ALTER TABLE Department ADD CONSTRAINT fk_depa_id FOREIGN KEY (depa_id) REFERENCES Company(Id);-- 删除外键约束ALTER TABLE Department DROP FOREIGN KEY fk_depa_id; 删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 设置删除/更新行为的语法：ON DELETE/UPDATE &lt;action&gt;例如 ALTER TABLE Department ADD CONSTRAINT fk_depa_id FOREIGN KEY (depa_id) REFERENCES Company(Id) ON DELETE CASCADE ON UPDATE CASCADE;","link":"/Tech/DataBase/DataBase02/"},{"title":"Glossary Of SQL","text":"Basic Structure of SQL Server syntaxIntro Generally speaking, the real difference between statements, clauses, batches, etc., is determined by how you use them at the time.The Difference Between SQL Statement,Command, Clause, Batch, etc by Aubrey Love 🪧Note:日常工作中,这些术语的使用并不是很严格,不必纠结于此.但是了解这些术语的含义,帮助我们在阅读文档时更加准确的理解文档的含义. 个人对此的简单总结如下: Statement：语句.是一条完整的 SQL 语句，可以是单行，也可以是多行。例如，SELECT * FROM Users; 就是一个 SQL 语句。通常用分号 ; 结尾。 Command：命令.通常指对数据库或数据库对象执行的操作。例如，CREATE, DROP, SELECT, INSERT, UPDATE, DELETE 等都是 SQL 命令。 Batch：批处理.这是一组 SQL 语句，它们作为一个单元一起发送到 SQL 服务器以便一起执行。在大多数 SQL 服务器中，批处理由一个或多个 SQL 语句组成，这些语句由分号 ; 分隔。 Clause：子句.这是 SQL 语句的一部分，它用于指定 SQL 语句的某些条件或修改 SQL 语句的行为。例如，WHERE, AND, OR, NOT, FROM, ORDER BY 等都是 SQL 子句。 Query : 查询.在 SQL 中，Query 是一个请求，用于从数据库中获取特定的数据。最常见的查询是 SELECT 语句，它用于从一个或多个表中选择数据。 SQL StatementSQL Server “statements” are the most basic unit of code that can be executed in SQL Server.A statement is typically a single line of code, although multiple lines may be combined into a single statement. You can also use a semicolon (;) as a batch terminator that separates one command statement or batch from another. SQL CommandCommands are often referred to as a STATEMENT or QUERY. However, a SQL command is any instruction set that directs SQL Server to perform an action against a given SQL Server object. DDL (Data Definition Language) DML (Data Manipulation Language) DCL (Data Control Language) TCL (Transaction Control Language) ps: 有时把DML中的 SELECT 单独拿出来，称为 DQL(Data Query Language) DDL DML DCL TCL CREATE SELECT GRANT COMMIT ALTER INSERT REVOKE ROLLBACK DROP UPDATE SAVEPOINT TRUNCATE DELETE SET TRANSACTION COMMENT MERGE RENAME CALL EXPLAIN PLAN LOCK TABLE SQL BatchA SQL Server “batch” is a single or multi-line block of code that tells the SQL Server what action to take on a SQL Server object. Batches are typically separated by the “GO” statement at the end of a SQL query; 12345678USE AdventureWorks2019;GOSELECT \\*FROM HumanResources.Department;GOSELECT \\*FROM HumanResources.Employee;GO SQL QueryThe “query” keyword in SQL Server is used to perform an action against a database or database object. SQL ClauseA SQL Server “clause” is a code element that defines a particular action. Clauses are typically used to control the flow of a query or Transact-SQL program. The most common clauses are the FROM, WHERE, and ORDER BY clauses. The SELECT clause is used to specify the columns or expressions that will be returned by a query. DataBase GlossaryDatabase,Schema：数据库，一个库可以有多个表Table,Relation：表（Table）是数据库中存储数据的主要结构，它由行（记录）和列（字段）组成.表的结构通常由字段名和字段类型定义Row,Record,Item,Tuple：行，一行可以有很多列；Column,Field，列，不再细分的具体值 References⭐www.mssqltips.comwww.databasestar.comdev.mysql.com","link":"/Tech/DataBase/Glossary%20Of%20SQL/"},{"title":"PicGo-Github配置图床(Typora&amp;VSCode)","text":"Intro什么是图床图床，也被称为图像托管服务（Image Hosting Service），是一种在线服务，它提供了一个方便的方式来存储和分享图片。用户可以上传图片到图床，然后图床会生成一个可以在网页、论坛、博客或其他地方使用的链接，以便他人可以查看或下载这些图片。 图床服务通常提供一定的免费存储空间，但可能会对图片的大小、格式或数量有限制。一些图床还提供额外的付费服务，如更大的存储空间、更高的带宽或更多的功能。 优缺点 节省存储空间：图床服务可以帮助你节省本地或服务器的存储空间，因为图片是存储在图床服务的服务器上的。 易于分享：图床服务通常会为上传的图片提供一个 URL 链接，你可以将这个链接分享给他人，或者在网站、博客、论坛等地方使用，让他人可以轻松地查看或下载图片。 易于管理：许多图床服务提供了用户友好的界面和工具，使得上传、管理和分享图片变得非常简单 虽然图床服务有许多优势，但也有一些潜在的缺点，如可能的隐私问题、服务商可能会关闭或更改服务条款、以及对免费用户的存储空间或带宽的限制等。 StepsGithub Repo 新建 Repo，可见性设置为 Public Gen GitHub Token,在Personal access tokens 中可选 Fine-grained tokens 或 Tokens(classic)，前者对权限有更细致的划分。 PicGo 下载源 地址/安装方式 GitHub Release https://github.com/Molunerfinn/PicGo/releases 腾讯云 COS https://github.com/Molunerfinn/PicGo/releases 山东大学镜像站 https://mirrors.sdu.edu.cn/github-release/Molunerfinn_PicGo 在图床设置中进行如下配置 自定义域名可设置为https://cdn.jsdelivr.net/gh/your-repo-name@master Typora语言设置为中文 偏好-图形，进行如下设置 VSCode下载 PicGo 插件，Ctrl+Shift+P - Preferences: Open User Settings (JSON)，添加如下配置 默认快捷键如下","link":"/Tech/FrontEnd/imageBed/"},{"title":"Hashtable如何插入键值对?","text":"Intro如果你已了解 HashTable 相关的基本概念, 可以跳过本节.Next Part Hashtable 是一种数据结构, 用于存储键值对, 通过 key 来计算 index, 从而快速查找 value. 它以数组+链表或者数组+红黑树的形式来存储数据（在 Java 8 之后，当链表的长度超过一定阈值时，链表会转换为红黑树以提高性能）, 通过 key 的 hashcode 来计算 index, 从而快速查找 value. 名词解释 Buckets HashTable 内部有一个数组(Buckets),存放多个 Bucket，每个元素（也称为 bucket）存储键值对组（Key-Value Pairs）,每个 Bucket 中存放着所有 HashKey 相同的(Key, Value);ps:hash bucket 是一个概念,在 JDK 中其数据结构可为链表或者红黑树.引入 bucket 的目的是为了解决 hash 冲突. Hash collision 哈希冲突/哈希碰撞,指不同的 key 通过哈希函数计算出相同的 index,这种情况称为哈希冲突。 hashCode() 哈希函数,它接受一个键作为输入，并返回一个整数，该整数用作在数组中存储键值对的索引。设计哈希函数时,应使得哈希函数尽可能地均匀地分布,尽量让不同的 key 得到不同的 hashCode。 Key-Value Pair 这是存储在 HashTable 中的数据。每个键都是唯一的，并映射到一个值。 index 索引.本文中指 通过 key 的 hashcode 计算出来的 index(index 应该小于 buckets 的长度), 用于定位 key-value pair 所在的 bucket 插入键值对流程计算 index 在 Java 中，Object 类提供了一个方法 hashCode()，它返回对象的哈希码值。帮助确定对象应该存储在哈希表的哪个位置。 hashCode() 的具体实现取决于对象的类。例如，对于 String 类，hashCode() 方法计算字符串中每个字符的哈希码值，并将它们组合在一起。 请注意，Objects 规范中,如果两个对象相等（根据 equals(Object) 方法），那么它们的哈希码值必须相同。但是，两个对象的哈希码值相同时，两个对象不一定相等。这是因为可能存在哈希冲突，即两个不同的对象具有相同的哈希码值。 在哈希表中，我们首先需要通过 hashCode() 方法获取对象的哈希码，然后再通过取余操作将哈希码映射到哈希表的大小范围(即 bucketsLen)内。取余对 HashCollision 的影响 JDK 源码中,取余操作的实现为: 123static int indexFor(int h, int length) { return h &amp; (length-1);} 原理见Hashtable 快速取模方案 解决 HashCollision插入键值对时,如果发生 index 相同,意味着发生了哈希冲突 冲突解决的方法有很多种，常见的有链地址法(每个 bucket 存储一个链表，新的键值对被添加到链表的末尾)和开放地址法(如果一个 bucket 被占用，HashTable 会寻找下一个可用的 bucket)。 JDK 中的 HashTable 使用的是链地址法,即每个 bucket 存储一个链表，新的键值对被添加到链表的末尾。JDK 1.8 之后,当链表的长度超过一定阈值时，链表会转换为红黑树以提高性能。 补充取余对 HashCollision 的影响基本概念 被除数 ÷ 除数 = 商 ... 余数 被除数 mod|% 除数 = 余数 除数&gt;被除数,余数=被除数 被除数: dividend 除数: divisor 商: quotient 余数: remainder 素数/质数: prime number, 除了 1 和它本身以外不再有其他的因数 因子: factor, 一个数的因子是能够整除它的数,例如 2 是 4 的因子,因为 4/2=2 合数: composite number, 除了 1 和它本身以外还有其他的因数 在哈希函数中，取余操作通常用于将大范围的哈希值映射到一个较小的范围,取余操作的结果是哈希值的分布可能会发生变化，这可能会影响哈希碰撞的频率。 给定数列作为 keys, 以及模数(被除数) n 作为 buckets 长度, 通过取余操作, 可以将数列的值映射到[0, n)的范围内。$$a_n = 1+n*step, n \\in N$$ 取余操作可能会影响哈希碰撞的频率。除数选取素数可以减少哈希碰撞的频率。 ​ 如果 step 是 n 的因子,那么就容易发生哈希碰撞,哈希碰撞的间隔即为 step 的值。例如,n = 6, step = 2, 那么哈希碰撞的间隔为 2, 即 index = 1, 3, 5 处会发生哈希碰撞.见代码示例 123step = 2, n = 6;array: 1, 3, 5, 7, 9,11,13,15,17,19,21,23,25,27,29,31index: 1, 3, 5, 1, 3, 5, 1, 3, 5, 1, 3, 5, 1, 3, 5, 1 数列的冲突分布间隔为因子大小，对于同样的随机数列，n 的因子越多，发生冲突的可能性就越大.故而，我们应该尽量避免因子过多的情况,如果情况允许,尽量选择素数作为除数。 Hashtable 快速取模方案证明对于二进制的位运算，整除 8(2 的三次方) 等价于右移三位 \\(0110 0100 &gt;&gt; 3 = (0000 1100)_2 = 12\\) 即为商 而01100100的后三位\\((100)_2 = 4\\)即为余数 已知\\(n = 2^m\\)，商为hash二进制数右移 m 位，而余数为hash的后 m 位 要求hash % n，即求hash的后 m 位，而n-1的二进制表示恰为 m 个 1，可推得hash &amp; (n-1)等与hash % n $$ \\begin{align} \\nonumber & 2 = (10)_2 \\quad 2 -1 = (1)_2 \\\\ & 4 = (100)_2 \\quad 4 -1 = (11)_2 \\\\ & 8 = (1000)_2 \\quad 8 - 1 = (111)_2 \\\\ & ...... \\\\ &归纳得到:\\\\ & 2^m = (1000...0)_2 最高位为1，其后有m个零\\\\ & 2^m-1 = (111..1)_2 共有m个1 \\end{align} $$ 例题验证 (n-1) &amp; hash，不妨设hash = 45367，二进制为 0100 1010 1111 0111，求hash % 8 45367 % 8 = 45367 &amp; 7 $$ \\begin{align} &8 = (1000)_2 \\quad7 = (111)_2 \\quad hash = \\ (0100\\ 1010\\ 1111\\ 0111)_2 \\\\ &45367 \\ \\%\\ 8 = 7 \\\\ &(0100 1010 1111 0111)_2 \\ \\&\\ (0000\\ 0000\\ 0000\\ \\ 0111)_2 = (111)_2 = 7 \\end{align} $$ 为什么 java 中哈希表的大小是 2 的幂次方?代码验证在 JDK 中,Hashtable求模的方式为 hash &amp; (n-1),这种方式的前提是 n 为 2 的幂次方,其他情况下未必成立. 1234567891011121314public class HashTable { public static void main(String[] args) { int bucketsLen = new Scanner(System.in).nextInt(); int hashCode = new String(&quot;Hello&quot;).hashCode(); System.out.println(&quot;hashCode = &quot; + hashCode); int index = hashCode &amp; (bucketsLen - 1); System.out.println(&quot;index = &quot; + index); index = hashCode % bucketsLen; System.out.println(&quot;index = &quot; + index); String isEqual = (hashCode % bucketsLen) == (hashCode &amp; (bucketsLen - 1)) ? &quot;true&quot; : &quot;false&quot;; System.out.println(&quot;hashCode % bucketLen == hashCode &amp; (bucketsLen - 1) is &quot; + isEqual); }} 123456789101112[INPUT = 16][OUTPUT]hashCode = 69609650index = 2index = 2hashCode % 16 == hashCode &amp; (bucketsLen - 1) is true----------------------------------------[INPUT = 47]hashCode = 69609650index = 34index = 18hashCode % bucketLen == hashCode &amp; (bucketsLen - 1) is false hashMap 中的哈希函数 hash &amp; (n - 1) 跟取余运算 hash % n 结果是一致的。极端情况下，如果 hashMap 中存了几千万的数据。当某次插入数据引发扩容时，需要重新计算下标值，此时用位运算可以提高性能；平常代码中使用，对于代码性能提升优化微乎其微，且会影响代码可读性 References算法分析：哈希表的大小为何是素数哈希函数除数的选取为什么是质数？哈希冲突解决方法,闭散列&amp;开散列","link":"/Tech/Java/hashTable/"},{"title":"Java Evaluation Strategy","text":"基础概念Parameter: 形式参数,是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。Argument: 实际参数,在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”Pass By Value: 值传递,是指在调用函数时将实际参数复制一份传递到函数中,这样在函数中如果对参数进行修改,将不会影响到实际参数。 In Pass by value, the function is called by directly passing the value of the variable as an argument. So any changes made inside the function do not affect the original value. In Pass by value, parameters passed as arguments create their own copy. So any changes made inside the function are made to the copied value not to the original value Pass by Reference: 引用传递,是指在调用函数时将实际参数的地址直接传递到函数中,那么在函数中对参数所进行的修改,将影响到实际参数。 In Pass by Reference, Function is called by directly passing the reference/address of the variable as an argument. So changing the value inside the function also change the original value. In JavaScript array and Object follows pass by reference property. In Pass by reference, parameters passed as an arguments does not create its own copy, it refers to the original value so changes made inside function affect the original value. Call by value和call by reference的重要区别在于，call by value是将实际参数的副本传递给函数，而call by reference是将实际参数的地址传递给函数。在call by value中，函数对参数的修改不会影响到实际参数，而在call by reference中，函数对参数的修改会影响到实际参数。 在计算机科学中，求值策略（英语：Evaluation strategy）是确定编程语言中表达式的求值的一组（通常确定性的）规则。重点典型的位于函数或算子上——求值策略定义何时和以何种次序求值给函数的实际参数，什么时候把它们代换入函数，和代换以何种形式发生。经常使用用来研究函数的形式系统λ演算来建模求值策略，这里它们通常叫做归约策略。求值策略分为两大基本类，严格的和非严格的，基于如何处理给函数的实际参数from wikipedia Java中的参数传递那么为什么在Java中只有call by value呢？ 这主要是因为Java中的所有参数传递都是通过值传递的。在Java中，对象引用作为参数传递时，实际上是将对象在堆(heap)中地址值的copy传递给函数，而不是对象本身。基本类型的参数传递也是如此，传递的是基本类型字面量值的copy 123456789101112131415161718192021222324252627public class Test { public static void main(String[] args) { int x = 10; changePrimitive(x); System.out.println(x); // 输出 10，因为 x 的值没有被改变 Integer y = new Integer(10); changeReference(y);// num 是 y 的copy System.out.println(y); // 输出 10 int[] z = {10}; changeArray(z);// num 为 z 的 copy System.out.println(z[0]); // 输出 20，因为 z[0] 的值被改变 } public static void changePrimitive(int num) { num = 20; } public static void changeReference(Integer num) { num = new Integer(20);//num本来指向y对象,现在指向另一个Integer对象,此后num和y没有任何关系. } public static void changeArray(int[] num) { num[0] = 20; }}","link":"/Tech/Java/java%E6%B1%82%E5%80%BC%E7%AD%96%E7%95%A5/"},{"title":"Base64 Encoding","text":"叠甲限于知识水平，文章中可能存在错误，欢迎指正。 What is Base64? Base64 is a binary-to-text encoding scheme. It represents binary data in a printable ASCII string format by translating it into a radix-64 representation.Base64 encoding is commonly used when there is a need to transmit binary data over media that do not correctly handle binary data and is designed to deal with textual data belonging to the 7-bit US-ASCII charset only.One example of such a system is Email (SMTP), which was traditionally designed to work with plain text data in the 7-bit US-ASCII character set. Although, It was later extended to support non US-ASCII text messages as well as non-text messages such as audio and images, It is still recommended to encode the data to ASCII charset for backward compatibility.What is Base64 Encoding and How does it work? Base64 用 6 个 bit 来表示一个字符，输入流中每 3 个 Bytes 由 4 个 Base64 字符表示12343 Bytes = 3 * 8 bits = 24 bits = 4 * 6 bitsBase64 Encoding算法会在4组6bit各自的头部添0：4 * 6 bit -&gt; 4 * 8 bits = 4 Bytes这即是Base64编码后数据长度增加1/3的原因 Base64 包含 64 个字符(26 个大写字母，26 个小写字母，10 个数字，2 个特殊字符+，/) Base64 常用于在 URL、Cookie、网页中传输少量二进制数据。 How does Base64 Encoding work?Base64 encoding works with a 65-character subset of the US-ASCII charset. The first 64 characters out of the 65-character subset are mapped to an equivalent 6-bit binary sequence \\(2^6 = 64\\). The extra 65th character (=) is used for padding. 1234567891011121314151617181920## The Base64 AlphabetValue Encoding Value Encoding Value Encoding Value Encoding 0 A 17 R 34 i 51 z 1 B 18 S 35 j 52 0 2 C 19 T 36 k 53 1 3 D 20 U 37 l 54 2 4 E 21 V 38 m 55 3 5 F 22 W 39 n 56 4 6 G 23 X 40 o 57 5 7 H 24 Y 41 p 58 6 8 I 25 Z 42 q 59 7 9 J 26 a 43 r 60 8 10 K 27 b 44 s 61 9 11 L 28 c 45 t 62 + 12 M 29 d 46 u 63 / 13 N 30 e 47 v 14 O 31 f 48 w (pad) = 15 P 32 g 49 x 16 Q 33 h 50 y Steps 以 6 bit 为单位将二进制数据分组，不足 6 个 bit 的在末尾补 0，得到 8 组二进制数据：以ASCII编码的字符串HelloWorld\\n为例，其二进制数据为：01001000 01100101 01101100 01101100 01101111 01010111 01101111 01110010 01101100 01100100 00001010分组后为：010010 000110 010101 101100 011011 000110 111101 010111 011011 110111 001001 101100 011001 000000 1010 将各组二进制转成十进制，根据映射关系得到 Base64 编码1218 6 21 44 27 6 61 23 27 55 9 44 25 0 40S G V s b G 9 X b 3 J s Z A o 将 Base64 编码拼接起来，最终结果应为 4 的倍数，不足则在末尾补=SGVs bG9X b3Js ZAO= Why Base64？在早期的互联网协议中，设计者们主要考虑的是发送文本数据，因此这些协议通常只能处理 ASCII 字符集中的字符。然而，二进制文件（如图片、音频、视频等）包含的数据通常超出了 ASCII 字符集的范围。如果直接发送这些二进制数据，可能有部分字节被解释为控制字符，例如换行符、回车符、制表符等。这些控制字符在传输过程中可能会被解释为其他含义，从而导致数据传输错误。 Base64 编码出现是为了就是解决在网络上发送二进制数据的问题。Base64 选取 US-ASCII 中的64 个可打印字符作为编码后的字符集，这样就可以保证数据在传输过程中不会被解释为控制字符，从而确保数据传输的安全和可靠。 不过，Base64 编码会导致数据膨胀，大约增加 1/3 的大小。 Base64’s ApplicationsBase64 的应用非常广泛，包括但不限于： 电子邮件：在 MIME（多用途互联网邮件扩展）协议中，Base64 用于编码电子邮件的附件，使其可以通过电子邮件系统发送。电子邮件系统主要设计用于处理文本，而不是二进制数据，因此需要将二进制附件（如图片或文档）转换为文本格式。 数据 URI：在网页中，可以使用 Base64 编码的数据 URI 来内嵌图片或其他资源。这样可以减少 HTTP 请求的数量，从而提高页面加载速度。数据 URI 的格式为 data:[&lt;mediatype&gt;][;base64],&lt;data&gt;，其中 是资源的 MIME 类型， 是 Base64 编码的资源数据。 URL 编码：在某些情况下，URL 可能需要包含二进制数据。由于 URL 只能包含 ASCII 字符，因此需要使用 Base64 编码来编码这些数据。标准的 Base64 编码在 URL 中有特殊含义的字符(+ 和 /)，于是 + 和 / 分别被替换为 - 和 _。 证书和密钥：在 SSL/TLS 和其他安全协议中，证书和密钥通常使用 Base64 编码，以便在文本格式的配置文件中使用。这样可以避免二进制数据在处理或传输过程中可能出现的问题。 编码用户凭据：在 HTTP 基本认证中，用户的用户名和密码会被拼接成一个字符串，然后使用 Base64 编码，最后将编码后的字符串放在 HTTP 头的 Authorization 字段中发送给服务器。","link":"/Tech/Others/Base64Encoding/"},{"title":"VSCode C_Cpp Debug","text":"Intro ​ 今天阅读Configure launch.json for C/C++ debugging in Visual Studio Code，初步完成 VSCode C/C++ debug 的配置，于是写下本文，旨在记录个人在 Windows/WSL 平台，VSCode 配置 C/C++的 Debug 环境过程，以供其他初学者参考。在此之前，你需要先安装 VSCode，配置好 WSL 环境以及 gcc 环境变量。文章介绍了launch.json和tasks.json中部分attribute的含义，并给出本人的配置供读者参考 Stepslaunch.json配置 debug 环境，首先要配置launch.json，launch.json是用来配置 VSCode 的 debug 环境的，它包含了一系列的调试配置，每个调试配置都是一个对象，包含了一系列的字段，用于定义如何启动和运行调试器。在 VSCode 中，你可以通过F5快捷键或者点击左侧的 debug 按钮进入 debug 模式，此时 VSCode 会自动寻找当前工作目录下的launch.json文件，如果没有找到，VSCode 会提示你创建一个launch.json文件，如果找到了，VSCode 会自动加载launch.json中的配置，然后根据配置启动调试器。 A launch.json file is used to configure the debugger in Visual Studio Code. Visual Studio Code generates a launch.json (under a .vscode folder in your project) with almost all of the required information. To get started with debugging you need to fill in the program field with the path to the executable you plan to debug. This must be specified for both the launch and attach (if you plan to attach to a running instance at any point) configurations. Launch.json Code个人配置如下，仅供参考 123456789101112131415161718192021{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;c/c++ gdb&quot;, &quot;type&quot;: &quot;lldb&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;args&quot;: [], &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;console&quot;: &quot;integratedTerminal&quot;, &quot;windows&quot;: { &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;, &quot;preLaunchTask&quot;: &quot;compile c file(Windows)&quot; }, &quot;linux&quot;: { &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot;, &quot;preLaunchTask&quot;: &quot;compile c file(Linux)&quot; } } ]} Attributes version：version of this file format不必修改 configurations：List of configurations.configuration 数组， 包含了你的调试配置。每个调试配置都是一个对象，包含了一系列的字段，用于定义如何启动和运行调试器 type：Type of configuration用于指定要使用的调试器类型。可选的值取决于你已经安装的调试器扩展。常见的 type 字段值有 node、java、lldb(主要用于调试c/cpp以及其他llvm支持的语言)、chrome(JavaScript,TypeScript)等等 name：Name of configuration; appears in the launch configuration dropdown menu.字面意思，此处的c/c++ gdb即为launch.json的name preLaunchTask：Task to run before debug session starts.在 debug 开始前执行的 task，例如编译你的代码，生成一个可执行文件(.exe, .out e.g.)，如果 task 失败，则不会启动 debug session。此处我们要配置 c/cpp 的 debug 环境，所以 preLaunchTask 设置为 build active file(名字任意)，与tasks.json中的 task 对象的 label 属性对应即可 program：Path to the program to debug.Specify debug program’s path。以 windows 平台为例，我们编写了 hello.c，要调试的程序即为filePath/hello.exe，我们可以用如下预定义变量简化 program Common pre-defined variables provided by VSCode for configuration files: ${workspaceFolder}: The path of the folder opened in VS Code. ${workspaceRootFolderName}: The name of the folder opened in VS Code without any slashes (/). ${file}: The current opened file. ${fileWorkspaceFolder}: The current opened file’s workspace folder. ${relativeFile}: The current opened file relative to workspaceFolder. ${relativeFileDirname}: The current opened file’s dirname relative to workspaceFolder. ${fileBasename}: The current opened file’s basename. ${fileBasenameNoExtension}: The current opened file’s basename with no file extension. ${fileDirname}: The current opened file’s dirname. ${fileExtname}: The current opened file’s extension. ${lineNumber}: The current selected line number in the active file. ${selectedText}: The current selected text in the active file. ${execPath}: The location of the VS Code executable. ${defaultBuildTask}: The name of the default build task. request：Indicates whether the configuration section is intended to launch the program or attach to an already running instance.一般选择 launch，前端 debug 可能会用到 attach console：Terminal type to use.取决个人喜好，可选参数如下 internalConsole：VSCode Panel 中的 TERMINAL integratedTerminal：VSCode Panel 中的 DEBUG CONSOLE externalTerminal：外部的集成终端 cwd：Program working directory.cwd 字段用于设置当前工作目录（Current Working Directory）。当你启动调试器时，这个目录将被用作程序的工作目录，一般配置为 &quot;cwd&quot;: &quot;${fileDirname}&quot; window/linux/osx：specific launch configuration attributes针对 Window,Linux/WSL,MacOS 平台单独设置的 attributes tasks.jsondebugger 正常工作，需要先编译你的代码，生成一个可执行文件(.exe, .out e.g.)，于是在preLaunch中我们定义了两个 task,用来编译 c 文件[tasks.json的使用]-&gt;See more Tasks.json Code123456789101112131415161718192021222324252627{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;compile c file(Windows)&quot;, &quot;command&quot;: &quot;gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; ] }, { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;compile c file(Linux)&quot;, &quot;command&quot;: &quot;gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot; ] } ]} Attribute tasks：The task configurations. Usually these are enrichments of task already defined in the external task runner.例如之前在launch.json定义的两个task 12345678&quot;windows&quot;: { &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;, &quot;preLaunchTask&quot;: &quot;build active file(Windows)&quot;},&quot;linux&quot;: { &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot;, &quot;preLaunchTask&quot;: &quot;build active file(Linux)&quot;} type：Defines whether the task is run as a process or as a command inside a shell.可选参数有 shell,progess。gcc 命令在 shell 中执行，此处选择 shell 即可 label：The task’s user interface label任务的名称，在launch.json通过 label specify tasks to run command：The command to be executed. Can be an external program or a shell command.此处选择 gcc 即可，也可选 clang 等 c/cpp 编译器 args：Arguments passed to the command when this task is invoked.命令的参数，例如-o，-g 等等 Outro​ 以经典的hello.c测试，能正常 debug。希望本文对你有帮助 🕊️","link":"/Tech/VSCode/DebugForC/"},{"title":"VSCode Keyboard Shortcuts","text":"Ⅰ. EditorGroups Shortcut Command Ctrl + 1/2 Focus first/second editor group Ctrl + M Maximize editor group Ctrl + W Close editor Alt + F4 Close windows Alt + A/D Open previous/next editor Ctrl + Shift + W/A/S/D View: split editor up/down/left/right 📨 PS: Ctrl + M When spliting, maximize the current editor group, press again to cancel Alt + A/D Open previous/next editor in the current editor group Ctrl + Shift + W/A/S/D Move the current editor group to the up/left/down/right Coding Shortcut Command Alt + Up/DownArrow Move line up/down Alt + Shift + Up/DownArrow Copy line up/down Ctrl + C/X/Y Copy/Cut/Delete line Ctrl + Z Undo Ctrl + Shift + Z Redo Alt + Scroll Accelerate scrolling Ctrl + Alt + Up/DownArrow Add cursor above/below Alt + Click Insert cursor at click Ctrl + Home/End cursorTop/Bottom 📨 PS: Alt + Up/DownArrow Move the current line up/down Ctrl + Alt + Up/DownArrow Add cursor above/below the current line, press ESCto exit Alt + Click Insert cursor where you click, press ESC to exit Ctrl + Home/End Move cursor to the top/bottom of the file Go to and Peek Shortcut Command F12 Go to definition Ctrl + F12 Peek implementation Shift + F12 Go to references Alt + F12 Peek definition Shift + Alt + F12 Find all references Ctrl + Shift + O Go to symbol in editor Ctrl + T Go to symbol in workspace Ⅱ. ExplorerFiles Shortcut Command J New File K New Folder E Reveal in explorer C/X/R Copy/cut/rename T Open in default integrated terminal List Shortcut Command I List.focusParent A List.collapse D List.expand Q List.collapseAll F3 List.find Ⅲ. Workbench Shortcut Command Ctrl + Shift + P Show all command Ctrl + Shift + M Toggle panel visibility Ctrl + Shift + F Toggle search visibility Ctrl + Shift + G Toggle source control visibility Ctrl + Shift + T Toggle todo tree visibility Ctrl + E Toggle explorer visibility Alt + E Toggle Secondary Sidebar visibility Ⅳ. Extensions Shortcut Command Alt + O Project Manager: List Projects to Open Alt+Q Jumpy Word Mode Alt+W Jumpy Line Mode Ctrl+L Bookmarks: Toggle Labeled Bookmarks: List Bookmarks: List","link":"/Tech/VSCode/Shortcuts/"},{"title":"DisableShortcuts","text":"问题描述windows 系统中存在一些快捷键，比如 win+space 切换 keyboard layout,这些快捷键在某些情况下会造成不必要的麻烦，我尝试在Time &amp; language &gt; Typing &gt; Advanced keyboard settings &gt; Input language hot keys中弃用win+space快捷键,但d对于我的电脑而言,这并没有效果 因此,本文介绍通过 PowerToys Keyboardmanager 禁用这些快捷键。 The PowerToys Keyboard Manager enables you to redefine keys on your keyboard.For example, you can exchange the letter A for the letter B on your keyboard. When you press the A key, a B will be inserted. 解决方案 下载安装PowerToys 打开 PowerToys，在左侧边栏中选择键盘管理器，点击重新映射快捷键.进入如下页面 在页面中,点击Add shortcut remapping重新映射快捷键，你可以将win+space映射为undefined，在Target app中你可以填写你想要在哪个app中应用这一映射.这里我将其映射为PowerToysRun的快捷键 单击ok,成功添加映射 补充PowerToys 还有很多其他的功能，比如PowerToysRun，FancyZones等，可以根据自己的需求进行配置。关于Keyboard-manager的更多信息，可以参考Keyboard-manager文档","link":"/Tech/Others/DisableShortcuts/"},{"title":"tasks.json的使用","text":"Introtasks.json 的作用是什么呢？官方的解释是这样的： Lots of tools exist to automate tasks like linting, building, packaging, testing, or deploying software systems.Tasks in VS Code can be configured to run scripts and start processes so that many of these existing tools can be used from within VS Code without having to enter a command line or write new code.linting: Linting is a tool that analyzes source code to flag programming errors, bugs, stylistic errors, and suspicious constructs &gt; Integrate with External Tools via Tasks 简单来说，tasks.json 的作用就是可以在 VSCode 中编写一些脚本，用于执行一些任务，比如编译代码，运行代码，打包代码等等。 propertiesThe task’s properties have the following semantic: label: The task’s label used in the user interface. type: The task’s type. For a custom task, this can either be shell or process. If shell is specified, the command is interpreted as a shell command (for example: bash, cmd, or PowerShell). If process is specified, the command is interpreted as a process to execute. command: The actual command to execute. windows: Any Windows specific properties. Will be used instead of the default properties when the command is executed on the Windows operating system. group: Defines to which group the task belongs. In the example, it belongs to the test group. Tasks that belong to the test group can be executed by running Run Test Task from the Command Palette. presentation: Defines how the task output is handled in the user interface. In this example, the Integrated Terminal showing the output is always revealed and a new terminal is created on every task run. options: Override the defaults for cwd (current working directory), env (environment variables), or shell (default shell). Options can be set per task but also globally or per platform. Environment variables configured here can only be referenced from within your task script or process and will not be resolved if they are part of your args, command, or other task attributes. runOptions: Defines when and how a task is run. 示例tasks.json的功能十分丰富，这里只列举一些常用的功能，更多的功能可以参考官方文档。 12345678910111213141516171819202122232425262728293031323334353637383940{ &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;compile c file(Windows)&quot;, &quot;command&quot;: &quot;gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; ], &quot;group&quot;: &quot;build&quot; }, { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;compile c file(Linux)&quot;, &quot;command&quot;: &quot;gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot; ], &quot;group&quot;: &quot;build&quot; }, { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;run exe file(Windows)&quot;, &quot;command&quot;: &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; }, { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;compile and run c file(Windows)&quot;, &quot;command&quot;: &quot;gcc -g ${file} -o ${fileDirname}\\\\${fileBasenameNoExtension}.exe &amp;&amp; ${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;, &quot;problemMatcher&quot;: [&quot;$gcc&quot;] } ]} compile c file(Windows)和compile c file(Linux)：用于编译 c 文件 run exe file(Windows)用于运行编译好的 exe 文件，代码没有改动时，可以直接运行 exe 文件，避免重新编译。 compile and run c file(Windows)用于编译并运行 c 文件。 ps: 为workbench.action.tasks.runTask设置快捷键,可显示 tasks 列表","link":"/Tech/VSCode/tasks.json%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"Recommended VSCode Extensions","text":"个人使用插件推荐，仅供参考。 Ⅰ. Beautification Themes Dark Space Material Theme Tokyo Night Tokyo Night Ported Nvim Tokyo Night Frameless Solarized Palenight Icons Material Icon Theme Fluent Icons Customization CodeUIHighlight web colors in your editor Color HighlightHighlight web colors in your editor Apc Custom UI++Advanced VSCode user interface customizations. Very experimental. VSCode AnimationsClean and customizable animations for VSCode Ⅱ. ProductivityEditing BookmarksMark lines and jump to them jumpyJumpy provides fast cursor movement Code TranslateA pure vscode translation plug-in; 一款纯粹的 vscode 滑词翻译插件 CodeSnap📷 Take beautiful screenshots of your code Github CopilotYour AI pair programmer GitHub Copilot ChatAI chat features powered by Copilot Error LensImprove highlighting of errors, warnings and other language diagnostics. Better CommentsImprove your code commenting by annotating with alert, informational, TODOs, and more! Markdown Markdown All In OneAll you need to write Markdown (keyboard shortcuts, table of contents, auto preview and more) Markdown Preview EnhancedMarkdown Preview Enhanced ported to vscode Markdown LintMarkdown linting and style checking for Visual Studio Code MarkmapVisualize your Markdown as mindmaps with Markmap. PicGoUpload images to online, and generate markdown urls. FoamVS Code + Markdown + Wikilinks for your note taking and knowledge base Formatter PrettierCode formatter using prettier Git Git GraphView a Git Graph of your repository, and perform Git actions from the graph. Git HistoryView git log, file history, compare branches or commits GitHub CodespacesYour instant dev environment Web Live ServerLaunch a development local Server with live reload feature for static &amp; dynamic pages Miscellaneous Live ServerLaunch a development local Server with live reload feature for static &amp; dynamic pages LeetCodeSolve LeetCode problems in VS Code file-sizeShow file size in the status bar Resource MonitorDisplay CPU frequency, usage, memory consumption, and battery percentage remaining within the VSCode status bar","link":"/Tech/VSCode/RecommendedExtensions/"},{"title":"Computer networks and the Internet","text":"计算机网络在信息时代的作用计算机网络已经由通信基础设施发展成为一种重要的信息服务基础设施 因特网概述基本概念 NetWork 网络,由若干结点(Node)和链路(Link)组成 internet 互联网/互连网,多个网络可以通过路由器(Router)互联起来,形成一个覆盖范围更大的网络,互联网是由网络和网络之间互联而成的,是网络的网络(Network of Networks) Internet 因特网世界上最大的互联网络. Host 主机,连接到因特网上的计算机 internet 和 Internet 的区别 internet(互联网或互连网)是一个通用名词，它泛指多个计算机网络互连而成的网络。在这些网络之间的通信协议可以是任意的。 Internet（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络互连而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，其前身是美国的 ARPANET。 任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是互联网(Internet)。 Internet 发展的三个阶段 ISP(互联网服务提供商)Internet上的主机通过ISP接入Internet,之后才能互相通信;ISP可以从因特网管理机构申请到成块的 IP 地址,同时拥有通信线路以及路由器等联网设备.机构/个人缴纳一定的费用,就可以从ISP租用IP 地址,并通过ISP接入Internet.中国的主流ISP有:中国电信、中国移动、中国联通等 第一层 ISP（Tier 1 ISP）：这些是全球互联网的主干网络运营商，它们拥有遍布全球的网络基础设施。这些公司的网络通常覆盖了全球的主要地区和城市，包括北美、欧洲、亚洲、澳大利亚等。。第一层 ISP 之间通过免费的互联网络（Peering）协议进行数据交换，不需要向其他 ISP 支付费用。以下是一些知名的第一层 ISP 及其总部所在地： AT&amp;T：总部位于美国德克萨斯州达拉斯。 Verizon：总部位于美国纽约州纽约。 Level 3 Communications：总部位于美国科罗拉多州布隆菲尔德，现已被 CenturyLink（现为 Lumen Technologies）收购。 NTT Communications：总部位于日本东京。 Telia Company：总部位于瑞典斯德哥尔摩。 第二层 ISP（Tier 2 ISP）：这些 ISP 拥有自己的网络基础设施，但是不足以覆盖全球，所以它们需要购买第一层 ISP 的服务，以便将数据传输到全球的其他地方。第二层 ISP 通常会向本地或区域的客户提供服务。 er 3 ISP）：这些 ISP 通常没有自己的网络基础设施，而是购买第二层 ISP 的服务，然后将其转售给最终用户。第三层 ISP 通常会提供一些增值服务，如电子邮件、网页托管和虚拟专用网络（VPN）。 Internet 的标准化工作 因特网的标准化工作对因特网的发展起到了非常重要的作用。 因特网在指定其标准上的一个很大的特点是面向公众。 因特网所有的 RFC(Request For Comments)技术文档都可从因特网上免费下载； 任何人都可以随时用电子邮件发表对某个文档的意见或建议。 因特网协会 ISOC 是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。 因特网体系结构委员会 IAB，负责管理因特网有关协议的开发； 因特网工程部 IETF，负责研究中短期工程问题，主要针对协议的开发和标准化； 因特网研究部 IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。 制定因特网的正式标准需要四个阶段: 因特网草案 建议标准(该阶段的标准会开始写入 RFC 文档) 草案标准 因特网标准 Internet 的组成主要可分为边缘部分和核心部分边缘部分 由所有连接在因特网上的主机组成.这部分是用户直接使用的,用于通信和资源共享.核心部分 由大量网络和连接这些网络的路由器组成,这部分是为边缘部分提供服务的(提供连通性和交换). 路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为端系统(end system)端系统在功能上可能有很大的差别： 小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。 大的端系统则可以是一台非常昂贵的大型计算机。 端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个 ISP。 三种交换方式网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。 在网络核心部分起特殊作用的是路由器(router)。 路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 电路交换 Circuit Switching传统的电话两两相连,但当用户很多时,这种方式就不可行了,因此引入中间设备(电话交换机),使用电话交换机接通电话线的方式称为电路交换.从通信资源的分配角度来看,交换就是按照某种方式动态地分配传输线路的资源 电路交换的三个步骤是:建立连接(分配通信资源),传输数据(一直占用通信资源),释放连接(归还通信资源) 而当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。这是因为计算机数据是突发式地出现在传输线路上的。所以计算机通常采用的是分组交换，而不是线路交换 分组交换 Packet Switching报文: 信息交换的基本单位,在网络中传输的信息单位分组: 为了传输方便,将报文划分为固定长度的数据块,称为分组.在每一个数据段前面,加上一些由必要的控制信息组成的首部,这样就构成了一个分组(packet),首部称为包头在分组交换中，报文被分割成多个小的数据包（或称为分组），每个分组都独立地通过网络进行传输。这意味着分组可以通过不同的路径到达目的地，并且可能会在不同的时间到达。在接收端，这些分组会被重新组装成原始的报文。这种方式的优点是它可以更有效地使用网络资源，因为它允许多个报文的分组在同一时间通过网络进行传输。但是，它也更复杂，因为需要在接收端重新组装分组。 发送方:构造分组,发送分组路由器:缓存分组,转发分组(分组转发)接收方:接受分组,还原报文 在路由器的输入和输出端口之间没有直接连线,路由器处理分组的过程是:把收到的分组先放入缓存,查找转发表,找出某个目的地址的最佳输出端口,然后从缓存中取出该分组,通过输出端口转发出去. 报文交换 Message Switching在报文交换中，整个报文作为一个单元进行发送，并且在整个传输过程中保持其完整性。报文在发送前需要完全准备好，并且在传输过程中不会被分割。这种方式的优点是简单，但缺点是如果报文很大，那么它可能会占用网络资源一段很长的时间，导致网络拥塞。报文交换主要用于早期的电报通信网，现在较少使用，通常被较先进的分组交换方式所取代。 三种交换方式对比电路交换： 通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。 一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点； 报文交换： 可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。 整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。 分组交换： 可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。 构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。 A,B,C,D 为分组传输路径所经过的四个结点交换机,纵坐标为时间 计算机网络的定义和分类计算机网络的定义计算机网络的精确定义并未统一 计算机网络的最简单的定义是：一些互相连接的、自治的计算机的集合 互联 计算机之间可以通过有线或无线的方式进行数据通信 自治 指计算机有独立性,有自己的软硬件,可以单独允许使用 集合 至少两台计算机组成 计算机网络较好的定义是: 计算机网络主要是由一些通用的，可编程的硬件（一定包含有中央处理机 CPU）互连而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。 计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。 计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。 计算机网络的分类按交换技术分类: 电路交换网络 报文交换网络 分组交换网络按使用者分类: 公用网 专用网按传输介质分类: 有线网络 无线网络按覆盖范围分类: WAN MAN LAN PAN 广域网 Wide Area Network作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。城域网 Metropolitan Area Network作用范围一般是一个城市，可跨越几个街区甚至整个城市局域网 Local Area Network一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit/s 以上），但地理上范围较小（1 km 左右）个域网 Personal Area Network就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。 按拓扑结构分类 总线型 环型 星型 网状型 计算机网络的性能指标速率 Ratebit 比特.计算机中数据量的单位,也是信息论中信息量的单位.一个 bit 即是一个二进制数字,它只能取 0 或 1 两个值.8bit = 1Byte; KB=1024B,MB=1024KB,GB=1024MB,TB=1024GBrate 比特率,数据率.连接在计算机网络上的主机在数字信道上传送数据位数的速率,单位为 bit/s,也称为 bps(bit per second)kbs=1000bps,Mbps=1000kbs,Gbps=1000Mbps 100MB 的数据块,网卡的发送速率为 100Mbps,求发送所需时间? $$ \\frac{100MB}{100Mbps}=\\frac{MB}{Mbps}=\\frac{2^{20}B}{10^6bps}=\\frac{2^{20}\\times8}{10^6s^{-1}}=8.388608s $$ 带宽 BandwidthBandwidth在模拟信号系统中,表示信号所包含的各种不同频率成分所占据的频率范围(即最高频率与最低频率之差),单位为 Hz;在计算机网络中,表示网络中的通信线路所能传输数据的能力,网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的最高数据率(即网络设备所支持的最高速度),单位为 bps.带宽的带宽的这两种表述之间有着密切的联系,一条通信线路的频带宽度越宽，理论上所能传输的最高数据率也越高。(具体可自行查阅信号与系统相关知识,例如香农定理) 吞吐量 Throughput吞吐量是指单位时间内通过某个网络(或信道、接口)的数据量,单位为 bps.吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或或额定速率的限制(吞吐量往往小于带宽),同时还受到网络中其他因素的影响,例如网络拥塞、路由器转发速率、主机处理速度等. 时延 Delay计算机网络体系结构","link":"/Tech/Network/ComputerNetwork01/"}],"tags":[{"name":"CyberPunk2077","slug":"CyberPunk2077","link":"/tags/CyberPunk2077/"},{"name":"Music","slug":"Music","link":"/tags/Music/"},{"name":"CDPR","slug":"CDPR","link":"/tags/CDPR/"},{"name":"Games","slug":"Games","link":"/tags/Games/"},{"name":"Rock","slug":"Rock","link":"/tags/Rock/"},{"name":"TheWitcher3","slug":"TheWitcher3","link":"/tags/TheWitcher3/"},{"name":"HeartsOfStone","slug":"HeartsOfStone","link":"/tags/HeartsOfStone/"},{"name":"中国古代诗词","slug":"中国古代诗词","link":"/tags/%E4%B8%AD%E5%9B%BD%E5%8F%A4%E4%BB%A3%E8%AF%97%E8%AF%8D/"},{"name":"DataBase","slug":"DataBase","link":"/tags/DataBase/"},{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"Glossary","slug":"Glossary","link":"/tags/Glossary/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"Typora","slug":"Typora","link":"/tags/Typora/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Hashtable","slug":"Hashtable","link":"/tags/Hashtable/"},{"name":"Encoding","slug":"Encoding","link":"/tags/Encoding/"},{"name":"C_Cpp","slug":"C-Cpp","link":"/tags/C-Cpp/"},{"name":"Debug","slug":"Debug","link":"/tags/Debug/"},{"name":"json","slug":"json","link":"/tags/json/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"WSL","slug":"WSL","link":"/tags/WSL/"},{"name":"Shortcuts","slug":"Shortcuts","link":"/tags/Shortcuts/"},{"name":"Productivity","slug":"Productivity","link":"/tags/Productivity/"},{"name":"Extensions","slug":"Extensions","link":"/tags/Extensions/"},{"name":"Beautification","slug":"Beautification","link":"/tags/Beautification/"},{"name":"Network","slug":"Network","link":"/tags/Network/"}],"categories":[{"name":"Gaming","slug":"Gaming","link":"/categories/Gaming/"},{"name":"Reading， Poems","slug":"Reading，-Poems","link":"/categories/Reading%EF%BC%8C-Poems/"},{"name":"CyberPunk2077","slug":"Gaming/CyberPunk2077","link":"/categories/Gaming/CyberPunk2077/"},{"name":"Reading","slug":"Reading","link":"/categories/Reading/"},{"name":"Tech","slug":"Tech","link":"/categories/Tech/"},{"name":"The Witcher 3","slug":"Gaming/The-Witcher-3","link":"/categories/Gaming/The-Witcher-3/"},{"name":"Poems","slug":"Reading/Poems","link":"/categories/Reading/Poems/"},{"name":"DataBase","slug":"Tech/DataBase","link":"/categories/Tech/DataBase/"},{"name":"FrontEnd","slug":"Tech/FrontEnd","link":"/categories/Tech/FrontEnd/"},{"name":"Java","slug":"Tech/Java","link":"/categories/Tech/Java/"},{"name":"Others","slug":"Tech/Others","link":"/categories/Tech/Others/"},{"name":"VSCode","slug":"Tech/VSCode","link":"/categories/Tech/VSCode/"},{"name":"Network","slug":"Tech/Network","link":"/categories/Tech/Network/"}],"pages":[{"title":"","text":".title_card { display: flex; /* 使用flex布局 */ position: relative; /* 添加relative定位 */ box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2); transition: 0.3s; width: 100%; height: 100%; border-radius: 5px; overflow: hidden; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ } .title_card:hover { box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2); } .title_card_text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ color: white; /* 将文字颜色设置为白色 */ opacity: 0; transition: opacity 0.3s; font-family: 'Trebuchet MS'; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* 添加文字阴影 */ } .title_card:hover .title_card_text { opacity: 0.9; animation: jelly 0.5s; } @keyframes jelly { 0%, 100% { transform: scale(1, 1); } 25% { transform: scale(0.9, 1.1); } 50% { transform: scale(1.1, 0.9); } 75% { transform: scale(0.95, 1.05); } } h1 { text-align: center; font-size: 4em; font-family: 'Trebuchet MS'; color: teal; } GALLERY Photography Miscellaneous Anime Van Goah","link":"/gallery/index.html"},{"title":"","text":"基础篇通用语法及分类 DDL: 数据定义语言，用来定义数据库对象（数据库、表、字段） DML: 数据操作语言，用来对数据库表中的数据进行增删改 DQL: 数据查询语言，用来查询数据库中表的记录 DCL: 数据控制语言，用来创建数据库用户、控制数据库的控制权限 DDL（数据定义语言）数据定义语言 数据库操作查询所有数据库：SHOW DATABASES;查询当前数据库：SELECT DATABASE();创建数据库：CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];删除数据库：DROP DATABASE [ IF EXISTS ] 数据库名;使用数据库：USE 数据库名; 注意事项 UTF8字符集长度为3字节，有些符号占4字节，所以推荐用utf8mb4字符集 表操作查询当前数据库所有表：SHOW TABLES;查询表结构：DESC 表名;查询指定表的建表语句：SHOW CREATE TABLE 表名; 创建表： 1234567CREATE TABLE 表名( 字段1 字段1类型 [COMMENT 字段1注释], 字段2 字段2类型 [COMMENT 字段2注释], 字段3 字段3类型 [COMMENT 字段3注释], ... 字段n 字段n类型 [COMMENT 字段n注释])[ COMMENT 表注释 ]; 最后一个字段后面没有逗号 添加字段：ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];例：ALTER TABLE emp ADD nickname varchar(20) COMMENT '昵称'; 修改数据类型：ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);修改字段名和字段类型：ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];例：将emp表的nickname字段修改为username，类型为varchar(30)ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT '昵称'; 删除字段：ALTER TABLE 表名 DROP 字段名; 修改表名：ALTER TABLE 表名 RENAME TO 新表名 删除表：DROP TABLE [IF EXISTS] 表名;删除表，并重新创建该表：TRUNCATE TABLE 表名; DML（数据操作语言）添加数据指定字段：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);全部字段：INSERT INTO 表名 VALUES (值1, 值2, ...); 批量添加数据：INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...); 注意事项 字符串和日期类型数据应该包含在引号中 插入的数据大小应该在字段的规定范围内 更新和删除数据修改数据：UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];例：UPDATE emp SET name = 'Jack' WHERE id = 1; 删除数据：DELETE FROM 表名 [ WHERE 条件 ]; DQL（数据查询语言）语法： 1234567891011121314SELECT 字段列表FROM 表名字段WHERE 条件列表GROUP BY 分组字段列表HAVING 分组后的条件列表ORDER BY 排序字段列表LIMIT 分页参数 基础查询查询多个字段：SELECT 字段1, 字段2, 字段3, ... FROM 表名;SELECT * FROM 表名; 设置别名：SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名; 去除重复记录：SELECT DISTINCT 字段列表 FROM 表名; 转义：SELECT * FROM 表名 WHERE name LIKE '/_张三' ESCAPE '/'/ 之后的_不作为通配符 条件查询语法：SELECT 字段列表 FROM 表名 WHERE 条件列表; 条件： 比较运算符 功能 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 = 等于 &lt;&gt; 或 != 不等于 BETWEEN … AND … 在某个范围内（含最小、最大值） IN(…) 在in之后的列表中的值，多选一 LIKE 占位符 模糊匹配（_匹配单个字符，%匹配任意个字符） IS NULL 是NULL 逻辑运算符 功能 AND 或 &amp;&amp; 并且（多个条件同时成立） OR 或 || 或者（多个条件任意一个成立） NOT 或 ! 非，不是 例子： 123456789101112131415161718192021222324252627-- 年龄等于30select * from employee where age = 30;-- 年龄小于30select * from employee where age &lt; 30;-- 小于等于select * from employee where age &lt;= 30;-- 没有身份证select * from employee where idcard is null or idcard = '';-- 有身份证select * from employee where idcard;select * from employee where idcard is not null;-- 不等于select * from employee where age != 30;-- 年龄在20到30之间select * from employee where age between 20 and 30;select * from employee where age &gt;= 20 and age &lt;= 30;-- 下面语句不报错，但查不到任何信息select * from employee where age between 30 and 20;-- 性别为女且年龄小于30select * from employee where age &lt; 30 and gender = '女';-- 年龄等于25或30或35select * from employee where age = 25 or age = 30 or age = 35;select * from employee where age in (25, 30, 35);-- 姓名为两个字select * from employee where name like '__';-- 身份证最后为Xselect * from employee where idcard like '%X'; 聚合查询（聚合函数）常见聚合函数： 函数 功能 count 统计数量 max 最大值 min 最小值 avg 平均值 sum 求和 语法：SELECT 聚合函数(字段列表) FROM 表名;例：SELECT count(id) from employee where workaddress = &quot;广东省&quot;; 分组查询语法：SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ]; where 和 having 的区别： 执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。 判断条件不同：where不能对聚合函数进行判断，而having可以。 例子： 12345678910-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）select count(*) from employee group by gender;-- 根据性别分组，统计男性和女性数量select gender, count(*) from employee group by gender;-- 根据性别分组，统计男性和女性的平均年龄select gender, avg(age) from employee group by gender;-- 年龄小于45，并根据工作地址分组select workaddress, count(*) from employee where age &lt; 45 group by workaddress;-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3; 注意事项 执行顺序：where &gt; 聚合函数 &gt; having 分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义 排序查询语法：SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2; 排序方式： ASC: 升序（默认） DESC: 降序 例子： 12345-- 根据年龄升序排序SELECT * FROM employee ORDER BY age ASC;SELECT * FROM employee ORDER BY age;-- 两字段排序，根据年龄升序排序，入职时间降序排序SELECT * FROM employee ORDER BY age ASC, entrydate DESC; 注意事项如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 分页查询语法：SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数; 例子： 1234-- 查询第一页数据，展示10条SELECT * FROM employee LIMIT 0, 10;-- 查询第二页SELECT * FROM employee LIMIT 10, 10; 注意事项 起始索引从0开始，起始索引 = （查询页码 - 1） * 每页显示记录数 分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT 如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10 DQL执行顺序FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT DCL管理用户查询用户： 12USE mysql;SELECT * FROM user; 创建用户:CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码'; 修改用户密码：ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码'; 删除用户：DROP USER '用户名'@'主机名'; 例子： 123456789-- 创建用户test，只能在当前主机localhost访问create user 'test'@'localhost' identified by '123456';-- 创建用户test，能在任意主机访问create user 'test'@'%' identified by '123456';create user 'test' identified by '123456';-- 修改密码alter user 'test'@'localhost' identified with mysql_native_password by '1234';-- 删除用户drop user 'test'@'localhost'; 注意事项 主机名可以使用 % 通配 权限控制常用权限： 权限 说明 ALL, ALL PRIVILEGES 所有权限 SELECT 查询数据 INSERT 插入数据 UPDATE 修改数据 DELETE 删除数据 ALTER 修改表 DROP 删除数据库/表/视图 CREATE 创建数据库/表 更多权限请看权限一览表 查询权限：SHOW GRANTS FOR '用户名'@'主机名'; 授予权限：GRANT 权限列表 ON 数据库名.表名 TO '用户名'@'主机名'; 撤销权限：REVOKE 权限列表 ON 数据库名.表名 FROM '用户名'@'主机名'; 注意事项 多个权限用逗号分隔 授权时，数据库名和表名可以用 * 进行通配，代表所有 函数 字符串函数 数值函数 日期函数 流程函数 字符串函数常用函数： 函数 功能 CONCAT(s1, s2, …, sn) 字符串拼接，将s1, s2, …, sn拼接成一个字符串 LOWER(str) 将字符串全部转为小写 UPPER(str) 将字符串全部转为大写 LPAD(str, n, pad) 左填充，用字符串pad对str的左边进行填充，达到n个字符串长度 RPAD(str, n, pad) 右填充，用字符串pad对str的右边进行填充，达到n个字符串长度 TRIM(str) 去掉字符串头部和尾部的空格 SUBSTRING(str, start, len) 返回从字符串str从start位置起的len个长度的字符串 REPLACE(column, source, replace) 替换字符串 使用示例： 1234567891011121314-- 拼接SELECT CONCAT('Hello', 'World');-- 小写SELECT LOWER('Hello');-- 大写SELECT UPPER('Hello');-- 左填充SELECT LPAD('01', 5, '-');-- 右填充SELECT RPAD('01', 5, '-');-- 去除空格SELECT TRIM(' Hello World ');-- 切片（起始索引为1）SELECT SUBSTRING('Hello World', 1, 5); 数值函数常见函数： 函数 功能 CEIL(x) 向上取整 FLOOR(x) 向下取整 MOD(x, y) 返回x/y的模 RAND() 返回0~1内的随机数 ROUND(x, y) 求参数x的四舍五入值，保留y位小数 日期函数常用函数： 函数 功能 CURDATE() 返回当前日期 CURTIME() 返回当前时间 NOW() 返回当前日期和时间 YEAR(date) 获取指定date的年份 MONTH(date) 获取指定date的月份 DAY(date) 获取指定date的日期 DATE_ADD(date, INTERVAL expr type) 返回一个日期/时间值加上一个时间间隔expr后的时间值 DATEDIFF(date1, date2) 返回起始时间date1和结束时间date2之间的天数 例子： 12-- DATE_ADDSELECT DATE_ADD(NOW(), INTERVAL 70 YEAR); 流程函数常用函数： 函数 功能 IF(value, t, f) 如果value为true，则返回t，否则返回f IFNULL(value1, value2) 如果value1不为空，返回value1，否则返回value2 CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果val1为true，返回res1，… 否则返回default默认值 CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END 如果expr的值等于val1，返回res1，… 否则返回default默认值 例子： 12345678select name, (case when age &gt; 30 then '中年' else '青年' end)from employee;select name, (case workaddress when '北京市' then '一线城市' when '上海市' then '一线城市' else '二线城市' end) as '工作地址'from employee; 约束分类： 约束 描述 关键字 非空约束 限制该字段的数据不能为null NOT NULL 唯一约束 保证该字段的所有数据都是唯一、不重复的 UNIQUE 主键约束 主键是一行数据的唯一标识，要求非空且唯一 PRIMARY KEY 默认约束 保存数据时，如果未指定该字段的值，则采用默认值 DEFAULT 检查约束（8.0.1版本后） 保证字段值满足某一个条件 CHECK 外键约束 用来让两张图的数据之间建立连接，保证数据的一致性和完整性 FOREIGN KEY 约束是作用于表中字段上的，可以再创建表/修改表的时候添加约束。 常用约束 约束条件 关键字 主键 PRIMARY KEY 自动增长 AUTO_INCREMENT 不为空 NOT NULL 唯一 UNIQUE 逻辑条件 CHECK 默认值 DEFAULT 例子： 1234567create table user( id int primary key auto_increment, name varchar(10) not null unique, age int check(age &gt; 0 and age &lt; 120), status char(1) default '1', gender char(1)); 外键约束添加外键： 123456789CREATE TABLE 表名( 字段名 字段类型, ... [CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名));ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);-- 例子alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id); 删除外键：ALTER TABLE 表名 DROP FOREIGN KEY 外键名; 删除/更新行为 行为 说明 NO ACTION 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与RESTRICT一致） RESTRICT 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除/更新（与NO ACTION一致） CASCADE 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除/更新外键在子表中的记录 SET NULL 当在父表中删除/更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null） SET DEFAULT 父表有变更时，子表将外键设为一个默认值（Innodb不支持） 更改删除/更新行为：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为; 多表查询多表关系 一对多（多对一） 多对多 一对一 一对多案例：部门与员工关系：一个部门对应多个员工，一个员工对应一个部门实现：在多的一方建立外键，指向一的一方的主键 多对多案例：学生与课程关系：一个学生可以选多门课程，一门课程也可以供多个学生选修实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键 一对一案例：用户与用户详情关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE） 查询合并查询（笛卡尔积，会展示所有组合结果）：select * from employee, dept; 笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积） 消除无效笛卡尔积：select * from employee, dept where employee.dept = dept.id; 内连接查询内连接查询的是两张表交集的部分 隐式内连接：SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...; 显式内连接：SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...; 显式性能比隐式高 例子： 12345-- 查询员工姓名，及关联的部门的名称-- 隐式select e.name, d.name from employee as e, dept as d where e.dept = d.id;-- 显式select e.name, d.name from employee as e inner join dept as d on e.dept = d.id; 外连接查询左外连接：查询左表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;相当于查询表1的所有数据，包含表1和表2交集部分数据 右外连接：查询右表所有数据，以及两张表交集部分数据SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...; 例子： 12345-- 左select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;select d.name, e.* from dept d left outer join emp e on e.dept = d.id; -- 这条语句与下面的语句效果一样-- 右select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id; 左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept 自连接查询当前表与自身的连接查询，自连接必须使用表别名 语法：SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...; 自连接查询，可以是内连接查询，也可以是外连接查询 例子： 1234-- 查询员工及其所属领导的名字select a.name, b.name from employee a, employee b where a.manager = b.id;-- 没有领导的也查询出来select a.name, b.name from employee a left join employee b on a.manager = b.id; 联合查询 union, union all把多次查询的结果合并，形成一个新的查询集 语法： 123SELECT 字段列表 FROM 表A ...UNION [ALL]SELECT 字段列表 FROM 表B ... 注意事项 UNION ALL 会有重复结果，UNION 不会 联合查询比使用or效率高，不会使索引失效 子查询SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个 根据子查询结果可以分为： 标量子查询（子查询结果为单个值） 列子查询（子查询结果为一列） 行子查询（子查询结果为一行） 表子查询（子查询结果为多行多列） 根据子查询位置可分为： WHERE 之后 FROM 之后 SELECT 之后 标量子查询子查询返回的结果是单个值（数字、字符串、日期等）。常用操作符：- &lt; &gt; &gt; &gt;= &lt; &lt;= 例子： 123456789-- 查询销售部所有员工select id from dept where name = '销售部';-- 根据销售部部门ID，查询员工信息select * from employee where dept = 4;-- 合并（子查询）select * from employee where dept = (select id from dept where name = '销售部');-- 查询xxx入职之后的员工信息select * from employee where entrydate &gt; (select entrydate from employee where name = 'xxx'); 列子查询返回的结果是一列（可以是多行）。 常用操作符： 操作符 描述 IN 在指定的集合范围内，多选一 NOT IN 不在指定的集合范围内 ANY 子查询返回列表中，有任意一个满足即可 SOME 与ANY等同，使用SOME的地方都可以使用ANY ALL 子查询返回列表的所有值都必须满足 例子： 123456-- 查询销售部和市场部的所有员工信息select * from employee where dept in (select id from dept where name = '销售部' or name = '市场部');-- 查询比财务部所有人工资都高的员工信息select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = '财务部'));-- 查询比研发部任意一人工资高的员工信息select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = '研发部')); 行子查询返回的结果是一行（可以是多列）。常用操作符：=, &lt;, &gt;, IN, NOT IN 例子： 123-- 查询与xxx的薪资及直属领导相同的员工信息select * from employee where (salary, manager) = (12500, 1);select * from employee where (salary, manager) = (select salary, manager from employee where name = 'xxx'); 表子查询返回的结果是多行多列常用操作符：IN 例子： 1234-- 查询与xxx1，xxx2的职位和薪资相同的员工select * from employee where (job, salary) in (select job, salary from employee where name = 'xxx1' or name = 'xxx2');-- 查询入职日期是2006-01-01之后的员工，及其部门信息select e.*, d.* from (select * from employee where entrydate &gt; '2006-01-01') as e left join dept as d on e.dept = d.id; 事务事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 基本操作： 1234567891011121314151617181920212223-- 1. 查询张三账户余额select * from account where name = '张三';-- 2. 将张三账户余额-1000update account set money = money - 1000 where name = '张三';-- 此语句出错后张三钱减少但是李四钱没有增加模拟sql语句错误-- 3. 将李四账户余额+1000update account set money = money + 1000 where name = '李四';-- 查看事务提交方式SELECT @@AUTOCOMMIT;-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效SET @@AUTOCOMMIT = 0;-- 提交事务COMMIT;-- 回滚事务ROLLBACK;-- 设置手动提交后上面代码改为：select * from account where name = '张三';update account set money = money - 1000 where name = '张三';update account set money = money + 1000 where name = '李四';commit; 操作方式二： 开启事务：START TRANSACTION 或 BEGIN TRANSACTION;提交事务：COMMIT;回滚事务：ROLLBACK; 操作实例： 12345start transaction;select * from account where name = '张三';update account set money = money - 1000 where name = '张三';update account set money = money + 1000 where name = '李四';commit; 四大特性ACID 原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败 一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态 隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 并发事务 问题 描述 脏读 一个事务读到另一个事务还没提交的数据 不可重复读 一个事务先后读取同一条记录，但两次读取的数据不同 幻读 一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在 这三个问题的详细演示：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd 并发事务隔离级别： 隔离级别 脏读 不可重复读 幻读 Read uncommitted √ √ √ Read committed × √ √ Repeatable Read(默认) × × √ Serializable × × × √表示在当前隔离级别下该问题会出现 Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差 查看事务隔离级别：SELECT @@TRANSACTION_ISOLATION;设置事务隔离级别：SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE };SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效 进阶篇存储引擎MySQL体系结构： 存储引擎就是存储数据、建立索引、更新/查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。默认存储引擎是InnoDB。 相关操作： 12345678-- 查询建表语句show create table account;-- 建表时指定存储引擎CREATE TABLE 表名( ...) ENGINE=INNODB;-- 查看当前数据库支持的存储引擎show engines; InnoDBInnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。 特点： DML 操作遵循 ACID 模型，支持事务 行级锁，提高并发访问性能 支持外键约束，保证数据的完整性和正确性 文件： xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。 参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间 知识点： 查看 Mysql 变量：show variables like 'innodb_file_per_table'; 从idb文件提取表结构数据：（在cmd运行）ibd2sdi xxx.ibd InnoDB 逻辑存储结构： MyISAMMyISAM 是 MySQL 早期的默认存储引擎。 特点： 不支持事务，不支持外键 支持表锁，不支持行锁 访问速度快 文件： xxx.sdi: 存储表结构信息 xxx.MYD: 存储数据 xxx.MYI: 存储索引 MemoryMemory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。 特点： 存放在内存中，速度快 hash索引（默认） 文件： xxx.sdi: 存储表结构信息 存储引擎特点 特点 InnoDB MyISAM Memory 存储限制 64TB 有 有 事务安全 支持 - - 锁机制 行锁 表锁 表锁 B+tree索引 支持 支持 支持 Hash索引 - - 支持 全文索引 支持（5.6版本之后） 支持 - 空间使用 高 低 N/A 内存使用 高 低 中等 批量插入速度 低 高 高 支持外键 支持 - - 存储引擎的选择在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。 InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择 MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。 Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性 电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。 性能分析查看执行频次查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：SHOW GLOBAL STATUS LIKE 'Com_______'; 或者 SHOW SESSION STATUS LIKE 'Com_______';例：show global status like 'Com_______' 慢查询日志慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（/etc/my.cnf）中配置如下信息： # 开启慢查询日志开关 slow_query_log=1 # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 long_query_time=2更改后记得重启MySQL服务，日志文件位置：/var/lib/mysql/localhost-slow.log 查看慢查询日志开关状态：show variables like 'slow_query_log'; profileshow profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：SELECT @@have_profiling;profiling 默认关闭，可以通过set语句在session/global级别开启 profiling：SET profiling = 1;查看所有语句的耗时：show profiles;查看指定query_id的SQL语句各个阶段的耗时：show profile for query query_id;查看指定query_id的SQL语句CPU的使用情况show profile cpu for query query_id; explainEXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。语法： # 直接在select语句之前加上关键字 explain / desc EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件; EXPLAIN 各字段含义： id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行） select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all possible_key：可能应用在这张表上的索引，一个或多个 Key：实际使用的索引，如果为 NULL，则没有使用索引 Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好 rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的 filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好 索引索引是帮助 MySQL 高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。 优缺点： 优点： 提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗 缺点： 索引列也是要占用空间的 索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE 索引结构 索引结构 描述 B+Tree 最常见的索引类型，大部分引擎都支持B+树索引 Hash 底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询 R-Tree(空间索引) 空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 Full-Text(全文索引) 是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES 索引 InnoDB MyISAM Memory B+Tree索引 支持 支持 支持 Hash索引 不支持 不支持 支持 R-Tree索引 不支持 支持 不支持 Full-text 5.6版本后支持 支持 不支持 B-Tree 二叉树的缺点可以用红黑树来解决：红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。 为了解决上述问题，可以使用 B-Tree 结构。B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针） B-Tree 的数据插入过程动画参照：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68演示地址：https://www.cs.usfca.edu/~galles/visualization/BTree.html B+Tree结构图： 演示地址：https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html 与 B-Tree 的区别： 所有的数据都会出现在叶子节点 叶子节点形成一个单向链表 MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。 Hash哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。 特点： Hash索引只能用于对等比较（=、in），不支持范围查询（betwwn、&gt;、&lt;、…） 无法利用索引完成排序操作 查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引 存储引擎支持： Memory InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的 面试题 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？ 相对于二叉树，层级更少，搜索效率高 对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低 相对于 Hash 索引，B+Tree 支持范围匹配及排序操作 索引分类 分类 含义 特点 关键字 主键索引 针对于表中主键创建的索引 默认自动创建，只能有一个 PRIMARY 唯一索引 避免同一个表中某数据列中的值重复 可以有多个 UNIQUE 常规索引 快速定位特定数据 可以有多个 全文索引 全文索引查找的是文本中的关键词，而不是比较索引中的值 可以有多个 FULLTEXT 在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种： 分类 含义 特点 聚集索引(Clustered Index) 将数据存储与索引放一块，索引结构的叶子节点保存了行数据 必须有，而且只有一个 二级索引(Secondary Index) 将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键 可以存在多个 演示图： 聚集索引选取规则： 如果存在主键，主键索引就是聚集索引 如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引 如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引 思考题1. 以下 SQL 语句，哪个执行效率高？为什么？ 123select * from user where id = 10;select * from user where name = 'Arm';-- 备注：id为主键，name字段创建的有索引 答：第一条语句，因为第二条需要回表查询，相当于两个步骤。 2. InnoDB 主键索引的 B+Tree 高度为多少？ 答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.可得公式：n * 8 + (n + 1) * 6 = 16 * 1024，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。 如果树的高度为2，那么他能存储的数据量大概为：1171 * 16 = 18736；如果树的高度为3，那么他能存储的数据量大概为：1171 * 1171 * 16 = 21939856。 另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。 语法创建索引：CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引 查看索引：SHOW INDEX FROM table_name; 删除索引：DROP INDEX index_name ON table_name; 案例： 1234567891011-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引create index idx_user_name on tb_user(name);-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引create unique index idx_user_phone on tb_user (phone);-- 为profession, age, status创建联合索引create index idx_user_pro_age_stat on tb_user(profession, age, status);-- 为email建立合适的索引来提升查询效率create index idx_user_email on tb_user(email);-- 删除索引drop index idx_user_email on tb_user; 使用规则最左前缀法则如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效（后面的字段索引失效）。 联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;=或者&lt;=来规避索引失效问题。 索引失效情况 在索引列上进行运算操作，索引将失效。如：explain select * from tb_user where substring(phone, 10, 2) = '15'; 字符串类型字段使用时，不加引号，索引将失效。如：explain select * from tb_user where phone = 17799990015;，此处phone的值没有加引号 模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：explain select * from tb_user where profession like '%工程';，前后都有 % 也会失效。 用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。 如果 MySQL 评估使用索引比全表更慢，则不使用索引。 SQL 提示是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。 例如，使用索引：explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;不使用哪个索引：explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;必须使用哪个索引：explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;; use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。 覆盖索引&amp;回表查询尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。 explain 中 extra 字段含义：using index condition：查找使用了索引，但是需要回表查询数据using where; using index;：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询 如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如select id, name from xxx where name='xxx';，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如select id, name, gender from xxx where name='xxx'; 所以尽量不要用select *，容易出现回表查询，降低效率，除非有联合索引包含了所有字段 面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：select id, username, password from tb_user where username='itcast'; 解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引 前缀索引当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。 语法：create index idx_xxxx on table_name(columnn(n));前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。求选择性公式： 12select count(distinct email) / count(*) from tb_user;select count(distinct substring(email, 1, 5)) / count(*) from tb_user; show index 里面的sub_part可以看到接取的长度 单列索引&amp;联合索引单列索引：即一个索引只包含单个列联合索引：即一个索引包含了多个列在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。 单列索引情况：explain select id, phone, name from tb_user where phone = '17799990010' and name = '韩信';这句只会用到phone索引字段 注意事项 多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询 设计原则 针对于数据量较大，且查询比较频繁的表建立索引 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高 如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询 SQL 优化插入数据普通插入： 采用批量插入（一次插入的数据不建议超过1000条） 手动提交事务 主键顺序插入 大批量插入：如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。 1234567# 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）mysql --local-infile -u root -p# 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关set global local_infile = 1;select @@local_infile;# 执行load指令将准备好的数据，加载到表结构中load data local infile '/root/sql1.log' into table 'tb_user' fields terminated by ',' lines terminated by '\\n'; 主键优化数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT） 页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。 MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定 文字说明不够清晰明了，具体可以看视频里的PPT演示过程：https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90 主键设计原则： 满足业务需求的情况下，尽量降低主键的长度 插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键 尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号 业务操作时，避免对主键的修改 order by优化 Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序 Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高 如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是Using index, Using filesort，如果要优化掉Using filesort，则需要另外再创建一个索引，如：create index idx_user_age_phone_ad on tb_user(age asc, phone desc);，此时使用select id, age, phone from tb_user order by age asc, phone desc;会全部走索引 总结： 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则 尽量使用覆盖索引 多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC） 如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k） group by优化 在分组操作时，可以通过索引来提高效率 分组操作时，索引的使用也是满足最左前缀法则的 如索引为idx_user_pro_age_stat，则句式可以是select ... where profession order by age，这样也符合最左前缀法则 limit优化常见的问题如limit 2000000, 10，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化 例如： 12345678-- 此语句耗时很长select * from tb_sku limit 9000000, 10;-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询select id from tb_sku order by id limit 9000000, 10;-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id; count优化MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis count的几种用法： 如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值 用法：count(*)、count(主键)、count(字段)、count(1) count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0 各种用法的性能： count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空） count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加 count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加 count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加 按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*) update优化（避免行锁升级为表锁）InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。 如以下两条语句：update student set no = '123' where id = 1;，这句由于id有主键索引，所以只会锁这一行；update student set no = '123' where name = 'test';，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引 数据类型整型 类型名称 取值范围 大小 TINYINT -128〜127 1个字节 SMALLINT -32768〜32767 2个宇节 MEDIUMINT -8388608〜8388607 3个字节 INT (INTEGHR) -2147483648〜2147483647 4个字节 BIGINT -9223372036854775808〜9223372036854775807 8个字节 无符号在数据类型后加 unsigned 关键字。 浮点型 类型名称 说明 存储需求 FLOAT 单精度浮点数 4 个字节 DOUBLE 双精度浮点数 8 个字节 DECIMAL (M, D)，DEC 压缩的“严格”定点数 M+2 个字节 日期和时间 类型名称 日期格式 日期范围 存储需求 YEAR YYYY 1901 ~ 2155 1 个字节 TIME HH:MM:SS -838:59:59 ~ 838:59:59 3 个字节 DATE YYYY-MM-DD 1000-01-01 ~ 9999-12-3 3 个字节 DATETIME YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 8 个字节 TIMESTAMP YYYY-MM-DD HH:MM:SS 1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC 4 个字节 字符串 类型名称 说明 存储需求 CHAR(M) 固定长度非二进制字符串 M 字节，1&lt;=M&lt;=255 VARCHAR(M) 变长非二进制字符串 L+1字节，在此，L&lt; = M和 1&lt;=M&lt;=255 TINYTEXT 非常小的非二进制字符串 L+1字节，在此，L&lt;2^8 TEXT 小的非二进制字符串 L+2字节，在此，L&lt;2^16 MEDIUMTEXT 中等大小的非二进制字符串 L+3字节，在此，L&lt;2^24 LONGTEXT 大的非二进制字符串 L+4字节，在此，L&lt;2^32 ENUM 枚举类型，只能有一个枚举字符串值 1或2个字节，取决于枚举值的数目 (最大值为65535) SET 一个设置，字符串对象可以有零个或 多个SET成员 1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员） 二进制类型 类型名称 说明 存储需求 BIT(M) 位字段类型 大约 (M+7)/8 字节 BINARY(M) 固定长度二进制字符串 M 字节 VARBINARY (M) 可变长度二进制字符串 M+1 字节 TINYBLOB (M) 非常小的BLOB L+1 字节，在此，L&lt;2^8 BLOB (M) 小 BLOB L+2 字节，在此，L&lt;2^16 MEDIUMBLOB (M) 中等大小的BLOB L+3 字节，在此，L&lt;2^24 LONGBLOB (M) 非常大的BLOB L+4 字节，在此，L&lt;2^32 权限一览表 具体权限的作用详见官方文档 GRANT 和 REVOKE 允许的静态权限 Privilege Grant Table Column Context ALL [PRIVILEGES] Synonym for “all privileges” Server administration ALTER Alter_priv Tables ALTER ROUTINE Alter_routine_priv Stored routines CREATE Create_priv Databases, tables, or indexes CREATE ROLE Create_role_priv Server administration CREATE ROUTINE Create_routine_priv Stored routines CREATE TABLESPACE Create_tablespace_priv Server administration CREATE TEMPORARY TABLES Create_tmp_table_priv Tables CREATE USER Create_user_priv Server administration CREATE VIEW Create_view_priv Views DELETE Delete_priv Tables DROP Drop_priv Databases, tables, or views DROP ROLE Drop_role_priv Server administration EVENT Event_priv Databases EXECUTE Execute_priv Stored routines FILE File_priv File access on server host GRANT OPTION Grant_priv Databases, tables, or stored routines INDEX Index_priv Tables INSERT Insert_priv Tables or columns LOCK TABLES Lock_tables_priv Databases PROCESS Process_priv Server administration PROXY See proxies_priv table Server administration REFERENCES References_priv Databases or tables RELOAD Reload_priv Server administration REPLICATION CLIENT Repl_client_priv Server administration REPLICATION SLAVE Repl_slave_priv Server administration SELECT Select_priv Tables or columns SHOW DATABASES Show_db_priv Server administration SHOW VIEW Show_view_priv Views SHUTDOWN Shutdown_priv Server administration SUPER Super_priv Server administration TRIGGER Trigger_priv Tables UPDATE Update_priv Tables or columns USAGE Synonym for “no privileges” Server administration GRANT 和 REVOKE 允许的动态权限 Privilege Context APPLICATION_PASSWORD_ADMIN Dual password administration AUDIT_ABORT_EXEMPT Allow queries blocked by audit log filter AUDIT_ADMIN Audit log administration AUTHENTICATION_POLICY_ADMIN Authentication administration BACKUP_ADMIN Backup administration BINLOG_ADMIN Backup and Replication administration BINLOG_ENCRYPTION_ADMIN Backup and Replication administration CLONE_ADMIN Clone administration CONNECTION_ADMIN Server administration ENCRYPTION_KEY_ADMIN Server administration FIREWALL_ADMIN Firewall administration FIREWALL_EXEMPT Firewall administration FIREWALL_USER Firewall administration FLUSH_OPTIMIZER_COSTS Server administration FLUSH_STATUS Server administration FLUSH_TABLES Server administration FLUSH_USER_RESOURCES Server administration GROUP_REPLICATION_ADMIN Replication administration GROUP_REPLICATION_STREAM Replication administration INNODB_REDO_LOG_ARCHIVE Redo log archiving administration NDB_STORED_USER NDB Cluster PASSWORDLESS_USER_ADMIN Authentication administration PERSIST_RO_VARIABLES_ADMIN Server administration REPLICATION_APPLIER PRIVILEGE_CHECKS_USER for a replication channel REPLICATION_SLAVE_ADMIN Replication administration RESOURCE_GROUP_ADMIN Resource group administration RESOURCE_GROUP_USER Resource group administration ROLE_ADMIN Server administration SESSION_VARIABLES_ADMIN Server administration SET_USER_ID Server administration SHOW_ROUTINE Server administration SYSTEM_USER Server administration SYSTEM_VARIABLES_ADMIN Server administration TABLE_ENCRYPTION_ADMIN Server administration VERSION_TOKEN_ADMIN Server administration XA_RECOVER_ADMIN Server administration 图形化界面工具 Workbench(免费): http://dev.mysql.com/downloads/workbench/ navicat(收费，试用版30天): https://www.navicat.com/en/download/navicat-for-mysql Sequel Pro(开源免费，仅支持Mac OS): http://www.sequelpro.com/ HeidiSQL(免费): http://www.heidisql.com/ phpMyAdmin(免费): https://www.phpmyadmin.net/ SQLyog: https://sqlyog.en.softonic.com/ 安装小技巧 在SQL语句之后加上\\G会将结果的表格形式转换成行文本形式 查看Mysql数据库占用空间：1234SELECT table_schema &quot;Database Name&quot; , SUM(data_length + index_length) / (1024 * 1024) &quot;Database Size in MB&quot;FROM information_schema.TABLESGROUP BY table_schema; 后续内容后续内容因为跟当前学习、工作计划有冲突，所以后续课程的学习计划会无限期推后。目前的工作重点放在重做一个学习笔记网站，当然这是边做边学的，开发过程中遇到的难点和知识点我也会记录下来供大家学习。在此感谢B站同样爱学习的同学 @守心-人 提供的后续课程笔记，大家有条件一定要去给个star，你的每一个star和点赞都是我们前进的动力https://github.com/Buildings-Lei/mysql_note/blob/main/README.md","link":"/MySQL.html"},{"title":"","text":"h1 { font-family: Consolas; color: #426cc2; text-align: center; font-style: bold; /* font-size: 3em; */ } div.intro-container { background-color:rgba(255, 255, 255, 0.1); border: 1px solid rgba(0, 0, 0, 0.1); /* 更改边框颜色和透明度 */ padding: 20px; margin: 10px; border-radius: 10px; box-shadow: 10px 10px 20px rgba(0, 0, 0, 0.2); } p.intro::first-letter { font-size: 3em; line-height: 0.8; float: left; padding-top: 0.1em; padding-right: 0.1em; font-style: bold; } p.intro:hover::first-letter { color: #426cc2; font-size: 3em; line-height: 0.8; float: left; padding-top: 0.1em; padding-right: 0.1em; font-style: bold; } p.intro { color: #8dbeea; line-height: 1.5; text-align: left; font-family: Consolas; font-style: bold; } .title_card { display: flex; /* 使用flex布局 */ position: relative; /* 添加relative定位 */ box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2); transition: 0.3s; width: 100%; height: 100%; border-radius: 5px; overflow: hidden; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ } .title_card:hover { box-shadow: 0 8px 16px 0 rgba(0,0,0,0.2); } .title_card_text { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ color: white; /* 将文字颜色设置为白色 */ opacity: 0; transition: opacity 0.3s; font-family: 'Trebuchet MS'; /* 将字体设置为Arial */ text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* 添加文字阴影 */ } .title_card:hover .title_card_text { opacity: 0.9; animation: jelly 0.5s; } @keyframes jelly { 0%, 100% { transform: scale(1, 1); } 25% { transform: scale(0.9, 1.1); } 50% { transform: scale(1.1, 0.9); } 75% { transform: scale(0.95, 1.05); } } ABOUT 🐳Welcome To My Website! Glad to have you here as we surf the Internet. This website is not just a platform for me to express my thoughts and ideas, but also a place where I hope to connect with people who share similar interests or are simply curious about the world. Just here, I will delve into topics that fascinate me, share stories from my personal experiences, and offer insights that I've gained along the way. Whether it's about my latest adventures, reflections on life, or thoughts on various topics, I hope to provide content that is engaging and thought-provoking. Xplore this site, leave comments, ask questions, share experiences. We can learn from each other, and I'm excited to hear from you.Once again, thank you for visiting. I hope you find something here that resonates with you, inspires you, or simply makes you think. Enjoy exploring! 🔗About This Site 📝Embark on a voyage through my educational explorations 📖Plunge into the chapters of my bookish journeys 🎮Venture into the digital landscapes of my gaming exploits 🦋Feast your eyes on the captivating imagery 💡Insights from my Tech Learning Journey","link":"/about/index.html"}]}